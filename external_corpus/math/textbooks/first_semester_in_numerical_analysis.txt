First Semester in Numerical Analysis with Python

                                     Yaning Liu
           Department of Mathematical and Statistical Sciences

                         University of Colorado Denver
                                 Denver CO 80204

                                    Giray Ökten
                          Department of Mathematics

                             Florida State University
                               Tallahassee FL 32306
To my wife Yanjun Pan-YL
Contents

1 Introduction                              5

1.1 Review of Calculus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

1.2 Python basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.3 Computer arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2 Solutions of equations: Root-finding      42

2.1 Error analysis for iterative methods . . . . . . . . . . . . . . . . . . . . . . . 45

2.2 Bisection method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

2.3 Newton's method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

2.4 Secant method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

2.5 Muller's method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

2.6 Fixed-point iteration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

2.7 High-order fixed-point iteration . . . . . . . . . . . . . . . . . . . . . . . . . 72

3 Interpolation                             75

3.1 Polynomial interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

3.2 High degree polynomial interpolation . . . . . . . . . . . . . . . . . . . . . . 92

3.3 Hermite interpolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

3.4 Piecewise polynomials: spline interpolation . . . . . . . . . . . . . . . . . . . 104

4 Numerical Quadrature and Differentiation  121

4.1 Newton-Cotes formulas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

4.2 Composite Newton-Cotes formulas . . . . . . . . . . . . . . . . . . . . . . . 127

4.3 Gaussian quadrature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

4.4 Multiple integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137

4.5 Improper integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

4.6 Numerical differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

                                        2
CONTENTS                3

5 Approximation Theory  153

5.1 Discrete least squares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153

5.2 Continuous least squares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170

5.3 Orthogonal polynomials and least squares . . . . . . . . . . . . . . . . . . . 173

References              187

Index                   188
Preface

The book is based on "First semester in Numerical Analysis with Julia", written by Giray
Ökten1. The contents of the original book are retained, while all the algorithms are im-
plemented in Python (Version 3.8.0). Python is an open source (under OSI), interpreted,
general-purpose programming language that has a large number of users around the world.
Python is ranked the third in August 2020 by the TIOBE programming community index2, a
measure of popularity of programming languages, and is the top-ranked interpreted language.
We hope this book will better serve readers who are interested in a first course in Numerical
Analysis, but are more familiar with Python for the implementation of the algorithms.

    The first chapter of the book has a self-contained tutorial for Python, including how to
set up the computer environment. Anaconda, the open-source individual edition, is recom-
mended for an easy installation of Python and effortless management of Python packages,
and the Jupyter environment, a web-based interactive development environment for Python
as well as many other programming languages, was used throughout the book and is recom-
mended to the readers for easy code developement, graph visualization and reproducibility.

    The book was also inspired by a series of Open Educational Resources workshops at Uni-
versity of Colorado Denver and supported partially by the professional development funding
thereof. Yaning Liu also thanks his students in his Numerical Analysis classes, who enjoyed
using Python to implement the algorithms and motivated him to write a Numerical Analysis
textbook with codes in Python.

Yaning Liu        Giray Ökten
August 2020       August 2020
Denver, Colorado  Tallahassee, Florida

1https://open.umn.edu/opentextbooks/textbooks/first-semester-in-numerical-analysis-with-julia
2https://www.tiobe.com/tiobe-index/

                                                       4
Chapter 1
Introduction

1.1 Review of Calculus

There are several concepts and facts from Calculus that we need in Numerical Analysis. In
this section we will list some definitions and theorems that will be needed later. For the
most part functions in this book refer to real valued functions defined on real numbers R,
or an interval (a, b)  R.

Definition 1. 1. A function f has the limit L at x0, written as limxx0 f (x) = L, if for
       any > 0, there exists  > 0 such that |f (x) - L| < whenever 0 < |x - x0| < .

   2. A function f is continuous at x0 if limxx0 f (x) = f (x0), and f is continuous on a set
       A if it is continuous at each x0  A.

   3. Let {xn} n=1 be an infinite sequence of real numbers. The sequence has the limit x,
       i.e., limn xn = x (or, written as xn  x as n  ) if for any > 0, there exists an
       integer N > 0 such that |xn - x| < whenever n > N.

Theorem 2. The following are equivalent for a real valued function f :

1. f is continuous at x0
2. If {xn} n=1 is any sequence converging to x0, then limn f (xn) = f (x0).

Definition 3. We say f (x) is differentiable at x0 if

         f (x0) = lim f (x) - f (x0) = lim f (x0 + h) - f (x0)
              xx0 x - x0     h0                        h

exists.

                          5
CHAPTER 1. INTRODUCTION                                                           6

Notation: Cn(A) denotes the set of all functions f such that f and its first n derivatives
       are continuous on A. If f is only continuous on A, then we write f  C0(A). C(A)
       consists of functions that have derivatives of all orders, for example, f (x) = sin x or
       f (x) = ex.

    The following well-known theorems of Calculus will often be used in the remainder of the
book.

Theorem 4 (Mean value theorem). If f  C0[a, b] and f is differentiable on (a, b), then
there exists c  (a, b) such that f (c) = b-a f(b)-f(a) .

Theorem 5 (Extreme value theorem). If f  C0[a, b] then the function attains a minimum
and maximum value over [a, b]. If f is differentiable on (a, b), then the extreme values occur
either at the endpoints a, b or where f is zero.

Theorem 6 (Intermediate value theorem). If f  C0[a, b] and K is any number between
f (a) and f (b), then there exists c  (a, b) with f (c) = K.

Theorem 7 (Taylor's theorem). Suppose f  Cn[a, b] and f (n+1) exists on (a, b), and x0 
(a, b). Then, for x  (a, b)

                                             f (x) = Pn(x) + Rn(x)

where Pn is the nth order Taylor polynomial

P (x - x0)2 n(x) = f (x0) + f (x0)(x - x0) + f (x0) + ... + f (n)(x (x - x0)n 0)
                                             2!                             n!

and Rn is the remainder term

                              Rn(x) = f (n+1)() (x - x0)n+1
                                                       (n + 1)!

for some  between x and x0.

Example 8. Let f (x) = x cos x - x.

1. Find P3(x) about x0 = /2 and use it to approximate f (0.8).

2. Compute the exact value for f (0.8), and the error |f (0.8) - P3(0.8)|.

3. Use the remainder term R3(x) to find an upper bound for the error |f (0.8) - P3(0.8)|.
   Compare the upper bound with the actual error found in part 2.
CHAPTER 1. INTRODUCTION                                               7

Solution. 1. First note that f (/2) = -/2. Differentiating f we get:

        f (x) = cos x - x sin x - 1  f (/2) = -/2 - 1
       f (x) = -2 sin x - x cos x  f (/2) = -2
       f (x) = -3 cos x + x sin x  f (/2) = /2.

   Therefore
                P3(x) = -/2 - (/2 + 1)(x - /2) - (x - /2)2 +  (x - /2)3.
                                                                                    12

   Then we approximate f (0.8) by P3(0.8) = -0.3033 (using 4-digits with rounding).
2. The exact value is f (0.8) = -0.2426 and the absolute error is |f (0.8) - P3(0.8)| =

   0.06062.

3. To find an upper bound for the error, write

       |f (0.8) - P3(0.8)| = |R3(0.8)|

where  R3(0.8) = f (4)() (0.8 - /2)4
                                   4!

and  is between 0.8 and /2. We need to differentiate f one more time: f (4)(x) =

4 sin x + x cos x. Since 0.8 <  < /2, we can find an upper bound for f (4)(x), and thus

an upper bound for R3(0.8), using triangle inequality:

       |R3(0.8)| = f (4)() (0.8 - /2)4 = |4 sin  +  cos | (0.01471)
                                      4!

                    0.05883| sin | + 0.01471||| cos |.

Note that on 0.8 <  < /2, sin  is a positive increasing function, and | sin()| <
sin(/2) = 1. For the second term, we can find an upper bound by observing ||
attains a maximum value of /2 on 0.8 <  < /2, and cos , which is a decreasing
positive function on 0.8 <  < /2, has a maximum value of cos (0.8) = 0.6967.
Putting these together, we get

       |R3(0.8)| < 0.05883(1) + (0.01471)(/2)(0.6967)  0.07493.

Therefore, our estimate for the actual error (which is 0.06062 from part 2) is 0.07493.
CHAPTER 1. INTRODUCTION                               8

    Exercise 1.1-1: Find the second order Taylor polynomial for f (x) = ex sin x about
x0 = 0.

a) Compute P2(0.4) to approximate f (0.4). Use the remainder term R2(0.4) to find an
    upper bound for the error |P2(0.4)-f (0.4)|. Compare the upper bound with the actual
    error.

1                        1
b) Compute 0 P2(x)dx to approximate 0 f (x)dx. Find an upper bound for the error

              1

using 0 R2(x)dx, and compare it to the actual error.

1.2 Python basics

We recommend using the free and open-source Python package manager Anaconda (Individ-
ual Edition https://www.anaconda.com/products/individual). Go to the webpage and
choose the installer according to your operating system. At the time of writing this book,
Python Version 3.8 is installed by default, which is also the version we use in this book.
There are different environments and editors to run Python. Here we will use the Jupyter
environment, which will be ready after Anaconda is installed. There are several tutorials
and other resources on Python at https://www.python.org/ where one can find up-to-date
information on Python.

    The Jupyter environment uses the so-called Jupyter notebook where one can write and
edit a Python code, run the code, and export the work into various file formats including
Latex and pdf. Most of our interaction with Python will be through the Jupyter notebooks.
Note that Anaconda, once installed, has already preinstalled a large number of commonly
used Python packages, so it is not necessary to install new packages for the purpose of
running the codes in this book.

    After installing Anaconda, open a Jupyter notebook by following Anaconda  Jupyter
Notebook  new  Python 3 . Here is a screenshot of my notebook:
CHAPTER 1. INTRODUCTION  9

    Let's start with some basic computations.

In [1]: 2+3
Out[1]: 5

    Now we import the sin and log function, as well as the  constant from the math
package,

In [2]: from math import sin, pi, log
    and compute sin (/4):

In [3]: sin(pi/4)
Out[3]: 0.7071067811865475

    One way to learn about a function is to search for it online in the Python documentation
https://docs.python.org/3/. For example, the syntax for the logarithm function in the
math package is log(x[, b]) where b is the optional base. If b is not provided, the natural
logarithm of x (to base e) is computed.

In [4]: log(4, 2)
Out[4]: 2.0
CHAPTER 1. INTRODUCTION                                                           10

NumPy arrays

NumPy is a useful Python package for array data structure, random number generation,
linear algebra algorithms, and so on. A NumPy array is a data structure that can be used
to represent vectors and matrices, for which the computations are also made easier. Import
the NumPy package and define an alias (np) for it.

In [5]: import numpy as np
    Here is the basic syntax to create a 1D NumPy array (representing a vector):

In [6]: x = np.array([10, 20, 30])
            x

Out[6]: array([10, 20, 30])

    The following line of code shows the entries of the created array are integers of 64 bits.
In [7]: x.dtype
Out[7]: dtype('int64')

    If we input a real, Python will change the type accordingly:
In [8]: x = np.array([10, 20, 30, 0.1])

            x
Out[8]: array([10. , 20. , 30. , 0.1])
In [9]: x.dtype
Out[9]: dtype('float64')

    A 1D NumPy array does not assume a particular row or column arrangement of the
data, and hence taking transpose for a 1D NumPy array is not valid. Here is another way
to construct a 1D array, and some array operations:

In [10]: x = np.array([10*i for i in range(1, 6)])
              x

Out[10]: array([10, 20, 30, 40, 50])

In [11]: x[-1]
CHAPTER 1. INTRODUCTION                               11

Out[11]: 50
In [12]: min(x)
Out[12]: 10
In [13]: np.sum(x)
Out[13]: 150
In [14]: x = np.append(x, 99)

              x
Out[14]: array([10, 20, 30, 40, 50, 99])
In [15]: x[3]
Out[15]: 40
In [16]: x.size
Out[16]: 6

    The NumPy package has a wide range of mathematical functions such as sin, log, etc.,
which can be applied elementwise to an array:

In [17]: x = np.array([1,2,3])
In [18]: np.sin(x)
Out[18]: array([0.84147098, 0.90929743, 0.14112001])

Plotting

There are several packages for plotting functions and we will use the PyPlot package. The
package is preinstalled in Anaconda. To start the package, use

In [19]: import matplotlib.pyplot as plt
              %matplotlib inline

The following piece of code is a simple example of plotting with PyPlot.
CHAPTER 1. INTRODUCTION                                                   12

In [20]: x = np.linspace(0, 2*np.pi, 1000)
              y = np.sin(3*x)
              plt.plot(x, y, color='red', linewidth=2.0, linestyle='--')
              plt.title('The sine function');

    Let's plot two functions, sin 3x and cos x, and label them appropriately.

In [21]: x = np.linspace(0, 2*np.pi, 1000)
              y = np.sin(3*x)
              z = np.cos(x)
              plt.plot(x, y, color='red', linewidth=2.0, linestyle='--', label='sin(3x)')
              plt.plot(x, z, color='blue', linewidth=1.0, linestyle='-', label='cos(x)')
              plt.legend(loc='upper center');
CHAPTER 1. INTRODUCTION                                                              13

Matrix operations

NumPy uses 2D arrays to represent matrices. Let's create a 3 × 3 matrix (2D array):

In [22]: A = np.array([[-1, 0.26, 0.74], [0.09, -1, 0.26], [1,1,1]])
              A

Out[22]: array([[-1. , 0.26,           0.74],
                        [ 0.09, -1. ,  0.26],
                        [ 1. , 1. ,    1. ]])

Transpose of A is computed as:

In [23]: A.T

Out[23]: array([[-1. , 0.09, 1. ],
                        [ 0.26, -1. , 1. ],
                        [ 0.74, 0.26, 1. ]])

Here is its inverse.

In [24]: np.linalg.inv(A)
CHAPTER 1. INTRODUCTION                                                       14

Out[24]: array([[-0.59693007, 0.22740193,            0.38260375],
                        [ 0.08053818, -0.82433201,   0.15472807],
                        [ 0.51639189, 0.59693007,    0.46266818]])

To compute the product of A and the inverse of A, use:

In [25]: np.dot(A, np.linalg.inv(A))

Out[25]: array([[ 1.00000000e+00,          1.24617643e-17, -1.74319952e-17],
                        [-3.98224397e-17,  1.00000000e+00, 1.74319952e-17],
                        [ 0.00000000e+00,  0.00000000e+00, 1.00000000e+00]])

Let's try matrix vector multiplication. Define some vector v as:

In [26]: v = np.array([0,0,1])
              v

Out[26]: array([0, 0, 1])

    Now try np.dot(A, v) to multiply them.

In [27]: np.dot(A, v)

Out[27]: array([0.74, 0.26, 1. ])
    To solve the matrix equation Ax = v, type:

In [28]: np.linalg.solve(A, v)

Out[28]: array([0.38260375, 0.15472807, 0.46266818])
    The solution to Ax = v can be also computed as x = A-1v as follows:

In [29]: np.dot(np.linalg.inv(A), v)

Out[29]: array([0.38260375, 0.15472807, 0.46266818])
    Powers of A can be computed as:

In [30]: np.linalg.matrix_power(A, 5)

Out[30]: array([[-2.80229724, 0.39583437,            2.76651959],
                         [ 0.12572728, -1.39301724,  0.84621677],
                         [ 3.74250756, 3.24338756,   4.51654028]])
CHAPTER 1. INTRODUCTION                               15

Logic operations

Here are some basic logic operations:
In [31]: 2 == 3
Out[31]: False
In [32]: 2 <= 3
Out[32]: True
In [33]: (2==2) or (1<0)
Out[33]: True
In [34]: (2==2) and (1<0)
Out[34]: False
In [35]: (4 % 2) == 0 # Check if 4 is an even number
Out[35]: True
In [36]: (5 % 2) == 0
Out[36]: False
In [37]: (5 % 2) == 1 # Check if 5 is an odd number
Out[37]: True

Defining functions

There are two ways to define a function. Here is the basic syntax:

In [38]: def squareit(x):
                    return x**2

In [39]: squareit(3)

Out[39]: 9

    There is also a compact form to define a function, if the body of the function is a short, simple
expression:
CHAPTER 1. INTRODUCTION  16

In [40]: cubeit = lambda x: x**3
In [41]: cubeit(5)
Out[41]: 125

    Suppose we want to pick the elements of an array that are greater than 0. This can be done
using:
In [42]: x = np.array([-2,3,4,5,-3,0])

              x[x>0]
Out[42]: array([3, 4, 5])

    To count the number of elements that are greater than 0 in the array above, use
In [43]: x[x>0].size
Out[43]: 3

Types

In Python, there are several types for integers and floating-point numbers such as int8, int64, float32,
float64, and more advanced types for Boolean variables and strings. When we write a function, we
do not have to declare the type of its variables: Python figures what the correct type is when
the code is compiled. This is called a dynamic type system. For example, consider the squareit
function we defined before:

In [44]: def squareit(x):
                    return x**2

    The type of x is not declared in the function definition. We can call it with real or integer
inputs, and Python will know what to do:

In [45]: squareit(5)

Out[45]: 25

In [46]: squareit(5.5)

Out[46]: 30.25

    Now suppose the type of the input is a floating-point number. We can write another version of
squareit that specifies the type.
CHAPTER 1. INTRODUCTION  17

In [47]: def typesquareit(x: float):
                    return x**2

    The input x is now statically typed. However, the purpose here is to add an annotation to
remind the users of the input type that should be used. In fact, Python interpreter will not perform
any type checking automatically, unless some additional packages are used. In other words, there
will be no difference between the squareit and typesquareit functions.

In [48]: typesquareit(5.5)

Out[48]: 30.25

In [49]: typesquareit(5)

Out[49]: 25

    It can be seen that the function typesquareit has no problem taking the integer 5 as an input.

Control flow

Let's create a NumPy array of 10 entries of floating-type. A simple way to do it is by using the
function np.zeros(n), which creates an array of size n, and sets each entry to zero. (A similar
function is np.ones(n) which creates an array of size n with each entry set to 1.)

In [50]: values = np.zeros(10)
              values

Out[50]: array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

    Now we will set the elements of the array to values of sin function.

In [51]: for n in range(10):
                    values[n] = np.sin((n+1)**2)

In [52]: values

Out[52]: array([ 0.84147098, -0.7568025 , 0.41211849, -0.28790332, -0.13235175,
                         -0.99177885, -0.95375265, 0.92002604, -0.62988799, -0.50636564])

    Here is another way to do this. Start with creating an empty array:

In [53]: newvalues = np.array([])

    Then use a while statement to generate the values, and append them to the array.
CHAPTER 1. INTRODUCTION                                                                    18

In [54]: n = 1
              while n<=10:
                    newvalues = np.append(values, np.sin(n**2))
                    n += 1
              newvalues

Out[54]: array([ 0.84147098, -0.7568025 ,           0.41211849, -0.28790332, -0.13235175,
                         -0.99177885, -0.95375265,  0.92002604, -0.62988799, -0.50636564,
                         -0.50636564])

Here is how the if statement works:

In [55]: def f(x, y):
                    if x < y:
                          print(x, ' is less than ', y)
                    elif x > y:
                          print(x, ' is greater than ', y)
                    else:
                          print(x, ' is equal to ', y)

In [56]: f(2, 3)

2 is less than 3

In [57]: f(3, 2)
3 is greater than 2

In [58]: f(1, 1)
1 is equal to 1

    In the next example we use if and while to find all the odd numbers in {1, . . . , 10}. The empty
array created in the first line is of int64 type.

In [59]: odds = np.array([]).astype('int64')
              n=1
              while n <= 10:
                    if n%2 == 1:
                          odds = np.append(odds, n)
                    n += 1
              odds
CHAPTER 1. INTRODUCTION                                                              19

Out[59]: array([1, 3, 5, 7, 9])

    Here is an interesting property of the function break:

In [60]: n = 1
              while n <= 20:
                    if n%2 == 0:
                          print(n)
                          break
                    n += 1

2

    Why did the above execution stop at 2? Let's try removing break:

In [61]: n = 1
              while n <= 20:
                    if n%2 == 0:
                          print(n)
                    n += 1

2
4
6
8
10
12
14
16
18
20

    The function break causes the code to exit the while loop once it is evaluated.

Random numbers

These are 5 uniform random numbers from (0,1).
In [62]: import numpy as np
CHAPTER 1. INTRODUCTION  20

In [63]: np.random.rand(5)
Out[63]: array([0.43296376, 0.66060029, 0.91030457, 0.27065652, 0.58976353])

    And these are random numbers from the standard normal distribution:

In [64]: np.random.randn(5)
Out[64]: array([-0.60385045, -0.1138149 , 0.80330871, -0.85704952, 1.26651986])

    Here is a frequency histogram of 105 random numbers from the standard normal distribution
using 50 bins:

In [65]: y = np.random.randn(10**5)
              plt.hist(y, 50);

    Sometimes we are interested in relative frequency histograms where the height of each bin is the
relative frequency of the numbers in the bin. Adding the option "density=true" outputs a relative
frequency histogram:

In [66]: y = np.random.randn(10**5)
              plt.hist(y, 50, density=True);
CHAPTER 1. INTRODUCTION                                                              21

    Exercise 1.2-1: In Python you can compute the factorial of a positive integer n by the built-

in function factorial(n) from the subpackage special in SciPy (scipy.special.factorial(n)). Write
your own version of this function, called f actorial2, using a for loop. Use the time.time() function
to compare the execution time of your version and the built-in version of the factorial function.

    Exercise 1.2-2: Write a Python code to estimate the value of  using the following procedure:

Place a circle of diameter one in the unit square. Generate 10,000 pairs of random numbers (u, v)
from the unit square. Count the number of pairs (u, v) that fall into the circle, and call this number
n. Then n/10000 is approximately the area of the circle. (This approach is known as the Monte
Carlo method.)

Exercise 1.2-3: Consider the following function

                                          ni

                              f (x, n) =           xn-j+1.

                                          i=1 j=1

a) Compute f (2, 3) by hand.

b) Write a Python code that computes f . Verify f (2, 3) matches your answer above.

1.3 Computer arithmetic

The way computers store numbers and perform computations could surprise the beginner. In Python
if you type (3)2 the result will be 2.9....96, where 9 is repeated 15 times. Here are two obvious
but fundamental differences in the way computers do arithmetic:

    · only finitely many numbers can be represented in a computer;

    · a number represented in a computer can only have finitely many digits.

Therefore the numbers that can be represented in a computer exactly is only a subset of rational
numbers. Anytime the computer performs an operation whose outcome is not a number that can be
represented exactly in the computer, an approximation will replace the exact number. This is called
the roundoff error : error produced when a computer is used to perform real number calculations.

Floating-point representation of real numbers

Here is a general model for representing real numbers in a computer:

                              x = s(.a1a2...at) × e                                  (1.1)
CHAPTER 1. INTRODUCTION                           22

where

                                             s  sign of x = ±1
                                             e  exponent, with bounds L  e  U
                                 (.a1...at) = a1  + 2 a2 + ... + t at ; the mantissa
                                              base
                                             t  number of digits; the precision.

    In the floating-point representation (1.1), if we specify e in such a way that a1 = 0, then the
representation will be unique. This is called the normalized floating-point representation. For
example if  = 10, in the normalized floating-point we would write 0.012 as 0.12 × 10-1, instead of
choices like 0.012 × 100 or 0.0012 × 10.

    In most computers today, the base is  = 2. Bases 8 and 16 were used in old IBM mainframes in
the past. Some handheld calculators use base 10. An interesting historical example is a short-lived
computer named Setun developed at Moscow State University which used base 3.

    There are several choices to make in the general floating-point model (1.1) for the values of
s, , t, e. The IEEE 64-bit floating-point representation is the specific model used in most computers
today:

                x = (-1)s(1.a2a3...a53)22e-1023.  (1.2)

Some comments:

· Notice how s appears in different forms in equations (1.1) and (1.2). In (1.2), s is either 0 or
   1. If s = 0, then x is positive. If s = 1, x is negative.

· Since  = 2, in the normalized floating-point representation of x the first (nonzero) digit after
   the decimal point has to be 1. Then we do not have to store this number. That's why we
   write x as a decimal number starting at 1 in (1.2). Even though precision is t = 52, we are
   able to access up to the 53rd digit a53.

· The bounds for the exponent are: 0  e  2047. We will discuss where 2047 comes from
   shortly. But first, let's discuss why we have e-1023 as the exponent in the representation (1.2),
   as opposed to simply e (which we had in the representation (1.1)). If the smallest exponent
   possible was e = 0, then the smallest positive number the computer can generate would be
   (1.00...0)2 = 1: certainly we need the computer to represent numbers less than 1! That's why
   we use the shifted expression e - 1023, called the biased exponent, in the representation
   (1.2). Note that the bounds for the biased exponent are -1023  e - 1023  1024.

Here is a schema that illustrates how the physical bits of a computer correspond to the representation
CHAPTER 1. INTRODUCTION                                                                  23

above. Each cell in the table below, numbered 1 through 64, correspond to the physical bits in the
computer memory.

                                      1 2 3 . . . 12 13 . . . 64

· The first bit is the sign bit: it stores the value for s, 0 or 1.

· The blue bits 2 through 12 store the exponent e (not e-1023). Using 11 bits, one can generate
   the integers from 0 to 211 - 1 = 2047. Here is how you get the smallest and largest values for
   e:

                                                          e = (00...0)2 = 0
                                  e = (11...1)2 = 20 + 21 + ... + 210 = 211 - 1 = 2047.

                                                                                    2-1
    · The red bits, and there are 52 of them, store the digits a2 through a53.
Example 9. Find the floating-point representation of 10.375.
Solution. You can check that 10 = (1010)2 and 0.375 = (.011)2 by computing

         10 = 0 × 20 + 1 × 21 + 0 × 22 + 1 × 23
      0.375 = 0 × 2-1 + 1 × 2-2 + 1 × 2-3.

Then

      10.375 = (1010.011)2 = (1.010011)2 × 23

where (1.010011)2 × 23 is the normalized floating-point representation of the number. Now we
rewrite this in terms of the representation (1.2):

      10.375 = (-1)0(1.010011)2 × 21026-1023.

Since 1026 = (10000000010)2, the bit by bit representation is:

      0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 1 1 0 ... 0

Notice the first sign bit is 0 since the number is positive. The next 11 bits (in blue) represent the
exponent e = 1026, and the next group of red bits are the mantissa, filled with 0's after the last
digit of the mantissa. In Python, although there is no built-in function that produces the bit by bit
representation of a number, we can define the following function named float2bin, which provides
the bit representation of a floating-point number, based on the struct package:
CHAPTER 1. INTRODUCTION                                                       24

In [1]: import struct
            def float2bin(f):
                  (d,) = struct.unpack(">Q", struct.pack(">d", f))
                  return f'{d:064b}'

In [2]: float2bin(10.375)

Out[2]: '0100000000100100110000000000000000000000000000000000000000000000'

Special cases: zero, infinity, NAN

In the floating-point arithmetic there are two zeros: +0.0 and -0.0, and they have special repre-
sentations. In the representation of zero, all exponent and mantissa bits are set to 0. The sign bit
is 0 for +0.0, and 1, for -0.0:

                                  0.0  0 0 all zeros 0 0 all zeros 0

                                 -0.0  1 0 all zeros 0 0 all zeros 0

    When the exponent bits are set to zero, we have e = 0 and thus e - 1023 = -1023. This
arrangement, all exponent bits set to zero, is reserved for ±0.0 and subnormal numbers. Subnor-
mal numbers are an exception to our normalized floating-point representation, an exception that is
useful in various ways. For details see Goldberg [9].

    Here is how plus and minus infinity is represented in the computer:

                                  - 0 1 all ones 1 0 all zeros 0

                                 -- 1 1 all ones 1 0 all zeros 0

    When the exponent bits are set to one, we have e = 2047 and thus e - 1023 = 1024. This
arrangement is reserved for ± as well as other special values such as NaN (not-a-number).

    In conclusion, even though -1023  e-1023  1024 in (1.2), when it comes to representing non-
zero real numbers, we only have access to exponents in the following range: -1022  e-1023  1023.

    Therefore, the smallest positive real number that can be represented in a computer is

                    x = (-1)0(1.00 . . . 0)2 × 2-1022 = 2-1022  0.2 × 10-307

and the largest is

x = (-1)0(1.11 . . . 1)2 × 21023 = 1 + 12 + 221 + ... + 252 1  × 21023
                                       = (2 - 2-52)21023
                                        0.18 × 10309.
CHAPTER 1. INTRODUCTION  25

During a calculation, if a number less than the smallest floating-point number is obtained, then we
obtain the underflow error. A number greater than the largest gives overflow error.

    Exercise 1.3-1: Consider the following toy model for a normalized floating-point represen-

tation in base 2: x = (-1)s(1.a2a3)2 × 2e where -1  e  1. Find all positive machine numbers
(there are 12 of them) that can be represented in this model. Convert the numbers to base 10,
and then carefully plot them on the number line, by hand, and comment on how the numbers are
spaced.

Representation of integers

In the previous section, we discussed representing real numbers in a computer. Here we will give
a brief discussion of representing integers. How does a computer represent an integer n? As in
real numbers, we start with writing n in base 2. We have 64 bits to represent its digits and sign.
As in the floating-point representation, we can allocate one bit for the sign, and use the rest, 63
bits, for the digits. This approach has some disadvantages when we start adding integers. Another
approach, known as the two's complement, is more commonly used, including in Python.

    For an example, assume we have 8 bits in our computer. To represent 12 in two's complement
(or any positive integer), we simply write it in its base 2 expansion: (00001100)2. To represent -12,
we do the following: flip all digits, replacing 1 by 0, and 0 by 1, and then add 1 to the result. When
we flip digits for 12, we get (11110011)2, and adding 1 (in binary), gives (11110100)2. Therefore
-12 is represented as (11110100)2 in two's complement approach. It may seem mysterious to go
through all this trouble to represent -12, until you add the representations of 12 and -12,

                                    (00001100)2 + (11110100)2 = (100000000)2

and realize that the first 8 digits of the sum (from right to left), which is what the computer can
only represent (ignoring the red digit 1), is (00000000)2. So just like 12 + (-12) = 0 in base 10, the
sum of the representations of these numbers is also 0.

    We can repeat these calculations with 64-bits, using Python. The function int2bin defined below
outputs the digits of an integer, using two's complement for negative numbers:

In [1]: import struct
            def int2bin(i):
                  (d,) = struct.unpack(">Q", struct.pack(">q", i))
                  return f'{d:064b}'

In [2]: int2bin(12)
CHAPTER 1. INTRODUCTION  26

Out[2]: '0000000000000000000000000000000000000000000000000000000000001100'

In [3]: int2bin(-12)

Out[3]: '1111111111111111111111111111111111111111111111111111111111110100'

    You can verify that the sum of these representations is 0, when truncated to 64-digits.
    Here is another example illustrating the advantages of two's complement. Consider -3 and 5,
with representations,

                                      -3 = (11111101)2 and 5 = (00000101)2.
The sum of -3 and 5 is 2; what about the binary sum of their representations? We have

                                    (11111101)2 + (00000101)2 = (100000010)2

and if we ignore the ninth bit in red, the result is (10)2, which is indeed 2. Notice that if we followed
the same approach used in the floating-point representation and allocated the leftmost bit to the
sign of the integer, we would not have had this property.

    We will not discuss integer representations and integer arithmetic any further. However one
useful fact to keep in mind is the following: in two's complement, using 64 bits, one can represent
integers between -263 = -9223372036854775808 and 263 - 1 = 9223372036854775807. Any integer
below or above yields underflow or overflow error. However, Python is special compared to
the other programming languages in that it supports arbitrary-precision integer implementation.
Integers of any size can be supported in Python, while it is not true for floats.

Example 10. From Calculus, we know that limn-> n! nn = . Therefore, computing n! nn , which is
a float, for large n will cause overflow at some point. Here is a Python code for this calculation:

In [1]: from scipy.special import factorial
            f = lambda n: n**n/factorial(n)

    Let's have a closer look at this function. The Python function factorial(n) computes the
factorial, returned as a float, as the gamma function at n + 1. If we call f with an integer input,
then the above code will compute nn as an integer and factorial(n) as a float. Then it will divide
these numbers, by first converting nn to a float, and obtain a floating-point factorial. Let's compute
f (n) = n! nn as n = 1, ..., 1000:

In [2]: for n in range(1, 1001):
                  print(n, f(n))

.
.
CHAPTER 1. INTRODUCTION                              27

.
135 1.4629522660965042e+57
136 3.962087287769907e+57
137 1.0730739055834461e+58
138 2.90634235201109e+58
139 7.871822311096416e+58
140 2.132136506640898e+59
141 5.775183434192781e+59
142 1.5643266954396485e+60
143 4.2374040203696554e+60

---------------------------------------------------------------------------

OverflowError                               Traceback (most recent call last)

<ipython-input-2-88a424afb432> in <module>

1 for n in range(1, 1001):

----> 2  print(n, f(n))

      <ipython-input-1-6df979c5f68c> in <lambda>(n)
         1 from scipy.special import factorial

----> 2 f = lambda n: n**n/factorial(n)

            OverflowError: int too large to convert to float

    Notice that the process cannot proceed beyond n = 143. Where exactly does the error occur?
Python can compute 144144 exactly (arbitrary-precision); however, when it is converted to a floating-
point number, overflow occurs. For 143143, overflow does not happen.
In [3]: float(143**143)
Out[3]: 1.6332525972973913e+308
In [4]: float(144**144)
CHAPTER 1. INTRODUCTION                           28

---------------------------------------------------------------------------

OverflowError                                     Traceback (most recent call last)

      <ipython-input-2-9d2f48a83404> in <module>
----> 1 float(144**144)

            OverflowError: int too large to convert to float

    The function f (n) can be coded in a much better way if we rewrite n! nn as n n n n-1 ... n1 . Each
fraction can be computed separately, and then multiplied, which will slow down the growth of the
numbers. Here is a new code using a for statement.

In [5]: def f(n):
                  pr = 1.
                  for i in range(1, n):
                         pr *= n/(n-i)
                  return pr

    Let's compute f (n) = n! nn as n = 1, ..., 1000 again:

In [6]: for i in range(1, 1001):
                  print(i, f(i))

.
.
.
705 2.261381911989747e+304
706 6.142719392952918e+304
707 1.6685832310803885e+305
708 4.532475935558631e+305
709 1.2311857272492938e+306
710 3.34435267514059e+306
711 9.084499321839277e+306
712 2.4676885942863887e+307
713 6.70316853566547e+307
714 inf
CHAPTER 1. INTRODUCTION  29

715 inf
716 inf
717 inf
718 inf
.
.
.

    The previous version of the code gave overflow error when n = 144. This version has no difficulty
in computing nn/n! for n = 144. In fact, we can go as high as n = 713. Overflow in floating-point
arithmetic yields the output inf, which stands for infinity.

    Another way to accommodate a larger value of n is to define the function f in this way:

In [7]: from scipy.special import factorial
            f = lambda n: n**n/factorial(n, True)

    With the addition input "True", the function factorial(n) returns an integer with arbitrary
precision, instead of a float, so that both the numerator and denominator are integers. The limit
process stops only when the division produces a floating-point number that is so large that overflow
occurs. As a result, the same result as in the improved algorithm above is expected. Please verify
that the process can continue until n = 713 with the modified f function.

    We will discuss several features of computer arithmetic in the rest of this section. The discussion
is easier to follow if we use the familiar base 10 representation of numbers instead of base 2. To this
end, we introduce the normalized decimal floating-point representation:

                                                    ±0.d1d2...dk × 10n

where 1  d1  9, 0  di  9 for all i = 2, 3, ..., k. Informally, we call these numbers k-digit decimal
machine numbers.

Chopping & Rounding

Let x be a real number with more digits the computer can handle: x = 0.d1d2 . . . dkdk+1 . . . × 10n.
How will the computer represent x? Let's use the notation f l(x) for the floating-point representation
of x. There are two choices, chopping and rounding:

    · In chopping, we simply take the first k digits and ignore the rest: f l(x) = 0.d1d2 . . . dk.

    · In rounding, if dk+1  5 we add 1 to dk to obtain f l(x). If dk+1 < 5, then we simply do as in
        chopping.
CHAPTER 1. INTRODUCTION                                                                               30

Example 11. Find 5-digit (k = 5) chopping and rounding values of the numbers below:

    ·  = 0.314159265... × 101
        Chopping gives f l() = 0.31415 and rounding gives f l() = 0.31416.

    · 0.0001234567
        We need to write the number in the normalized representation first as 0.1234567 × 10-3. Now
        chopping gives 0.12345 and rounding gives 0.12346.

Absolute and relative error

Since computers only give approximations to real numbers, we need to be clear on how we measure
the error of an approximation.

Definition 12. Suppose x is an approximation to x.

· |x - x| is called the absolute error
· |x| |x-x| is called the relative error (x = 0)

Relative error usually is a better choice of measure, and we need to understand why.

Example 13. Find absolute and relative errors of

1. x = 0.20 × 101, x = 0.21 × 101
2. x = 0.20 × 10-2, x = 0.21 × 10-2
3. x = 0.20 × 105, x = 0.21 × 105

Notice how the only difference in the three cases is the exponent of the numbers. The absolute
errors are: 0.01 × 10 , 0.01 × 10-2 , 0.01 × 105. The absolute errors are different since the exponents
are different. However, the relative error in each case is the same: 0.05.

Definition 14. The number x is said to approximate x to s significant digits (or figures) if s is
the largest nonnegative integer such that

                                                   |x - x|  5 × 10-s.
                                                       |x|

In  Example  13  we  had  |x-x|  =  0.05    5 × 10-2  but  not  less  than  or  equal  to  5 × 10-3.  Therefore
                            |x|

we say x = 0.21 approximates x = 0.20 to 2 significant digits (but not to 3 digits).

When the computer approximates a real number x by f l(x), what can we say about the error?

The following result gives an upper bound for the relative error.
CHAPTER 1. INTRODUCTION                                                                         31

Lemma 15.       The relative error of approximating x by    f l(x) in the  k-digit  normalized  decimal
floating-point  representation satisfies
                                                            if chopping
                                                            if rounding.
                     |x - f l(x)| 10-k+1
                                             
                                   |x|          1 (10-k+1)

                                                 2

Proof. We will give the proof for chopping; the proof for rounding is similar but tedious. Let

                                   x = 0.d1d2...dkdk+1... × 10n.

Then                                    f l(x) = 0.d1d2...dk × 10n
if chopping is used. Observe that

                |x - f l(x)| 0.dk+1dk+2... × 10n-k          0.dk+1dk+2...  10-k .
                          =                           n=       0.d1d2...
                |x|                     0.d1d2... × 10

We have two simple bounds: 0.dk+1dk+2... < 1 and 0.d1d2...  0.1, the latter true since the smallest
d1 can be, is 1. Using these bounds in the equation above we get

                             |x - f l(x)|  1 10-k = 10-k+1.
                                        |x|         0.1

Remark 16. Lemma 15 easily transfers to the base 2 floating-point representation:               x=
(-1)s(1.a2...a53)2 × 2e-1023, by

                                        
                |x - f l(x)| 2-t+1 = 2-53+1 = 2-52
                                                                    if chopping
                     |x|                 1 (2-t+1) = 2-53           if rounding.

                                          2

Machine epsilon

Machine epsilon is the smallest positive floating point number for which f l(1 + ) > 1. This means,
if we add to 1.0 any number less than , the machine computes the sum as 1.0.

    The number 1.0 in its binary floating-point representation is simply (1.0 . . . 0)2 where a2 = a3 =
... = a53 = 0. We want to find the smallest number that gives a sum larger than 1.0, when it is
added to 1.0. The answer depends on whether we chop or round.

    If we are chopping, examine the binary addition
CHAPTER 1. INTRODUCTION                                                                             32

                                           a2           a52 a53

                                           1. 0 ... 0 0

                                + 0. 0 ... 0 1

                                           1. 0 ... 0 1

and notice (0.0...01)2 =     1  52 = 2-52  is the smallest number we can add to 1.0 such that the sum
                             2

will be different than 1.0.

If we are rounding, examine the binary addition

                                           a2       a52 a53

                                           1. 0 ... 0 0

                                + 0. 0 ... 0 0 1

                                           1. 0 ... 0 0 1

where the sum has to be rounded to 53 digits to obtain

                                           a2 a52 a53 1. 0 ... 0 1 .

Observe that the number added to 1.0 above is (0.0...01)2 =           1     53 = 2-53, which is the smallest
                                                                      2

number that will make the sum larger than 1.0 with rounding.

In summary, we have shown                     
                                              2-52
                                           =        if chopping
                                              2-53                 .

                                                    if rounding

As a consequence, notice that we can restate the inequality in Remark 16 in a compact way using

the machine epsilon as:

                                           |x - f l(x)|
                                                          .

                                                |x|

Remark 17. There is another definition of machine epsilon: it is the distance between 1.0 and the
next floating-point number.

                                                    a2       a52 a53

                                number 1.0 1. 0 ... 0 0

                                next number 1. 0 ... 0 1

                                distance 0. 0 ... 0 1

Note that the distance (absolute value of the difference) is             1  52  =  2-52.  In  this  alternative
                                                                         2

definition, machine epsilon is not based on whether rounding or chopping is used. Also, note that

the distance between two adjacent floating-point numbers is not constant, but it is smaller for

smaller values, and larger for larger values (see Exercise 1.3-1).
CHAPTER 1. INTRODUCTION                                  33

Propagation of error

We discussed the resulting error when chopping or rounding is used to approximate a real number by
its machine version. Now imagine carrying out a long calculation with many arithmetical operations,
and at each step there is some error due to say, rounding. Would all the rounding errors accumulate
and cause havoc? This is a rather difficult question to answer in general. For a much simpler
example, consider adding two real numbers x, y. In the computer, the numbers are represented as
f l(x), f l(y). The sum of these number is f l(x) + f l(y); however, the computer can only represent
its floating-point version, f l(f l(x) + f l(y)). Therefore the relative error in adding two numbers is:

                                              (x + y) - f l(f l(x) + f l(y))
                                                                                   .

                                                            x+y

In this section, we will look at some specific examples where roundoff error can cause problems, and
how we can avoid them.

Subtraction of nearly equal quantities: Cancellation of leading digits

The best way to explain this phenomenon is by an example. Let x = 1.123456, y = 1.123447. We
will compute x - y and the resulting roundoff error using rounding and 6-digit arithmetic. First,
we find f l(x), f l(y) :

                                           f l(x) = 1.12346, f l(y) = 1.12345.

The absolute and relative error due to rounding is:

|x - f l(x)| = 4 × 10-6, |y - f l(y)| = 3 × 10-6

|x - f l(x)| = 3.56 × 10-6, |y - f l(y)| = 2.67 × 10-6.
|x|                      |y|

From the relative errors, we see that f l(x) and f l(y) approximate x and y to six significant digits.
Let's see how the error propagates when we subtract x and y. The actual difference is:

x - y = 1.123456 - 1.123447 = 0.000009 = 9 × 10-6.

The computer finds this difference first by computing f l(x), f l(y), then taking their difference and
approximating the difference by its floating-point representation: f l(f l(x) - f l(y)) :

f l(f l(x) - f l(y)) = f l (1.12346 - 1.12345) = 10-5.
CHAPTER 1. INTRODUCTION                                                                                   34

The resulting absolute and relative errors are:

                                        |(x - y) - (f l(f l(x) - f l(y)))| = 10-6

                                        |(x - y) - (f l(f l(x) - f l(y)))|
                                                                                = 0.1.

                                                       |x - y|

Notice how large the relative error is compared to the absolute error! The machine version of x - y
approximates x - y to only one significant digit. Why did this happen? When we subtract two
numbers that are nearly equal, the leading digits of the numbers cancel, leaving a result close to
the rounding error. In other words, the rounding error dominates the difference.

Division by a small number

Let  x = 0.444446  and  compute       x   in  a  computer  with  5-digit  arithmetic  and  rounding.  We  have
                                    10-5

f l(x) = 0.44445, with an absolute error of 4 × 10-6 and relative error of 9 × 10-6. The exact division

is    x   =  0.444446 × 105 .  The  computer  computes:  fl    x   = 0.44445×105, which has an absolute
    10-5                                                     10-5

error of 0.4 and relative error of 9 × 10-6. The absolute error went from 4 × 10-6 to 0.4. Perhaps

not surprisingly, division by a small number magnifies the absolute error but not the relative error.

     Consider the computation of                 1 - cos x

                                                 sin x

when x is near zero. This is a problem where we have both subtraction of nearly equal quantities
which happens in the numerator, and division by a small number, when x is close to zero. Let
x = 0.1. Continuing with five-digit rounding, we have

                               f l(sin 0.1) = 0.099833, f l(cos 0.1) = 0.99500

                               fl   1 - cos 0.1  = 0.050084.

                                    sin 0.1

The exact result to 8 digits is 0.050041708, and the relative error of this computation is 8.5 × 10-4.
Next we will see how to reduce this error using a simple algebraic identity.

Ways to avoid loss of accuracy

Here we will discuss some examples where a careful rewriting of the expression to compute can make
the roundoff error much smaller.

Example 18. Let's revisit the calculation of
                                                          1 - cos x
                                                                      .
                                                             sin x
CHAPTER 1. INTRODUCTION                                                                                35

Observe that using the algebraic identity

                                                   1 - cos x sin x
                                                               =

                                                     sin x 1 + cos x
removes both difficulties encountered before: there is no cancellation of significant digits or division
by a small number. Using five-digit rounding, we have

                                         fl    sin 0.1       = 0.050042.

                                             1 + cos 0.1

The relative error is 5.8 × 10-6, about a factor of 100 smaller than the error in the original compu-
tation.

Example 19. Consider the quadratic formula: the solution of ax2 + bx + c = 0 is

                                                                      
                                     -b + b2 - 4ac           -b - b2 - 4ac
                               r1 =          2a , r2 =                            .
                                                                      2a

If b  b2 - 4ac, then we have a potential loss of precision in computing one of the roots due to

cancellation. Let's consider a specific equation: x2 - 11x + 1 = 0. The roots from the quadratic
                                                             
formula  are:         11+ 117    10.90832691,  and           11- 117
               r1  =       2                        r2    =       2     0.09167308680.

Next will use four-digit arithmetic with rounding to compute the roots:

                                                  
                                               f l( 117) = 10.82

                                         
                      f l(f l(11.0) + f l( 117))             f l(11.0 + 10.82)         21.82
f l(r1) = f l                                     = fl                          = fl    2.0   = 10.91
 f l(r2) = f l                 f l(2.0)                           2.0            = fl         = 0.09.
                                                                                        0.18
                                                                                        2.0
                      f l(f l(11.0) - f l( 117))             f l(11.0 - 10.82)
                                                    = fl
                               f l(2.0)                           2.0

    The relative errors are:

                               rel error in r1= 10.90832691 - 10.91 = 1.5 × 10-4
                                                          10.90832691

                             rel error in r2 = 0.09167308680 - 0.09 = 1.8 × 10-2.
                                                         0.09167308680

Notice the larger relative error in r2 compared to that of r1, about a factor of 100, which is due to
cancellation of leading digits when we compute 11.0 - 10.82.

    One way to fix this problem is to rewrite the offending expression by rationalizing the numerator:
           11.0 - 117 1 11.0 - 117  1 4 2

    r2 = 2 = 2 11.0 + 117 11.0 + 117 = 2 11.0 + 117 = 11.0 + 117 .
CHAPTER 1. INTRODUCTION                                                                                                     36

If we use this formula to compute r2 we get:

               f l(r2) = f l                           2.0              = fl     2.0       = 0.09166.

                                       f l(11.0 + f l( 117))                     21.82

The new relative error in r2 is:

                         rel error in r2 = 0.09167308680 - 0.09166 = 1.4 × 10-4,
                                                         0.09167308680

an improvement about a factor of 100, even though in the new way of computing r2 there are two
operations where rounding error happens instead of one.

Example 20. The simple procedure of adding numbers, even if they do not have mixed signs, can
accumulate large errors due to rounding or chopping. Several sophisticated algorithms to add large
lists of numbers with accumulated error smaller than straightforward addition exist in the literature
(see, for example, Higham [11]).

    For a simple example, consider using four-digit arithmetic with rounding, and computing the
average of two numbers, 2 a+b . For a = 2.954 and b = 100.9, the true average is 51.927. However,
four-digit arithmetic with rounding yields:

               fl        100.9 + 2.954            = fl     f l(103.854)      = fl  103.9        = 51.95,

                                    2                              2                    2

which  has  a  relative  error  of  4.43  ×  10-4.     If  we  rewrite  the  averaging  formula  as  a  +  b-a  ,  on  the  other
                                                                                                            2

hand, we obtain 51.93, which has a much smaller relative error of 5.78 × 10-5. The following table

displays the exact and 4-digit computations, with the corresponding relative error at each step.

       4-digit rounding              a         b            a+b             a+b     b-a             b-a    a + 2 b-a
       Exact                       2.954     100.9          103.9            2      97.95            2      51.93
       Relative error                                      103.854                 97.946
                                                           4.43e-4       51.95     4.08e-5       48.98     51.927

                                                                        51.927                  48.973     5.78e-5

                                                                        4.43e-4                 1.43e-4

Example 21. There are two standard formulas given in textbooks to compute the sample variance
s2 of the numbers x1, ..., xn:

1. s2 = 1 n-1 i=1 n xi2 - n1 ( i=1 n xi)2 ,

2.     First compute x¯ =       1      i=1 n xi,  and  then    s2  =    1    i=1 n (xi - x¯)2.
                                n                                     n-1

Both formulas can suffer from roundoff errors due to adding large lists of numbers if n is large,
as mentioned in the previous example. However, the first formula is also prone to error due to
cancellation of leading digits (see Chan et al [6] for details).

    For an example, consider four-digit rounding arithmetic, and let the data be 1.253, 2.411, 3.174.
The sample variance from formula 1 and formula 2 are, 0.93 and 0.9355, respectively. The exact
CHAPTER 1. INTRODUCTION                                                         37

value, up to 6 digits, is 0.935562. Formula 2 is a numerically more stable choice for computing the
variance than the first one.

Example 22. We have a sum to compute:

              e-7 = 1 + -7 + (-7)2 + (-7)3 + ... + (-7)n .
                               1            2!   3!             n!

The alternating signs make this a potentially error prone calculation.
    Python reports the "exact" value for e-7 as 0.0009118819655545162. If we use Python to

compute this sum with n = 20, the result is 0.009183673977218275. Here is the Python code for
the calculation:

In [1]: import numpy as np
            from scipy.special import factorial

In [2]: sum = 1.0
            for n in range(1, 21):
                  sum += (-7)**n/factorial(n)
            sum

Out[2]: 0.009183673977218275

This result has a relative error of 9.1. We can avoid this huge error if we simply rewrite the

above sum as  e-7 = 71 =                         1

                                                 72 73       .
                                  e 1 + 7 + 2! + 3! + ...

The Python code for this computation using n = 20 is below:

In [3]: sum = 1.0
            for n in range(1, 21):
                  sum += 7**n/factorial(n)
            sum = 1/sum
            sum

Out[3]: 0.0009118951837867185

The result is 0.0009118951837867185, which has a relative error of 1.4 × 10-5.
CHAPTER 1. INTRODUCTION                                                                        38

    Exercise 1.3-2: The x-intercept of the line passing through the points (x1, y1) and (x2, y2)

can be computed using either one of the following formulas:

or,                              x = x1y2 - x2y1
with the assumption y1 = y2.              y2 - y1

                              x = x1 - (x2 - x1)y1
                                             y2 - y1

a) Show that the formulas are equivalent to each other.

b) Compute the x-intercept using each formula when (x1, y1) = (1.02, 3.32) and (x2, y2) =
    (1.31, 4.31). Use three-digit rounding arithmetic.

c) Use Python (or a calculator) to compute the x-intercept using the full-precision of the device
    (you can use either one of the formulas). Using this result, compute the relative and absolute
    errors of the answers you gave in part (b). Discuss which formula is better and why.

Exercise 1.3-3:          Write two functions in Python to compute the binomial coefficient  m  using
                                                                                            k

the following formulas:

a)  m  =      m!    (m!  is  scipy.special.factorial(m)  in  Python.)
    k     k!(m-k)!

b) mk = ( mk )( m-1 k-1 ) × ... × ( m-k+1 1 )
    Then, experiment with various values for m, k to see which formula causes overflow first.

    Exercise 1.3-4: Polynomials can be evaluated in a nested form (also called Horner's method)

that has two advantages: the nested form has significantly less computation, and it can reduce
roundoff error. For

                                 p(x) = a0 + a1x + a2x2 + ... + an-1xn-1 + anxn

its nested form is

                         p(x) = a0 + x(a1 + x(a2 + ... + x(an-1 + x(an))...)).

Consider the polynomial p(x) = x2 + 1.1x - 2.8.

a) Compute p(3.5) using three-digit rounding, and three-digit chopping arithmetic. What are
    the absolute errors? (Note that the exact value of p(3.5) is 13.3.)

b) Write x2 + 1.1x - 2.8 in nested form by these simple steps:

                         x2 + 1.1x - 2.8 = (x2 + 1.1x) - 2.8 = (x + 1.1)x - 2.8.
CHAPTER 1. INTRODUCTION  39

Then compute p(3.5) using three-digit rounding and chopping using the nested form. What
are the absolute errors? Compare the errors with the ones you found in (a).

Exercise 1.3-5: Consider the polynomial written in standard form: 5x4 + 3x3 + 4x2 + 7x - 5.

a) Write the polynomial in its nested form. (See the previous problem.)

b) How many multiplications does the nested form require when we evaluate the polynomial at a
    real number? How many multiplications does the standard form require? Can you generalize
    your answer to any nth degree polynomial?
CHAPTER 1. INTRODUCTION  40

Arya and the unexpected challenges of data analysis

Meet Arya! Arya is a college student interested in math, biology, literature, and acting. Like a
typical college student, she texts while walking on campus, complains about demanding professors,
and argues in her blogs that homework should be outlawed.

    Arya is taking a chemistry class, and she per-
forms some experiments in the lab to find the
weight of two substances. Due to difficulty in
making precise measurements, she can only as-
sess the weights to four-significant digits of accu-
racy: 2.312 grams and 0.003982 grams. Arya's
professor wants to know the product of these
weights, which will be used in a formula.

    Arya computes the product using her calculator: 2.312 × 0.003982 = 0.009206384, and stares at
the result in bewilderment. The numbers she multiplied had four-significant digits, but the product
has seven digits! Could this be the result of some magic, like a rabbit hopping out of a magician's
hat that was only a handkerchief a moment ago? After some internal deliberations, Arya decides
to report the answer to her professor as 0.009206. Do you think Arya was correct in not reporting
all of the digits of the product?
CHAPTER 1. INTRODUCTION  41

Sources of error in applied mathematics

Here is a list of potential sources of error when we solve a problem.
    1. Error due to the simplifying assumptions made in the development of a mathematical model
        for the physical problem.
    2. Programming errors.
    3. Uncertainty in physical data: error in collecting and measuring data.
    4. Machine errors: rounding/chopping, underflow, overflow, etc.
    5. Mathematical truncation error: error that results from the use of numerical methods in solving
        a problem, such as evaluating a series by a finite sum, a definite integral by a numerical
        integration method, solving a differential equation by a numerical method.

Example 23. The volume of the Earth could be computed using the formula for the volume of a
sphere, V = 4/3r3, where r is the radius. This computation involves the following approximations:

    1. The Earth is modeled as a sphere (modeling error)
    2. Radius r  6370 km is based on empirical measurements (uncertainty in physical data)
    3. All the numerical computations are done in a computer (machine error)
    4. The value of  has to be truncated (mathematical truncation error)

    Exercise 1.3-6: The following is from "Numerical mathematics and computing" by Cheney

& Kincaid [7]:

In 1996, the Ariane 5 rocket launched by the European Space Agency exploded 40 seconds
after lift-off from Kourou, French Guiana. An investigation determined that the horizontal velocity
required the conversion of a 64-bit floating-point number to a 16-bit signed integer. It failed because
the number was larger than 32,767, which was the largest integer of this type that could be stored in
memory. The rocket and its cargo were valued at $500 million.

Search online, or in the library, to find another example of computer arithmetic going very
wrong! Write a short paragraph explaining the problem, and give a reference.
Chapter 2
Solutions of equations: Root-finding

Arya and the mystery of the Rhind papyrus

College life is full of adventures, some hopefully of intellectual nature, and Arya is doing her part by
taking a history of science class. She learns about the Rhind papyrus; an ancient Egyptian papyrus
purchased by an antiquarian named Henry Rhind in Luxor, Egypt, in 1858.

Figure 2.1: Rhind Mathematical Papyrus. (British Museum Image under a Creative Com-
mons license.)

    The papyrus has a collection of mathematical problems and their solutions; a translation is given
by Chace and Manning [2]. The following is Problem 26, taken from [2]:

                                                         42
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                       43

A quantity and its 1/4 added together become 15. What is the quantity?
Assume 4.

                  \1     4

                  \1/4   1

                  Total  5

As many times as 5 must be multiplied to give 15, so many times 4 must be multiplied
to give the required number. Multiply 5 so as to get 15.

                  \1     5

                  \2     10

                  Total  3

Multiply 3 by 4.

                  1      3

                  2      6

                  \4     12

The quantity is

                         12

                  1/4    3

                  Total  15

    Arya's instructor knows she has taken math classes and asks her if she could decipher this
solution. Although Arya's initial reaction to this assignment can be best described using the word
"despair", she quickly realizes it is not as bad as she thought. Here is her thought process: the
question, in our modern notation is, find x if x + x/4 = 15. The solution starts with an initial guess
p = 4. It then evaluates x + x/4 when x = p, and finds the result to be 5: however, what we need is
15, not 5, and if we multiply both sides of p + p/4 = 5 by 3, we get (3p) + (3p)/4 = 15. Therefore,
the solution is 3p = 12.

    Here is a more general analysis of this solution technique. Suppose we want to solve the equation
g(x) = a, and that g is a linear map, that is, g(x) = g(x) for any constant . Then, the solution
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  44

is x = ap/b where p is an initial guess with g(p) = b. To see this, simply observe

                                                       ap a
                                                    g( ) = g(p) = a.

                                                        bb

The general problem

How can we solve equations that are far complicated than the ancient Egyptians solved? For
example, how can we solve x2 + 5 cos x = 0? Stated differently, how can we find the root p such
that f (p) = 0, where f (x) = x2 + 5 cos x? In this chapter we will learn some iterative methods
to solve equations. An iterative method produces a sequence of numbers p1, p2, ... such that
limn pn = p, and p is the root we seek. Of course, we cannot compute the exact limit, so we
stop the iteration at some large N , and use pN as an approximation to p.

The stopping criteria

With any iterative method, a key question is how to decide when to stop the iteration. How well
does pN approximate p?

    Let > 0 be a small tolerance picked ahead of time. Here are some stopping criteria: stop when

    1. |pN - pN-1| < ,
    2. p pN -pN-1 N < , pN = 0, or
    3. |f (pN )| < .

However, difficulties can arise with any of these criteria:

    1. It is possible to have a sequence {pn} such that pn - pn-1  0 but {pn} diverges.

    2. It is possible to have |f (pN )| small (called residual) but pN not close to p.

In our numerical results, we will experiment with various stopping criteria. However, the second
criterion is usually preferred over the others.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                  45

    Exercise 2.-1: Solve the following problems and discuss their relevance to the stopping

criteria.

a) Consider the sequence pn where pn =  i=1 i n 1 . Argue that pn diverges, but limn(pn -
    pn-1) = 0.

b)  Let f (x) = x10.  Clearly, p = 0 is a root of f , and the sequence pn =  1  converges to p.  Show
                                                                             n

    that f (pn) < 10-3 if n > 1, but to obtain |p - pn| < 10-3, n must be greater than 103.

2.1 Error analysis for iterative methods

Assume we have an iterative method {pn} that converges to the root p of some function. How can
we assess the rate of convergence?

Definition 24. Suppose {pn} converges to p. If there are constants C > 0 and  > 1 such that

                      |pn+1 - p|  C|pn - p|,                                                     (2.1)

for n  1, then we say {pn} converges to p with order .

Special cases:

· If  = 1 and C < 1, we say the convergence is linear, and the rate of convergence is C. In
   this case, using induction, we can show

                      |pn+1 - p|  Cn|p1 - p|.                                                    (2.2)

   There are some methods for which Equation (2.2) holds, but Equation (2.1) does not hold
   for any C < 1. We still call these methods to be of linear convergence. An example is the
   bisection method.

· If  > 1, we say the convergence is superlinear. In particular, the case  = 2 is called
   quadratic convergence.

Example 25. Consider the sequences defined by

                      pn+1 = 0.7pn and p1 = 1
                      pn+1 = 0.7p2n and p1 = 1.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                               46

The first sequence converges to 0 linearly, and the second quadratically. Here are a few iterations
of the sequences:

                    n Linear           Quadratic

                    1      0.7         0.7

                    4      0.24        4.75 × 10-3

                    8 5.76 × 10-2 3.16 × 10-40

Observe how fast quadratic convergence is compared to linear convergence.

2.2 Bisection method

Let's recall the Intermediate Value Theorem (IVT), Theorem 6: If a continuous function f defined
on [a, b] satisfies f (a)f (b) < 0, then there exists p  [a, b] such that f (p) = 0.

    Here is the idea behind the method. At each iteration, divide the interval [a, b] into two subin-
tervals and evaluate f at the midpoint. Discard the subinterval that does not contain the root and
continue with the other interval.

Example 26. Compute the first three iterations by hand for the function plotted in Figure (2.2).

                                 2.5

        -4  -3  -2     -1        0     1            2  3                   4

                                 -2.5

                           Figure 2.2

Step 1  : To start, we need to pick an interval [a, b] that contains the root, that is, f (a)f (b) < 0. From
        the plot, it is clear that [0, 4] is a possible choice. In the next few steps, we will be working with
        a sequence of intervals. For convenience, let's label them as [a, b] = [a1, b1], [a2, b2], [a3, b3],
        etc. Our first interval is then [a1, b1] = [0, 4]. Next we find the midpoint of the interval,
        p1 = 4/2 = 2, and use it to obtain two subintervals [0, 2] and [2, 4]. Only one of them
        contains the root, and that is [2, 4].
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                                  47

Step 2: From the previous step, our current interval is [a2, b2] = [2, 4]. We find the midpoint1 p2 =

    2+4  =  3,  and  form  the  subintervals  [2, 3], [3, 4].  The  one  that  contains  the  root  is  [3, 4].
      2

Step 3: We have [a3, b3] = [3, 4]. The midpoint is p3 = 3.5. We are now pretty close to the root
          visually, and we stop the calculations!

In this simple example, we did not consider

· Stopping criteria

· It's possible that the stopping criterion is not satisfied in a reasonable amount of time. We
   need a maximum number of iterations we are willing to run the code with.

Remark 27.

1.  A  numerically   more  stable  formula    to  compute      the  midpoint   is  a  +  b-a  (see Example 20).
                                                                                          2

2. There is a convenient stopping criterion for the bisection method that was not mentioned
   before. One can stop when the interval [a, b] at step n is such that |a - b| < . This is similar
   to the first stopping criterion discussed earlier, but not the same. One can also use more than
   one stopping criterion; an example is in the Python code that follows.

Python code for the bisection method

In Example 26, we kept track of the intervals and midpoints obtained from the bisection method,
by labeling them as [a1, b1], [a2, b2], ..., and p1, p2, .... So at step n of the method, we know we are
working on the interval [an, bn] and its midpoint is pn. This approach will be useful when we study
the convergence of the method in the next theorem. However, keeping track of the intervals and
midpoints is not needed in the computer code. Instead, in the Python code below, we will let [a, b]
be the current interval we are working on, and when we obtain a new interval in the following
step, we will simply call the new interval [a, b], overwriting the old one. Similarly, we will call the
midpoint p, and update it at each step.

In [1]: import numpy as np

In [2]: def bisection(f, a, b, eps, N):
                  n=1
                  p = 0. # to ensure the value of p carries out of the while loop
                  while n <= N:
                         p = a + (b-a)/2
                         if np.isclose(f(p), 0) or np.abs(a-b)<eps:

    1Notice how we label the midpoints, as well as the endpoints of the interval, with the step number.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                     48

                               print('p is ', p, ' and the iteration number is ', n)
                               return
                         if f(a)*f(p) < 0:
                               b=p
                         else:
                               a=p
                         n += 1
                  y = f(p)
                  print('Method did not converge. The last iteration gives ',
                            p, ' with function value ', y)

    Let's use the bisection method to find the root of f (x) = x5 + 2x3 - 5x - 2, with = 10-4. Note
that [0, 2] contains a root, since f (0) < 0 and f (2) > 0. We set N = 20 below.

In [3]: bisection(lambda x: x**5+2*x**3-5*x-2, 0, 2, 1e-4, 20)

p is 1.319671630859375 and the iteration number is 16

    The value of the function at the estimated root is:

In [4]: x = 1.319671630859375
            x**5+2*x**3-5*x-2

Out[4]: 0.000627945623044468
    Let's see what happens if N is set too small and the method does not converge.

In [5]: bisection(lambda x: x**5+2*x**3-5*x-2, 0, 2, 1e-4, 5)

Method did not converge. The last iteration gives 1.3125 with
function value -0.14562511444091797

Theorem 28. Suppose that f  C0[a, b] and f (a)f (b) < 0. The bisection method generates a
sequence {pn} approximating a zero p of f (x) with

                                                               b-a
                                                 |pn - p|  2n , n  1.
Proof. Let the sequences {an} and {bn} denote the left-end and right-end points of the subintervals
generated by the bisection method. Since at each step the interval is halved, we have

                                                             1
                                               bn - an = 2 (bn-1 - an-1).
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                                        49

By mathematical induction, we get                                                                                    (2.3)

                              1                         1                              1
                  bn - an = 2 (bn-1 - an-1) = 22 (bn-2 - an-2) = ... = 2n-1 (b1 - a1).

Therefore bn - an = 2n-1 1 (b - a). Observe that

                                                     1              1
                                        |pn - p|  2 (bn - an) = 2n (b - a)

and thus |pn - p|  0 as n  .

Corollary 29. The bisection method has linear convergence.

Proof. The bisection method does not satisfy (2.1) for any C < 1, but it satisfies a variant of (2.2)
with C = 1/2 from the previous theorem.

Finding the number of iterations to obtain a specified accuracy: Can we find n that will
        ensure |pn - p|  10-L for some given L?

We   have,  from  the  proof  of  the   previous  theorem   (see  (2.3))  :  |pn - p|     1   (b  -  a).  Therefore,     we
                                                                                          2n

can  make   |pn  - p|    10-L,    by    choosing  n  large  enough  so  that  the  upper  bound      1    (b  -  a)  is  less
                                                                                                     2n

than 10-L :                       2n1 (b - a)  10-L  n  log2 10-L b - a .

Example 30. Determine the number of iterations necessary to solve f (x) = x5 + 2x3 - 5x - 2 = 0
with accuracy 10-4, a = 0, b = 2.

Solution. Since n  log2             2   = 4 log2 10 + 1 = 14.3, the number of required iterations is 15.
                                  10-4

    Exercise 2.2-1: Find the root of f (x) = x3 + 4x2 - 10 using the bisection method, with the

following specifications:

   a) Modify the Python code for the bisection method so that the only stopping criterion is whether
        f (p) = 0 (remove the other criterion from the code). Also, add a print statement to the code,
        so that every time a new p is computed, Python prints the value of p and the iteration number.

   b) Find the number of iterations N necessary to obtain an accuracy of 10-4 for the root, using
        the theoretical results of Section 2.2. (The function f (x) has one real root in (1, 2), so set
        a = 1, b = 2.)

   c) Run the code using the value for N obtained in part (b) to compute p1, p2, ..., pN (set a =
        1, b = 2 in the modified Python code).
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                      50

d) The actual root, correct to six digits, is p = 1.36523. Find the absolute error when pN is used
    to approximate the actual root, that is, find |p - pN |. Compare this error, with the upper
    bound for the error used in part (b).

    Exercise 2.2-2: Find an approximation to 251/3 correct to within 10-5 using the bisection

algorithm, following the steps below:

   a) First express the problem as f (x) = 0 with p = 251/3 the root.

   b) Find an interval (a, b) that contains the root, using Intermediate Value Theorem.

   c) Determine, analytically, the number of iterates necessary to obtain the accuracy of 10-5.

   d) Use the Python code for the bisection method to compute the iterate from (c), and compare
        the actual absolute error with 10-5.

2.3 Newton's method

Suppose f  C2[a, b], i.e., f, f , f are continuous on [a, b]. Let p0 be a "good" approximation to p

such that f (p0) = 0 and |p - p0| is "small". First Taylor polynomial for f at p0 with the remainder

term is                                               (x - p0)2

         f (x) = f (p0) + (x - p0)f (p0) +                   2!      f ((x))

where (x) is a number between x and p0. Substitute x = p and note f (p) = 0 to get:

         0 = f (p0) + (p - p0)f (p0) +                (p - p0)2  f ((p))

                                                             2!

where (p) is a number between p and p0. Rearrange the equation to get

                              p = p0 -  f (p0) (p - p0)2 f ((p))                     (2.4)
                                                -                    .
                                        f (p0)     2         f (p0)

If |p - p0| is "small" then (p - p0)2 is even smaller, and the error term can be dropped to obtain

the following approximation:

                                        p  p0 - f (p0) .
                                                    f (p0)

The idea in Newton's method is to set the next iterate, p1, to this approximation:

                                        p1 = p0 - f (p0) .
                                                     f (p0)
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                  51

Equation (2.4) can be written as

                                  p = p1 -  (p - p0)2 f ((p))  .                                 (2.5)

                                            2       f (p0)

Summary: Start with an initial approximation p0 to p and generate the sequence {pn} n=1 by

                                                pn = pn-1 - f (pn-1) , n  1.                     (2.6)
                                                                  f (pn-1)

       This is called Newton's method.

Graphical interpretation:

Start with p0. Draw the tangent line at (p0, f (p0)) and approximate p by the intercept p1 of the

line:  f (p0) = 0 - f (p0)  p1 - p0 = - f (p0)  p1 = p0 - f (p0) .

                           p1 - p0                  f (p0)                               f (p0)

Now draw the tangent at (p1, f (p1)) and continue.

Remark 31.

    1. Clearly Newton's method will fail if f (pn) = 0 for some n. Graphically this means the
        tangent line is parallel to the x-axis so we cannot get the x-intercept.

    2. Newton's method may fail to converge if the initial guess p0 is not close to p. In Figure (2.3),
        either choice for p0 results in a sequence that oscillates between two points.

       1

                           p0
                                                                                     p0

                                    0

                 Figure 2.3: Non-converging behavior for Newton's method

3. Newton's method requires f (x) is known explicitly.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  52

    Exercise 2.3-1: Sketch the graph for f (x) = x2 - 1. What are the roots of the equation

f (x) = 0?

    1. Let p0 = 1/2 and find the first two iterations p1, p2 of Newton's method by hand. Mark the
        iterates on the graph of f you sketched. Do you think the iterates will converge to a zero of
        f?

    2. Let p0 = 0 and find p1. What are your conclusions about the convergence of the iterates?

Python code for Newton's method

The Python code below is based on Equation (2.6). The variable pin in the code corresponds to
pn-1, and p corresponds to pn. The code overwrites these variables as the iteration continues. Also
notice that the code has two functions as inputs; f and fprime (the derivative f ).

In [1]: def newton(f, fprime, pin, eps, N):
                  n=1
                  p = 0. # to ensure the value of p carries out of the while loop
                  while n <= N:
                         p = pin - f(pin)/fprime(pin)
                         if np.isclose(f(p), 0) or np.abs(p-pin) < eps:
                               print('p is ', p, ' and the iteration number is ', n)
                               return
                         pin = p
                         n += 1
                  y = f(p)
                  print('Method did not converge. The last iteration gives ',
                            p, ' with function value ', y)

    Let's apply Newton's method to find the root of f (x) = x5 + 2x3 - 5x - 2, a function we
considered before. First, we plot the function.

In [2]: import matplotlib.pyplot as plt
            %matplotlib inline
            import numpy as np

In [3]: x = np.linspace(-2, 2, 1000)
            y = x**5+2*x**3-5*x-2
            ax = plt.gca()
            ax.spines['left'].set_position('center')
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  53

ax.spines['right'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['top'].set_position('center')
ax.set_ylim([-40, 40])
plt.plot(x,y);

    The derivative is f = 5x4 + 6x2 - 5, we set pin = 1, eps = = 10-4, and N = 20, in the code.
In [4]: newton(lambda x: x**5+2*x**3-5*x-2, lambda x: 5*x**4+6*x**2-5, 1, 1e-4, 20)
p is 1.3196411672093726 and the iteration number is 6

    Recall that the bisection method required 16 iterations to approximate the root in [0, 2] as
p = 1.31967. (However, the stopping criterion used in bisection and Newton's methods are slightly
different.) 1.3196 is the rightmost root in the plot. But there are other roots of the function. Let's
run the code with pin = 0.
In [5]: newton(lambda x: x**5+2*x**3-5*x-2, lambda x: 5*x**4+6*x**2-5, 0, 1e-4, 20)
p is -0.43641313299799755 and the iteration number is 4

    Now we use pin = -2.0 which will give the leftmost root.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                       54

In [6]: newton(lambda x: x**5+2*x**3-5*x-2, lambda x: 5*x**4+6*x**2-5, -2, 1e-4, 20)
p is -1.0000000001014682 and the iteration number is 7

Theorem 32. Let f  C2[a, b] and assume f (p) = 0, f (p) = 0 for p  (a, b). If p0 is chosen
sufficiently close to p, then Newton's method generates a sequence that converges to p with

                   lim  p - pn+1 2 =-  f (p)   .

                   n (p - pn)          2f (p)

Proof. Since f  is continuous and f (p) = 0, there exists an interval I = [p -  ,p +  ] on which
f = 0. Let                                  M = maxxI |f (x)| .
                                                    2 minxI |f (x)|

Pick p0 from the interval I (which means |p - p0|  ), sufficiently close to p so that M |p - p0| < 1.
From Equation (2.5) we have:

|p - p1| = |p - p0||p - p0| f ((p)) < |p - p0||p - p0|M < |p - p0|  .                 (2.7)
                2       f (p0)

Multiply both sides of |p - p1| < |p - p0| by M to get M |p - p1| < M |p - p0| < 1. Therefore, we have
obtained: |p - p1| < and M |p - p1| < 1. Repeating the same argument used in 2.7 to |p - p2|, we
can show |p - p2| < and M |p - p2| < 1. Therefore by induction |p - pn| < and M |p - pn| < 1, for
all n. This implies that all the iterates pn are in the interval I so f (pn) is never zero in Newton's
iteration.

    If we replace p1 by pn+1, and p0 by pn in Equation (2.5), we get

                   p - pn+1 = -  (p - pn)2 f ((p))  .                                 (2.8)

                                  2    f (pn)

Here (p) is a number between p and pn. Since (p) changes recursively with n, let's update our
notation as: (p) = n. Then, Equation (2.8) implies

                |p - pn+1|  M |p - pn|2  M |p - pn+1|  (M |p - pn|)2 .

Similarly, |p - pn|  M |p - pn-1|2, or M |p - pn|  (M |p - pn-1|)2, and thus M |p - pn+1| 
(M |p - pn-1|)22 . By induction, we can show

                         M |p - pn|  (M |p - p0|)2n  |p - pn|  1 (M |p - p0|)2n .
                                                                                M
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                           55

Since M |p - p0| < 1, |p - pn|  0 as n  . Therefore limn pn = p. Finally,

                                   lim  p - pn+1    2 = lim -   1 f (n)         ,

                                   n (p - pn) n 2 f (pn)

and since pn  p, and n is between pn and p, n  p, and therefore

                                        lim       p - pn+12 =-  1 f (p)

                                   n (p - pn)                   2 f (p)

proving the theorem.

Corollary 33. Newton's method has quadratic convergence.
Proof. Recall that quadratic convergence means

                                        |pn+1 - p|  C|pn - p|2,

for some constant C > 0. Taking the absolute values of the limit established in the previous theorem,

we obtain                          p - pn+1                  |pn+1 - p| 1 f (p)

                             lim              2 = lim           2=                     .
                             n (p - pn)             n |pn - p|             2 f (p)

Let C  =   1f  (p)  .  From  the  definition  of  limit  of  a  sequence,  for  any    > 0, there exists an integer
           2f  (p)

N > 0 such that |p|pn+ n-1p-|2p| < C + whenever n > N. Set C = C + to obtain |pn+1 - p|  C|pn - p|2
for n > N .

Example 34. The Black-Scholes-Merton (BSM) formula, for which Myron Scholes and Robert
Merton were awarded the Nobel prize in economics in 1997, computes the fair price of a contract
known as the European call option. This contract gives its owner the right to purchase the asset
the contract is written on (for example, a stock), for a specific price denoted by K and called the
strike price (or exercise price), at a future time denoted by T and called the expiry. The formula
gives the value of the European call option, C, as

                                   C = S(d1) - Ke-rT (d2)

where S is the price of the asset at the present time, r is the risk-free interest rate, and (x) is the
distribution function of the standard normal random variable, given by

                                   (x) =            1 -t x 2/2
                                                                e dt.
                                                    2 -

The constants d1, d2 are obtained from

                                   log(S/K) + (r + 2/2)T                             
                             d1 =                               , d2 = d1 -  T .
                                              T
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                             56

All the constants in the BSM formula can be observed, except for , which is called the volatility
of the underlying asset. It has to be estimated from empirical data in some way. We want to
concentrate on the relationship between C and , and think of C as a function of  only. We
rewrite the BSM formula emphasizing :

                                 C() = S(d1) - Ke-rT (d2)

It may look like the independent variable  is missing on the right hand side of the above formula,

but it is not: the constants d1, d2 both depend on . We can also think about d1, d2 as functions

of .
    There are two questions financial engineers are interested in:

    · Compute the option price C based on an estimate of 

    · Observe the price of an option C^ traded in the market, and find  for which the BSM
        formula gives the output C^, i.e, C() = C^. The volatility  obtained in this way is called
        the implied volatility.

The second question can be answered using a root-finding method, in particular, Newton's method.
To summarize, we want to solve the equation:

                                                       C() - C^ = 0

where C^ is a given constant, and

                                     C() = S(d1) - Ke-rT (d2).

To use Newton's method, we need C () = d dC . Since d1, d2 are functions of , we have

                                     dC = S d(d1) - Ke-rT d(d2) .                           (2.9)
                                     d             d                    d

Let's compute the derivatives on the right hand side of (2.9).

                                                                                          
                                                                            d1 2 
                    d(d1) = d          1       d1 e-t2/2dt           1  d
                                                                               e-t /2dt .
                                              -                =                          
                    d            d     2                             2 d
                                                                           -
                                                                                   u

We  will  use  the  chain  rule  to  compute  the  derivative  d      d1 -t2/2 du
                                                               d         e dt = d :

                                                                     -
                                                                             u

                                              du d = du dd1 dd1 d .
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                  57

The first derivative follows from the Fundamental Theorem of Calculus

                                         du dd1 = e-d12/2,

and the second derivative is an application of the quotient rule of differentiation

   dd1 = d             log(S/K) + (r + 2/2)T      log(S/K) + (r + 2/2)T
                                                 = T-                                .
   d d                                                                   2 T
                                   T

Putting the pieces together, we have

                       d(d1) e-d12/2  log(S/K) + (r + 2/2)T
                           =                 T-                            .
                       d      2                  2 T

Going back to the second derivative we need to compute in equation (2.9), we have:

                           d(d2) 1               d e d2 -t2/2dt .
                                      =          d -
                           d                 2

Using the chain rule and the Fundamental Theorem of Calculus we obtain

                                      d(d2) = e-d22/2  dd2 .
                                          d      2 d

                                              

Since d2 is defined as d2 = d1 -  T , we can express dd2/d in terms of dd1/d as:

                                          dd2 = dd1  - T .

                                          d d

Finally, we have the derivative we need:

                  d12   log( KS ) + (r + 22 )T                      d22  log( KS ) + (r + 22 )T  (2.10)
                                                                                     
dC Se- 2                                               e-(rT + 2 )
   =                   T-                        +K                              2 T
d     2                    2 T
                                                             2

    We are ready to apply Newton's method to solve the equation C() - C^ = 0. Now let's find
some data.

    The General Electric Company (GE) stock is $7.01 on Dec 8, 2018, and a European call option
on this stock, expiring on Dec 14, 2018, is priced at $0.10. The option has strike price K = $7.5.
The risk-free interest rate is 2.25%. The expiry T is measured in years, and since there are 252
trading days in a year, T = 6/252. We put this information in Python:

In [1]: S = 7.01
            K = 7.5
            r = 0.0225
            T = 6/252
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  58

    We have not discussed how to compute the distribution function of the standard normal ran-
dom variable (x) = 12 -x e-t2/2dt. In Chapter 4, we will discuss how to compute integrals
numerically, but for this example, we will use the built-in function Python has for (x). It is in a
subpackage of SciPy called stats:

In [2]: from scipy import stats

    The following defines stdnormal as the standard normal random variable.

In [3]: stdnormal = stats.norm(loc=0, scale=1)

    The member function cdf (x) of stdnormal computes the standard normal distribution function
at x. We write a function phi(x) based on this member function, matching our notation (x) for
the distribution function.

In [4]: phi = lambda x: stdnormal.cdf(x)

    Next we define C() and C (). In the Python code, we replace  by x.

In [5]: def c(x):
                  d1 = (np.log(S/K)+(r+x**2/2)*T) / (x*np.sqrt(T))
                  d2 = d1 - x*np.sqrt(T)
                  return S*phi(d1) - K*np.exp(-r*T)*phi(d2)

    The function cprime(x) is based on equation (2.10):

In [6]: def cprime(x):
                  d1 = (np.log(S/K)+(r+x**2/2)*T) / (x*np.sqrt(T))
                  d2 = d1 - x*np.sqrt(T)
                  A = (np.log(S/K)+(r+x**2/2)*T) / (np.sqrt(T)*x**2)
                  return S*(np.exp(-d1**2/2) / np.sqrt(2*np.pi)) * (np.sqrt(T)-A) \
                  + K*np.exp(-(r*T+d2**2/2)) * A / np.sqrt(2*np.pi)

    We then load the newton function and run it to find the implied volatility which turns out to
be 62%.

In [7]: newton(lambda x: c(x)-0.1, cprime, 1, 1e-4, 60)

p is 0.6231138483741047 and the iteration number is 3
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                          59

2.4 Secant method

One drawback of Newton's method is that we need to know f (x) explicitly to evaluate f (pn-1) in

                                    pn = pn-1 - f (pn-1) , n  1.
                                                     f (pn-1)

If we do not know f (x) explicitly, or if its computation is expensive, we might approximate f (pn-1)

by the finite difference

                                    f (pn-1 + h) - f (pn-1)                                              (2.11)
                                                 h

for some small h. We then need to compute two values of f at each iteration to approximate f .

Determining h in this formula brings some difficulty, but there is a way to get around this. We will

use the iterates themselves to rewrite the finite difference (2.11) as

                                                    f (pn-1) - f (pn-2) .
                                                        pn-1 - pn-2

Then, the recursion for pn simplifies as

                                 f (pn-1)                                  pn-1 - pn-2          , n  2.  (2.12)
            pn = pn-1 - f (pn-1)-f (pn-2) = pn-1 - f (pn-1)
                                                                           f (pn-1) - f (pn-2)
                               pn-1 -pn-2

This is called the secant method. Observe that

1. No additional function evaluations are needed,

2. The recursion requires two initial guesses p0, p1.

Geometric interpretation: The slope of the secant line through the points (pn-1, f (pn-1)) and
(pn-2, f (pn-2)) is pn-1-pn-2 f(pn-1)-f(pn-2) . The x-intercept of the secant line, which is set to pn, is

            0 - f (pn-1) = f (pn-1) - f (pn-2)  pn = pn-1 - f (pn-1) pn-1 - pn-2
            pn - pn-1             pn-1 - pn-2                              f (pn-1) - f (pn-2)

which is the recursion of the secant method.
    The following theorem shows that if the initial guesses are "good", the secant method has

superlinear convergence. A proof can be found in Atkinson [3].

Theorem 35. Let f  C2[a, b] and assume f (p) = 0, f (p) = 0, for p  (a, b). If the initial guesses
p0, p1 are sufficiently close to p, then the iterates of the secant method converge to p with

                                           |p - pn+1| f (p) r1
                                    lim                  =
                                           |p  -  pn|r0     2f (p)
                                    n

where r0 =    5+1                   5-1 2  0.62.
              2
                     1.62, r1  =
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  60

Python code for the secant method

The following code is based on Equation (2.12); the recursion for the secant method. The initial
guesses are called pzero and pone in the code. The same stopping criterion as in Newton's method
is used. Notice that once a new iterate p is computed, pone is updated as p, and pzero is updated
as pone.

In [1]: def secant(f, pzero, pone, eps, N):
                  n=1
                  p = 0. # to ensre the value of p carries out of the while loop
                  while n <= N:
                         p = pone - f(pone)*(pone-pzero) / (f(pone)-f(pzero))
                         if np.isclose(f(p), 0) or np.abs(p-pone)<eps:
                               print('p is ', p, ' and the iteration number is ', n)
                               return
                         pzero = pone
                         pone = p
                         n += 1
                  y = f(p)
                  print('Method did not converge. The last iteration gives ',
                            p, ' with function value ', y)

    Let's find the root of f (x) = cos x - x using the secant method, using 0.5 and 1 as the initial
guesses.

In [2]: secant(lambda x: np.cos(x)-x, 0.5, 1, 1e-4, 20)

p is 0.739085132900112 and the iteration number is 4

    Exercise 2.4-1: Use the Python codes for the secant and Newton's methods to find solutions

for the equation sin x - e-x = 0 on 0  x  1. Set tolerance to 10-4, and take p0 = 0 in Newton,
and p0 = 0, p1 = 1 in secant method. Do a visual inspection of the estimates and comment on the
convergence rates of the methods.

    Exercise 2.4-2:

   a) The function y = log x has a root at x = 1. Run the Python code for Newton's method with
        p0 = 2, = 10-4, N = 20, and then try p0 = 3. Does Newton's method find the root in each
        case? If Python gives an error message, explain what the error is.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  61

b) One can combine the bisection method and Newton's method to develop a hybrid method
    that converges for a wider range of starting values p0, and has better convergence rate than
    the bisection method.

    Write a Python code for a bisection-Newton hybrid method, as described below. (You can use
    the Python codes for the bisection and Newton's methods from the lecture notes.) Your code
    will input f, f , a, b, , N where f, f are the function and its derivative, (a, b) is an interval that
    contains the root (i.e., f (a)f (b) < 0), and , N are the tolerance and the maximum number
    of iterations. The code will use the same stopping criterion used in Newton's method.

    The method will start with computing the midpoint of (a, b), call it p0, and use Newton's
    method with initial guess p0 to obtain p1. It will then check whether p1  (a, b). If p1  (a, b),
    then the code will continue using Newton's method to compute the next iteration p2. If
    p1 / (a, b), then we will not accept p1 as the next iteration: instead the code will switch
    to the bisection method, determine which subinterval among (a, p0), (p0, b) contains the root,
    updates the interval (a, b) as the subinterval that contains the root, and sets p1 to the midpoint
    of this interval. Once p1 is obtained, the code will check if the stopping criterion is satisfied.
    If it is satisfied, the code will return p1 and the iteration number, and terminate. If it is
    not satisfied, the code will use Newton's method, with p1 as the initial guess, to compute
    p2. Then it will check whether p2  (a, b), and continue in this way. If the code does not
    terminate after N iterations, output an error message similar to Newton's method.

    Apply the hybrid method to:

        · a polynomial with a known root, and check if the method finds the correct root;

        · y = log x with (a, b) = (0, 6), for which Newton's method failed in part (a).

c) Do you think in general the hybrid method converges to the root, provided the initial interval
    (a, b) contains the root, for any starting value p0? Explain.

2.5 Muller's method

The secant method uses a linear function that passes through (p0, f (p0)) and (p1, f (p1)) to find the
next iterate p2. Muller's method takes three initial approximations, passes a parabola (quadratic
polynomial) through (p0, f (p0)), (p1, f (p1)), (p2, f (p2)), and uses one of the roots of the polynomial
as the next iterate.

    Let the quadratic polynomial written in the following form

P (x) = a(x - p2)2 + b(x - p2) + c.              (2.13)
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                    62

Solve the following equations for a, b, c

                                   P (p0) = f (p0) = a(p0 - p2)2 + b(p0 - p2) + c
                                   P (p1) = f (p1) = a(p1 - p2)2 + b(p1 - p2) + c
                                   P (p2) = f (p2) = c

to get

            c = f (p2)

            b = (p0 - p2)(f (p1) - f (p2)) - (p1 - p2)(f (p0) - f (p2))            (2.14)
            (p1 - p2)(p0 - p1)                   (p0 - p2)(p0 - p1)

            a = f (p0) - f (p2) - f (p1) - f (p2) .
                 (p0 - p2)(p0 - p1) (p1 - p2)(p0 - p1)

    Now that we have determined P (x), the next step is to solve P (x) = 0, and set the next iterate
p3 to its solution. To this end, put w = x - p2 in (2.13) to rewrite the quadratic equation as

                          aw2 + bw + c = 0.

From the quadratic formula, we obtain the roots

                                                 -2c                               (2.15)
                        w^ = x^ - p2 =                         .
                                                 b ± b2 - 4ac

Let  = b2 - 4ac. We have two roots (which could be complex numbers), -2c/(b + ) and
            

-2c/(b - ), and we need to pick one of them. We will pick the root that is closer to p2, in other
words, the root that makes |x^ - p2| the smallest. (If the numbers are complex, the absolute value
means the norm of the complex number.) Therefore we have

                                     if |b + | > |b - |                            (2.16)
                         -2c         if |b + |  |b -  . |
            x^ - p2 = b+ 
                         -2c

                                b- 

The next iterate of Muller's method, p3, is set to the value of x^ obtained from the above calculation,

that is,                                         if |b + | > |b - |
                                                 if |b + |  |b -  . |
                        p2 - 2c
            p3 = x^ =     b+ 

                        p2 - 2c
                          b- 

Remark 36.

1. Muller's method can find real as well as complex roots.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                 63

2. The convergence of Muller's method is superlinear, that is,

                     -1

     |p - pn+1| f (3)(p) 2
lim       =
n |p - pn|   6f (p)

   where   1.84, provided f  C3[a, b], p  (a, b), and f (p) = 0.

3. Muller's method converges for a variety of starting values even though pathological examples
   that do not yield convergence can be found (for example, when the three starting values fall
   on a line).

Python code for Muller's method

The following Python code takes initial guesses p0, p1, p2 (written as pzero, pone, ptwo in the code),
computes the coefficients a, b, c from Equation (2.14), and sets the root p3 to p. It then updates the
three initial guesses as the last three iterates, and continues until the stopping criterion is satisfied.

    We need to compute the square root, and the absolute value, of possibly complex numbers in
Equations (2.15) and (2.16). The Python function for the square root of a possibly complex number
z is complex(z)0.5, and its absolute value is np.abs(z).

In [1]: def muller(f, pzero, pone, ptwo, eps, N):
                  n=1
                  p=0
                  while n <= N:
                         c = f(ptwo)
                         b1 = (pzero-ptwo) * (f(pone)-f(ptwo)) / ((pone-ptwo)*(pzero-pone))
                         b2 = (pone-ptwo) * (f(pzero)-f(ptwo)) / ((pzero-ptwo)*(pzero-pone))
                         b = b1 - b2
                         a1 = (f(pzero)-f(ptwo)) / ((pzero-ptwo)*(pzero-pone))
                         a2 = (f(pone)-f(ptwo)) / ((pone-ptwo)*(pzero-pone))
                         a = a1 - a2
                         d = (complex(b**2-4*a*c))**0.5
                         if np.abs(b-d) < np.abs(b+d):
                               inc = 2*c/(b+d)
                         else:
                               inc = 2*c/(b-d)
                         p = ptwo - inc
                         if np.isclose(f(p), 0) or np.abs(p-ptwo)<eps:
                               print('p is ', p, ' and the iteration number is ', n)
                               return
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                64

                         pzero = pone
                         pone = ptwo
                         ptwo = p
                         n += 1
                  y = f(p)
                  print('Method did not converge. The last iteration gives ',

                            p, ' with function value ', y)

    The polynomial x5 +2x3 -5x-2 has three real roots, and two complex roots that are conjugates.
Let's find them all, by experimenting with various initial guesses.

In [2]: muller(lambda x: x**5+2*x**3-5*x-2, 0.5, 1.0, 1.5, 1e-5, 10)

p is (1.3196411677283386+0j) and the iteration number is 4

In [3]: muller(lambda x: x**5+2*x**3-5*x-2, 0.5, 0, -0.1, 1e-5, 10)
p is (-0.43641313299908585+0j) and the iteration number is 5

In [4]: muller(lambda x: x**5+2*x**3-5*x-2, 0, -0.1, -1, 1e-5, 10)
p is (-1+0j) and the iteration number is 1

In [5]: muller(lambda x: x**5+2*x**3-5*x-2, 5, 10, 15, 1e-5, 20)
p is (0.05838598289491982+1.8626227582154478j) and the iteration number is 18

2.6 Fixed-point iteration

Many root-finding methods are based on the so-called fixed-point iteration, a method we discuss in
this section.
Definition 37. A number p is a fixed-point for a function g(x) if g(p) = p.

    We have two problems that are related to each other:
    · Fixed-point problem: Find p such that g(p) = p.
    · Root-finding problem: Find p such that f (p) = 0.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                            65

    We can formulate a root-finding problem as a fixed-point problem, and vice versa. For example,
assume we want to solve the root finding problem, f (p) = 0. Define g(x) = x-f (x), and observe that
if p is a fixed-point of g(x), that is, g(p) = p - f (p) = p, then p is a root of f (x). Here the function
g is not unique: there are many ways one can represent the root-finding problem f (p) = 0 as a
fixed-point problem, and as we will learn later, not all will be useful to us in developing fixed-point
iteration algorithms.

    The next theorem answers the following questions: When does a function g have a fixed-point?
If it has a fixed-point, is it unique?

Theorem 38. 1. If g is a continuous function on [a, b] and g(x)  [a, b] for all x  [a, b], then
        g has at least one fixed-point in [a, b].

    2. If, in addition, |g(x)-g(y)|  |x-y| for all x, y  [a, b] where 0 <  < 1, then the fixed-point
        is unique.

Proof. Consider f (x) = g(x) - x. Assume g(a) = a and g(b) = b (otherwise the proof is over.)
Then f (a) = g(a) - a > 0 since g(a) must be greater than a if it's not equal to a. Similarly,
f (b) = g(b) - b < 0. Then from IVT, there exists p  (a, b) such that f (p) = 0, or g(p) = p. To
prove part 2, suppose there are two different fixed-points p, q. Then

                       |p - q| = |g(p) - g(q)|  |p - q| < |p - q|

which is a contradiction.

Remark 39. Let g be a differentiable function on [a, b] such that |g (x)|  k for all x  (a, b) for
some positive constant k < 1. Then the hypothesis of part 2 of Theorem 38 is satisfied with  = k.
Indeed, from the mean value theorem

                       |g(x) - g(y)| = |g ()(x - y)|  k|x - y|

for all x, y  [a, b].

The following theorem describes how we can find a fixed point.

Theorem 40. If g is a continuous function on [a, b] satisfying the conditions

1. g(x)  [a, b] for all x  [a, b],

2. |g(x) - g(y)|  |x - y|, for x, y  [a, b] where 0 <  < 1,

then the fixed-point iteration

                                    pn = g(pn-1), n  1

converges to p, the unique fixed-point of g in [a, b], for any starting point p0  [a, b].
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                    66

Proof. Since p0  [a, b] and g(x)  [a, b] for all x  [a, b], all iterates pn  [a, b]. Observe that

                              |p - pn| = |g(p) - g(pn-1)|  |p - pn-1|.

Then by induction, |p - pn|  n|p - p0|. Since 0 <  < 1, n  0 as n  , and thus pn  p.

Remark 41. Theorem 40 still holds if the second condition |g(x) - g(y)|  |x - y|, is replaced by
|g (x)|  k for all x  [a, b] where 0 < k < 1. (See Remark 39).

Corollary 42. If g satisfies the hypothesis of Theorem 40, then the following error bounds hold.

1. |p - pn|  1- n |p1 - p0|

2.  |p - pn|     1  |pn+1  -  pn|
               1-

3.  |p - pn+1|       |pn+1    -  pn|
                 1-

4. |p - pn|  n max{p0 - a, b - p0}

Geometric interpretation of fixed-point iteration

    In Figures (2.4) and (2.5), take a starting value p0 close to p, and mark the first few fixed-point
iterations, p0, p1, p2. Observe that the fixed-point iteration converges in the first graph, but diverges
in the second one.

                     4                                                        4

                     3                         y = x

                                  y = g(x)                                    3

                     2                                                        2

                     1                                                  1

                     0                                                  0

                                            p

                     Figure 2.4: Fixed-point iteration: |g (p)| < 1.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                              67

                    4                                                4

                                                              y = x

                    3                                                3

                    2                                                2

                    1                                                1

                                              y = g(x)

                    0                                                0

                                                        p

                    Figure 2.5: Fixed-point iteration: |g (p)| > 1.

Example 43. Consider the root-finding problem x3 - 2x2 - 1 = 0 on [1, 3].

    1. Write the problem as a fixed-point problem, g(x) = x, for some g. Verify that the hypothesis
        of Theorem 40 (or Remark 41) is satisfied so that the fixed-point iteration converges.

    2. Let p0 = 1. Use Corollary 42 to find n that ensures an estimate to p accurate to within 10-4.
Solution. 1. There are several ways we can write this problem as g(x) = x :

(a) Let f (x) = x3 - 2x2 - 1, and p be its root, that is, f (p) = 0. If we let g(x) = x - f (x),
     then g(p) = p - f (p) = p, so p is a fixed-point of g. However, this choice for g will not
     be helpful, since g does not satisfy the first condition of Theorem 40: g(x) / [1, 3] for
     all x  [1, 3] (g(3) = -5 / [1, 3]).

(b) Since p is a root for f , we have p3 = 2p2 + 1, or p = (2p2 + 1)1/3. Therefore, p is the
     solution to the fixed-point problem g(x) = x where g(x) = (2x2 + 1)1/3.

       · g is increasing on [1, 3] and g(1) = 1.44, g(3) = 2.67, thus g(x)  [1, 3] for all
          x  [1, 3]. Therefore, g satisfies the first condition of Theorem 40.

       · g (x) =           4x    and g (1) = 0.64, g (3) = 0.56 and g             is decreasing on [1, 3].
                    3(2x2+1)2/3

          Therefore g satisfies the condition in Remark 41 with  = 0.64.

       Then, from Theorem 40 and Remark 41, the fixed-point iteration converges if g(x) =
       (2x2 + 1)1/3.

2. Take  = k = 0.64 in Corollary 42 and use bound (4):

                       |p - pn|  (0.64)n max{1 - 1, 3 - 1} = 2(0.64n).

We  want  2(0.64n)  <  10-4,  which  implies  n log 0.64   <  -4 log 10 - log 2,  or  n  >  -4 log 10-log 2  
                                                                                                 log 0.64

22.19. Therefore n = 23 is the smallest number of iterations that ensures an absolute error of

10-4.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING  68

Python code for fixed-point iteration

The following code starts with the initial guess p0 (pzero in the code), computes p1 = g(p0), and
checks if the stopping criterion |p1 - p0| < is satisfied. If it is satisfied the code terminates with
the value p1. Otherwise p1 is set to p0, and the next iteration is computed.

In [1]: def fixedpt(g, pzero, eps, N):
                  n=1
                  while n<N:
                         pone = g(pzero)
                         if np.abs(pone-pzero)<eps:
                               print('p is ', pone, ' and the iteration number is ', n)
                               return
                         pzero = pone
                         n += 1
                  print('Did not converge. The last estimate is p = ', pzero)

    Let's find the fixed-point of g(x) = x where g(x) = (2x2 + 1)1/3, with p0 = 1. We studied this
problem in Example 43 where we found that 23 iterations guarantee an estimate accurate to within
10-4. We set = 10-4, and N = 30, in the above code.

In [2]: fixedpt(lambda x: (2*x**2+1)**(1/3), 1, 1e-4, 30)

p is 2.205472095330031 and the iteration number is 19

    The exact value of the fixed-point, equivalently the root of x3 - 2x2 - 1, is 2.20556943. Then
the exact error is:

In [3]: 2.205472095330031-2.20556943

Out[3]: -9.733466996930673e-05

    A take home message and a word of caution:
    · The exact error, |pn - p|, is guaranteed to be less than 10-4 after 23 iterations from Corollary

        42, but as we observed in this example, this could happen before 23 iterations.

    · The stopping criterion used in the code is based on |pn - pn-1|, not |pn - p|, so the iteration
        number that makes these quantities less than a tolerance will not be the same in general.

Theorem 44. Assume p is a solution of g(x) = x, and suppose g(x) is continuously differentiable
in some interval about p with |g (p)| < 1. Then the fixed-point iteration converges to p, provided p0
is chosen sufficiently close to p. Moreover, the convergence is linear if g (p) = 0.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                69

Proof. Since g is continuous and |g (p)| < 1, there exists an interval I = [p - , p + ] such that
|g (x)|  k for all x  I, for some k < 1. Then, from Remark 39, we know |g(x) - g(y)|  k|x - y|
for all x, y  I. Next, we argue that g(x)  I if x  I. Indeed, if |x - p| < , then

|g(x) - p| = |g(x) - g(p)|  |g ()||x - p| < k <

hence g(x)  I. Now use Theorem 40, setting [a, b] to [p -  ,p +  ], to conclude the fixed-point
iteration converges.

    To prove convergence is linear, we note

|pn+1 - p| = |g(pn) - g(p)|  |g (n)||pn - p|  k|pn - p|

which is the definition of linear convergence (with k being a positive constant less than 1).
    We can actually prove something more:

lim |pn+1 - p| = lim |g(pn) - g(p)| = lim |g (n)||pn - p| = lim |g (n)| = |g (p)|.
n |pn - p| n |pn - p|  n |pn - p|                                n

The last equality follows since g is continuous, and n  p, which is a consequence of n being
between p and pn, and pn  p, as n  .

Example 45. Let g(x) = x + c(x2 - 2), which has the fixed-point p = 2  1.4142. Pick a value for
c to ensure the convergence of fixed-point iteration. For the picked value c, determine the interval
of convergence I = [a, b], that is, the interval for which any p0 from the interval gives rise to a
converging fixed-point iteration. Then write a Python code to test the results.

Solution. Theorem 44 requires |g (p)| < 1. We have g (x) = 1 + 2xc, and thus g (2) = 1 + 22c.
Therefore

                       
|g ( 2)| < 1  -1 < 1 + 2 2c < 1

               
   -2 < 2 2c < 0

      -1
    < c < 0.

        2

Any c from this interval works: let's pick c = -1/4.
    Now we need to find an interval I = [2 - , 2 + ] such that

                                                                             x
                                           |g (x)| = |1 + 2xc| = 1 -  k

                                                                             2

for some k < 1, for all x  I. Plot g (x) and observe that one choice is = 0.1, so that I =
[2 - 0.1, 2 + 0.1] = [1.3142, 1.5142]. Since g (x) is positive and decreasing on I = [1.3142, 1.5142],
|g (x)|  1- 1.3142 2 = 0.3429 < 1, for any x  I. Then any starting value x0 from I gives convergence.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                          70

    For c = -1/4, the function becomes g(x) = x - 4 x2-2 . Pick p0 = 1.5 as the starting point. Using
the fixed-point iteration code of the previous example, we obtain:

In [4]: fixedpt(lambda x: x-(x**2-2)/4, 1.5, 1e-5, 15)
p is 1.414214788550556 and the iteration number is 9

    The absolute error is:
In [5]: 1.414214788550556-(2**.5)
Out[5]: 1.2261774609001463e-06

    Let's experiment with other starting values. Although p0 = 2 is not in the interval of convergence
I, we expect convergence since g (2) = 0:
In [6]: fixedpt(lambda x: x-(x**2-2)/4, 2, 1e-5, 15)
p is 1.414214788550556 and the iteration number is 10

    Let's try p0 = -5. Note that this is not only outside the interval of convergence I, but g (-5) =
3.5 > 1, so we do not expect convergence.

In [7]: fixedpt(lambda x: x-(x**2-2)/4, -5, 1e-5, 15)

---------------------------------------------------------------------------

OverflowError                        Traceback (most recent call last)

      <ipython-input-8-2df659a6b4d1> in <module>
----> 1 fixedpt(lambda x: x-(x**2-2)/4, -5, 1e-5, 15)

<ipython-input-2-d29380b04f2a> in fixedpt(g, pzero, eps, N)

2        n=1

3        while n<N:

----> 4  pone = g(pzero)

5        if np.abs(pone-pzero)<eps:

6              print('p is ', pone, ' and the iteration number is ', n)
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                                            71

      <ipython-input-8-2df659a6b4d1> in <lambda>(x)
----> 1 fixedpt(lambda x: x-(x**2-2)/4, -5, 1e-5, 15)

       OverflowError: (34, 'Result too large')

Let's  verify  the  linear  convergence  of  the  fixed-point  iteration  numerically  in  this  example.  We

                                                                                       
write another version of the fixed-point code, fixedpt2, and we compute pn- p 2 n-1- 2 for each n.

In [1]: import numpy as np
            import matplotlib.pyplot as plt
            %matplotlib inline

In [2]: def fixedpt2(g, pzero, eps, N):
                  n=1
                  arr = np.array([])
                  error = 1.
                  while n<N and error>1e-5:
                         pone = g(pzero)
                         error = np.abs(pone-pzero)
                         arr = np.append(arr, (pone-2**0.5)/(pzero-2**0.5))
                         pzero = pone
                         n += 1
                  return arr

In [3]: arr = fixedpt2(lambda x: x-(x**2-2)/4, 1.5, 1e-7, 15)
            arr

Out[3]: array([0.27144661, 0.28707161, 0.291222 , 0.29240652, 0.29275091,
                       0.29285156, 0.29288102, 0.29288965, 0.29289217])

In [4]: plt.plot(arr);
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                     72

                Figure 2.6: Fixed-point iteration

                                                                        

    The graph suggests the limit of pn- p 2 n-1- 2 exists and it is around 0.295, supporting linear conver-
gence.

2.7 High-order fixed-point iteration

In the proof of Theorem 44, we showed

                lim |pn+1 - p| = |g (p)|
                n |pn - p|

which implied that the fixed-point iteration has linear convergence, if g (p) = 0.
    If this limit were zero, then we would have

                                                    lim |pn+1 - p| = 0,
                                                   n |pn - p|
which means the denominator is growing at a larger rate than the numerator. We could then ask if

                lim  |pn+1 - p| = nonzero constant
                n |pn - p|

for some  > 1.
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                      73

Theorem 46. Assume p is a solution of g(x) = x where g  C(I) for some interval I that contains
p, and for some   2. Furthermore assume

                g (p) = g (p) = ... = g(-1)(p) = 0, and g()(p) = 0.

Then if the initial guess p0 is sufficiently close to p, the fixed-point iteration pn = g(pn-1), n  1,
will have order of convergence of , and

                               lim        pn+1 - p g()(p)
                                                =                  .
                               n (pn - p)           !

Proof. From Taylor's theorem,

p (pn - p)-1 n+1 = g(pn) = g(p) + (pn - p)g (p) + ... + g(-1)(p) + (pn - p) g()(n)
                                                    ( - 1)!                       !

where n is a number between pn and p, and all numbers are in I. From the hypothesis, this

simplifies as

                pn+1 = p +     (pn - p) ()          pn+1 - p g()(n)
                                          g (n)                       =        .
                               !                    (pn - p)             !

From Theorem 44, if p0 is chosen sufficiently close to p, then limn pn = p. The order of conver-

gence is  with

                              |pn+1 - p|        |g()(n)| |g()(p)|
                         lim             = lim            =              = 0.
                         n |pn - p|       n !                         !

Application to Newton's Method

Recall Newton's iteration               pn = pn-1 - f (pn-1) .
                                                         f (pn-1)

Put g(x) = x - f (x) f(x) . Then the fixed-point iteration pn = g(pn-1) is Newton's method. We have

                                        [f (x)]2 - f (x)f (x) f (x)f (x)
                           g (x) = 1 -                    = [f (x)]2
                                          [f (x)]2

and thus                                          f (p)f (p)
Similarly,                              g (p) = [f (p)]2 = 0.

                g (x) =  (f (x)f (x) + f (x)f (x)) (f (x))2 - f (x)f (x)2f (x)f (x)

                                                [f (x)]4
CHAPTER 2. SOLUTIONS OF EQUATIONS: ROOT-FINDING                                       74

which implies           (f (p)f (p)) (f (p))2 f (p)

               g (p) =                   [f (p)]4  =     f (p)  .

If f (p) = 0, then Theorem 46 implies Newton's method has quadratic convergence with

                        lim              pn+1 - p f (p)
                                         2=
               n (pn - p) 2f (p)

which was proved earlier in Theorem 32.

    Exercise 2.7-1: Use Theorem 38 (and Remark 39) to show that g(x) = 3-x has a unique

fixed-point on [1/4, 1]. Use Corollary 42, part (4), to find the number of iterations necessary to
achieve 10-5 accuracy. Then use the Python code to obtain an approximation, and compare the
error with the theoretical estimate obtained from Corollary 42.

    Exercise 2.7-2: Let g(x) = 2x - cx2 where c is a positive constant. Prove that if the

fixed-point iteration pn = g(pn-1) converges to a non-zero limit, then the limit is 1/c.
Chapter 3

Interpolation

In this chapter, we will study the following problem: given data (xi, yi), i = 0, 1, ..., n, find a
function f such that f (xi) = yi. This problem is called the interpolation problem, and f is called
the interpolating function, or interpolant, for the given data.

    Interpolation is used, for example, when we use mathematical software to plot a smooth curve
through discrete data points, when we want to find the in-between values in a table, or when we
differentiate or integrate black-box type functions.

    How do we choose f ? Or, what kind of function do we want f to be? There are several options.
Examples of functions used in interpolation are polynomials, piecewise polynomials, rational func-
tions, trigonometric functions, and exponential functions. As we try to find a good choice for f for
our data, some questions to consider are whether we want f to inherit the properties of the data
(for example, if the data is periodic, should we use a trigonometric function as f ?), and how we
want f behave between data points. In general f should be easy to evaluate, and easy to integrate
& differentiate.

    Here is a general framework for the interpolation problem. We are given data, and we pick a
family of functions from which the interpolant f will be chosen:

    · Data: (xi, yi), i = 0, 1, ..., n

    · Family: Polynomials, trigonometric functions, etc.
Suppose the family of functions selected forms a vector space. Pick a basis for the vector space:
0(x), 1(x), ..., n(x). Then the interpolating function can be written as a linear combination of
the basis vectors (functions):

                                                                                      n

                                                   f (x) = akk(x).

                                                                                    k=0

We want f to pass through the data points, that is, f (xi) = yi. Then determine ak so that:

                                                                      n

                                      f (xi) = akk(xi) = yi, i = 0, 1, ..., n,

                                                                    k=0

                                                         75
CHAPTER 3. INTERPOLATION                     76

which is a system of n + 1 equations with n + 1 unknowns. Using matrices, the problem is to solve
the matrix equation

                                                            Aa = y

for a, where                

              0(x0) ... n(x0)  a0   y0 
              0(x1) ... n(x1)  a1   y1 
              A= .        ,a =  . ,y =  . .
               ..           ..   .. 
                            

              0(xn) ... n(xn)  an   yn

3.1 Polynomial interpolation

In polynomial interpolation, we pick polynomials as the family of functions in the interpolation
problem.

    · Data: (xi, yi), i = 0, 1, ..., n

    · Family: Polynomials

    The space of polynomials up to degree n is a vector space. We will consider three choices for
the basis for this vector space:

    · Basis:

           - Monomial basis: k(x) = xk
           - Lagrange basis: k(x) = j=0,j=k xk-xj n x-xj
           - Newton basis: k(x) = j=0 k-1(x - xj)

        where k = 0, 1, ..., n.

Once we decide on the basis, the interpolating polynomial can be written as a linear combination
of the basis functions: n

                                                   pn(x) = akk(x)

                                                                                      k=0

where pn(xi) = yi, i = 0, 1, ..., n.
    Here is an important question. How do we know that pn, a polynomial of degree at most n

passing through the data points, actually exists? Or, equivalently, how do we know the system of
equations pn(xi) = yi, i = 0, 1, ..., n, has a solution?

    The answer is given by the following theorem, which we will prove later in this section.

Theorem 47. If points x0, x1, ..., xn are distinct, then for real values y0, y1, ..., yn, there is a unique
polynomial pn of degree at most n such that pn(xi) = yi, i = 0, 1, ..., n.
CHAPTER 3. INTERPOLATION                                                 77

    We mentioned three families of basis functions for polynomials. The choice of a family of basis
functions affects:

    · The accuracy of the numerical methods to solve the system of linear equations Aa = y.

    · The ease at which the resulting polynomial can be evaluated, differentiated, integrated, etc.

Monomial form of polynomial interpolation

Given data (xi, yi), i = 0, 1, ..., n, we know from the previous theorem that there exists a polynomial
pn(x) of degree at most n, that passes through the data points. To represent pn(x), we will use the
monomial basis functions, 1, x, x2, ..., xn, or written more succinctly,

     k(x) = xk, k = 0, 1, ..., n.

The interpolating polynomial pn(x) can be written as a linear combination of these basis functions
as

                                        pn(x) = a0 + a1x + a2x2 + ... + anxn.

We will determine ai using the fact that pn is an interpolant for the data:

pn(xi) = a0 + a1xi + a2x2i + ... + anxni = yi

for i = 0, 1, ..., n. Or, in matrix form, we want to solve

                                        
1 x0 x20 ... xn0  a0 y0
1    x1                   x2   x  n                         a       y1 
                                  1                            1  
.                           1         .  =  . 

 ..                                    ..   .. 
                                        

1    xn                   x2   xn                           an      yn

                            n    n

                          A                                 a       y

for [a0, ..., an]T where [·]T stands for the transpose of the vector. The coefficient matrix A is known
as the van der Monde matrix. This is usually an ill-conditioned matrix, which means solving the
system of equations could result in large error in the coefficients ai. An intuitive way to understand
the ill-conditioning is to plot several basis monomials, and note how less distinguishable they are as
the degree increases, making the columns of the matrix nearly linearly dependent.
CHAPTER 3. INTERPOLATION                                                                         78

Figure 3.1: Monomial basis functions

    Solving the matrix equation Aa = b could also be expensive. Using Gaussian elimination to
solve the matrix equation for a general matrix A requires O(n3) operations. This means the number
of operations grows like Cn3, where C is a positive constant.1 However, there are some advantages
to the monomial form: evaluating the polynomial is very efficient using Horner's method, which
is the nested form discussed in Exercises 1.3-4, 1.3-5 of Chapter 1, requiring O(n) operations.
Differentiation and integration are also relatively efficient.

Lagrange form of polynomial interpolation

The ill-conditioning of the van der Monde matrix, as well as the high complexity of solving the
resulting matrix equation in the monomial form of polynomial interpolation, motivate us to explore
other basis functions for polynomials. As before, we start with data (xi, yi), i = 0, 1, ..., n, and call
our interpolating polynomial of degree at most n, pn(x). The Lagrange basis functions up to degree
n (also called cardinal polynomials) are defined as

                   n      x - xj   , k = 0, 1, ..., n.
                          xk - xj
lk(x) =

              j=0,j=k

We write the interpolating polynomial pn(x) as a linear combination of these basis functions as

                                      pn(x) = a0l0(x) + a1l1(x) + ... + anln(x).

    1The formal definition of the big O notation is as follows: We write f (n) = O(g(n)) as n   if and
only if there exists a positive constant M and a positive integer n such that |f (n)|  M g(n) for all n  n.
CHAPTER 3. INTERPOLATION                                                                 79

We will determine ai from

     pn(xi) = a0l0(xi) + a1l1(xi) + ... + anln(xi) = yi

for i = 0, 1, ..., n. Or, in matrix form, we want to solve

                                                                    

                           l0(x0) l1(x0) ... ln(x0) a0 y0
                           l0(x1) l1(x1)         ln  (  x     )      a       y1 
                                                           1            1  
                           .                                      .  =  . 
                            ..                                     ..   .. 
                                                                    

                           l0(xn) l1(xn)         ln(xn) an                   yn

                                          A                          a       y

for [a0, ..., an]T .
    Solving this matrix equation is trivial for the following reason. Observe that lk(xk) = 1 and

lk(xi) = 0 for all i = k. Then the coefficient matrix A becomes the identity matrix, and

                                    ak = yk for k = 0, 1, ..., n.

The interpolating polynomial becomes

                             pn(x) = y0l0(x) + y1l1(x) + ... + ynln(x).

The main advantage of the Lagrange form of interpolation is that finding the interpolating polyno-
mial is trivial: there is no need to solve a matrix equation. However, the evaluation, differentiation,
and integration of the Lagrange form of a polynomial is more expensive than, for example, the
monomial form.

Example 48. Find the interpolating polynomial using the monomial basis and Lagrange basis
functions for the data: (-1, -6), (1, 0), (2, 6).

· Monomial basis: p2(x) = a0 + a1x + a2x2

                                2                                               
  1 x0 x0 a0                                 y0                  1 -1 1 a0        -6
                                2                                               
 1 x1 x1  a1 = y1   1 1 1  a1 =  0 

  1                        x2  x2     a2     y2                  1 2 4 a2         6

                                 2

                           A          a      y

We can use Gaussian elimination to solve this matrix equation, or get help from Python:

In [1]: import numpy as np

In [2]: A = np.array([[1,-1,1], [1,1,1], [1,2,4]])
            A
CHAPTER 3. INTERPOLATION                                                                 80

Out[2]: array([[ 1, -1,         1],
                       [ 1, 1,  1],
                       [ 1, 2,  4]])

In [3]: y = np.array([-6, 0, 6])
            y

Out[3]: array([-6, 0, 6])

In [4]: np.linalg.solve(A, y)

Out[4]: array([-4., 3., 1.])

Since the solution is a = [-4, 3, 1]T , we obtain

                                      p2(x) = -4 + 3x + x2.

· Lagrange basis: p2(x) = y0l0(x) + y1l1(x) + y2l2(x) = -6l0(x) + 0l1(x) + 6l2(x) where

           l0(x) = (x - x1)(x - x2) = (x - 1)(x - 2) = (x - 1)(x - 2)
           (x0 - x1)(x0 - x2) (-1 - 1)(-1 - 2)                  6

           l2(x) = (x - x0)(x - x1) = (x + 1)(x - 1) = (x + 1)(x - 1)
           (x2 - x0)(x2 - x1) (2 + 1)(2 - 1)                 3

therefore

           (x - 1)(x - 2) (x + 1)(x - 1)           = -(x - 1)(x - 2) + 2(x + 1)(x - 1).
p2(x) = -6 6                    +6
                                             3

If we multiply out and collect the like terms, we obtain p2(x) = -4 + 3x + x2, which is the
polynomial we obtained from the monomial basis earlier.

    Exercise 3.1-1: Prove that k=0 n lk(x) = 1 for all x, where lk are the Lagrange basis func-

tions for n + 1 data points. (Hint. First verify the identity for n = 1 algebraically, for any two
data points. For the general case, think about what special function's interpolating polynomial in
Lagrange form is k=0 n lk(x) ).
CHAPTER 3. INTERPOLATION                                                                          81

Newton's form of polynomial interpolation

The Newton basis functions up to degree n are

                                                                         k-1

                                          k(x) = (x - xj), k = 0, 1, ..., n

                                                                         j=0

where 0(x) = j=0 -1 (x - xj) is interpreted as 1. The interpolating polynomial pn, written as a
linear combination of Newton basis functions, is

             pn(x) = a00(x) + a11(x) + ... + ann(x)
                     = a0 + a1(x - x0) + a2(x - x0)(x - x1) + ... + an(x - x0) · · · (x - xn-1).

We will determine ai from

     pn(xi) = a0 + a1(xi - x0) + ... + an(xi - x0) · · · (xi - xn-1) = yi,

for i = 0, 1, ..., n, or in matrix form

                                                           0    

1    0                                   0       ...             a0            y0

1    (x1 - x0)                           0                 0       
                                                                       a       y1 
1 (x2 - x0) (x2 - x0)(x2 - x1)                                            1  
                                                           0     .  =  . 
 ..   ..                                 ..                .      ..   .. 
.    .                                     .                ..     
                                                                
                                                                     an        yn
1 (xn - x0) (xn - x0)(xn - x1) . . .                  n-1
                                                      i=0 (xn - xi)

                                                                       a       y

                                              A

for [a0, ..., an]T . Note that the coefficient matrix A is lower-triangular, and a can be solved by
forward substitution, which is shown in the next example, in O(n2) operations.

Example 49. Find the interpolating polynomial using Newton's basis for the data:
(-1, -6), (1, 0), (2, 6).

Solution. We have p2(x) = a0 + a11(x) + a22(x) = a0 + a1(x + 1) + a2(x + 1)(x - 1). Find
a0, a1, a2 from

p2(-1) = -6  a0 + a1(-1 + 1) + a2(-1 + 1)(-1 - 1) = a0 = -6
    p2(1) = 0  a0 + a1(1 + 1) + a2(1 + 1)(1 - 1) = a0 + 2a1 = 0
    p2(2) = 6  a0 + a1(2 + 1) + a2(2 + 1)(2 - 1) = a0 + 3a1 + 3a2 = 6
CHAPTER 3. INTERPOLATION                                                      82

or, in matrix form             
Forward substitution is:  1 0 0 a0  -6
                               
                          1 2 0 a1 =  0  .

                          1 3 3 a2  6

                                                           a0 = -6
                                      a0 + 2a1 = 0  -6 + 2a1 = 0  a1 = 3
                               a0 + 3a1 + 3a2 = 6  -6 + 9 + 3a2 = 6  a2 = 1.

Therefore a = [-6, 3, 1]T and

                                      p2(x) = -6 + 3(x + 1) + (x + 1)(x - 1).

Factoring out and simplifying gives p2(x) = -4 + 3x + x2, which is the polynomial discussed in
Example 48.

Summary: The interpolating polynomial p2(x) for the data, (-1, -6), (1, 0), (2, 6), represented in
        three different basis functions is:

                                   Monomial: p2(x) = -4 + 3x + x2
                                 Lagrange: p2(x) = - (x - 1)(x - 2) + 2(x + 1)(x - 1)

                                   Newton: p2(x) = - 6 + 3(x + 1) + (x + 1)(x - 1)

    Similar to the monomial form, a polynomial written in Newton's form can be evaluated using
the Horner's method which has O(n) complexity:

       pn(x) = a0 + a1(x - x0) + a2(x - x0)(x - x1) + ... + an(x - x0)(x - x1) · · · (x - xn-1)
               = a0 + (x - x0)(a1 + (x - x1)(a2 + ... + (x - xn-2)(an-1 + (x - xn-1)(an)) · · · ))

Example 50. Write p2(x) = -6 + 3(x + 1) + (x + 1)(x - 1) using the nested form.

Solution. -6 + 3(x + 1) + (x + 1)(x - 1) = -6 + (x + 1)(2 + x); note that the left-hand side has 2
multiplications, and the right-hand side has 1.

Complexity of the three forms of polynomial interpolation: The number of multiplica-
        tions required in solving the corresponding matrix equation in each polynomial basis is:
            · Monomial  O(n3)
            · Lagrange  trivial
CHAPTER 3. INTERPOLATION                                   83

    · Newton  O(n2)

Evaluating the polynomials can be done efficiently using Horner's method for monomial and
Newton forms. A modified version of Lagrange form can also be evaluated using Horner's
method, but we do not discuss it here.

    Exercise 3.1-2: Compute, by hand, the interpolating polynomial to the data (-1, 0), (0.5, 1),

(1, 0) using the monomial, Lagrange, and Newton basis functions. Verify the three polynomials are
identical.

    It's time to discuss some theoretical results for polynomial interpolation. Let's start with proving
Theorem 47 which we stated earlier:

Theorem. If points x0, x1, ..., xn are distinct, then for real values y0, y1, ..., yn, there is a unique
polynomial pn of degree at most n such that pn(xi) = yi, i = 0, 1, ..., n.

Proof. We have already established the existence of pn without mentioning it! The Lagrange form
of the interpolating polynomial constructs pn directly:

n n n x - xj
pn(x) = yklk(x) = yk                             .
                                       xk - xj
k=0                       k=0 j=0,j=k

Let's prove uniqueness. Assume pn, qn are two distinct polynomials satisfying the conclusion. Then
pn - qn is a polynomial of degree at most n such that (pn - qn)(xi) = 0 for i = 0, 1, ..., n. This
means the non-zero polynomial (pn - qn) of degree at most n, has (n + 1) distinct roots, which is a
contradiction.

    The following theorem, which we state without proof, establishes the error of polynomial inter-
polation. Notice the similarities between this and Taylor's Theorem 7.

Theorem 51. Let x0, x1, ..., xn be distinct numbers in the interval [a, b] and f  Cn+1[a, b]. Then
for each x  [a, b], there is a number  between x0, x1, ..., xn such that

                     f (n+1)()
f (x) - pn(x) = (n + 1)! (x - x0)(x - x1) · · · (x - xn).

    The following lemma is useful in finding upper bounds for |f (x) - pn(x)| using Theorem 51,
when the nodes x0, ..., xn are equally spaced.
CHAPTER 3. INTERPOLATION                                                                           84

Lemma 52. Consider the partition of [a, b] as x0 = a, x1 = a + h, ..., xn = a + nh = b. More
succinctly, xi = a + ih for i = 0, 1, ..., n and h = n b-a . Then for any x  [a, b]

                             n

                                              1 n+1
                                |x - xi|  4 h n!

                            i=0

Proof. Since x  [a, b], it falls into one of the subintervals: let x  [xj, xj+1]. Consider the product
|x - xj||x - xj+1|. Put s = |x - xj| and t = |x - xj+1|. The maximum of st given s + t = h, using
Calculus, can be found to be h2/4, which is attained when x is the midpoint, and thus s = t = h/2.
Then

               n

                  |x - xi| = |x - x0| · · · |x - xj-1||x - xj||x - xj+1||x - xj+2| · · · |x - xn|

i=0

                                                 h2
                   |x - x0| · · · |x - xj-1| 4 |x - xj+2| · · · |x - xn|

                                                         h2
                   |xj+1 - x0| · · · |xj+1 - xj-1| 4 |xj - xj+2| · · · |xj - xn|

                   (j + 1)h · · · 2h  h2  (2h) · · · (n - j)h

                                      4

                  = hj(j + 1)! h2 (n - j)!hn-j-1
                                   4

                   hn+1 n! .
                            4

Example 53. Find an upper bound for the absolute error when f (x) = cos x is approximated by its
interpolating polynomial pn(x) on [0, /2]. For the interpolating polynomial, use 5 equally spaced
nodes (n = 4) in [0, /2], including the endpoints.

Solution. From Theorem 51,

                                        |f (5)()|
                  |f (x) - p4(x)| = 5! |(x - x0) · · · (x - x4)|.

We have |f (5)()|  1. The nodes are equally spaced with h = (/2 - 0)/4 = /8. Then from the

previous lemma,                                             1 5
                            |(x - x0) · · · (x - x4)|  4 8 4!

and therefore     |f (x) - p 1 1  5 4(x)|  4! = 4.7 × 10-4.
                                        5! 4 8
CHAPTER 3. INTERPOLATION                                                                                          85

    Exercise 3.1-3: Find an upper bound for the absolute error when f (x) = ln x is approxi-

mated by an interpolating polynomial of degree five with six nodes equally spaced in the interval

[1, 2].

    We now revisit Newton's form of interpolation, and learn an alternative method, known as
divided differences, to compute the coefficients of the interpolating polynomial. This approach
is numerically more stable than the forward substitution approach we used earlier. Let's recall the
interpolation problem.

    · Data: (xi, yi), i = 0, 1, ..., n

    · Interpolant in Newton's form:

                 pn(x) = a0 + a1(x - x0) + a2(x - x0)(x - x1) + ... + an(x - x0) · · · (x - xn-1)

        Determine ai from pn(xi) = yi, i = 0, 1, ..., n.
    Let's think of the y-coordinates of the data, yi, as values of an unknown function f evaluated
at xi, i.e., f (xi) = yi. Substitute x = x0 in the interpolant to get:

                          a0 = f (x0).

Substitute x = x1 to get a0 + a1(x1 - x0) = f (x1) or,

                                                   a1 = f (x1) - f (x0) .
                                                               x1 - x0

Substitute x = x2 to get, after some algebra

                                         a x 2 = 2-x1 f (x2)-f (x0) - x1-x0 x2-x1 f (x1)-f (x0) x2-x0
                                                               x2 - x0

which can be further rewritten as
                                             a x 2 = 2-x1 f (x2)-f (x1) - x1-x0 f (x1)-f (x0) .
                                                               x2 - x0

Inspecting the formulas for a0, a1, a2 suggests the following simplified new notation called divided
differences:

a0 = f (x0) = f [x0] - 0th divided difference

a1 = f (x1) - f (x0) = f [x0, x1] - 1st divided difference
           x1 - x0

a x 2 = 2-x1 f(x2)-f(x1) - x1-x0 f(x1)-f(x0) = f [x1, x2] - f [x0, x1] = f [x0, x1, x2] - 2nd divided difference
x2 - x0                   x2 - x0
CHAPTER 3. INTERPOLATION                                                            86

And in general, ak will be given by the kth divided difference:

                                                   ak = f [x0, x1, ..., xk].

With this new notation, Newton's interpolating polynomial can be written as

                                   n

  pn(x) = f [x0] + f [x0, x1, ..., xk](x - x0) · · · (x - xk-1)

                                 k=1

                       = f [x0] + f [x0, x1](x - x0) + f [x0, x1, x2](x - x0)(x - x1) + . . .
                                                                + f [x0, x1, ..., xn](x - x0)(x - x1) · · · (x - xn-1)

Here is the formal definition of divided differences:

Definition 54. Given data (xi, f (xi)), i = 0, 1, ..., n, the divided differences are defined recursively
as

                                     f [x0] = f (x0)
                         f [x0, x1, ..., xk] = f [x1, ..., xk] - f [x0, ..., xk-1]

                                                             xk - x0

where k = 0, 1, ..., n.

Theorem 55. The ordering of the data in constructing divided differences is not important, that is,
the divided difference f [x0, ..., xk] is invariant under all permutations of the arguments x0, ..., xk.

Proof. Consider the data (x0, y0), (x1, y1), ..., (xk, yk) and let pk(x) be its interpolating polynomial:

                   pk(x) = f [x0] + f [x0, x1](x - x0) + f [x0, x1, x2](x - x0)(x - x1) + ...
                           + f [x0, ..., xk](x - x0) · · · (x - xk-1).

Now let's consider a permutation of the xi; let's label them as x~0, x~1, ..., x~k. The interpolating
polynomial for the permuted data does not change, since the data x0, x1, ..., xk (omitting the y-
coordinates) is the same as x~0, x~1, ..., x~k, just in different order. Therefore

                   pk(x) = f [x~0] + f [x~0, x~1](x - x~0) + f [x~0, x~1, x~2](x - x~0)(x - x~1) + ...
                           + f [x~0, ..., x~k](x - x~0) · · · (x - x~k-1).

The coefficient of the polynomial pk(x) for the highest degree xk is f [x0, ..., xk] in the first equation,
and f [x~0, ..., x~k] in the second. Therefore they must be equal to each other.

Example 56. Find the interpolating polynomial for the data (-1, -6), (1, 0), (2, 6) using Newton's
form and divided differences.
CHAPTER 3. INTERPOLATION                                                                                      87

Solution. We want to compute

                      p2(x) = f [x0] + f [x0, x1](x - x0) + f [x0, x1, x2](x - x0)(x - x1).
Here are the finite differences:

    x          f [x]     First divided difference                  Second divided difference
x0 = -1    f [x0] = -6  f [x0, x1] = x1-x0 f [x1]-f [x0] = 3  f [x0, x1, x2] = x2-x0 f [x1,x2]-f [x0,x1] = 1
                        f [x1, x2] = x2-x1 f [x2]-f [x1] = 6
 x1 = 1     f [x1] = 0

 x2 = 2     f [x2] = 6

Therefore

                        p2(x) = -6 + 3(x + 1) + 1(x + 1)(x - 1),

which is the same polynomial we had in Example 49.

    Exercise 3.1-4: Consider the function f given in the following table.

                                                 x 1246
                                               f (x) 2 3 5 9

   a) Construct a divided difference table for f by hand, and write the Newton form of the inter-
        polating polynomial using the divided differences.

   b) Assume you are given a new data point for the function: x = 3, y = 4. Find the new
        interpolating polynomial. (Hint: Think about how to update the interpolating polynomial
        you found in part (a).)

   c) If you were working with the Lagrange form of the interpolating polynomial instead of the
        Newton form, and you were given an additional data point like in part (b), how easy would
        it be (compared to what you did in part (b)) to update your interpolating polynomial?

Example 57. Before the widespread availability of computers and mathematical software, the
values of some often-used mathematical functions were disseminated to researchers and engineers
via tables. The following table, taken from [1], displays some values of the gamma function, (x) =
  0 tx-1e-tdt.
CHAPTER 3. INTERPOLATION                                                        88

                                     x 1.750 1.755 1.760 1.765
                                   (x) 0.91906 0.92021 0.92137 0.92256

Use polynomial interpolation to estimate (1.761).

Solution. The finite differences, with five-digit rounding, are:

i xi  f [xi] f [xi, xi+1] f [xi-1, xi, xi+1] f [x0, x1, x2, x3]

0 1.750 0.91906

                          0.23

1 1.755 0.92021                  0.2

                          0.232                                         26.667

2 1.760 0.92137                  0.6

                          0.238

3 1.765 0.92256

    Here are various estimates for (1.761) using interpolating polynomials of increasing degrees:

    p1(x) = f [x0] + f [x0, x1](x - x0)  p1(1.761) = 0.91906 + 0.23(1.761 - 1.750) = 0.92159
    p2(x) = f [x0] + f [x0, x1](x - x0) + f [x0, x1, x2](x - x0)(x - x1)

             p2(1.761) = 0.92159 + (0.2)(1.761 - 1.750)(1.761 - 1.755) = 0.9216
    p3(x) = p2(x) + f [x0, x1, x2, x3](x - x0)(x - x1)(x - x2)

             p3(1.761) = 0.9216 + 26.667(1.761 - 1.750)(1.761 - 1.755)(1.761 - 1.760) = 0.9216

    Next we will change the ordering of the data and repeat the calculations. We will list the data
in decreasing order of the x-coordinates:

i xi  f [xi] f [xi, xi+1] f [xi-1, xi, xi+1] f [x0, x1, x2, x3]

0 1.765 0.92256

                          0.238

1 1.760 0.92137                  0.6

                          0.232                                         26.667

2 1.755 0.92021                  0.2

                          0.23

3 1.750 0.91906
CHAPTER 3. INTERPOLATION                                                             89

The polynomial evaluations are:

p1(1.761) = 0.92256 + 0.238(1.761 - 1.765) = 0.92161
p2(1.761) = 0.92161 + 0.6(1.761 - 1.765)(1.761 - 1.760) = 0.92161
p3(1.761) = 0.92161 + 26.667(1.761 - 1.765)(1.761 - 1.760)(1.761 - 1.755) = 0.92161

    Summary of results: The following table displays the results for each ordering of the data,
together with the correct (1.761) to 7 digits of accuracy.

Ordering   (1.75, 1.755, 1.76, 1.765)  (1.765, 1.76, 1.755, 1.75)
p1(1.761)
p2(1.761)            0.92159                     0.92161
p3(1.761)            0.92160                     0.92161
(1.761)              0.92160                     0.92161
                    0.9216103                   0.9216103

    Exercise 3.1-5: Answer the following questions:

   a) Theorem 55 stated that the ordering of the data in divided differences does not matter. But
        we see differences in the two tables above. Is this a contradiction?

   b) p1(1.761) is a better approximation to (1.761) in the second ordering. Is this expected?

   c) p3(1.761) is different in the two orderings, however, this difference is due to rounding error.
        In other words, if the calculations can be done exactly, p3(1.761) will be the same in each
        ordering of the data. Why?

    Exercise 3.1-6: Consider a function f (x) such that f (2) = 1.5713, f (3) = 1.5719, f (5) =

1.5738, and f (6) = 1.5751. Estimate f (4) using a second degree interpolating polynomial (inter-
polating the first three data points) and a third degree interpolating polynomial (interpolating the
first four data points). Round the final results to four decimal places. Is there any advantage here
in using a third degree interpolating polynomial?

Python code for Newton interpolation

Consider the following finite difference table.
    There are 2 + 1 = 3 divided differences in the table, not counting the 0th divided differences.

In general, the number of divided differences to compute is 1 + ... + n = n(n + 1)/2. However, to
construct Newton's form of the interpolating polynomial, we need only n divided differences and
the 0th divided difference y0. These numbers are displayed in red in Table 3.1. The important
CHAPTER 3. INTERPOLATION                                                                    90

x f (x)                      f [xi, xi+1]                     f [xi-1, xi, xi+1]

x0 y0

                      x1-x0 y1-y0 = f [x0, x1]  x2-x0 f [x1,x2]-f [x0,x1] = f [x0, x1, x2]

x1 y1

                      x2-x1 y2-y1 = f [x1, x2]

x2 y2

                      Table 3.1: Divided differences for three data points

observation is, even though all the divided differences have to be computed in order to get the ones
needed for Newton's form, they do not have to be all stored. The following Python code is based on
an efficient algorithm that goes through the divided difference calculations recursively, and stores
an array of size m = n + 1 at any given time. In the final iteration, this array has the divided
differences needed for Newton's form.

    Let's explain the idea of the algorithm using the simple example of Table 3.1. The code creates
an array a = (a0, a1, a2) of size m = n + 1, which is three in our example, and sets

                                 a0 = y0, a1 = y1, a2 = y2.

In the first iteration (for loop, j = 1), a1 and a2 are updated:

a1 := a1 - a0 = y1 - y0 = f [x0, x1], a2 := a2 - a1 = y2 - y1 .
                      x1 - x0 x1 - x0                         x2 - x1 x2 - x1

In the last iteration (for loop, j = 2), only a2 is updated:

                      a a2 - a1 x 2 := = 2-x1 y2-y1 - x1-x0 y1-y0 = f [x0, x1, x2].
                            x2 - x0        x2 - x0

The final array a is

                             a = (y0, f [x0, x1], f [x0, x1, x2])

containing the divided differences needed to construct the Newton's form of the polynomial.
    Here is the Python function diff that computes the divided differences. The code uses a function

we have not used before: np.flip(np.arange(j,m)). An example illustrates what it does the best:

In [1]: import numpy as np

In [2]: np.flip(np.arange(2,6))

Out[2]: array([5, 4, 3, 2])

    In the code diff the inputs are the x- and y-coordinates of the data. The numbering of the
indices starts at 0.
CHAPTER 3. INTERPOLATION                                                                                  91

In [3]: def diff(x, y):
                  m = x.size # here m is the number of data points.
                  # the degree of the polynomial is m-1
                  a = np.zeros(m)
                  for i in range(m):
                         a[i] = y[i]
                  for j in range(1, m):
                         for i in np.flip(np.arange(j,m)):
                               a[i] = (a[i]-a[i-1]) / (x[i]-x[i-(j)])
                  return a

Let's compute the divided differences of Example 56:

In [4]: diff(np.array([-1,1,2]), np.array([-6,0,6]))

Out[4]: array([-6., 3., 1.])

These are the divided differences in the second ordering of the data in Example 57:

In [5]: diff(np.array([1.765,1.760,1.755,1.750]),
                    np.array([0.92256,0.92137,0.92021,0.91906]))

Out[5]: array([ 0.92256 , 0.238  , 0.6                , 26.66666667])

    Now let's write a code for the Newton form of polynomial interpolation. The inputs to the
function newton are the x- and y-coordinates of the data, and where we want to evaluate the
polynomial: z. The code uses the divided differences function diff discussed earlier to compute:

              f [x0] + f [x0, x1](z - x0) + . . . + f [x0, x1, ..., xn](z - x0)(z - x1) · · · (z - xn-1)

In [6]: def newton(x, y, z):
                  m = x.size # here m is the number of data points, not the degree
                  # of the polynomial
                  a = diff(x, y)
                  sum = a[0]
                  pr = 1.0
                  for j in range(m-1):
                         pr *= (z-x[j])
                         sum += a[j+1]*pr
                  return sum

    Let's verify the code by computing p3(1.761) of Example 57:
CHAPTER 3. INTERPOLATION                                                    92

In [7]: newton(np.array([1.765,1.760,1.755,1.750]),
                       np.array([0.92256,0.92137,0.92021,0.91906]), 1.761)

Out[7]: 0.92160496

    Exercise 3.1-7: This problem discusses inverse interpolation which gives another method

to find the root of a function. Let f be a continuous function on [a, b] with one root p in the
interval. Also assume f has an inverse. Let x0, x1, ..., xn be n + 1 distinct numbers in [a, b] with
f (xi) = yi, i = 0, 1, ..., n. Construct an interpolating polynomial Pn for f -1(x), by taking your data
points as (yi, xi), i = 0, 1, ..., n. Observe that f -1(0) = p, the root we are trying to find. Then,
approximate the root p, by evaluating the interpolating polynomial for f -1 at 0, i.e., Pn(0)  p.
Using this method, and the following data, find an approximation to the solution of log x = 0.

                                        x 0.4 0.8 1.2 1.6
                                      log x -0.92 -0.22 0.18 0.47

3.2 High degree polynomial interpolation

Suppose we approximate f (x) using its polynomial interpolant pn(x) obtained from (n + 1) data
points. We then increase the number of data points, and update pn(x) accordingly. The central
question we want to discuss is the following: as the number of nodes (data points) increases, does
pn(x) become a better approximation to f (x) on [a, b]? We will investigate this question numerically,
using a famous example: Runge's function, given by f (x) = 1+x2 1 .

    We will interpolate Runge's function using polynomials of various degrees, and plot the func-
tion, together with its interpolating polynomial and the data points. We are interested to see
what happens as the number of data points, and hence the degree of the interpolating polynomial,
increases.

In [8]: import matplotlib.pyplot as plt
            %matplotlib inline

    We start with taking four equally spaced x-coordinates between -5 and 5, and plot the corre-
sponding interpolating polynomial and Runge's function. Matplotlib allows typing mathematics in
captions of a plot using Latex. (Latex is a typesetting program this book is written with.) Latex
commands need to be enclosed by a pair of dollar signs, in addition to a pair of quotation marks.
CHAPTER 3. INTERPOLATION                                                    93

In [9]: f = lambda x: 1/(1+x**2)
            xi = np.linspace(-5, 5, 4) # x-coordinates of the data, 4 points equally spaced from
            #-5 to 5 in increments of 10/3
            yi = f(xi) # the corresponding y-coordinates
            xaxis = np.linspace(-5, 5, 1000)
            runge = f(xaxis) # Runge's function values
            interp = newton(xi, yi, xaxis)
            plt.plot(xaxis, interp, label='interpolating poly')
            plt.plot(xaxis, runge, label="$f(x)=1/(1+x^2)$")
            plt.plot(xi, yi, 'o', label='data')
            plt.legend(loc='upper right');

    Next, we increase the number of data points to 6.

In [10]: xi = np.linspace(-5, 5, 6) # 6 equally spaced values from -5 to 5
              yi = f(xi) # the corresponding y-coordinates
              interp = newton(xi, yi, xaxis)
              plt.plot(xaxis, interp, label='interpolating poly')
              plt.plot(xaxis, runge, label="$f(x)=1/(1+x^2)$")
              plt.plot(xi, yi, 'o', label='data')
              plt.legend(loc='upper right');
CHAPTER 3. INTERPOLATION                                                                  94

    The next two graphs plot interpolating polynomials on 11 and 21 equally spaced data.

In [11]: xi = np.linspace(-5, 5, 11) # 11 equally spaced values from -5 to 5
              yi = f(xi) # the corresponding y-coordinates
              interp = newton(xi, yi, xaxis)
              plt.plot(xaxis, interp, label='interpolating poly')
              plt.plot(xaxis, runge, label="$f(x)=1/(1+x^2)$")
              plt.plot(xi, yi, 'o', label='data')
              plt.legend(loc='upper center');
CHAPTER 3. INTERPOLATION                                                      95

In [12]: xi = np.linspace(-5, 5, 21) # 21 equally spaced values from -5 to 5
              yi = f(xi) # the corresponding y-coordinates
              interp = newton(xi, yi, xaxis)
              plt.plot(xaxis, interp, label='interpolating poly')
              plt.plot(xaxis, runge, label="$f(x)=1/(1+x^2)$")
              plt.plot(xi, yi, 'o', label='data')
              plt.legend(loc='lower center');

We observe that as the degree of the interpolating polynomial increases, the polynomial has

large oscillations toward the end points of the interval. In fact, it can be shown that for any x such

that 3.64 < |x| < 5, supn0 |f (x) - pn(x)| = , where f is Runge's function.

This troublesome behavior of high degree interpolating polynomials improves significantly, if we

consider data with x-coordinates that are not equally spaced. Consider the interpolation error of

Theorem 51:                       f (n+1)()
             f (x) - pn(x) = (n + 1)! (x - x0)(x - x1) · · · (x - xn).

Perhaps surprisingly, the right-hand side of the above equation is not minimized when the nodes,
xi, are equally spaced! The set of nodes that minimizes the interpolation error is the roots of
the so-called Chebyshev polynomials. The placing of these nodes is such that there are more nodes
towards the end points of the interval, than the middle. We will learn about Chebyshev polynomials
in Chapter 5. Using Chebyshev nodes in polynomial interpolation avoids the diverging behavior
CHAPTER 3. INTERPOLATION                                                                 96

of polynomial interpolants as the degree increases, as observed in the case of Runge's function, for
sufficiently smooth functions.

Divided differences and derivatives

The following theorem shows the similarity between divided differences and derivatives.

Theorem 58. Suppose f  Cn[a, b] and x0, x1, ..., xn are distinct numbers in [a, b]. Then there

exists   (a, b) such that

                                              f (n)()
                           f [x0, ..., xn] = n! .

To prove this theorem, we need the generalized Rolle's theorem.

Theorem 59 (Rolle's theorem). Suppose f is a differentiable function on (a, b). If f (a) = f (b),
then there exists c  (a, b) such that f (c) = 0.

Theorem 60 (Generalized Rolle's theorem). Suppose f has n derivatives on (a, b). If f (x) = 0 at
(n + 1) distinct numbers x0, x1, ..., xn  [a, b], then there exists c  (a, b) such that f (n)(c) = 0.

Proof of Theorem 58 . Consider the function g(x) = pn(x) - f (x). Observe that g(xi) = 0 for
i = 0, 1, ..., n. From generalized Rolle's theorem, there exists   (a, b) such that g(n)() = 0, which
implies

                                                   pn(n)() - f (n)() = 0.
Since pn(x) = f [x0] + f [x0, x1](x - x0) + ... + f [x0, ..., xn](x - x0) · · · (x - xn-1), pn(n)(x) equals n!
times the leading coefficient f [x0, ..., xn]. Therefore

                                                 f (n)() = n!f [x0, ..., xn].

3.3 Hermite interpolation

In polynomial interpolation, our starting point has been the x- and y-coordinates of some data we
want to interpolate. Suppose, in addition, we know the derivative of the underlying function at
these x-coordinates. Our new data set has the following form.

Data:

        x0, x1, ..., xn
        y0, y1, ..., yn; yi = f (xi)
CHAPTER 3. INTERPOLATION                             97

        y0, y1, ..., yn; yi = f (xi)

We seek a polynomial that fits the y and y values, that is, we seek a polynomial H(x) such that
H(xi) = yi and H (xi) = yi, i = 0, 1, ..., n. This makes 2n + 2 equations, and if we let

             H(x) = a0 + a1x + ... + a2n+1x2n+1,

then there are 2n + 2 unknowns, a0, ..., a2n+1, to solve for. The following theorem shows that there
is a unique solution to this system of equations; a proof can be found in Burden, Faires, Burden [4].

Theorem 61. If f  C1[a, b] and x0, ..., xn  [a, b] are distinct, then there is a unique polynomial

H2n+1(x), of degree at most 2n + 1, agreeing with f and f at x0, ..., xn. The polynomial can be

written as:               n    n

             H2n+1(x) = yihi(x) + yihi(x)

                          i=0  i=0

where

             hi(x) = 1 - 2(x - xi)li(xi) (li(x))2
             hi(x) = (x - xi)(li(x))2.

Here li(x) is the ith Lagrange basis function for the nodes x0, ..., xn, and li(x) is its derivative.
H2n+1(x) is called the Hermite interpolating polynomial.

    The only difference between Hermite interpolation and polynomial interpolation is that in the
former, we have the derivative information, which can go a long way in capturing the shape of the
underlying function.

Example 62. We want to interpolate the following data:

             x-coordinates : -1.5, 1.6, 4.7
             y-coordinates : 0.071, -0.029, -0.012.

The underlying function the data comes from is cos x, but we pretend we do not know this. Figure
(3.2) plots the underlying function, the data, and the polynomial interpolant for the data. Clearly,
the polynomial interpolant does not come close to giving a good approximation to the underlying
function cos x.
CHAPTER 3. INTERPOLATION  98

                                                    Figure 3.2

    Now let's assume we know the derivative of the underlying function at these nodes:

                                        x-coordinates : -1.5, 1.6, 4.7
                                        y-coordinates : 0.071, -0.029, -0.012

                                               y -values : 1, -1, 1.

    We then construct the Hermite interpolating polynomial, incorporating the derivative infor-
mation. Figure (3.3) plots the Hermite interpolating polynomial, together with the polynomial
interpolant, and the underlying function.

    It is visually difficult to separate the Hermite interpolating polynomial from the underlying
function cos x in Figure (3.3). Going from polynomial interpolation to Hermite interpolation results
in rather dramatic improvement in approximating the underlying function.
CHAPTER 3. INTERPOLATION  99

                                                    Figure 3.3

Computing the Hermite polynomial

We do not use Theorem 61 to compute the Hermite polynomial: there is a more efficient method
using divided differences for this computation.

    We start with the data:
                                                 x0, x1, ..., xn
                                                 y0, y1, ..., yn; yi = f (xi)
                                                 y0, y1, ..., yn; yi = f (xi)

and define a sequence z0, z1, ..., z2n+1 by
                                       z0 = x0, z2 = x1, z4 = x2, ..., z2n = xn
                                       z1 = x0, z3 = x1, z5 = x2, ..., z2n+1 = xn

i.e., z2i = z2i+1 = xi, for i = 0, 1, ..., n.
CHAPTER 3. INTERPOLATION                                                                    100

Then the Hermite polynomial can be written as:

                 H2n+1(x) =f [z0] + f [z0, z1](x - z0) + f [z0, z1, z2](x - z0)(x - z1)+

                                 . . . + f [z0, z1, ..., z2n+1](x - z0) · · · (x - z2n)

                                                   2n+1

                              =f [z0] + f [z0, ...., zi](x - z0)(x - z1) · · · (x - zi-1).

                                                     i=1

There is a little problem with some of the first divided differences above: they are undefined!

Observe that     f [z0, z1] = f [x0, x0] = f (x0) - f (x0)
                                                  x0 - x0

or, in general,

                 f [z2i, z2i+1] = f [xi, xi] = f (xi) - f (xi)
                                                      xi - xi

for i = 0, ..., n.
    From Theorem 58, we know f [x0, ..., xn] = n! f(n)() for some  between the min and max of

x0, ..., xn. From a classical result by Hermite & Gennochi (see Atkinson [3], page 144), divided

differences are continuous functions of their variables x0, ..., xn. This implies we can take the limit

of the above result as xi  x0 for all i, which results in

                 f [x0, ..., x0] =  f (n)(x0)              .

                                                n!

Therefore in the Hermite polynomial coefficient calculations, we will put

                 f [z2i, z2i+1] = f [xi, xi] = f (xi) = yi

for i = 0, 1, ..., n.
Example 63. Let's compute the Hermite polynomial of Example 62. The data is:

                          i xi  yi yi

                          0 -1.5 0.071 1

                          1 1.6 -0.029 -1

                          2 4.7 -0.012 1

Here n = 2, and 2n + 1 = 5, so the Hermite polynomial is

                                                                         5

                              H5(x) = f [z0] + f [z0, ..., zi](x - z0) · · · (x - zi-1).

                                                                       i=1

The divided differences are:
CHAPTER 3. INTERPOLATION                                                                        101

     z      f (z)         1st diff           2nd diff             3rd diff  4th diff  5th diff
z0 = -1.5  0.071        f (z0) = 1                                                    -0.005
z1 = -1.5  0.071   f [z1, z2] = -0.032  -0.032-1 1.6+1.5 = -0.33  0.0065     0.015
 z2 = 1.6  -0.029      f (z2) = -1      -1+0.032 1.6+1.5 = -0.31    0.10    -0.016
 z3 = 1.6  -0.029  f [z3, z4] = 0.0055   0.0055+1 4.7-1.6 = 0.32
 z4 = 4.7  -0.012       f (z4) = 1       1-0.0055 4.7-1.6 = 0.32      0
 z5 = 4.7  -0.012

Therefore, the Hermite polynomial is:

H5(x) =0.071 + 1(x + 1.5)-0.33(x + 1.5)2 + 0.0065(x + 1.5)2(x - 1.6)+
           + 0.015(x + 1.5)2(x - 1.6)2-0.005(x + 1.5)2(x - 1.6)2(x - 4.7).

Python code for computing Hermite interpolating polynomial

In [1]: import numpy as np
            import matplotlib.pyplot as plt
            %matplotlib inline

    The following function hdiff computes the divided differences needed for Hermite interpolation.
It is based on the function diff for computing divided differences for Newton interpolation. The
inputs to hdiff are the x-coordinates, the y-coordinates, and the derivatives yprime.

In [2]: def hdiff(x, y, yprime):
                  m = x.size # here m is the number of data points. Note n=m-1
                  # and 2n+1=2m-1
                  l = 2*m
                  z = np.zeros(l)
                  a = np.zeros(l)
                  for i in range(m):
                         z[2*i] = x[i]
                         z[2*i+1] = x[i]
                  for i in range(m):
                         a[2*i] = y[i]
CHAPTER 3. INTERPOLATION                                                     102

      a[2*i+1] = y[i]
for i in np.flip(np.arange(1, m)): # computes the first divided

      # differences using derivatives
      a[2*i+1] = yprime[i]
      a[2*i] = (a[2*i]-a[2*i-1]) / (z[2*i]-z[2*i-1])
a[1] = yprime[0]
for j in range(2, l): # computes the rest of the divided differences
      for i in np.flip(np.arange(j, l)):

            a[i]=(a[i]-a[i-1]) / (z[i]-z[i-j])
return a

Let's compute the divided differences of Example 62.

In [3]: hdiff(np.array([-1.5, 1.6, 4.7]),
                     np.array([0.071,-0.029,-0.012]),
                     np.array([1,-1,1]))

Out[3]: array([ 0.071  , 1.  , -0.33298647, 0.00671344, 0.0154761 ,

-0.00519663])

    Note that in the hand-calculations of Example 63, where two-digit rounding was used, we
obtained 0.0065 as the first third divided difference. In the Python output above, this divided
difference is 0.0067.

    The following function computes the Hermite interpolating polynomial, using the divided dif-
ferences obtained from hdiff, and then evaluates the polynomial at w.

In [4]: def hermite(x, y, yprime, w):
                  m = x.size # here m is the number of data points. not the
                  # degree of the polynomial
                  a = hdiff(x, y, yprime)
                  z = np.zeros(2*m)
                  for i in range(m):
                         z[2*i] = x[i]
                         z[2*i+1] = x[i]
                  sum = a[0]
                  pr = 1.0
                  for j in range(2*m-1):
                         pr *= w-z[j]
                         sum += a[j+1]*pr
                  return sum
CHAPTER 3. INTERPOLATION                                                     103

    Let's recreate the Hermite interpolating polynomial plot of Example 62.

In [5]: xaxis = np.linspace(-np.pi/2, 3*np.pi/2, 120)
            x = np.array([-1.5, 1.6, 4.7])
            y = np.array([0.071,-0.029,-0.012])
            yprime = np.array([1, -1, 1])
            funct = np.cos(xaxis)
            interp = hermite(x, y, yprime, xaxis)
            plt.plot(xaxis, interp, label='Hermite interpolation')
            plt.plot(xaxis, funct, label="cos(x)")
            plt.plot(x, y, 'o', label='data')
            plt.legend(loc='upper right');

    Exercise 3.3-1: The following table gives the values of y = f (x) and y = f (x) where

f (x) = ex + sin 10x. Compute the Hermite interpolating polynomial and the polynomial interpolant
for the data in the table. Plot the two interpolating polynomials together with f (x) = ex + sin 10x
on (0, 3).

                                 x 0 0.4 1 2 2.6 3
                                 y 1 0.735 2.17 8.30 14.2 19.1
                                 y 11 -5.04 -5.67 11.5 19.9 21.6
CHAPTER 3. INTERPOLATION                  104

3.4 Piecewise polynomials: spline interpolation

As we observed in Section 3.2, a polynomial interpolant of high degree can have large oscillations,
and thus provide an overall poor approximation to the underlying function. Recall that the degree
of the interpolating polynomial is directly linked to the number of data points: we do not have the
freedom to choose the degree of the polynomial.

    In spline interpolation, we take a very different approach: instead of finding a single polynomial
that fits the given data, we find one low-degree polynomial that fits every pair of data. This results
in several polynomial pieces joined together, and we typically impose some smoothness conditions
on different pieces. The term spline function means a function that consists of polynomial pieces
joined together with some smoothness conditions.

    In linear spline interpolation, we simply join data points (the nodes), by line segments,
that is, linear polynomials. For example, consider the following figure that plots three data
points (xi-1, yi-1), (xi, yi), (xi+1, yi+1). We fit a linear polynomial P (x) to the first pair of data
points (xi-1, yi-1), (xi, yi), and another linear polynomial Q(x) to the second pair of data points
(xi, yi), (xi+1, yi+1).

yi                                  Q(x)

                          P(x)

yi+1

yi-1

      xi-1                      xi  xi+1

      Figure 3.4: Linear spline

    Let P (x) = ax + b and Q(x) = cx + d. We find the coefficients a, b, c, d by solving

                                                       P (xi-1) = yi-1
                                                          P (xi) = yi
                                                          Q(xi) = yi

                                                       Q(xi+1) = yi+1

which is a system of four equations and four unknowns. We then repeat this procedure for all data
points, (x0, y0), (x1, y1), ..., (xn, yn), to determine all of the linear polynomials.
CHAPTER 3. INTERPOLATION                  105

    One disadvantage of linear spline interpolation is the lack of smoothness. The first derivative
of the spline is not continuous at the nodes (unless the data fall on a line). We can obtain better
smoothness by increasing the degree of the piecewise polynomials. In quadratic spline interpo-
lation, we connect the nodes via second degree polynomials.

yi Q(x)
               P(x)

yi+1

yi-1

                          xi-1  xi  xi+1

      Figure 3.5: Quadratic spline

    Let P (x) = a0 + a1x + a2x2 and Q(x) = b0 + b1x + b2x2. There are six unknowns to determine,
but only four equations from the interpolation conditions: P (xi-1) = yi-1, P (xi) = yi, Q(xi) =
yi, Q(xi+1) = yi+1. We can find extra two conditions by requiring some smoothness, P (xi) = Q (xi),
and another equation by requiring P or Q take a certain value at one of the end points.

Cubic spline interpolation

This is the most common spline interpolation. It uses cubic polynomials to connect the nodes.
Consider the data

                                              (x0, y0), (x1, y1), ..., (xn, yn),

where x0 < x1 < ... < xn. In the figure below, the cubic polynomials interpolating pairs of data are
labeled as S0, ..., Sn-1 (we ignore the y-coordinates in the plot).
CHAPTER 3. INTERPOLATION                                                                   106
                                                                        Sn-1
                                                        Si
                                        Si-1

              S0

x0  x1  xi-1  xi                                            xi+1  xn-1  xn

                                           Figure 3.6: Cubic spline

    The polynomial Si interpolates the nodes (xi, yi), (xi+1, yi+1). Let

                                             Si(x) = ai + bix + cix2 + dix3

for i = 0, 1, ..., n - 1. There are 4n unknowns to determine: ai, bi, ci, di, as i takes on values from 0
to n - 1. Let's describe the equations Si must satisfy. First, the interpolation conditions, that is,
the requirement that Si passes through the nodes (xi, yi), (xi+1, yi+1):

                                                         Si(xi) = yi
                                                      Si(xi+1) = yi+1

for i = 0, 1, ..., n - 1, which gives 2n equations. The next group of equations are about smoothness:

                                                     Si-1(xi) = Si(xi)
                                                     Si-1(xi) = Si (xi)

for i = 1, 2, ..., n - 1, which gives 2(n - 1) = 2n - 2 equations. Last two equations are called the
boundary conditions. There are two choices:

    · Free or natural boundary: S0 (x0) = Sn-1(xn) = 0
    · Clamped boundary: S0(x0) = f (x0) and Sn-1(xn) = f (xn)
CHAPTER 3. INTERPOLATION                                                         107

Each boundary choice gives another two equations, bringing the total number of equations to 4n.
There are 4n unknowns as well. Do these systems of equations have a unique solution? The answer
is yes, and a proof can be found in Burden, Faires, Burden [4]. The spline obtained from the first
boundary choice is called a natural spline, and the other one is called a clamped spline.

Example 64. Find the natural cubic spline that interpolates the data (0, 0), (1, 1), (2, 0).

Solution. We have two cubic polynomials to determine:

                                            S0(x) = a0 + b0x + c0x2 + d0x3
                                            S1(x) = a1 + b1x + c1x2 + d1x3

The interpolation equations are:

                                        S0(0) = 0  a0 = 0
                                        S0(1) = 1  a0 + b0 + c0 + d0 = 1
                                        S1(1) = 1  a1 + b1 + c1 + d1 = 1
                                        S1(2) = 0  a1 + 2b1 + 4c1 + 8d1 = 0

We need the derivatives of the polynomials for the other equations:

                                               S0(x) = b0 + 2c0x + 3d0x2
                                               S1(x) = b1 + 2c1x + 3d1x2
                                               S0 (x) = 2c0 + 6d0x
                                               S1 (x) = 2c1 + 6d1x

The smoothness conditions are:

                                 S0(1) = S1(1)  b0 + 2c0 + 3d0 = b1 + 2c1 + 3d1
                                S0 (1) = S1 (1)  2c0 + 6d0 = 2c1 + 6d1

The natural boundary conditions are:

                                              S0 (0) = 0  2c0 = 0
                                              S1 (2) = 0  2c1 + 12d1 = 0

There are eight equations and eight unknowns. However, a0 = c0 = 0, so that reduces the number
of equations and unknowns to six. We rewrite the equations below, substituting a0 = c0 = 0, and
CHAPTER 3. INTERPOLATION                                                      108

simplifying when possible:

                                               b0 + d0 = 1
                                  a1 + b1 + c1 + d1 = 1
                              a1 + 2b1 + 4c1 + 8d1 = 0

                                             b0 + 3d0 = b1 + 2c1 + 3d1
                                                    3d0 = c1 + 3d1

                                             c1 + 6d1 = 0

We will use Python to solve this system of equations. To do that, we first rewrite the system of
equations as a matrix equation

                                                            Ax = v

where                                                                   

                            110 0 0 0             b0                    1
                                                                        
                            0 0 1 1 1 1           d0                    1
                                                                        
        A = 0 0 1 2 4 8    , x = a1   , v = 0 .
                            1 3 0 -1 -2 -3     b  1   0  
                            0 3 0 0 -1 -3         c1                    0

                            000 0 1 6             d1                    0

    We enter the matrices A, v in Python and solve the equation Ax = v using the command
np.linalg.solve.

In [1]: A = np.array([[1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1],
                                  [0, 0, 1, 2, 4, 8], [1, 3, 0, -1, -2, -3],
                                  [0, 3, 0, 0, -1, -3], [0, 0, 0, 0, 1, 6]])

            A

Out[1]: array([[ 1, 1, 0, 0, 0, 0],
                       [ 0, 0, 1, 1, 1, 1],
                       [ 0, 0, 1, 2, 4, 8],
                       [ 1, 3, 0, -1, -2, -3],
                       [ 0, 3, 0, 0, -1, -3],
                       [ 0, 0, 0, 0, 1, 6]])

In [2]: v = np.array([1, 1, 0, 0, 0, 0])
            v

Out[2]: array([1, 1, 0, 0, 0, 0])

In [3]: np.linalg.solve(A, v)
CHAPTER 3. INTERPOLATION                                                           109

Out[3]: array([ 1.5, -0.5, -1. , 4.5, -3. , 0.5])

    Therefore, the polynomials are:

                                           S0(x) = 1.5x - 0.5x3
                                           S1(x) = -1 + 4.5x - 3x2 + 0.5x3

    Solving the equations of a spline even for three data points can be tedious. Fortunately, there
is a general approach to solving the equations for natural and clamped splines, for any number of
data points. We will use this approach when we write Python codes for splines next.

Exercise 3.4-1: Find the natural cubic spline interpolant for the following data:

                                              x -1 0 1
                                              y 1 20

Exercise 3.4-2: The following is a clamped cubic spline for a function f defined on [1, 3]:

                                                       if 1  x < 2
         s0(x) = (x - 1) + (x - 1)2 - (x - 1)3,        if 2  x < 3.
s(x) =
         s1(x) = a + b(x - 2) + c(x - 2)2 + d(x - 2)3

Find a, b, c, and d, if f (1) = 1 and f (3) = 2.

Python code for spline interpolation

In [1]: import numpy as np
            import matplotlib.pyplot as plt
            %matplotlib inline

    The function CubicNatural takes the x- and y-coordinates of the data as input, and computes
the natural cubic spline interpolating the data, by solving the resulting matrix equation. The code
is based on Algorithm 3.4 of Burden, Faires, Burden [4]. The output is the coefficients of the
m - 1 cubic polynomials, ai, bi, ci, di, i = 0, ..., m - 2 where m is the number of data points. These
coefficients are stored in the arrays a, b, c, d and returned at the end of the function, so that we can
access these arrays later to evaluate the spline for a given value w.

In [2]: def CubicNatural(x, y):
                  m = x.size # m is the number of data points
                  n = m-1
CHAPTER 3. INTERPOLATION  110

                  a = np.zeros(m)
                  b = np.zeros(n)
                  c = np.zeros(m)
                  d = np.zeros(n)
                  for i in range(m):

                         a[i] = y[i]
                  h = np.zeros(n)
                  for i in range(n):

                         h[i] = x[i+1] - x[i]
                  u = np.zeros(n)
                  u[0] = 0
                  for i in range(1, n):

                         u[i] = 3*(a[i+1]-a[i])/h[i]-3*(a[i]-a[i-1])/h[i-1]
                  s = np.zeros(m)
                  z = np.zeros(m)
                  t = np.zeros(n)
                  s[0] = 1
                  z[0] = 0
                  t[0] = 0
                  for i in range(1, n):

                         s[i] = 2*(x[i+1]-x[i-1])-h[i-1]*t[i-1]
                         t[i] = h[i]/s[i]
                         z[i]=(u[i]-h[i-1]*z[i-1])/s[i]
                  s[m-1] = 1
                  z[m-1] = 0
                  c[m-1] = 0
                  for i in np.flip(np.arange(n)):
                         c[i] = z[i]-t[i]*c[i+1]
                         b[i] = (a[i+1]-a[i])/h[i]-h[i]*(c[i+1]+2*c[i])/3
                         d[i] = (c[i+1]-c[i])/(3*h[i])
                  return a, b, c, d

    Once the matrix equation is solved, and the coefficients of the cubic polynomials are computed
by CubicNatural, the next step is to evaluate the spline at a given value. This is done by the
following function CubicNaturalEval. The inputs are the value at which the spline is evaluated,
w, the x-coordinates of the data and the coefficients computed by CubicNatural. The function
first finds the interval [xi, xi+1], i = 0, ..., m - 2, w belongs to, and then evaluates the spline at w
using the corresponding cubic polynomial.

In [3]: def CubicNaturalEval(w, x, coeff):
CHAPTER 3. INTERPOLATION  111

                  m = x.size
                  if w<x[0] or w>x[m-1]:

                         print('error: spline evaluated outside its domain')
                         return
                  n = m-1
                  p=0
                  for i in range(n):
                         if w <= x[i+1]:

                               break
                         else:

                               p += 1
                  # p is the number of the subinterval w falls into, i.e., p=i means
                  # w falls into the ith subinterval $(x_i,x_{i+1}), and therefore
                  # the value of the spline at w is
                  # a_i+b_i*(w-x_i)+c_i*(w-x_i)^2+d_i*(w-x_i)^3.
                  a = coeff[0]
                  b = coeff[1]
                  c = coeff[2]
                  d = coeff[3]
                  return a[p]+b[p]*(w-x[p])+c[p]*(w-x[p])**2+d[p]*(w-x[p])**3

    Next we will compare Newton and natural cubic spline interpolation when applied to Runge's
function. We import the functions for Newton interpolation first.

In [4]: def diff(x, y):
                  m = x.size #here m is the number of data points.
                  a = np.zeros(m)
                  for i in range(m):
                         a[i] = y[i]
                  for j in range(1, m):
                         for i in np.flip(np.arange(j,m)):
                               a[i] = (a[i]-a[i-1]) / (x[i]-x[i-(j)])
                  return a

In [5]: def newton(x, y, z):
                  m = x.size # here m is the number of data points, not the degree
                  # of the polynomial
                  a = diff(x, y)
                  sum = a[0]
                  pr = 1.0
CHAPTER 3. INTERPOLATION  112

                  for j in range(m-1):
                         pr *= (z-x[j])
                         sum += a[j+1]*pr

                  return sum

    Here is the code that computes the cubic spline, Newton interpolation, and plot them.

In [6]: xaxis = np.linspace(-5, 5, 1000)
            f = lambda x: 1/(1+x**2)
            runge = f(xaxis)
            xi = np.arange(-5, 6)
            yi = f(xi)
            coeff = CubicNatural(xi, yi)
            naturalspline = np.array(list(map(lambda x: CubicNaturalEval(x, xi, coeff), xaxis)))
            interp = newton(xi, yi, xaxis) # Interpolating polynomial for
            # the data
            plt.plot(xaxis, runge, label='$1/(1+x^2)$')
            plt.plot(xaxis, interp, label='Interpolating poly')
            plt.plot(xaxis, naturalspline, label='Natural cubic spline')
            plt.plot(xi, yi, 'o', label='Data')
            plt.legend(loc='upper center');

    The cubic spline gives an excellent fit to Runge's function on this scale: we cannot visually
separate it from the function itself.

    The following function CubicClamped computes the clamped cubic spline; the code is based
on Algorithm 3.5 of Burden, Faires, Burden [4]. The function CubicClampedEval evaluates the
spline at a given value.
CHAPTER 3. INTERPOLATION                                                     113

In [7]: def CubicClamped(x, y, yprime_left, yprime_right):
                  m = x.size # m is the number of data points
                  n = m-1
                  A = np.zeros(m)
                  B = np.zeros(n)
                  C = np.zeros(m)
                  D = np.zeros(n)
                  for i in range(m):
                         A[i] = y[i]
                  h = np.zeros(n)
                  for i in range(n):
                         h[i] = x[i+1] - x[i]
                  u = np.zeros(m)
                  u[0] = 3*(A[1]-A[0])/h[0]-3*yprime_left
                  u[m-1] = 3*yprime_right-3*(A[m-1]-A[m-2])/h[m-2]
                  for i in range(1, n):
                         u[i] = 3*(A[i+1]-A[i])/h[i]-3*(A[i]-A[i-1])/h[i-1]
                  s = np.zeros(m)
                  z = np.zeros(m)
                  t = np.zeros(n)
                  s[0] = 2*h[0]
                  t[0] = 0.5
                  z[0] = u[0]/s[0]
                  for i in range(1, n):
                         s[i] = 2*(x[i+1]-x[i-1])-h[i-1]*t[i-1]
                         t[i] = h[i]/s[i]
                         z[i] = (u[i]-h[i-1]*z[i-1])/s[i]
                  s[m-1] = h[m-2]*(2-t[m-2])
                  z[m-1] = (u[m-1]-h[m-2]*z[m-2])/s[m-1]
                  C[m-1] = z[m-1]
                  for i in np.flip(np.arange(n)):
                         C[i] = z[i]-t[i]*C[i+1]
                         B[i] = (A[i+1]-A[i])/h[i]-h[i]*(C[i+1]+2*C[i])/3
                         D[i] = (C[i+1]-C[i])/(3*h[i])
                  return A, B, C, D

In [8]: def CubicClampedEval(w, x, coeff):
                  m = x.size
                  if w<x[0] or w>x[m-1]:
CHAPTER 3. INTERPOLATION                                              114

                         print('error: spline evaluated outside its domain')
                         return
                  n = m-1
                  p=0
                  for i in range(n):
                         if w <= x[i+1]:

                               break
                         else:

                               p += 1
                  A = coeff[0]
                  B = coeff[1]
                  C = coeff[2]
                  D = coeff[3]
                  return A[p]+B[p]*(w-x[p])+C[p]*(w-x[p])**2+D[p]*(w-x[p])**3

    In the following, we use natural and clamped cubic splines to interpolate data coming from sin x
at the x-coordinates: 0, , 3/2, 2. The derivatives at the end points are both equal to 1.

In [9]: xaxis = np.linspace(0, 2*np.pi, 600)
            f = lambda x: np.sin(x)
            funct = f(xaxis)
            xi = np.array([0, np.pi, 3*np.pi/2, 2*np.pi])
            yi = f(xi)
            coeff = CubicNatural(xi, yi)
            naturalspline = np.array(list(map(lambda x: CubicNaturalEval(x, xi, coeff), xaxis)))
            coeff = CubicClamped(xi, yi, 1, 1)
            clampedspline = np.array(list(map(lambda x: CubicClampedEval(x, xi, coeff), xaxis)))

plt.plot(xaxis, funct, label='sin(x)')                         cubic  spline')
plt.plot(xaxis, naturalspline, linestyle='--', label='Natural
plt.plot(xaxis, clampedspline, label='Clamped cubic spline')
plt.plot(xi, yi, 'o', label='Data')
plt.legend(loc='upper right');
CHAPTER 3. INTERPOLATION                                              115

    Especially on the interval (0, ), the clamped spline gives a much better approximation to sin x
than the natural spline. However, adding an extra data point between 0 and  removes the visual
differences between the splines.

In [10]: xaxis = np.linspace(0, 2*np.pi, 600)
              f = lambda x: np.sin(x)
              funct = f(xaxis)
              xi = np.array([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
              yi = f(xi)
              coeff = CubicNatural(xi, yi)
              naturalspline = np.array(list(map(lambda x: CubicNaturalEval(x, xi, coeff), xaxis)))
              coeff = CubicClamped(xi, yi, 1, 1)
              clampedspline = np.array(list(map(lambda x: CubicClampedEval(x, xi, coeff), xaxis)))

plt.plot(xaxis, funct, label='sin(x)')                         cubic  spline')
plt.plot(xaxis, naturalspline, linestyle='--', label='Natural
plt.plot(xaxis, clampedspline, label='Clamped cubic spline')
plt.plot(xi, yi, 'o', label='Data')
plt.legend(loc='upper right');
CHAPTER 3. INTERPOLATION  116
CHAPTER 3. INTERPOLATION                           117

Arya and the letter NUH

    Arya loves Dr. Seuss (who doesn't?), and she
is writing her term paper in an English class on
On Beyond Zebra! 2. In this book Dr. Seuss in-
vents new letters, one of which is called NUH. He
writes:

        And NUH is the letter I use to spell
        Nutches
        Who live in small caves, known as
        Nitches, for hutches.
        These Nutches have troubles, the
        biggest of which is
        The fact there are many more
        Nutches than Nitches.

What does this letter look like? Well, something
like this.

    What Arya wants is a digitized version of the sketch; a figure that is smooth and can be
manipulated using graphics software. The letter NUH is a little complicated to apply a spline
interpolation directly, since it has some cusps. For such planar curves, we can use their parametric
representation, and use a cubic spline interpolation for x- and y-coordinates separately. To this end,
Arya picks eight points on the letter NUH, and labels them as t = 1, 2, ..., 8; see the figure below.

    2Seuss, 1955. On Beyond Zebra! Random House for Young Readers.
CHAPTER 3. INTERPOLATION                  118

    Then for each point she eyeballs the x and y-coordinates with the help of a graph paper. The
results are displayed in the table below.

                             t1 2 3 4 5 6 7 8
                            x 0 0 -0.05 0.1 0.4 0.65 0.7 0.76
                            y 0 1.25 2.5 1 0.3 0.9 1.5 0

    The next step is to fit a cubic spline to the data (t1, x1), ..., (t8, x8), and another cubic spline
to the data (t1, y1), ..., (t8, y8). Let's call these splines xspline(t), yspline(t), respectively, since they
represent the x- and y-coordinates as functions of the parameter t. Plotting xspline(t), yspline(t)
will produce the letter NUH, as we can see in the following Python codes.

    First, load the NumPy and Matplotlib packages, and copy and evaluate the functions Cubic-
Natural and CubicNaturalEval that we discussed earlier. Here is the letter NUH, obtained by
spline interpolation:

In [1]: t = np.array([1,2,3,4,5,6,7,8])
            x = np.array([0,0,-0.05,0.1,0.4,0.65,0.7,0.76])
            y = np.array([0,1.25,2.5,1,0.3,0.9,1.5,0])
            taxis = np.linspace(1, 8, 700)
            coeff = CubicNatural(t, x)
            xspline = np.array(list(map(lambda x: CubicNaturalEval(x, t, coeff), taxis)))

coeff = CubicNatural(t, y)
yspline = np.array(list(map(lambda x: CubicNaturalEval(x, t, coeff), taxis)))

plt.plot(xspline, yspline, linewidth=5);

    This looks like it needs to be squeezed! Adjusting the aspect ratio gives a better image. In the
following, we use the commands

In [2]: w, h = plt.figaspect(2);
            plt.figure(figsize=(w, h));
CHAPTER 3. INTERPOLATION                  119

to adjust the aspect ratio.

In [3]: t = np.array([1,2,3,4,5,6,7,8])
            x = np.array([0,0,-0.05,0.1,0.4,0.65,0.7,0.76])
            y = np.array([0,1.25,2.5,1,0.3,0.9,1.5,0])
            taxis = np.linspace(1, 8, 700)
            coeff = CubicNatural(t, x)
            xspline = np.array(list(map(lambda x: CubicNaturalEval(x, t, coeff), taxis)))

coeff = CubicNatural(t, y)
yspline = np.array(list(map(lambda x: CubicNaturalEval(x, t, coeff), taxis)))

w, h = plt.figaspect(2)
plt.figure(figsize=(w, h))
plt.plot(xspline, yspline, linewidth=5);

    Exercise 3.4-3: Limaçon is a curve, named after a French word for snail, which appears in

the study of planetary motion. The polar equation for the curve is r = 1 + c sin  where c is a
constant. Below is a plot of the curve when c = 1.
CHAPTER 3. INTERPOLATION  120

    The x, y coordinates of the dots on the curve are displayed in the following table:

                             x 0 0.5 1 1.3 0 -1.3 -1 -0.5 0
                             y 0 -0.25 0 0.71 2 0.71 0 -0.25 0

    Recreate the limaçon above, by applying the spline interpolation for plane curves approach used
in Arya and the letter NUH example to the points given in the table.
Chapter 4

Numerical Quadrature and
Differentiation

Estimating ab f (x)dx using sums of the form i=0 n wif (xi) is known as the quadrature problem.
Here wi are called weights, and xi are called nodes. The objective is to determine the nodes and

weights to minimize error.

4.1 Newton-Cotes formulas

The idea is to construct the polynomial interpolant P (x) and compute ab P (x)dx as an approxima-
tion to ab f (x)dx. Given nodes x0, x1, ..., xn, the Lagrange form of the interpolant is

                                                                                      n

                                                  Pn(x) = f (xi)li(x)

                                                                                     i=0

and from the interpolation error formula Theorem 51, we have

                                                   f (n+1)((x))
   f (x) = Pn(x) + (x - x0) · · · (x - xn) (n + 1)! ,

where (x)  [a, b]. (We have written (x) instead of  to emphasize that  depends on the value of
x.)

    Taking the integral of both sides yields

b  b                1              bn                                                     (4.1)

a a f (x)dx = Pn(x)dx + (n + 1)!        (x - xi)f (n+1)((x))dx.

   quadrature rule                a i=0

                                           error term

                    121
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                           122

The first integral on the right-hand side gives the quadrature rule:

                                                                      

         b                b   n                     n b                      n

            Pn(x)dx =            f (xi)li(x)  dx =         li(x)dx f (xi) =        wif (xi),
                                                         
      a                a     i=0                    i=0 a
                                                                             i=0

                                                           wi

and the second integral gives the error term.
    We obtain different quadrature rules by taking different nodes, or number of nodes. The following

result is useful in the theoretical analysis of Newton-Cotes formulas.

Theorem 65 (Weighted mean value theorem for integrals). Suppose f  C0[a, b], the Riemann
integral of g(x) exists on [a, b], and g(x) does not change sign on [a, b]. Then there exists   (a, b)
with ab f (x)g(x)dx = f () ab g(x)dx.

    Two well-known numerical quadrature rules, trapezoidal rule and Simpson's rule, are examples
of Newton-Cotes formulas:

· Trapezoidal rule
   Let f  C2[a, b]. Take two nodes, x0 = a, x1 = b, and use the linear Lagrange polynomial

                             P1(x) = x - x1 f (x0) + x - x0 f (x1)
                                         x0 - x1           x1 - x0

to estimate f (x). Substitute n = 1 in Equation (4.1) to get

                        b           b               1     b1

                         f (x)dx =  a P1(x)dx + 2              (x - xi)f ((x))dx,

                       a                                 a i=0

and then substitute for P1 to obtain

   b             b x - x1                     b x - x0               1b

      f (x)dx =  a x0 - x1   f (x0)dx +       a x1 - x0  f (x1)dx +  2a  (x - x0)(x - x1)f ((x))dx.

a

The first two integrals on the right-hand side are h2 f (x0) and h2 f (x1). Let's evaluate

                                                           b

                                            (x - x0)(x - x1)f ((x))dx.

                                                         a

We will use Theorem 65 for this computation. Note that the function (x - x0)(x - x1) =
(x - a)(x - b) does not change sign on the interval [a, b] and it is integrable: so this function
serves the role of g(x) in Theorem 65. The other term, f ((x)), serves the role of f (x).
Applying the theorem, we get

                          b                                    b

                             (x - a)(x - b)f ((x))dx = f () (x - a)(x - b)dx

                       a                                   a
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                 123

where we kept the same notation , somewhat inappropriately, as we moved f ((x)) from
inside to the outside of the integral. Finally, observe that

                                           b                      (a - b)3 -h3

                                              (x - a)(x - b)dx =    6   =,
                                                                            6
                                        a

where h = b - a. Putting all the pieces together, we have obtained

                                        b           h                   h3

                                a f (x)dx = 2 [f (x0) + f (x1)] - 12 f ().

· Simpson's rule

   Let f  C4[a, b]. Take three equally-spaced nodes, x0 = a, x1 = a + h, x2 = b, where h = 2 b-a ,
   and use the second degree Lagrange polynomial

   P2(x) = (x - x1)(x - x2) f (x0) + (x - x0)(x - x2) f (x1) + (x - x0)(x - x1) f (x2)
                (x0 - x1)(x0 - x2)                  (x1 - x0)(x1 - x2)          (x2 - x0)(x2 - x1)

to estimate f (x). Substitute n = 2 in Equation (4.1) to get

                           b                  b        1           b2

                            f (x)dx =         a P2(x)dx + 3!            (x - xi)f (3)((x))dx,

                          a                                       a i=0

and then substitute for P2 to obtain

    b               b (x - x1)(x - x2)              f (x0)dx +    b (x - x0)(x - x2)    f (x1)dx+

     f (x)dx =      a (x0 - x1)(x0 - x2)                          a (x1 - x0)(x1 - x2)

   a                b (x - x0)(x - x1) f (x 1 b 2)dx + (x - x0)(x - x1)(x - x2)f (3)((x))dx.
                    a (x2 - x0)(x2 - x1)                        6a
               +

The sum of the first three integrals on the right-hand side simplify as:

h  [f  (x0)  +  4f  (x1)  +  f  (x2)].        The last integral cannot be evaluated using Theorem 65
3

directly, like in the trapezoidal rule, since the function (x - x0)(x - x1)(x - x2) changes

sign on [a, b]. However, a clever application of integration by parts transforms the integral

to an integral where Theorem 65 is applicable (see Atkinson [3] for details), and the integral

simplifies as - 90 h5 f (4)() for some   (a, b). In summary, we obtain

                                b f (x)dx = h [f (x h5 0) + 4f (x1) + f (x2)] - f (4)()
                                                 3                          90
                             a

where   (a, b).
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                            124

    Exercise 4.1-1: Prove that the sum of the weights in Newton-Cotes rules is b - a, for any n.

Definition 66. The degree of accuracy, or precision, of a quadrature formula is the largest positive
integer n such that the formula is exact for f (x) = xk, when k = 0, 1, ..., n, or equivalently, for any
polynomial of degree less than or equal to n.

    Observe that the trapezoidal and Simpson's rules have degrees of accuracy of one and three.
These two rules are examples of closed Newton-Cotes formulas; closed refers to the fact that the end
points a, b of the interval are used as nodes in the quadrature rule. Here is the general definition.

Definition 67 (Closed Newton-Cotes). The (n + 1)-point closed Newton-Cotes formula uses nodes
xi = x0 + ih, for i = 0, 1, ..., n, where x0 = a, xn = b, h = n b-a , and

                                   wi =         xn             xn n x - xj
                                                                                     dx.
                                                   li(x)dx =
                                                              x0 j=0,j=i xi - xj
                                               x0

    The following theorem provides an error formula for the closed Newton-Cotes formula. A proof
can be found in Isaacson and Keller [12].

Theorem 68. For the (n + 1)-point closed Newton-Cotes formula, we have:

    · if n is even and f  Cn+2[a, b]

                             b              n             hn+3f (n+2)()   n

                            f (x)dx =       i=0  wif (xi) + (n + 2)!        t2(t - 1) · · · (t - n)dt,

                          a                                              0

    · if n is odd and f  Cn+1[a, b]

                                b           n             hn+2f (n+1)()            n

                               f (x)dx =    i=0  wif (xi) + (n + 1)!                 t(t - 1) · · · (t - n)dt

                             a                                                    0

       where  is some number in (a, b).

    Some well known examples of closed Newton-Cotes formulas are the trapezoidal rule (n = 1),
Simpson's rule (n = 2), and Simpson's three-eighth rule (n = 3). Observe that in the (n + 1)-point
closed Newton-Cotes formula, if n is even, then the degree of accuracy is (n + 1), although the
interpolating polynomial is of degree n. The open Newton-Cotes formulas exclude the end points of
the interval.

Definition 69 (Open Newton-Cotes). The (n + 1)-point open Newton-Cotes formula uses nodes

xi  =  x0  + ih,  for  i  =  0, 1, ..., n,  where  x0  =  a + h, xn  =  b - h, h  =  b-a  and
                                                                                     n+2

                                   wi =           b            b n x - xj
                                                                                   dx.
                                                   li(x)dx =
                                                              a j=0,j=i xi - xj
                                                 a
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                            125

We put a = x-1 and b = xn+1 .

    The error formula for the open Newton-Cotes formula is given next; for a proof see Isaacson and
Keller [12].

Theorem 70. For the (n + 1)-point open Newton-Cotes formula, we have:
    · if n is even and f  Cn+2[a, b]

b                              n              hn+3f (n+2)()   n+1

  f (x)dx =                i=0      wif (xi) + (n + 2)!            t2(t - 1) · · · (t - n)dt,

a                                                            -1

· if n is odd and f  Cn+1[a, b]

b                              n              hn+2f (n+1)()   n+1

  f (x)dx =                    i=0  wif (xi) + (n + 1)!            t(t - 1) · · · (t - n)dt,

a                                                            -1

where  is some number in (a, b).

The well-known midpoint rule is an example of open Newton-Cotes formula:

· Midpoint rule
   Take one node, x0 = a + h, which corresponds to n = 0 in the above theorem to obtain

                                    b                        h3f ()

                                    a f (x)dx = 2hf (x0) + 3

where h = (b - a)/2. This rule interpolates f by a constant (the values of f at the midpoint),
that is, a polynomial of degree 0, but it has degree of accuracy 1.

Remark 71. Both closed and open Newton-Cotes formulas using odd number of nodes (n is even),
gain an extra degree of accuracy beyond that of the polynomial interpolant on which they are based.
This is due to cancellation of positive and negative error.

    There are some drawbacks of Newton-Cotes formulas:

· In general, these rules are not of the highest degree of accuracy possible for the number of
   nodes used.

· The use of large number of equally spaced nodes may incur the erratic behavior associated
   with high-degree polynomial interpolation. Weights for a high-order rule may be negative,
   potentially leading to loss of significance errors.

· Let In denote the Newton-Cotes estimate of an integral based on n nodes. In may not converge
   to the true integral as n   for perfectly well-behaved integrands.

Example 72. Estimate  1    xxdx   using  the  midpoint,  trapezoidal,  and  Simpson's  rules.
                      0.5
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                      126

Solution. Let f (x) = xx. The midpoint estimate for the integral is 2hf (x0) where h =

(b - a)/2 = 1/4 and x0 = 0.75. Then the midpoint estimate, using 6 digits, is f (0.75)/2 =

0.805927/2 = 0.402964.  The trapezoidal estimate is             h  [f (0.5) + f (1)]  where  h  =  1/2,  which  re-
                                                                2

sults in 1.707107/4 = 0.426777. Finally, for Simpson's rule, h = (b - a)/2 = 1/4, and thus the

estimate is

             h                                     1
                [f (0.5) + 4f (0.75) + f (1)] = [0.707107 + 4(0.805927) + 1] = 0.410901.
             3                                     12

Here is a summary of the results:                  Trapezoidal     Simpson's
                                         Midpoint    0.426777      0.410901

                                         0.402964

Example 73. Find the constants c0, c1, x1 so that the quadrature formula

                                                                 1

                                                 f (x)dx = c0f (0) + c1f (x1)

                                                               0

has the highest possible degree of accuracy.

Solution. We will find how many of the polynomials 1, x, x2, ... the rule can integrate exactly. If

p(x) = 1, then

                                                    1

                                        p(x)dx = c0p(0) + c1p(x1)  1 = c0 + c1.

                                                  0

If p(x) = x, we get        1

                                                                   1
                        0 p(x)dx = c0p(0) + c1p(x1)  2 = c1x1

and p(x) = x2 implies      1 12
                            p(x)dx = c0p(0) + c1p(x1)  = c1x1.
                                                                   3
                        0

We have three unknowns and three equations, so we have to stop here. Solving the three equations
we get: c0 = 1/4, c1 = 3/4, x1 = 2/3. So the quadrature rule is of precision two and it is:

                                 1                     1           32

                                    f (x)dx = f (0) + f ( ).
                                                       4           43
                              0

    Exercise 4.1-2: Find c0, c1, c2 so that the quadrature rule -1 1 f (x)dx = c0f (-1) + c1f (0) +

c2f (1) has degree of accuracy 2.
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                                   127

4.2 Composite Newton-Cotes formulas

If the interval [a, b] in the quadrature is large, then the Newton-Cotes formulas will give poor
approximations. The quadrature error depends on h = (b - a)/n (closed formulas), and if b - a is
large, then so is h, hence error. If we raise n to compensate for large interval, then we face a problem
discussed earlier: error due to the oscillatory behavior of high-degree interpolating polynomials that
use equally-spaced nodes. A solution is to break up the domain into smaller intervals and use a
Newton-Cotes rule with a smaller n on each subinterval: this is known as a composite rule.

Example 74. Let's compute           2  ex  sin xdx.  The   antiderivative  can     be  computed  using        integration
                                    0

by parts, and the true value of the integral to 6 digits is 5.39689. If we apply the Simpson's rule we

get:             2 ex sin xdx  1 (e0 sin 0 + 4e sin 1 + e2 sin 2) = 5.28942.

              0                            3

If we partition the integration domain (0, 2) into (0, 1) and (1, 2), and apply Simpson's rule to each
domain separately, we get

         2          1                            2

            ex sin xdx = ex sin xdx + ex sin xdx

      0          0                            1

              1 (e0          sin 0  +  4e0.5  sin(0.5)  +  e sin 1)  +  1          +  4e1.5  sin(1.5)  +  e2  sin 2)
              6                                                          (e sin 1
                                                                        6

            = 5.38953,

improving the accuracy significantly. Note that we have used five nodes, 0, 0.5, 1, 1.5, 2, which split
the domain (0, 2) into four subintervals.

    The composite rules for midpoint, trapezoidal, and Simpson's rule, with their error terms, are:

    · Composite Midpoint rule
        Let f  C2[a, b], n be even, h = n+2 b-a , and xj = a + (j + 1)h for j = -1, 0, ..., n + 1. The
        composite Midpoint rule for n + 2 subintervals is

                                     b n/2 f (x)dx = 2h f (x b - a 2j) + h2f ()                                       (4.2)
                                    a j=0 6

      for some   (a, b).

      · Composite Trapezoidal rule

      Let f  C2[a, b], h = n b-a , and xj = a + jh for j = 0, 1, ..., n. The composite Trapezoidal rule

      for n subintervals is

                                                                           

                  b f (x)dx = h f (a) + 2 f (xj) + f (b) n-1 - b - a h2f ()                                           (4.3)
                 a 2 j=1 12
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                      128

for some   (a, b).

· Composite Simpson's rule

   Let f  C4[a, b], n be even, h = n b-a , and xj = a + jh for j = 0, 1, ..., n. The composite
   Simpson's rule for n subintervals is

 b 2  n -1 n/2                                                           (4.4)
  f (x)dx = h f (a) + 2 f (x2j) + 4 f (x2j-1) + f (b) - b - a h4f (4)()

a 3 j=1 j=1 180

for some   (a, b).

    Exercise 4.2-1: Show that the quadrature rule in Example 74 corresponds to taking n = 4

in the composite Simpson's formula (4.4).

    Exercise 4.2-2: Show that the absolute error for the composite trapezoidal rule decays at

the rate of 1/n2, and the absolute error for the composite Simpson's rule decays at the rate of 1/n4,
where n is the number of subintervals.

Example 75. Determine n that ensures the composite Simpson's rule approximates 12 x log xdx
with an absolute error of at most 10-6.

Solution. The error term for the composite Simpson's rule is b-a 180 h4f (4)() where  is some number
between a = 1 and b = 2, and h = (b - a)/n. Differentiate to get f (4)(x) = x3 2 . Then

                                b - a 4 (4)  1 4 2 h4
                                     h f () = h 3 
                                180          180  90

where we used the fact that  2    2  = 2 when   (1, 2).  Now make the upper bound less than
                             3    1

10-6, that is,  h4 -6                         10-6  n4  106  11111.11

                     10  4           1

                90                   n (90)              90

which implies n  10.27. Since n must be even for Simpson's rule, this means the smallest value of
n to ensure an error of at most 10-6 is 12.

    Using the Python code for the composite Simpson's rule that will be introduced next, we get
0.6362945608 as the estimate, using 10 digits. The correct integral to 10 digits is 0.6362943611,
which means an absolute error of 2 × 10-7, better than the expected 10-6.
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION  129

Python codes for Newton-Cotes formulas

We write codes for the trapezoidal and Simpson's rules, and the composite Simpson's rule. Coding
trapezoidal and Simpson's rule is straightforward.

Trapezoidal rule

In [1]: def trap(f, a, b):
                  return (f(a)+f(b))*(b-a)/2

    Let's verify the calculations of Example 72:

In [2]: trap(x->x^x,0.5,1)

Out[2]: 0.42677669529663687

Simpson's rule

In [3]: def simpson(f, a, b):
                  return (f(a)+4*f((a+b)/2)+f(b))*(b-a)/6

In [4]: simpson(lambda x: x**x, 0.5, 1)
Out[4]: 0.4109013813880978

    Recall that the degree of accuracy of Simpson's rule is 3. This means the rule integrates poly-
nomials 1, x, x2, x3 exactly, but not x4. We can use this as a way to verify our code:
In [5]: simpson(lambda x: x, 0, 1)
Out[5]: 0.5
In [6]: simpson(lambda x: x**2, 0, 1)
Out[6]: 0.3333333333333333
In [7]: simpson(lambda x: x**3, 0, 1)
Out[7]: 0.25
In [8]: simpson(lambda x: x**4, 0, 1)
Out[8]: 0.20833333333333334
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                              130

Composite Simpson's rule

Next we code the composite Simpson's rule, and verify the result of Example 75.

In [9]: def compsimpson(f, a, b, n):
                  h = (b-a)/n
                  nodes = np.zeros(n+1)
                  for i in range(n+1):
                         nodes[i] = a+i*h
                  sum = f(a)+f(b)
                  for i in range(2, n-1, 2):
                         sum += 2*f(nodes[i])
                  for i in range(1, n, 2):
                         sum += 4*f(nodes[i])
                  return sum*h/3

In [10]: compsimpson(lambda x: x*np.log(x), 1, 2, 12)

Out[10]: 0.636294560831306

    Exercise 4.2-3: Determine the value of n required to approximate

                                                            21
                                                                     dx

                                                          0 x+1

to within 10-4, and compute the approximation, using the composite trapezoidal and composite
Simpson's rule.

Composite rules and roundoff error

As we increase n in the composite rules to lower error, the number of function evaluations increases,
and a natural question to ask would be whether roundoff error could accumulate and cause problems.
Somewhat remarkably, the answer is no. Let's assume the roundoff error associated with computing
f (x) is bounded for all x, by some positive constant . And let's try to compute the roundoff error
in composite Simpson rule. Since each function evaluation in the composite rule incorporates an
error of (at most) , the total error is bounded by

2  n -1            

         n/2
h  + 2 + 4 +   h + 2 n - 1 + 4 n + = h (3n ) = hn .
3 j=1 j=1            3  2           2  3
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION  131

However, since h = (b - a)/n, the bound simplifies as hn = (b - a) . Therefore no matter how large
n is, that is, how large the number of function evaluations is, the roundoff error is bounded by the
same constant (b - a) which only depends on the size of the interval.

    Exercise 4.2-4: (This problem shows that numerical quadrature is stable with respect to

error in function values.) Assume the function values f (xi) are approximated by f~(xi), so that
|f (xi) - f~(xi)| < for any xi  (a, b). Find an upper bound on the error of numerical quadrature

   wif (xi) when it is actually computed as wif~(xi).

4.3 Gaussian quadrature

Newton-Cotes formulas were obtained by integrating interpolating polynomials with equally-spaced
nodes. The equal spacing is convenient in deriving simple expressions for the composite rules.
However, this placement of nodes is not necessarily the optimal placement. For example, the
trapezoidal rule approximates the integral by integrating a linear function that joins the endpoints
of the function. The fact that this is not the optimal choice can be seen by sketching a simple
parabola.

    The idea of Gaussian quadrature is the following: in the numerical quadrature rule

   b                     n

      f (x)dx  wif (xi)

a                        i=1

choose xi and wi in such a way that the quadrature rule has the highest possible accuracy. Note
that unlike Newton-Cotes formulas where we started labeling the nodes with x0, in the Gaussian
quadrature the first node is x1. This difference in notation is common in the literature, and each
choice makes the subsequent equations in the corresponding theory easier to read.

Example 76. Let (a, b) = (-1, 1), and n = 2. Find the "best" xi and wi.

    There are four parameters to determine: x1, x2, w1, w2. We need four constraints. Let's require

the rule to integrate the following functions exactly: f (x) = 1, f (x) = x, f (x) = x2, and f (x) = x3.
    If the rule integrates f (x) = 1 exactly, then -1 1 dx = i=1 2 wi, i.e., w1 + w2 = 2. If the rule

integrates f (x) = x exactly, then -1 1 xdx = i=1 2 wixi, i.e., w1x1 + w2x2 = 0. Continuing this for
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                               132

f (x) = x2, and f (x) = x3, we obtain the following equations:

        w1 + w2 = 2

        w1x1 + w2x2 = 0
        w1x12 + w2x22 = 2

                             3
        w1x31 + w2x32 = 0.

                                
Solving the equations gives: w1 = w2 = 1, x1 = - 3 3 , x2 = 33 . Therefore the quadrature rule is:

1 -3 3
    f (x)dx  f         +f                                             .
                3                                                  3
-1

Observe that:

    · The two nodes are not equally spaced on (-1, 1).

    · The accuracy of the rule is three, and it uses only two nodes. Recall that the accuracy of
        Simpson's rule is also three but it uses three nodes. In general Gaussian quadrature gives a
        degree of accuracy of 2n - 1 using only n nodes.

    We were able to solve for the nodes and weights in the simple example above, however, as
the number of nodes increases, the resulting non-linear system of equations will be very diffi-
cult to solve. There is an alternative approach using the theory of orthogonal polynomials, a
topic we will discuss in detail later. Here, we will use a particular set of orthogonal polynomials
{L0(x), L1(x), ..., Ln(x), ...} called Legendre polynomials. We will give a definition of these poly-
nomials in the next chapter. For this discussion, we just need the following properties of these
polynomials:

    · Ln(x) is a monic polynomial of degree n for each n.

    · -1 1 P (x)Ln(x)dx = 0 for any polynomial P (x) of degree less than n.
The first few Legendre polynomials are

L0(x) = 1, L1(x) = x, L2(x) = x2 - 1 , L3(x) = x3 - 3 x, L4(x) = x4 - 6 x2 + 3 .
        3                                                       5        7 35

How do these polynomials help with finding the nodes and the weights of the Gaussian quadrature
rule? The answer is short: the roots of the Legendre polynomials are the nodes of the quadrature
rule!

    To summarize, the Gauss-Legendre quadrature rule for the integral of f over (-1, 1) is

    1              n

        f (x)dx = wif (xi)

    -1            i=1
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                               133

where x1, x2, ..., xn are the roots of the nth Legendre polynomial, and the weights are computed
using the following theorem.

Theorem 77. Suppose that x1, x2, ..., xn are the roots of the nth Legendre polynomial Ln(x) and

the weights are given by                1 n x - xj
                                                             dx.
                                 wi =
                                       -1 j=1,j=i xi - xj

Then the Gauss-Legendre quadrature rule has degree of accuracy 2n - 1. In other words, if P (x) is
any polynomial of degree less than or equal to 2n - 1, then

                                 1               n

                                     P (x)dx = wiP (xi).

                                 -1              i=1

Proof. Let's start with a polynomial P (x) with degree less than n. Construct the Lagrange inter-
polant for P (x), using the nodes as x1, ..., xn

                            n n n x - xj
                          P (x) = P (xi)li(x) =               xi - xj P (xi).

                            i=1                  i=1 j=1,j=i

There is no error term above because the error term depends on the nth derivative of P (x), but
P (x) is a polynomial of degree less than n, so that derivative is zero. Integrate both sides to get

                                                                                             

 1            1 n n x - xj                                    1n               n x - xj       dx
                                       P (xi) dx =             P (xi)
   P (x)dx =  -1 i=1 j=1,j=i xi - xj                                        j=1,j=i xi - xj
                                                      -1 i=1
-1

                                                                                               

                                                      n           1            n x - xj

                                                      =  P (xi)             j=1,j=i xi - xj  dx

                                                      i=1 -1
                                                                               

                                                      n 1 n x - xj
                                                      =                        dx P (xi)
                                                      i=1 -1 j=1,j=i xi - xj

                                                      n

                                                      = wiP (xi).

                                                      i=1

Therefore the theorem is correct for polynomials of degree less than n. Now let P (x) be a polynomial
of degree greater than or equal to n, but less than or equal to 2n - 1. Divide P (x) by the Legendre
polynomial Ln(x) to get

                                               P (x) = Q(x)Ln(x) + R(x).

Note that

                            P (xi) = Q(xi)Ln(xi) + R(xi) = R(xi)

since Ln(xi) = 0 , for i = 1, 2, ..., n. Also observe the following facts:
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                          134

1. -1 1 Q(x)Ln(x)dx = 0, since Q(x) is a polynomial of degree less than n, and from the second
   property of Legendre polynomials.

2. -1 1 R(x)dx = i=1 n wiR(xi), since R(x) is a polynomial of degree less than n, and from the
   first part of the proof.

Putting these facts together we get:

 1             1                            1        n             n

   P (x)dx =     [Q(x)Ln(x) + R(x)] dx =       R(x)dx = wiR(xi) = wiP (xi).

-1            -1                           -1        i=1           i=1

    Table 4.1 displays the roots of the Legendre polynomials L2, L3, L4, L5 and the corresponding
weights.

              n              Roots                   Weights

              2  1        =  0.5773502692            1
                   3

                 - 1      =  -0.5773502692           1

                       3

              3  -( 35 )1/2 = -0.7745966692    5  =  0.5555555556
                                               9

                             0.0               8  =  0.8888888889
                                               9

                 ( 35 )1/2 = 0.7745966692      5  =  0.5555555556
                                               9

              4           0.8611363116            0.3478548451

                          0.3399810436            0.6521451549

                          -0.3399810436           0.6521451549

                          -0.8611363116           0.3478548451

              5           0.9061798459            0.2369268850

                          0.5384693101            0.4786286705

                             0.0                  0.5688888889

                          -0.5384693101           0.4786286705

                          -0.9061798459           0.2369268850

Table 4.1: Roots of Legendre polynomials L2 through L5
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                                         135

Example 78. Approximate -1 1 cos xdx using Gauss-Legendre quadrature with n = 3 nodes.
Solution. From Table 4.1, and using two-digit rounding, we have

                   1

                     cos xdx  0.56 cos(-0.77) + 0.89 cos 0 + 0.56 cos(0.77) = 1.69

                  -1

and the true solution is sin(1) - sin(-1) = 1.68.

    So far we discussed integrating functions over the interval (-1, 1). What if we have a different
integration domain? The answer is simple: change of variables! To compute ab f (x)dx for any
a < b, we use the following change of variables:

                                t=   2x - a - b                1
                                                    x = [(b - a)t + a + b]
                                       b-a                     2

With this substitution, we have

                             b              b-a 1         1
                                                            [(b - a)t + a + b] dt.
                                f (x)dx =     2 -1     f
                                                          2
                        a

Now we can approximate the integral on the right-hand side as before.

Example 79. Approximate         1    xxdx   using   Gauss-Legendre        quadrature           with  n     =  2  nodes.
                                0.5

Solution.    Transform  the  integral  using  x  =  1  (0.5t + 1.5)    =  21 ( 2t  +  32 )  =  t+3 4 , dx  =  dt  to  get:
                                                    2                                                         4

                                       1 xxdx = 1 1               t+3  t+3
                                                    4 -1            4    4

                                                                           dt.

                                       0.5

For n = 2    t+3                         13         41 3 + 34             13                           
               4                        +                         + - +
       11         t+3                  43 4                            43 4                 - 41 3 + 34
       4 -1
                   dt  4 1                                                                              = 0.410759,
                             4

using six significant digits. We will next use Python for a five-node computation of the integral.

Python code for Gauss-Legendre rule with five nodes

The following code computes the Gauss-Legendre rule for -1 1 f (x)dx using n = 5 nodes. The nodes
and weights are from Table 4.1.

In [1]: def gauss(f):
                  return 0.2369268851*f(-0.9061798459) + 0.2369268851*f(0.9061798459) + \
                             0.5688888889*f(0) + 0.4786286705*f(0.5384693101) + \
                             0.4786286705*f(-0.5384693101)
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                        136

    Now we compute 4 -1 4 1 1 t+3 dt t+43 using the code:
In [2]: 0.25*gauss(lambda t: (t/4+3/4)**(t/4+3/4))

Out[2]: 0.41081564812239885

    The next theorem is about the error of the Gauss-Legendre rule. Its proof can be found in
Atkinson [3]. The theorem shows, in particular, that the degree of accuracy of the quadrature rule,
using n nodes, is 2n - 1.

Theorem 80. Let f  C2n[-1, 1]. The error of Gauss-Legendre rule satisfies

                     b       n              22n+1(n!)4 f (2n)()

                     a i=1 f (x)dx - wif (xi) = (2n + 1) [(2n)!]2 (2n)!

for some   (-1, 1).

    Using Stirling's formula n!  e-nnn(2n)1/2, where the symbol  means the ratio of the two
sides converges to 1 as n  , it can be shown that

                                22n+1(n!)4  
                             (2n + 1) [(2n)!]2  4n .

This means the error of Gauss-Legendre rule decays at an exponential rate of 1/4n as opposed to,
for example, the polynomial rate of 1/n4 for composite Simpson's rule.

    Exercise 4.3-1: Prove that the sum of the weights in Gauss-Legendre quadrature is 2, for

any n.

    Exercise 4.3-2: Approximate 11.5 x2 log xdx using Gauss-Legendre rule with n = 2 and

n = 3. Compare the approximations to the exact value of the integral.

    Exercise 4.3-3: A composite Gauss-Legendre rule can be obtained similar to compos-

ite Newton-Cotes formulas. Consider 20 exdx. Divide the interval (0, 2) into two subintervals
(0, 1), (1, 2) and apply the Gauss-Legendre rule with two-nodes to each subinterval. Compare the
estimate with the estimate obtained from the Gauss-Legendre rule with four-nodes applied to the
whole interval (0, 2).
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                         137

4.4 Multiple integrals

The numerical quadrature methods we have discussed can be generalized to higher dimensional
integrals. We will consider the two-dimensional integral

                                                              f (x, y)dA.

                                                                                 R

The domain R determines the difficulty in generalizing the one-dimensional formulas we learned
before. The simplest case would be a rectangular domain R = {(x, y)|a  x  b, c  y  d}. We
can then write the double integral as the iterated integral

                                                  b        d

         f (x, y)dA =                                        f (x, y)dy dx.

      R                                        a          c

Consider a numerical quadrature rule

                                         b           n

                                            f (x)dx  wif (xi).

                                      a              i=1

Apply the rule using n2 nodes to the inner integral to get the approximation

                                                          
                                         b n2
                                             wjf (x, yj) dx

                                      a j=1

where the yj's are the nodes. Rewrite, by interchanging the integral and summation, to get

                                       n2       b

                                          wj     f (x, yj)dx

                                      j=1      a

and apply the quadrature rule again, using n1 nodes, to get the approximation

                                      n2      n1

                                         wj       wif (xi, yj) .

                                     j=1      i=1

This gives the two-dimensional rule

   b     d                                           n2 n1

            f (x, y)dy dx                                     wiwjf (xi, yj).

a     c                                              j=1 i=1

For simplicity, we ignored the error term in the above derivation; however, its inclusion is straight-
forward.
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                           138

For an example, let's derive the two-dimensional Gauss-Legendre rule for the integral

                                            11                                                (4.5)

                                                   f (x, y)dydx

                                           00

using two nodes for each axis. Note that each integral has to be transformed to (-1, 1). Start with
the inner integral 01 f (x, y)dy and use

                                           t = 2y - 1, dt = 2dy

to transform it to                         11          t+1

                                           2 -1  f x,  2    dt

and apply Gauss-Legendre rule with two nodes to get the approximation

                                                                  
                        1               -1/ 3 + 1              1/ 3 + 1
                             f x,                  + f x,                      .
                        2                  2                        2

Substitute this approximation in (4.5) for the inner integral to get

                        1 1 -1/3 + 1                   + f x,                    dx.
                               f x,                            1/ 3 + 1

                        02                 2                          2

Now transform this integral to the domain (-1, 1) using

                                           s = 2x - 1, ds = 2dx

to get                                                                 
                               s + 1 -1/ 3 + 1              s + 1 1/ 3 + 1
                    11  f            ,                 +f          ,                  ds.

                    40            2        2                   2         2

Apply the Gauss-Legendre rule again to get

                                                                               
        1 -1/ 3 + 1 -1/ 3 + 1                               -1/ 3 + 1 1/ 3 + 1
                    f                ,                 +f                   ,
        4                   2              2                      2               2

                                                                               
                        1/ 3 + 1 -1/ 3 + 1                  1/ 3 + 1 1/ 3 + 1
                    +f                  ,              +f                ,                 .  (4.6)
                               2              2                   2            2

Figure (4.1) displays the nodes used in this calculation.
    Next we derive the two-dimensional Simpson's rule for the same integral, 0 0 1 1 f (x, y)dydx,

using n = 2, which corresponds to three nodes in the Simpson's rule (recall that n is the number of

nodes in Gauss-Legendre rule, but n + 1 is the number of nodes in Newton-Cotes formulas).
1 ,- 1
CHAPTER 4(. N3 UME3 )RICAL QUADRATURE AND DIFFERENTIATION
                                                                                           139

                -1, 1                           1     1, 1
              ( 3 3)                               ( 3 3)

                      -1                           1

              - 1 ,- 1                          -1 1 , - 1
                                                   (3           3)
              (3                       3)

Figure 4.1: Nodes of double Gauss-Legendre rule

The inner integral is approximated as

           1          1

              f (x, y)dy  (f (x, 0) + 4f (x, 0.5) + f (x, 1)) .
                      6
        0

Substitute this approximation for the inner integral in 0 0 1 1 f (x, y)dy dx to get

                                       11
                                              (f (x, 0) + 4f (x, 0.5) + f (x, 1)) dx.

                                       60
Apply Simpson's rule again to this integral with n = 2 to obtain the final approximation:

11
        f (0, 0) + 4f (0, 0.5) + f (0, 1) + 4(f (0.5, 0) + 4f (0.5, 0.5) + f (0.5, 1))

66

+ f (1, 0) + 4f (1, 0.5) + f (1, 1) .                                                      (4.7)

Figure (4.2) displays the nodes used in the above calculation.

              1
              0.5

                   0                       0.5     1

        Figure 4.2: Nodes of double Simpson's rule
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                  140

For a specific example, consider the integral

                             1 1                     
                                        sin x          sin y dydx.

                            00 2                     2

This integral can be evaluated exactly, and its value is 1. It is used as a test integral for numerical

quadrature rules. Evaluating equations (4.6) and (4.7) with f (x, y) =     sin  x         sin  y  ,  we
                                                                        2              2

obtain the approximations given in the table below:

Simpson's rule (9 nodes)           Gauss-Legendre (4 nodes)         Exact integral
            1.0966                             0.93685                      1

The Gauss-Legendre rule gives a slightly better estimate than Simpson's rule, but using less than
half the number of nodes.

    The approach we have discussed can be extended to regions that are not rectangular, and to
higher dimensions. More details, including algorithms for double and triple integrals using Simpson's
and Gauss-Legendre rule, can be found in Burden, Faires, Burden [4].

    There is however, an obvious disadvantage of the way we have generalized one-dimensional
quadrature rules to higher dimensions. Imagine a numerical integration problem where the dimen-
sion is 360; such high dimensions appear in some problems from financial engineering. Even if we
used two nodes for each dimension, the total number of nodes would be 2360, which is about 10100,
a number too large. In very large dimensions, the only general method for numerical integration is
the Monte Carlo method. In Monte Carlo, we generate pseudorandom numbers from the domain,
and evaluate the function average at those points. In other words,

                                   f (x)dx     1n    f (xi)

                            R n i=1

where xi are pseudorandom vectors uniformly distributed in R. For the two-dimensional integral
we discussed before, the Monte Carlo estimate is

bd                          (b - a)(d - c) n                                                      (4.8)

    f (x, y)dydx                   n i=1             f (a + (b - a)xi, c + (d - c)yi)

ac

where xi, yi are pseudorandom numbers from (0, 1). In Python, the function np.random.rand()
generates a pseudorandom number from the uniform distribution between 0 and 1. The following
code takes the endpoints of the intervals a, b, c, d, and the number of nodes n, which is called the
sample size in the Monte Carlo literature, and returns the estimate for the integral using Equation
(4.8).

In [1]: import numpy as np

In [2]: def mc(f, a, b, c, d, n):
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                                   141

             sum = 0.
             for i in range(n):

                   sum += f(a+(b-a)*np.random.rand(),
                                 c+(d-c)*np.random.rand())*(b-a)*(d-c)

             return sum/n

Now we use Monte Carlo to estimate the integral                             1  1         sin  x     sin    y  dydx:
                                                                            0  0  2              2

In [2]: mc((x,y)->(pi^2/4)*sin(pi*x)*sin(pi*y),0,1,0,1,500)

Out[2]: 0.9441778334708931

    With n = 500, we obtain a Monte Carlo estimate of 0.944178. An advantage of the Monte
Carlo method is its simplicity: the above code can be easily generalized to higher dimensions. A
disadvantage of Monte Carlo is its slow rate of convergence, which is O(1/n). Figure (4.3) displays
500 pseudorandom vectors from the unit square.

                               Figure 4.3: Monte Carlo: 500 pseudorandom vectors

Example 81. Capstick & Keister [5] discuss some high dimensional test integrals, some with ana-

lytical solutions, motivated by physical applications such as the calculation of quantum mechanical

matrix elements in atomic, nuclear, and particle physics. One of the integrals with a known solution

is
                                                 cos( t ))e- t 2dt1dt2 · · · dts

                                                               Rs

where  t  =  (t21  +  .  .  .  +  t  2  )  1/2  .  This  integral  can  be  transformed  to  an  integral  over  the  s-dimensional
                                     s
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                               142

unit cube as

              s/2          cos  (F -1(x1))2 + . . . + (F -1(xs))2 1/2             (4.9)
                                                   2 dx1dx2 · · · dxs
                   (0,1)s

where F -1 is the inverse of the cumulative distribution function of the standard normal distribution:

                                              1   x
                                F (x) = (2)1/2           -s2/2

                                                     e ds.

                                                 -

We will estimate the integral (4.9) by Monte Carlo as

                                    (F -1(x1(i)))2 + . . . + (F -1(xs(i)))2  1/2
                   s/2 n cos                            2                       

                    n

                           i=1

where x(i) = (x1(i), . . . , xs(i)) is an s-dimensional vector of uniform random numbers between 0 and
1.

In [1]: import numpy as np

In [2]: import matplotlib.pyplot as plt
            %matplotlib inline

    The following algorithm, known as the Beasley-Springer-Moro algorithm [8], gives an approxi-
mation to F -1(x).

In [3]: def invNormal(u):
                  # Beasley-Springer-Moro algorithm
                  a0 = 2.50662823884
                  a1 = -18.61500062529
                  a2 = 41.39119773534
                  a3 = -25.44106049637
                  b0 = -8.47351093090
                  b1 = 23.08336743743
                  b2 = -21.06224101826
                  b3 = 3.13082909833
                  c0 = 0.3374754822726147
                  c1 = 0.9761690190917186
                  c2 = 0.1607979714918209
                  c3 = 0.0276438810333863
                  c4 = 0.0038405729373609
                  c5 = 0.0003951896511919
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION  143

c6 = 0.0000321767881768
c7 = 0.0000002888167364
c8 = 0.0000003960315187

                  y = u-0.5
                  if np.abs(y)<0.42:

                         r = y*y
                         x = y*(((a3*r+a2)*r+a1)*r+a0)/((((b3*r+b2)*r+b1)*r+b0)*r+1)
                  else:
                         r=u
                         if y>0:

                               r = 1-u
                         r = np.log(-np.log(r))
                         x = c0+r*(c1+r*(c2+r*(c3+r*(c4+r*(c5+r*(c6+r*(c7+r*c8)))))))
                         if y<0:

                               x = -x
                  return x

    The following is the Monte Carlo estimate of the integral. It takes the dimension s and the
sample size n as inputs.

In [4]: def mc(s, n):
                  est = 0
                  for j in range(n):
                         sum = 0
                         for i in range(s):
                               sum += (invNormal(np.random.rand()))**2
                         est += np.cos((sum/2)**0.5)
                  return np.pi**(s/2)*est/n

    The exact value of the integral for s = 25 is 1.356914 × 106. The following code computes the
relative error of the Monte Carlo estimate with sample size n.

In [5]: relerror = lambda n: np.abs(mc(25,n)+1.356914*10**6)/(1.356914*10**6)

    Let's plot the relative error of some Monte Carlo estimates. First, we generate sample sizes from
50,000 to 1,000,000 in increments of 50,000.

In [6]: samples = [n for n in range(50000,1000001, 50000)]

    For each sample size, we compute the relative error, and then plot the results.
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION            144

In [7]: error = [relerror(n) for n in samples]

In [8]: plt.plot(samples, error)
            plt.xlabel('Sample size (n)')
            plt.ylabel('Relative error');

Figure 4.4: Monte Carlo relative error for the integral (4.9)

4.5 Improper integrals

The quadrature rules we have learned so far cannot be applied (or applied with a poor performance)

to integrals such as ab f (x)dx if a, b = ± or if a, b are finite but f is not continuous at one or

both of the endpoints: recall that both Newton-Cotes and Gauss-Legendre error bound theorems

require the integrand to have a number of continuous derivatives on the closed interval [a, b]. For

example, an integral in the form  1 f (x)

                                             dx
                                  -1 1 - x2

clearly cannot be approximated using the trapezoidal or Simpson's rule without any modifications,
since both rules require the values of the integrand at the end points which do not exist. One could
try using the Gauss-Legendre rule, but the fact that the integrand does not satisfy the smoothness
conditions required by the Gauss-Legendre error bound means the error of the approximation might
be large.

    A simple remedy to the problem of improper integrals is to change the variable of integration
and transform the integral, if possible, to one that behaves well.

Example 82. Consider the previous integral -11 f(x) 1-x2 dx. Try the transformation  = cos-1 x.
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                    145

Then d = -dx/1 - x2 and

1 f (x)                                      0                

                                dx = - f (cos )d = f (cos )d.
-1 1 - x2
                                                           0

The latter integral can be evaluated using, for example, Simpson's rule, provided f is smooth on
[0, ].

    If the interval of integration is infinite, another approach that might work is truncation of the
interval to a finite one. The success of this approach depends on whether we can estimate the
resulting error.

Example 83. Consider the improper integral 0 e-x2dx. Write the integral as

                                  e-x2 dx =   t e-x2 dx +    e-x2 dx,

                                0            0             t

where t is the "level of truncation" to determine. We can estimate the first integral on the right-

hand side using a quadrature rule. The second integral on the right-hand side is the error due to
approximating 0 e-x2dx by 0t e-x2dx. An upper bound for the error can be found easily for this
example: note that when x  t, x2 = xx  tx, thus

                                  e-x2 dx         e-txdx = e-t2 /t.

                                t               t

When t = 5, e-t2/t  10-12, therefore, approximating the integral 0 e-x2dx by 05 e-x2dx will be
accurate within 10-12. Additional error will come from estimating the latter integral by numerical

quadrature.

4.6 Numerical differentiation

The derivative of f at x0 is

                                f (x0) = lim f (x0 + h) - f (x0) .
                                h0              h

This formula gives an obvious way to estimate the derivative by

                                              f (x0)  f (x0 + h) - f (x0)
                                                                      h

for small h. What this formula lacks, however, is it does not give any information about the error
of the approximation.

    We will try another approach. Similar to Newton-Cotes quadrature, we will construct the
interpolating polynomial for f , and then use the derivative of the polynomial as an approximation
for the derivative of f .
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                          146

    Let's assume f  C2(a, b), x0  (a, b), and x0 + h  (a, b). Construct the linear Lagrange
interpolating polynomial p1(x) for the data (x0, f (x0)), (x1, f (x1)) = (x0 + h, f (x0 + h)). From
Theorem 51, we have

f (x) = x - x1 f (x0) + x - x0 f (x1) + f ((x)) (x - x0)(x - x1)
             x0 - x1             x1 - x0                2!

                      p1(x)                                 interpolation error

             = x - (x0 + h) f (x0) + x - x0 f (x0 + h) + f ((x)) (x - x0)(x - x0 - h)
             x0 - (x0 + h)          x0 + h - x0                     2!

             = x - x0 - h f (x0) + x - x0 f (x0 + h) + f ((x)) (x - x0)(x - x0 - h).
             -h                     h                       2!

Now let's differentiate f (x) :

f (x) = - f (x0) + f (x0 + h) + f ((x)) d (x - x0)(x - x0 - h)
             h                   h                  dx          2

                                    + (x - x0)(x - x0 - h) d f ((x))
                                                    2           dx

= f (x0 + h) - f (x0) + 2x - 2x0 - h f ((x)) + (x - x0)(x - x0 - h) f            ((x)) (x).
             h                      2                               2

In the above equation, we know  is between x0 and x0 + h; however, we have no knowledge about

 (x), which appears in the last term. Fortunately, if we set x = x0, the term with  (x) vanishes

and we get:

                      f (x0) = f (x0 + h) - f (x0) - h f ((x0)).
                                             h              2

This formula is called the forward-difference formula if h > 0 and backward-difference formula

if h < 0. Note that from this formula we can obtain a bound on the error

                      f (x0) - f (x0 + h) - f (x0)  h sup f (x).
                                          h                 2 x(x0,x0+h)

    To obtain the forward-difference and backward-difference formulas we started with a linear
polynomial interpolant on two points. Using more points and a higher order interpolant gives more
accuracy, but also increases the computing time and roundoff error. In general, let f  Cn+1[a, b]
and x0, x1, ..., xn are distinct numbers in [a, b]. We have

                        n (x - x0)(x - x1) · · · (x - xn)
             f (x) = f (xk)lk(x) + f (n+1)()

                                                                       (n + 1)!

                          k=0

                             nd                             (x - x0)(x - x1) · · · (x - xn)
              f (x) = f (xk)lk(x) + f (n+1)() dx                         (n + 1)!

                                 k=0

                      + (x - x0)(x - x1) · · · (x - xn) d (f (n+1)()).
                                          (n + 1)!          dx
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                                         147

If x = xj for j = 0, 1, ..., n, the last term vanishes, and using the following result

                           dn
                       dx [(x - x0)(x - x1) · · · (x - xn)]x=xj =              (xj - xk)

                                                                      k=0,k=j

we obtain                           n                     f (n+1)((xj )) n

                       f (xj) = f (xk)lk(xj) + (n + 1)!                        (xj - xk)                    (4.10)

                                    k=0                               k=0,k=j

which is called the (n + 1)-point formula to approximate f (xj). The most common formulas use
n = 2 and n = 4. Here we discuss n = 2, that is, three-point formulas. The nodes are, x0, x1, x2.
The Lagrange basis polynomials and their derivatives are:

                       l0(x) = (x - x1)(x - x2)  l0(x) = 2x - x1 - x2
                                    (x0 - x1)(x0 - x2)             (x0 - x1)(x0 - x2)

                       l1(x) = (x - x0)(x - x2)  l1(x) = 2x - x0 - x2
                                    (x1 - x0)(x1 - x2)             (x1 - x0)(x1 - x2)

                       l2(x) = (x - x0)(x - x1)  l2(x) = 2x - x0 - x1
                                    (x2 - x0)(x2 - x1)             (x2 - x0)(x2 - x1)

These derivatives can be substituted in (4.10) to obtain the three-point formula. We can simplify
these formulas if the nodes are spaced equally, that is, x1 = x0 + h, x2 = x1 + h = x0 + 2h. Then,
we obtain

                       f (x 1 h2 0) = [-3f (x0) + 4f (x0 + h) - f (x0 + 2h)] + f (3)(0)                     (4.11)
                                    2h                                              3                       (4.12)
                                                                                                            (4.13)
                   f (x 1 h2 0 + h) = [-f (x0) + f (x0 + 2h)] - f (3)(1)
                                    2h                             6

                   f (x 1 h2 0 + 2h) = [f (x0) - 4f (x0 + h) + 3f (x0 + 2h)] + f (3)(2).
                                    2h                                         3

    It turns out that the first and third equations ((4.11) and (4.13)) are equivalent. To see this,
first substitute x0 by x0 - 2h in the third equation to get (ignoring the error term)

                                            1
                               f (x0) = 2h [f (x0 - 2h) - 4f (x0 - h) + 3f (x0)] ,

and  then  set  h  to  -h  in  the  right-hand  side  to  get  1   [-f (x0 + 2h) + 4f (x0 + h) - 3f (x0)],  which
                                                               2h

gives us the first equation.

     Therefore we have only two distinct equations, (4.11) and (4.12). We rewrite these equations

below with one modification: in (4.12), we substitute x0 by x0 - h. We then obtain two different
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                          148

formulas for f (x0) :

f (x0) = -3f (x0) + 4f (x0 + h) - f (x0 + 2h) + h f (0)  2 (3) three-point endpoint formula
                           2h             3

f (x0) = f (x0 + h) - f (x0 - h) - h f (1)  2 (3) three-point midpoint formula
                       2h              6

The three-point midpoint formula has some advantages: it has half the error of the endpoint formula,
and it has one less function evaluation. The endpoint formula is useful if one does not know the
value of f on one side, a situation that may happen if x0 is close to an endpoint.

Example 84. The following table gives the values of f (x) = sin x. Estimate f (0.1), f (0.3) using
an appropriate three-point formula.

                                                         x f (x)
                                                        0.1 0.09983
                                                        0.2 0.19867
                                                        0.3 0.29552
                                                        0.4 0.38942

Solution. To estimate f (0.1), we set x0 = 0.1, and h = 0.1. Note that we can only use the
three-point endpoint formula.

                                      1
                       f (0.1)  (-3(0.09983) + 4(0.19867) - 0.29552) = 0.99835.

                                     0.2

The correct answer is cos 0.1 = 0.995004.
    To estimate f (0.3) we can use the midpoint formula:

                                                  1
                                   f (0.3)  (0.38942 - 0.19867) = 0.95375.

                                                0.2

The correct answer is cos 0.3 = 0.955336 and thus the absolute error is 1.59 × 10-3. If we use the
endpoint formula to estimate f (0.3) we set h = -0.1 and compute

f (0.3)                    1     (-3(0.29552) + 4(0.19867) - 0.09983) = 0.95855

                           -0.2

with an absolute error of 3.2 × 10-3.

    Exercise 4.6-1: In some applications, we want to estimate the derivative of an unknown

function from empirical data. However, empirical data usually come with "noise", that is, error
due to data collection, data reporting, or some other reason. In this exercise we will investigate
how stable the difference formulas are when there is noise in the data. Consider the following
data obtained from y = ex. The data is exact to six digits. We estimate f (1.01) using the
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                            149

                                  x 1.00 1.01 1.02
                                f (x) 2.71828 2.74560 2.77319

three-point  midpoint  formula  and  obtain  f (1.01)     =  2.77319-2.71828  =   2.7455.  The true value is
                                                                     0.02

f (1.01) = e1.01 = 2.74560, and the relative error due to rounding is 3.6 × 10-5.

Next, we add some noise to the data: we increase 2.77319 by 10% to 3.050509, and decrease

2.71828 by 10% to 2.446452. Here is the noisy data:

                                x    1.00                 1.01      1.02

                       f (x) 2.446452 2.74560 3.050509

    Estimate f (1.01) using the noisy data, and compute its relative error. How does the relative
error compare with the relative error for the non-noisy data?

    We next want to explore how to estimate the second derivative of f. A similar approach to
estimating f can be taken and the second derivative of the interpolating polynomial can be used
as an approximation. Here we will discuss another approach, using Taylor expansions. Expand f
about x0, and evaluate it at x0 + h and x0 - h:

                                                      h2  (x0) + h f 3 (3)(x0) + h f 4 (4)(+)
             f (x0 + h) = f (x0) + hf (x0) + 2 f                6                 24

                                                      h2  (x0) - h f 3 (3)(x0) + h f 4 (4)(-)
             f (x0 - h) = f (x0) - hf (x0) + 2 f                6                 24

where + is between x0 and x0 + h, and - is between x0 and x0 - h. Add the equations to get

                 f (x0 + h) + f (x0 - h) = 2f (x0) + h2f (x h4 0) + f (4)(+) + f (4)(-) .
                                                                               24

Solving for f (x0) gives

             f (x0) =  f (x0 + h) - 2f (x0) + f (x0 - h) h2 (4)                       (4)
                                                                - f (+) + f (-) .
                                     h2                         24

Note that 2 f(4)(+)+f(4)(-) is a number between f (4)(+) and f (4)(-), so from the Intermediate
Value Theorem 6, we can conclude there exists some  between - and + so that

                                             f (4)() = f (4)(+) + f (4)(-) .
                                                                      2

Then the above formula simplifies as

                       f (x0) =    f (x0 + h) - 2f (x0) + f (x0 - h) h2 (4)
                                                                              - f ()
                                             h2                               12
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION    150

for some  between x0 - h and x0 + h.

Numerical differentiation and roundoff error

Arya and the mysterious black box

    College life is full of mysteries, and Arya faces
one in an engineering class: a black box! What is
a black box? It is a computer program, or some
device, which produces an output when an input
is provided. We do not know the inner workings
of the system, and hence comes the name black
box. Let's think of the black box as a function
f , and represent the input and output as x, f (x).
Of course, we do not have a formula for f .

    What Arya's engineering classmates want to do is compute the derivative information of the
black box, that is, f (x), when x = 2. (The input to this black box can be any real number.)
Students want to use the three-point midpoint formula to estimate f (2):

                                                      1
                                           f (2)  [f (2 + h) - f (2 - h)] .

                                                     2h

They argue how to pick h in this formula. One of them says they should make h as small as possible,
like 10-8. Arya is skeptical. She mutters to herself, "I know I slept through some of my numerical
analysis lectures, but not all!"

    She tells her classmates about the cancellation of leading digits phenomenon, and to make her
point more convincing, she makes the following experiment: let f (x) = ex, and suppose we want
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                                  151

to compute f (2) which is e2. Arya uses the three-point midpoint formula above to estimate f (2),
for various values of h, and for each case she computes the absolute value of the difference between
the three-point midpoint estimate and the exact solution e2. She tabulates her results in the table
below. Clearly, smaller h does not result in smaller error. In this experiment, h = 10-6 gives the
smallest error.

      h                10-4  10-5                           10-6     10-7    10-8

      Abs. error 1.2 × 10-8 1.9 × 10-10 5.2 × 10-11 7.5 × 10-9 2.1 × 10-8

Theoretical analysis

Numerical differentiation is a numerically unstable problem. To reduce the truncation error, we need
to decrease h, which in turn increases the roundoff error due to cancellation of significant digits in
the function difference calculation. Let e(x) denote the roundoff error in computing f (x) so that
f (x) = f~(x) + e(x), where f~ is the value computed by the computer. Consider the three-point
midpoint formula:

                             f~(x0 + h) - f~(x0 - h)
                 f (x0) - 2h

                 = f (x0) - f (x0 + h) - e(x0 + h) - f (x0 - h) + e(x0 - h)
                                                              2h

                 = f (x0) - f (x0 + h) - f (x0 - h) + e(x0 - h) - e(x0 + h)
                             2h                                      2h

                 = - h2 f (3)() + e(x0 - h) - e(x0 + h)  h2 M +
                       6                        2h                6      h

where we assumed |f (3)()|  M and |e(x)|  . To reduce the truncation error h2M/6 one would

decrease h, which would then result in an increase in the roundoff error /h. An optimal value

for h can be found with these assumptions using Calculus: find the value for h that minimizes the

function s(h) =  M h2  + h . The answer is h =  3  3  /M .
                   6

Let's revisit the table Arya presented where 10-6 was found to be the optimal value for h. The

calculations were done using Python, which reports 15 digits when asked for e2. Let's assume all

these digits are correct, and thus let = 10-16. Since f (3)(x) = ex and e2  7.4, let's take M = 7.4.

Then

                          h = 3 3 /M = 3 3 × 10-16/7.4  3.4 × 10-6

which is in good agreement with the optimal value 10-6 of Arya's numerical results.
CHAPTER 4. NUMERICAL QUADRATURE AND DIFFERENTIATION                               152

Exercise 4.6-2: Find the optimal value for h that will minimize the error for the formula

                          f (x0) = f (x0 + h) - f (x0) - h f ()
                                   h                         2

in the presence of roundoff error, using the approach of Section 4.6.

a) Consider estimating f (1) where f (x) = x2 using the above formula. What is the optimal
    value for h for estimating f (1), assuming that the roundoff error is bounded by = 10-16
    (which is the machine epsilon 2-53 in the 64-bit floating point representation).

b) Use Python to compute           f (1 + 10-n) - f (1)

                          fn(1) =                      10-n     ,

for n = 1, 2, ..., 20, and describe what happens.

c) Discuss your findings in parts (a) and (b) and how they relate to each other.

    Exercise 4.6-3: The function 0x 12 e-t2/2dt is related to the distribution function of the

standard normal random variable, a very important distribution in probability and statistics. Often
times we want to solve equations like

                           x 1 -t2/2                                              (4.14)
                              e dt = z

                          0 2

for x, where z is some real number between 0 and 1. This can be done by using Newton's method
to solve the equation f (x) = 0 where

                                      x 1 -t2/2
                          f (x) =  e dt - z.

                                     0 2

Note that from Fundamental Theorem of Calculus, f (x) = 12 e-x2/2. Newton's method will require
the calculation of
                          pk 1 -t2/2
                           e dt                                                   (4.15)
                          0 2

where pk is a Newton iterate. This integral can be computed using numerical quadrature. Write

a Python code that takes z as its input, and outputs x, such that Equation (4.14) holds. In your

code, use the Python codes for Newton's method and the composite Simpson's rule you were given

in class. For Newton's method set tolerance to 10-5 and p0 = 0.5, and for composite Simpson's rule

take n = 10, when computing the integrals (4.15) that appear in Newton iteration. Then run your

code for z = 0.4 and z = 0.1, and report your output.
Chapter 5
Approximation Theory

5.1 Discrete least squares

Arya's adventures in the physics lab

College life is expensive, and Arya is happy to land a job working at a physics lab for some extra
cash. She does some experiments, some data analysis, and a little grading. In one experiment she
conducted, where there is one independent variable x, and one dependent variable y, she was asked
to plot y against x values. (There are a total of six data points.) She gets the following plot:

                                      Figure 5.1: Scatter plot of data

    Arya's professor thinks the relationship between the variables should be linear, but we do not see
data falling on a perfect line because of measurement error. The professor is not happy, professors
are usually not happy when lab results act up, and asks Arya to come up with a linear formula,

                                                         153
CHAPTER 5. APPROXIMATION THEORY  154

something like y = ax + b, to explain the relationship. Arya first thinks about interpolation, but
quickly realizes it is not a good idea. (Why?). Let's help Arya with her problem.

Analysis of the problem

Let's try passing a line through the data points. Figure (5.2) plots one such line, y = 3x - 0.5,
together with the data points.

                              Figure 5.2: Data with an approximating line

    There are certainly many other choices we have for the line: we could increase or decrease the
slope a little, change the intercept a bit, and obtain multiple lines that have a visually good fit to
the data. The crucial question is, how can we decide which line is the "best" line, among all the
possible lines? If we can quantify how good the fit of a given line is to the data, and come up with
a notion for error, perhaps then we can find the line that minimizes this error.

    Let's generalize the problem a little. We have:

    · Data: (x1, y1), (x2, y2), ..., (xm, ym)

and we want to find a line that gives the "best" approximation to the data:

    · Linear approximation: y = f (x) = ax + b

The questions we want to answer are:

    1. What does "best" approximation mean?

    2. How do we find a, b that gives the line with the "best" approximation?
CHAPTER 5. APPROXIMATION THEORY                                                                              155

Observe that for each xi, there is the corresponding yi of the data point, and f (xi) = axi + b,
which is the predicted value by the linear approximation. We can measure error by considering the
deviations between the actual y coordinates and the predicted values:

                          (y1 - ax1 - b), (y2 - ax2 - b), ..., (ym - axm - b)

There are several ways we can form a measure of error using these deviations, and each approach
gives a different line approximating the data. The best approximation means finding a, b that
minimizes the error measured in one of the following ways:

· E = maxi {|yi - axi - b|} ; minimax problem

· E=      m       |yi  -  axi  -  b|;  absolute     deviations
          i=1

    · E = i=1 m (yi - axi - b)2; least squares problem

In this chapter we will discuss the least squares problem, the simplest one among the three options.
We want to minimize m

                                                  E = (yi - axi - b)2

                                                                             i=1

with respect to the parameters a, b. For a minimum to occur, we must have

                                                 E = 0 and E = 0.
                                                 a              b

We have:

                       E m E                                m
                           =                        2
                       a               a (yi - axi - b) = (-2xi)(yi - axi - b) = 0
                               i=1                              i=1

                       E m E                                m
                           =                        2
                       b               b (yi - axi - b) = (-2)(yi - axi - b) = 0
                               i=1                              i=1

Using algebra, these equations can be simplified as

                                                 m  m                m

                                       b xi + a xi2 = xiyi

                                       i=1          i=1              i=1

                                                    m                m

                                                    bm + a xi = yi,

                                                    i=1              i=1

which are called the normal equations. The solution to this system of equations is

               m       i=1 m xiyi -    i=1 m xi     i=1 m yi    i=1 m xi2  i=1 m yi - i=1 m xiyi i=1 m xi .
          a=                                          2 ,b =       m       i=1 m xi2 - ( i=1 m xi)2
                             m2              m
                  m i=1 xi - ( i=1 xi)

Let's consider a slightly more general question. Given data
CHAPTER 5. APPROXIMATION THEORY                                                    156

· Data: (x1, y1), (x2, y2), ..., (xm, ym)

can we find the best polynomial approximation

· Polynomial approximation: Pn(x) = anxn + an-1xn-1 + ... + a0

where m will be usually much larger than n. Similar to the above discussion, we want to minimize

                                                                           2

m                                                     m                 n

E = (yi - Pn(xi))2 = yi - ajxji 

i=1                                                   i=1            j=0

with respect to the parameters an, an-1, ..., a0. For a minimum to occur, the necessary conditions

are m n m
E = 0  - yixik + aj
ak i=1 j=0 i=1                                                          xik+j = 0

for k = 0, 1, ..., n. (we are skipping some algebra here!) The normal equations for polynomial
approximation are

      n                                     m               m                      (5.1)

         aj                                    xik+j   = yixki

     j=0                                   i=1             i=1

for k = 0, 1, ..., n. This is a system of (n + 1) equations and (n + 1) unknowns. We can write this
system as a matrix equation

                                               Aa = b                              (5.2)

where a is the unknown vector we are trying to find, and b is the constant vector

                                                           i=1 m yi     

     a0                                                                 
     a1                                                    m    yi  xi  
                                                           i=1          
     a =  . ,b =                                           .
      ..                                                   .. 
                                                                        

                                           an              i=1 m yixin

and A is an (n + 1) by (n + 1) symmetric matrix with (k, j)th entry Akj, k = 1, ..., n + 1, j =
1, 2, ..., n + 1 given by

                                                                                      m

                                                     Akj = xik+j-2.

                                                                                     i=1

The equation Aa = b has a unique solution if the xi are distinct, and n  m-1. Solving this equation
by computing the inverse matrix A-1 is not advisable, since there could be significant roundoff error.
Next, we will write a Python code for least squares approximation, and use the Python function
np.linalg.solve(A, b) to solve the matrix equation Aa = b for a. The np.linalg.solve function in
CHAPTER 5. APPROXIMATION THEORY  157

Python uses numerically optimized matrix factorizations based on the LAPACK routine to solve
the matrix equation. More details on this topic can be found in Heath [10] (Chapter 3).

Python code for least squares approximation

In [1]: import numpy as np
            import matplotlib.pyplot as plt
            %matplotlib inline

    The function leastsqfit takes the x- and y-coordinates of the data, and the degree of the
polynomial we want to use, n, as inputs. It solves the matrix Equation (5.2).

In [2]: def leastsqfit(x, y, n):
                  m = x.size # number of data points
                  d = n+1 # number of coefficients to be determined
                  A = np.zeros((d, d))
                  b = np.zeros(d)
                  # the linear system we want to solve is Ax=b
                  p = np.zeros(2*n+1)
                  for k in range(d):
                         sum = 0
                         for i in range(m):
                               sum += y[i]*x[i]**k
                         b[k] = sum
                  # p[i] below is the sum of the i-th power of the x coordinates
                  p[0] = m
                  for i in range(1, 2*n+1):
                         sum = 0
                         for j in range(m):
                               sum += x[j]**i
                         p[i] = sum
                  # We next compute the upper triangular part of the coefficient
                  # matrix A, and its diagonal
                  for k in range(d):
                         for j in range(k, d):
                               A[k, j] = p[k+j]
                  # The lower triangular part of the matrix is defined using the
                  # fact the matrix is symmetric
                  for i in range(1, d):
                         for j in range(i):
CHAPTER 5. APPROXIMATION THEORY                                               158

            A[i, j] = A[j, i]
a = np.linalg.solve(A, b)
return a

Here is the data used to produce the first plot of the chapter: Arya's data:

In [3]: xd = np.array([1, 2, 3, 4, 5, 6])
            yd = np.array([3, 5, 9.2, 11, 14.5, 19])

We fit a least squares line to the data:

In [4]: leastsqfit(xd, yd, 1)

Out[4]: array([-0.74666667, 3.15142857])

    The polynomial is -0.746667 + 3.15143x. The next function poly(x,a) takes the output of
a = leastsqfit, and evaluates the least squares polynomial at x.

In [5]: def poly(x, a):
                  d = a.size
                  sum = 0
                  for i in range(d):
                         sum += a[i]*x**i
                  return sum

For example, if we want to compute the least squares line at 3.5, we call the following functions:

In [6]: a = leastsqfit(xd, yd, 1)
            poly(3.5, a)

Out[6]: 10.283333333333335

    The next function computes the least squares error: E =  mi=1(yi -pn(xi))2. It takes the output
of a = leastsqfit, and the data, as inputs.

In [7]: def leastsqerror(a, x, y):
                  sum = 0
                  m = y.size
                  for i in range(m):
                         sum += (y[i]-poly(x[i],a))**2
                  return sum

In [8]: a = leastsqfit(xd, yd, 1)
            leastsqerror(a, xd, yd)
CHAPTER 5. APPROXIMATION THEORY                                             159

Out[8]: 2.6070476190476177

    Next we plot the least squares line and the data together.

In [9]: a = leastsqfit(xd, yd, 1)
            xaxis = np.linspace(1, 6, 500)
            yvals = poly(xaxis, a)
            plt.plot(xaxis, yvals)
            plt.plot(xd, yd, 'o');

    We try a second degree polynomial in least squares approximation next.

In [10]: a = leastsqfit(xd, yd, 2)
              xaxis = np.linspace(1, 6, 500)
              yvals = poly(xaxis, a)
              plt.plot(xaxis, yvals)
              plt.plot(xd, yd, 'o');
CHAPTER 5. APPROXIMATION THEORY               160

    The corresponding error is:

In [11]: leastsqerror(a, xd, yd)

Out[11]: 1.4869285714285714

    The next polynomial is of degree three:

In [12]: a = leastsqfit(xd, yd, 3)
              xaxis = np.linspace(1, 6, 500)
              yvals = poly(xaxis, a)
              plt.plot(xaxis, yvals)
              plt.plot(xd, yd, 'o');

    The corresponding error is:

In [13]: leastsqerror(a, xd, yd)

Out[13]: 1.2664285714285732

    The next polynomial is of degree four:

In [14]: a = leastsqfit(xd, yd, 4)
              xaxis = np.linspace(1, 6, 500)
              yvals = poly(xaxis, a)
              plt.plot(xaxis, yvals)
              plt.plot(xd, yd, 'o');
CHAPTER 5. APPROXIMATION THEORY  161

    The least squares error is:

In [15]: leastsqerror(a, xd, yd)

Out[15]: 0.723214285714292

    Finally, we try a fifth degree polynomial. Recall that the normal equations have a unique
solution when xi are distinct, and n  m - 1. Since m = 6 in this example, n = 5 is the largest
degree with guaranteed unique solution.

In [16]: a = leastsqfit(xd, yd, 5)
              xaxis = np.linspace(1, 6, 500)
              yvals = poly(xaxis, a)
              plt.plot(xaxis, yvals)
              plt.plot(xd, yd, 'o');
CHAPTER 5. APPROXIMATION THEORY                                                         162

    The approximating polynomial of degree five is the interpolating polynomial! What is the least
squares error?

Least squares with non-polynomials

The method of least squares is not only for polynomials. For example, suppose we want to find the
function

     f (t) = a + bt + c sin(2t/365) + d cos(2t/365)                                     (5.3)

that has the best fit to some data (t1, T1), ..., (tm, Tm) in the least-squares sense. This function is
used in modeling weather temperature data, where t denotes time, and T denotes the temperature.
The following figure plots the daily maximum temperature during a period of 1,056 days, from 2016
until November 21, 2018, as measured by a weather station at Melbourne airport, Australia1.

To find the best fit function of the form (5.3), we write the least squares error term

E = (f (ti) - Ti)2 m m = a + bt 2ti 2ti 2 i + c sin + d cos - Ti ,
                                 365  365
i=1  i=1

and set its partial derivatives with respect to the unknowns a, b, c, d to zero to obtain the normal
    1http://www.bom.gov.au/climate/data/
CHAPTER 5. APPROXIMATION THEORY                                       163

equations:                                                           (5.4)

            E m          2ti               2ti
                =0       2 a + bti + c sin 365 + d cos 365 - Ti = 0
            a       i=1

                     m 2ti 2ti
                 a + bti + c sin 365 + d cos 365 - Ti = 0,

                     i=1

            E m                  2ti       2ti
            b = 0  (2ti) a + bti + c sin 365 + d cos 365 - Ti = 0
                i=1

                     m 2ti 2ti                                       (5.5)
                 ti a + bti + c sin 365 + d cos 365 - Ti = 0,

                     i=1

E m 2ti                  a + bti + c sin 2ti + d cos 2ti - Ti = 0
            =0  2 sin
c i=1 365                             365       365

                 m 2ti   a + bti + c sin 2ti + d cos 2ti - Ti = 0,   (5.6)
             sin                 365       365

                i=1 365

E m 2ti                  a + bti + c sin 2ti + d cos 2ti - Ti = 0
            =0  2 cos
d i=1 365                             365       365

                 m 2ti   a + bti + c sin 2ti + d cos 2ti - Ti = 0.   (5.7)
             cos                 365       365

                i=1 365

Rearranging terms in equations (5.4, 5.5, 5.6, 5.7), we get a system of four equations and four
CHAPTER 5. APPROXIMATION THEORY                                                                    164

unknowns:

     m m 2ti                              m 2ti m
am + b ti + c sin 365                     + d cos 365 = Ti
     i=1             i=1                  i=1            i=1

m            m            m    2ti m                     2ti m

a ti + b ti2 + c ti sin                   365 + d ti cos 365 = Titi

i=1          i=1          i=1                  i=1                      i=1

m 2ti m                        2ti             m         2 2ti          m         2ti  cos 2ti
                                                                                              365
a sin 365 + b ti sin                      + c sin               + d sin
                               365 i=1 365 i=1 365                                         m
i=1                       i=1

                                                                                       = Ti sin    2ti
                                                                                                   365
                                                                                       i=1
                                                                                                   2ti
m 2ti m                                   2ti m 2ti                     2ti       m      2 2ti     365

a cos 365 + b ti cos                         + c sin            cos             + d cos
                                          365 i=1 365                   365 i=1 365
i=1                       i=1

                                                                                       m

                                                                                       = Ti cos

                                                                                       i=1

Using a short-hand notation where we suppress the argument                   2ti  in the trigonometric func-
                                                                             365

tions, and the summation indices, we write the above equations as a matrix equation:

                                                                                                 
                                                                                          Ti 
                  m               ti         sin(·)             cos(·)       a           Titi 
                                  t2i       ti sin(·)                                  Ti sin(·)
                  ti           ti sin(·)     sin2(·)     ti cos(·)    b     = 
                               ti cos(·)  sin(·) cos(·)                                Ti cos(·)
           
                sin(·)                                   sin(·) cos(·) c 

                cos(·)                                   cos2(·)             d

                                          A                                            r

Next, we will use Python to load the data and define the matrices A, r, and then solve the equation
Ax = r, where x = [a, b, c, d]T .

    We will use a package called pandas to import data. We import it in our notebook, along with
NumPy and Matplotlib:

In [1]: import pandas as pd
            import numpy as np
            import matplotlib.pyplot as plt
            %matplotlib inline

    We assume that the data which consists of temperatures is downloaded as a csv file in the same
directory where the Python notebook is stored. Make sure the data has no missing entries. The
function pd.read_csv imports the data into Python as a table (dataframe):

In [2]: df = pd.read_csv('WeatherData.csv')
            df
CHAPTER 5. APPROXIMATION THEORY  165

Out[2]:        Temp
               28.7
         0     27.5
         1     28.2
         2     24.5
         3     25.6
         4
         ...    ...
         1051  19.1
         1052  27.1
         1053  31.0
         1054  27.0
         1055  22.7

            [1056 rows x 1 columns]
    The next step is to store the part of the data we need as an array. In our table there is only
one column named Temp.

In [3]: temp = df['Temp'].to_numpy()
            temp

Out[3]: array([28.7, 27.5, 28.2, ..., 31. , 27. , 22.7])
    Let's check the type of temp, its first entry, and its length:

In [4]: type(temp)
Out[4]: numpy.ndarray
In [5]: temp[0]
Out[5]: 28.7
In [6]: temp.size
Out[6]: 1056

    There are 1,056 temperature values. The x-coordinates are the days, numbered t = 1, 2, ..., 1056.
Here is the array that stores these time values:

In [7]: time = np.arange(1, 1057)
    Next we define the matrix A, taking advantage of the fact that the matrix is symmetric. The

function np.sum(x) adds the entries of the array x.
CHAPTER 5. APPROXIMATION THEORY                                                 166

In [8]: A = np.zeros((4,4))
            A[0,0] = 1056
            A[0,1] = np.sum(time)
            A[0,2] = np.sum(np.sin(2*np.pi*time/365))
            A[0,3] = np.sum(np.cos(2*np.pi*time/365))
            A[1,1] = np.sum(time**2)
            A[1,2] = np.sum(time*np.sin(2*np.pi*time/365))
            A[1,3] = np.sum(time*np.cos(2*np.pi*time/365))
            A[2,2] = np.sum(np.sin(2*np.pi*time/365)**2)
            A[2,3] = np.sum(np.sin(2*np.pi*time/365)*np.cos(2*np.pi*time/365))
            A[3,3] = np.sum(np.cos(2*np.pi*time/365)**2)
            for i in range(1,4):
                  for j in range(i):
                         A[i,j] = A[j,i]

In [9]: A

Out[9]:   array([[ 1.05600000e+03, 5.58096000e+05,       1.22956884e+01,
                      -3.62432800e+01],                 -5.04581481e+04,

                    [ 5.58096000e+05, 3.93085616e+08,    5.42338826e+02,
                      -3.84772834e+04],                  1.09944004e+01,

                    [ 1.22956884e+01, -5.04581481e+04,
                        1.09944004e+01],

                    [-3.62432800e+01, -3.84772834e+04,
                        5.13661174e+02]])

    Now we define the vector r. The function np.dot(x,y) takes the dot product of the arrays x, y.
For example, np.dot([1, 2, 3], [4, 5, 6]) = 1 × 4 + 2 × 5 + 3 × 6 = 32.

In [10]: r = np.zeros((4,1))
              r[0] = np.sum(temp)
              r[1] = np.dot(temp, time)
              r[2] = np.dot(temp, np.sin(2*np.pi*time/365))
              r[3] = np.dot(temp, np.cos(2*np.pi*time/365))

In [11]: r

Out[11]:  array([[2.18615000e+04],
                    [1.13803102e+07],
                    [1.74207707e+03],
                    [2.78776127e+03]])
CHAPTER 5. APPROXIMATION THEORY                                            167

We can solve the matrix equation now.

In [12]: np.linalg.solve(A, r)

Out[12]:  array([[2.02897563e+01],
                    [1.16773021e-03],
                    [2.72116176e+00],
                    [6.88808561e+00]])

    Recall that these constants are the values of a, b, c, d in the definition of f (t). Here is the best
fitting function to the data:

In [13]: f = lambda t: 20.1393 + 0.00144928*t + 2.72174*np.sin(2*np.pi*t/365) + \
              6.88460*np.cos(2*np.pi*t/365)

We next plot the data together with f (t):

In [14]: xaxis = np.arange(1, 1057)
              yvals = f(xaxis)
              plt.plot(xaxis, yvals, label='Least squares approximation')
              plt.xlabel('time (t)')
              plt.ylabel('Temperature (T)')
              plt.plot(temp, linestyle='-', alpha=0.5, label='Data')
              plt.legend(loc='upper center');
CHAPTER 5. APPROXIMATION THEORY                                                  168

Linearizing data

For another example of non-polynomial least squares, consider finding the function f (x) = beax
with the best least squares fit to some data (x1, y1), (x2, y2), ..., (xm, ym). We need to find a, b that
minimize m

                                                   E = (yi - beaxi )2.

                                         i=1

The normal equations are           E = 0 and E = 0,

                                   a          b

however, unlike the previous example, this is not a system of linear equations in the unknowns a, b.
In general, a root finding type method is needed to solve these equations.

    There is a simpler approach we can use when we suspect the data is exponentially related.
Consider again the function we want to fit:

                                         y = beax.                               (5.8)

Take the logarithm of both sides:

                                   log y = log b + ax

and rename the variables as Y = log y, B = log b. Then we obtain the expression

                                         Y = ax + B                              (5.9)

which is a linear equation in the transformed variable. In other words, if the original variable y is
related to x via Equation (5.8), then Y = log y is related to x via a linear relationship given by
Equation (5.9). So, the new approach is to fit the least squares line Y = ax + B to the data

                          (x1, log y1), (x2, log y2), ..., (xm, log ym).

    However, it is important to realize that the least squares fit to the transformed data is not
necessarily the same as the least squares fit to the original data. The reason is the deviations which
least squares minimize are distorted in a non-linear way by the transformation.

Example 85. Consider the following data

                                   x012 3 4 5
                                   y 3 5 8 12 23 37

to which we will fit y = beax in the least-squares sense. The following table displays the data
(xi, log yi), using two-digits:

                          x        012345

                          Y = log y 1.1 1.6 2.1 2.5 3.1 3.6
CHAPTER 5. APPROXIMATION THEORY                                    169

    We use the Python code leastsqfit to fit a line to this data:
In [1]: x = np.array([0, 1, 2, 3, 4, 5])

            y = np.array([1.1, 1.6, 2.1, 2.5, 3.1, 3.6])
In [2]: leastsqfit(x, y, 1)
Out[2]: array([1.09047619, 0.49714286])

    Therefore the least squares line, using two-digits, is

Y = 0.5x + 1.1.

This equation corresponds to Equation (5.9), with a = 0.5 and B = 1.1. We want to obtain the
corresponding exponential Equation (5.8), where b = eB. Since e1.1 = 3, the best fitting exponential
function to the data is y = 3ex/2. The following graph plots y = 3ex/2 together with the data.

    Exercise 5.1-1: Find the function of the form y = aex + b sin(4x) that best fits the data

below in the least squares sense.

                                             x1234 5
                                             y -4 6 -1 5 20

    Plot the function and the data together.
CHAPTER 5. APPROXIMATION THEORY                                                                            170

    Exercise 5.1-2: Power-law type relationships are observed in many empirical data. Two

variables y, x are said to be related via a power-law if y = kx, where k,  are some constants. The
following data2 lists the top 10 family names in the order of occurrence according to Census 2000.
Investigate whether relative frequency of occurrences and the rank of the name are related via a
power-law, by

   a) Let y be the relative frequencies (number of occurrences divided by the total number of
        occurrences), and x be the rank, that is, 1 through 10.

   b) Use least squares to find a function of the form y = kx. Use linearization.

   c) Plot the data together with the best fitting function found in part (b).

                           Name                 Number of Occurrences
                           Smith                         2,376,206
                          Johnson                        1,857,160
                         Williams                        1,534,042
                           Brown                         1,380,145
                           Jones                         1,362,755
                           Miller                        1,127,803
                           Davis                         1,072,335
                           Garcia                         858,289
                         Rodriguez                        804,240
                           Wilson                         783,051

5.2 Continuous least squares

In discrete least squares, our starting point was a set of data points. Here we will start with a

continuous function f on [a, b] and answer the following question: how can we find the "best"

polynomial Pn(x) =  n    aj xj  of  degree  at   most  n  that  approximates  f  on  [a, b]?  As  before,  "best"
                    j=0

polynomial will mean the polynomial that minimizes the least squares error:

                                                                2

                                       b                  n

                                E=          f (x) - ajxj dx.                                               (5.10)

                                    a                     j=0

Compare this expression with that of the discrete least squares:

                                                                2

                                            m             n

                                    E = yi - ajxji  .

                                            i=1           j=0

2https://www.census.gov/topics/population/genealogy/data/2000_surnames.html
CHAPTER 5. APPROXIMATION THEORY                                                                            171

To  minimize  E  in  (5.10)  we  set         E   =  0,  for      k  =  0, 1, ..., n,  and  observe
                                             ak

                                                                                                       2 
    E =  
    ak ak                     b                            b              n                 bn

                               f 2(x)dx - 2                      f (x)  ajxj dx +            ajxj dx

                             a                          a                 j=0               a j=0

                          b                          n               b

                 = -2        f (x)xkdx + 2 aj                         xj+kdx = 0,

                       a                            j=0             a

which gives the (n + 1) normal equations for the continuous least squares problem:

                                              n          b                      b                          (5.11)

                                                 aj       xj+kdx =               f (x)xkdx

                                             j=0        a                      a

for k = 0, 1, ..., n. Note that the only unknowns in these equations are the aj's; hence this is a linear

system of equations. It is instructive to compare these normal equations with those of the discrete

least squares problem:                           n            m                m

                                                    aj xik+j = yixik.

                                             j=0              i=1              i=1

Example 86. Find the least squares polynomial approximation of degree 2 to f (x) = ex on (0, 2).

Solution. The normal equations are:

                                              2          2                      2

                                                 aj        xj+kdx =               ex xk dx

                                             j=0        0                      0

k = 0, 1, 2. Here are the three equations:

                                          2                   2                 2            2

                             a0 dx + a1 xdx + a2                                  x2dx =       exdx

                                       0                   0                   0            0

                                    2                      2                    2            2

                          a0 xdx + a1 x2dx + a2                                   x3dx =       exxdx

                                 0                      0                      0            0

                                 2                         2                    2            2

                       a0 x2dx + a1 x3dx + a2                                     x4dx =       exx2dx

                             0                          0                      0            0

Computing the integrals we get

                                                    2a0 + 2a1 + 8 a2 = e2 - 1
                                                                    3

                                                    2a0 + 8 a1 + 4a2 = e2 + 1
                                                            3

                                                 8 a0 + 4a1 + 32 a2 = 2e2 - 2
                                                 3                     5
CHAPTER 5. APPROXIMATION THEORY                                                      172

whose solution is a0 = 3(-7 + e2), a1 = - 32 (-37 + 5e2), a2 = 154 (-7 + e2). Then

        P2(x) = 1.17 + 0.08x + 1.46x2.

    The solution method we have discussed for the least squares problem by solving the normal
equations as a matrix equation has certain drawbacks:

    · The integrals ba xi+jdx = bi+j+1 - ai+j+1 /(i + j + 1) in the coefficient matrix give rise to
        matrix equation that is prone to roundoff error.

· There is no easy way to go from Pn(x) to Pn+1(x) (which we might want to do if we were not
   satisfied by the approximation provided by Pn).

There is a better approach to solve the discrete and continuous least squares problem using the
orthogonal polynomials we encountered in Gaussian quadrature. Both discrete and continuous
least squares problem tries to find a polynomial Pn(x) = j=0 n ajxj that satisfies some properties.
Notice how the polynomial is written in terms of the monomial basis functions xj and recall how
these basis functions caused numerical difficulties in interpolation. That was the reason we discussed
different basis functions like Lagrange and Newton for the interpolation problem. So the idea is to
write Pn(x) in terms of some other basis functions

                         n

        Pn(x) = ajj(x)

                        j=0

which would then update the normal equations for continuous least squares (5.11) as

 n       b                        b

    aj    j(x)k(x)dx =             f (x)k(x)dx

j=0     a                        a

for k = 0, 1, ..., n. The normal equations for the discrete least squares (5.1) gets a similar update:

 n       m                            m

    aj      j (xi )k (xi )       = yik(xi).

j=0     i=1                          i=1

Going forward, the crucial observation is that the integral of the product of two functions
  j(x)k(x)dx, or the summation of the product of two functions evaluated at some discrete

points, j(xi)k(xi), can be viewed as an inner product j, k of two vectors in a suitably de-
fined vector space. And when the functions (vectors) j are orthogonal, the inner product j, k
is 0 if j = k, which makes the normal equations trivial to solve. We will discuss details in the next
section.
CHAPTER 5. APPROXIMATION THEORY                                                          173

5.3 Orthogonal polynomials and least squares

Our discussion in this section will mostly center around the continuous least squares problem;

however, the discrete problem can be approached similarly. Consider the set C0[a, b], the set of all

continuous functions defined on [a, b], and Pn, the set of all polynomials of degree at most n on [a, b].

These two sets are vector spaces, the latter a subspace of the former, under the usual operations of

function addition and multiplying by a scalar. An inner product on this space is defined as follows:

given f, g  C0[a, b]

                                                       b                               (5.12)

                                      f, g = w(x)f (x)g(x)dx

                                                     a

and the norm of a vector under this inner product is

                                                             b       1/2

                             f = f, f 1/2 =                     w(x)f 2(x)dx .

                                                        a

Let's recall the definition of an inner product: it is a real valued function with the following prop-
erties:

1. f, g = g, f

2. f, f  0, with the equality only when f  0

3. f, g =  f, g for all real numbers 

4. f1 + f2, g = f1, g + f2, g

The mysterious function w(x) in (5.12) is called a weight function. Its job is to assign different
importance to different regions of the interval [a, b]. The weight function is not arbitrary; it has to
satisfy some properties.

Definition 87. A nonnegative function w(x) on [a, b] is called a weight function if

1.  b  |x|nw(x)dx     is  integrable  and  finite  for  all  n    0
    a

2. If ab w(x)g(x)dx = 0 for some g(x)  0, then g(x) is identically zero on (a, b).

With our new terminology and set-up, we can write the least squares problem as follows:

Problem (Continuous least squares) Given f  C0[a, b], find a polynomial Pn(x)  Pn that

    minimizes                b

                              w(x)(f (x) - Pn(x))2dx = f (x) - Pn(x), f (x) - Pn(x) .

                          a

    We will see this inner product can be calculated easily if Pn(x) is written as a linear combi-
    nation of orthogonal basis polynomials: Pn(x) = j=0 n ajj(x).
CHAPTER 5. APPROXIMATION THEORY                                                             174

We need some definitions and theorems to continue with our quest. Let's start with a formal
definition of orthogonal functions.

Definition 88. Functions {0, 1, ..., n} are orthogonal for the interval [a, b] and with respect to
the weight function w(x) if

                                                         
                                                         0
                                b                                  if j = k
                                                                   if j = k
                    j, k =      a w(x)j(x)k(x)dx = j > 0

where j is some constant. If, in addition, j = 1 for all j, then the functions are called orthonormal.

    How can we find an orthogonal or orthonormal basis for our vector space? Gram-Schmidt
process from linear algebra provides the answer.

Theorem     89 (Gram-Schmidt process). Given a weight function w(x), the Gram-Schmidt       process
constructs  a unique set of polynomials 0(x), 1(x), ..., n(x) where the degree of i(x) is   i, such
that
                                                   
                                   j, k            0     if j = k
                                                =        if j = k
                                                   1

and the coefficient of xn in n(x) is positive.

    Let's discuss two orthogonal polynomials that can be obtained from the Gram-Schmidt process
using different weight functions.

Example 90 (Legendre Polynomials). If w(x)  1 and [a, b] = [-1, 1], the first four polynomials ob-

tained from the Gram-Schmidt process, when the process is applied to the monomials 1, x, x2, x3, ...,

are:

                    1           3               1     5 (3x2 - 1), 3(x) = 1  7 (5x3 - 3x).
            0(x) =  2 , 1(x) =  2 x, 2(x) = 2                                2
                                                      2            2

Often these polynomials are written in its orthogonal form; that is, we drop the requirement

j, j = 1 in the Gram-Schmidt process, and we scale the polynomials so that the value of

each polynomial at 1 equals 1. The first four polynomials in that form are

                    L0(x) = 1, L1(x) = x, L2(x) = 3 x2 - 1 , L3(x) = 5 x3 - 3 x.
                                                   22              22

These are the Legendre polynomials, polynomials we first discussed in Gaussian quadrature, Section
4.33. They can be obtained from the following recursion

                                   2n + 1                n
                    Ln+1(x) = n + 1 xLn(x) - n + 1 Ln-1(x),

    3The Legendre polynomials in Section 4.3 differ from these by a constant factor. For example, in Section
4.3 the third polynomial was L2(x) = x2 - 13 , but here it is L2(x) = 32 (x2 - 13 ). Observe that multiplying these
polynomials by a constant does not change their roots (what we were interested in Gaussian quadrature),

or their orthogonality.
CHAPTER 5. APPROXIMATION THEORY                                  175

n = 1, 2, . . ., and they satisfy                           2
                                           Ln, Ln = 2n + 1 .

    Exercise 5.3-1: Show, by direct integration, that the Legendre polynomials L1(x) and L2(x)

are orthogonal.

Example 91 (Chebyshev polynomials). If we take w(x) = (1 - x2)-1/2 and [a, b] = [-1, 1], and
again drop the orthonormal requirement in Gram-Schmidt, we obtain the following orthogonal
polynomials:

                          T0(x) = 1, T1(x) = x, T2(x) = 2x2 - 1, T3(x) = 4x3 - 3x, ...

These polynomials are called Chebyshev polynomials and satisfy a curious identity:

                                             Tn(x) = cos(n cos-1 x), n  0.

Chebyshev polynomials also satisfy the following recursion:

                                   Tn+1(x) = 2xTn(x) - Tn-1(x)

for n = 1, 2, . . ., and                      
                                              0
                                   Tj, Tk         if j = k
                                           =      if j = k = 0
                                              /2  if j = k > 0.

    If we take the first n + 1 Legendre or Chebyshev polynomials, call them 0, ..., n, then these
polynomials form a basis for the vector space Pn. In other words, they form a linearly independent
set of functions, and any polynomial from Pn can be written as a unique linear combination of
them. These statements follow from the following theorem, which we will leave unproved.

Theorem 92. 1. If j(x) is a polynomial of degree j for j = 0, 1, ..., n, then 0, ..., n are
        linearly independent.

2. If 0, ..., n are linearly independent in Pn, then for any q(x)  Pn, there exist unique con-
    stants c0, ..., cn such that q(x) = j=0 n cjj(x).

    Exercise 5.3-2: Prove that if {0, 1, ..., n} is a set of orthogonal functions, then they must

be linearly independent.
CHAPTER 5. APPROXIMATION THEORY                                                            176

    We have developed what we need to solve the least squares problem using orthogonal polyno-
mials. Let's go back to the problem statement:

    Given f  C0[a, b], find a polynomial Pn(x)  Pn that minimizes

                                            b

                       E = w(x)(f (x) - Pn(x))2dx = f (x) - Pn(x), f (x) - Pn(x)

                                          a

with Pn(x) written as a linear combination of orthogonal basis polynomials: Pn(x) = j=0 n ajj(x).
In the previous section, we solved this problem using calculus by taking the partial derivatives of E
with respect to aj and setting them equal to zero. Now we will use linear algebra:

    n    n                                       n

E=  f - ajj, f - ajj     = f, f - 2 aj f, j +                                   aiaj i, j

    j=0  j=0                                     j=0                 ij

                                                 n                   n

                         = f 2 - 2 aj f, j + aj2 j, j

                                                 j=0                 j=0

                                                 n                   n

                         = f 2 - 2 aj f, j + a2j j

                                                 j=0                 j=0

                         = f 2 n - f, j 2 n +                             f, j  2
                                      j=0 j j=0                           j - aj j .

Minimizing this expression with respect to aj is now obvious: simply choose aj = j f,j so that the

                      n  f,j                        2
last summation in the above equation, j=0 j - aj j , vanishes. Then we have solved the

least squares problem! The polynomial that minimizes the error E is

              Pn(x) =    n f, j                  j (x)                                     (5.13)

                         j=0 j

where j = j, j . And the corresponding error is

              E = f 2 n - f, j 2 .
                              j=0 j

If the polynomials 0, ..., n are orthonormal, then these equations simplify by setting j = 1.
    We will appreciate the ease at which Pn(x) can be computed using this approach, via formula

(5.13), as opposed to solving the normal equations of (5.11) when we discuss some examples. But
first let's see the other advantage of this approach: how Pn+1(x) can be computed from Pn(x). In
CHAPTER 5. APPROXIMATION THEORY                                                                   177

Equation (5.13), replace n by n + 1 to get

           Pn+1(x) =  n+1 f, j     j(x) =        n f, j  j(x) +    f, n+1    n+1(x)

                      j=0 j                    j=0 j               n+1

                                                          Pn(x)

                                            = Pn(x) + f, n+1 n+1(x),
                                                             n+1

which is a simple recursion that links Pn+1 to Pn.

Example 93. Find the least squares polynomial approximation of degree three to f (x) = ex on
(-1, 1) using Legendre polynomials.

Solution. Put n = 3 in Equation (5.13) and let j be Lj to get

P3(x) =    f, L0  L0(x) +    f, L1 L1(x) + f, L2 L2(x) + f, L3 L3(x)
        =   0         ex, x     1                2              3

           ex, 1  +          x + ex, 32 x2 - 12     3 x2 - 1    + ex, 52 x3 - 32 x  5 x3 - 3 x ,
                       2/3               2/5        22                    2/7       22
             2

where we used the fact that j =    Lj, Lj   =     2  (see Example 90).  We will compute the inner
                                               2n+1

products, which are definite integrals on (-1, 1), using the five-node Gauss-Legendre quadrature we

discussed in the previous chapter. The results rounded to four digits are:

                                                      1

                                   ex, 1 = exdx = 2.350

                                               -1

                                                      1

                                   ex, x = exxdx = 0.7358

                                               -1

                  ex, 3 x2 - 1             1         3 x2 - 1   dx = 0.1431
                      22                             22
                                   = ex

                                         -1

                  ex, 5 x3 - 3 x           1        5 x3 - 3 x  dx = 0.02013.
                      22                            22
                                   = ex

                                         -1

Therefore

           P3(x) = 2.35 + 3(0.7358) x + 5(0.1431) 3 x2 - 1         7(0.02013)       5 x3 - 3 x
           2                 2              2        22         +                   22

                                                                         2

           = 0.1761x3 + 0.5366x2 + 0.9980x + 0.9961.

Example 94. Find the least squares polynomial approximation of degree three to f (x) = ex on
(-1, 1) using Chebyshev polynomials.
CHAPTER 5. APPROXIMATION THEORY                                                           178

Solution. As in the previous example solution, we take n = 3 in Equation (5.13)

                                     P3(x) =    3 f, j   j (x),

                                                j=0 j

but now j and j will be replaced by Tj, the Chebyshev polynomials, and its corresponding
constant; see Example 91. We have

           P3(x) =  ex, T0  T0(x) +     ex, T1  T1(x) +  ex, T2  T2(x) +  ex, T3  T3(x).

                                        /2                  /2            /2

Consider one of the inner products,

                                     x            1 exTj(x)
                                     e , Tj =                dx
                                                -1 1 - x2

which is an improper integral due to discontinuity at the end points.     However, we can use the
substitution  = cos-1 x to rewrite the integral as (see Section 4.5)

                      x              1 exTj(x)              
                    e , Tj =                                    cos 
                                                  dx = e cos(j)d.
                                     -1 1 - x2
                                                         0

The transformed integrand is smooth, and it is not improper, and hence we can use composite
Simpson's rule to estimate it. The following estimates are obtained by taking n = 20 in the
composite Simpson's rule:

                                                              

                                      ex, T0 = ecos d = 3.977

                                                            0
                                                     

                               ex, T1 = ecos  cos d = 1.775

                                                   0
                                                   

                              ex, T2 = ecos  cos 2d = 0.4265

                                                 0
                                                   

                              ex, T3 = ecos  cos 3d = 0.06964

                                                 0

Therefore

           P3(x) = 3.977 + 3.55 x + 0.853 (2x2 - 1) + 0.1393 (4x3 - 3x)
                                                                      

                    = 0.1774x3 + 0.5430x2 + 0.9970x + 0.9944.
CHAPTER 5. APPROXIMATION THEORY                                                179

Python code for orthogonal polynomials

Computing Legendre polynomials

Legendre polynomials satisfy the following recursion:

2n + 1                                                  n
Ln+1(x) = n + 1 xLn(x) - n + 1 Ln-1(x)

for n = 1, 2, . . . , with L0(x) = 1, and L1(x) = x.
    The Python code implements this recursion, with a little modification: the index n + 1 is shifted

down to n, so the modified recursion is: Ln(x) = 2n-1 n xLn-1(x) - n-n 1 Ln-2(x), for n = 2, 3, . . . .

In [1]: import numpy as np
            import matplotlib.pyplot as plt
            %matplotlib inline

In [2]: def leg(x, n):
                  if n == 0:
                         return 1
                  elif n == 1:
                         return x
                  else:
                         return ((2*n-1)/n)*x*leg(x,n-1)-((n-1)/n)*leg(x,n-2)

Here is a plot of the first five Legendre polynomials:

In [3]: xaxis = np.linspace(-1, 1, 200)
            legzero = np.array(list(map(lambda x: leg(x,0), xaxis)))
            legone = leg(xaxis, 1)
            legtwo = leg(xaxis, 2)
            legthree = leg(xaxis, 3)
            legfour = leg(xaxis, 4)
            plt.plot(xaxis, legzero, label='$L_0(x)$')
            plt.plot(xaxis, legone, label='$L_1(x)$')
            plt.plot(xaxis, legtwo, label='$L_2(x)$')
            plt.plot(xaxis, legthree, label='$L_3(x)$')
            plt.plot(xaxis, legfour, label='$L_4(x)$')
            plt.legend(loc='lower right');
CHAPTER 5. APPROXIMATION THEORY                                                                              180

Least-squares using Legendre polynomials

In Example 93, we computed the least squares approximation to ex using Legendre polynomials.
The inner products were computed using the five-node Gauss-Legendre rule below.

In [4]: def gauss(f):
                  return 0.2369268851*f(-0.9061798459) + 0.2369268851*f(0.9061798459) + \
                             0.5688888889*f(0) + 0.4786286705*f(0.5384693101) + \
                             0.4786286705*f(-0.5384693101)

The inner product,    ex, 32 x2 - 12  =  1    ex( 32 x2  -  12 )dx  is  computed  as
                                         -1

In [5]: gauss(lambda x: ((3/2)*x**2-1/2)*np.exp(x))

Out[5]: 0.1431256282441218

Now that we have a code leg(x,n) that generates the Legendre polynomials, we can do the above

computation  without  explicitly  specifying  the  Legendre  polynomial.  For     example,  since  32 x2  -  1  =
                                                                                                             2

L2, we can apply the gauss function directly to L2(x)ex:

In [6]: gauss(lambda x: leg(x,2)*np.exp(x))

Out[6]: 0.14312562824412176

    The following function polyLegCoeff(f,n) computes the coefficients j f,Lj of the least squares
polynomial Pn(x) = j=0 j n f,Lj Lj(x), j = 0, 1, ..., n, for any f and n, where Lj are the Legendre
polynomials. The coefficients are the outputs that are returned when the function is finished.

In [7]: def polyLegCoeff(f, n):
                  A = np.zeros(n+1)
                  for j in range(n+1):
                         A[j] = gauss(lambda x: leg(x,j)*f(x))*(2*j+1)/2
                  return A
CHAPTER 5. APPROXIMATION THEORY  181

    Once the coefficients are computed, evaluating the polynomial can be done efficiently by using
the coefficients. The next function polyLeg(x,n,A) evaluates the least squares polynomial Pn(x) =

   j=0 j n f,Lj Lj(x), j = 0, 1, ..., n, where the coefficients j f,Lj , stored in A, are obtained from calling
the function polyLegCoeff(f,n).

In [8]: def polyLeg(x, n, A):
                  sum = 0.
                  for j in range(n+1):
                         sum += A[j]*leg(x, j)
                  return sum

    Here we plot y = ex together with its least squares polynomial approximations of degree two and
three, using Legendre polynomials. Note that every time the function polyLegCoeff is evaluated,
a new coefficient array A is obtained.

In [9]: xaxis = np.linspace(-1, 1, 200)
            A = polyLegCoeff(lambda x: np.exp(x), 2)
            deg2 = polyLeg(xaxis, 2, A)
            A = polyLegCoeff(lambda x: np.exp(x), 3)
            deg3 = polyLeg(xaxis, 3, A)
            plt.plot(xaxis, np.exp(xaxis), label='$e^x$')
            plt.plot(xaxis, deg2, label='Legendre least squares poly of degree 2')
            plt.plot(xaxis, deg3, label='Legendre least squares poly of degree 3')
            plt.legend(loc='upper left');

Computing Chebyshev polynomials

The following function implements the recursion Chebyshev polynomials satisfy: Tn+1(x) =
2xTn(x) - Tn-1(x), for n = 1, 2, ..., with T0(x) = 1 and T1(x) = x. Note that in the code the
index is shifted from n + 1 to n.
CHAPTER 5. APPROXIMATION THEORY                                           182

In [10]: def cheb(x, n):
                    if n == 0:
                          return 1
                    elif n == 1:
                          return x
                    else:
                          return 2*x*cheb(x,n-1)-cheb(x,n-2)

    Here is a plot of the first five Chebyshev polynomials:

In [11]: xaxis = np.linspace(-1, 1, 200)
              chebzero = np.array(list(map(lambda x: cheb(x,0), xaxis)))
              chebone = cheb(xaxis, 1)
              chebtwo = cheb(xaxis, 2)
              chebthree = cheb(xaxis, 3)
              chebfour = cheb(xaxis, 4)
              plt.plot(xaxis, chebzero, label='$T_0(x)$')
              plt.plot(xaxis, chebone, label='$T_1(x)$')
              plt.plot(xaxis, chebtwo, label='$T_2(x)$')
              plt.plot(xaxis, chebthree, label='$T_3(x)$')
              plt.plot(xaxis, chebfour, label='$T_4(x)$')
              plt.legend(loc='lower right');

Least squares using Chebyshev polynomials

In Example 94, we computed the least squares approximation to ex using Chebyshev polynomials.
The inner products, after a transformation, were computed using the composite Simpson rule. Below
is the Python code for the composite Simpson rule we discussed in the previous chapter.
CHAPTER 5. APPROXIMATION THEORY                                              183

In [12]: def compsimpson(f, a, b, n):
                    h = (b-a)/n
                    nodes = np.zeros(n+1)
                    for i in range(n+1):
                          nodes[i] = a+i*h
                    sum = f(a) + f(b)
                    for i in range(2, n-1, 2):
                          sum += 2*f(nodes[i])
                    for i in range(1, n, 2):
                          sum += 4*f(nodes[i])
                    return sum*h/3

The integrals in Example 94 were computed using the composite Simpson rule with n = 20. For

example, the second integral  ex, T1  =     ecos   cos d  is  computed  as:
                                         0

In [13]: compsimpson(lambda x: np.exp(np.cos(x))*np.cos(x), 0, np.pi, 20)

Out[13]: 1.7754996892121808

    Next we write two functions, polyChebCoeff(f,n) and polyCheb(x,n,A). The first function
computes the coefficients j f,Tj of the least squares polynomial Pn(x) = j=0 j n f,Tj Tj(x), j =
0, 1, ..., n, for any f and n, where Tj are the Chebyshev polynomials. The coefficients are returned

as the output of the first function.
    The integral f, Tj is transformed to the integral 0 f (cos ) cos(j)d, similar to the derivation

in Example 94, and then the transformed integral is computed using the composite Simpson's rule

by polyChebCoeff.

In [14]: def polyChebCoeff(f, n):
                    A = np.zeros(n+1)
                    A[0] = compsimpson(lambda x: f(np.cos(x)), 0, np.pi, 20)/np.pi
                    for j in range(1, n+1):
                          A[j] = compsimpson(lambda x: f(np.cos(x))*np.cos(j*x), 0, np.pi, 20)*2/np.pi
                    return A

In [15]: def polyCheb(x, n, A):
                    sum = 0.
                    for j in range(n+1):
                          sum += A[j]*cheb(x, j)
                    return sum

    Next we plot y = ex together with polynomial approximations of degree two and three using
Chebyshev basis polynomials.
CHAPTER 5. APPROXIMATION THEORY  184

In [16]: xaxis = np.linspace(-1, 1, 200)
              A = polyChebCoeff(lambda x: np.exp(x), 2)
              deg2 = polyCheb(xaxis, 2, A)
              A = polyChebCoeff(lambda x: np.exp(x), 3)
              deg3 = polyCheb(xaxis, 3, A)
              plt.plot(xaxis, np.exp(xaxis), label='$e^x$')
              plt.plot(xaxis, deg2, label='Chebyshev least squares poly of degree 2')
              plt.plot(xaxis, deg3, label='Chebyshev least squares poly of degree 3')
              plt.legend(loc='upper left');

    The cubic Legendre and Chebyshev approximations are difficult to distinguish from the function
itself. Let's compare the quadratic approximations obtained by Legendre and Chebyshev polyno-
mials. Below, you can see visually that Chebyshev does a better approximation at the end points
of the interval. Is this expected?

In [17]: xaxis = np.linspace(-1, 1, 200)
              A = polyChebCoeff(lambda x: np.exp(x), 2)
              cheb2 = polyCheb(xaxis, 2, A)
              A = polyLegCoeff(lambda x: np.exp(x), 2)
              leg2 = polyLeg(xaxis, 2, A)
              plt.plot(xaxis, np.exp(xaxis), label='$e^x$')
              plt.plot(xaxis, cheb2, label='Chebyshev least squares poly of degree 2')
              plt.plot(xaxis, leg2, label='Legendre least squares poly of degree 2')
              plt.legend(loc='upper left');
CHAPTER 5. APPROXIMATION THEORY  185

    In the following, we compare second degree least squares polynomial approximations for
f (x) = ex2. Compare how good the Legendre and Chebyshev polynomial approximations are
in the midinterval and toward the endpoints.

In [18]: f = lambda x: np.exp(x**2)
              xaxis = np.linspace(-1, 1, 200)
              A = polyChebCoeff(lambda x: f(x), 2)
              cheb2 = polyCheb(xaxis, 2, A)
              A = polyLegCoeff(lambda x: f(x), 2)
              leg2 = polyLeg(xaxis, 2, A)
              plt.plot(xaxis, f(xaxis), label='$e^{x^2}}$')
              plt.plot(xaxis, cheb2, label='Chebyshev least squares poly of degree 2')
              plt.plot(xaxis, leg2, label='Legendre least squares poly of degree 2')
              plt.legend(loc='upper center');
CHAPTER 5. APPROXIMATION THEORY  186

    Exercise 5.3-3: Use Python to compute the least squares polynomial approximations

P2(x), P4(x), P6(x) to sin 4x using Chebyshev basis polynomials. Plot the polynomials together
with sin 4x.
References

 [1] Abramowitz, M., and Stegun, I.A., 1965. Handbook of mathematical functions: with formulas,
      graphs, and mathematical tables (Vol. 55). Courier Corporation.

 [2] Chace, A.B., and Manning, H.P., 1927. The Rhind Mathematical Papyrus: British Museum
      10057 and 10058. Vol 1. Mathematical Association of America.

 [3] Atkinson, K.E., 1989. An Introduction to Numerical Analysis, Second Edition, John Wiley &
      Sons.

 [4] Burden, R.L, Faires, D., and Burden, A.M., 2016. Numerical Analysis, 10th Edition, Cengage.
 [5] Capstick, S., and Keister, B.D., 1996. Multidimensional quadrature algorithms at higher degree

      and/or dimension. Journal of Computational Physics, 123(2), pp.267-273.
 [6] Chan, T.F., Golub, G.H., and LeVeque, R.J., 1983. Algorithms for computing the sample

      variance: Analysis and recommendations. The American Statistician, 37(3), pp.242-247.
 [7] Cheney, E.W., and Kincaid, D.R., 2012. Numerical mathematics and computing. Cengage

      Learning.
 [8] Glasserman, P., 2013. Monte Carlo methods in Financial Engineering. Springer.
 [9] Goldberg, D., 1991. What every computer scientist should know about floating-point arith-

      metic. ACM Computing Surveys (CSUR), 23(1), pp.5-48.
[10] Heath, M.T., 1997. Scientific Computing: An introductory survey. McGraw-Hill.
[11] Higham, N.J., 1993. The accuracy of floating point summation. SIAM Journal on Scientific

      Computing, 14(4), pp.783-799.
[12] Isaacson, E., and Keller, H.B., 1966. Analysis of Numerical Methods. John Wiley & Sons.

                                                         187
Index                                       Julia code, 68
                                            relation to Newton's method, 73
Absolute error, 30                    Floating-point, 21
                                            decimal, 29
Beasley-Springer-Moro, 142                  IEEE 64-bit, 22
Biased exponent, 22                         infinity, 24
Big O notation, 78                          NAN, 24
Bisection method, 46                        normalized, 22
                                            toy model, 25
     error theorem, 48                      zero, 24
     Julia code, 47
     linear convergence, 49           Gamma function, 87
Black-Scholes-Merton formula, 55      Gaussian quadrature, 131

Chebyshev nodes, 96                         error theorem, 136
Chebyshev polynomials, 175                  Julia code, 135
                                            Legendre polynomials, 132
     Julia code, 181                  Gram-Schmidt process, 174
Chopping, 29
Composite Newton-Cotes, 127           Hermite interpolation, 96
                                            computation, 99
     midpoint, 127                          Julia code, 101
     roundoff, 130
     Simpson, 127                     Implied volatility, 56
     trapezoidal, 127                 Improper integrals, 144
                                      Intermediate value theorem, 6
Degree of accuracy, 124               Interpolation, 75
Divided differences, 85               Inverse interpolation, 92
                                      Iterative method, 44
     derivative formula, 96
Dr. Seuss, 117                              stopping criteria, 44

Extreme value theorem, 6              Julia
                                            abs, 63
Fixed-point iteration, 64, 65
     error theorem, 68             188
     geometric interpretation, 66
     high-order, 72
     high-order error theorem, 73
INDEX                                                                                        189

     Complex, 63                             Julia code, 52
     Distributions, 58                       quadratic convergence, 55
     dot, 166                           Newton-Cotes, 121
     JuliaDB, 164                            closed, 124
     LatexStrings, 92                        Julia code, 128
     LinearAlgebra, 164                      open, 124
     reverse, 90                        Normal equations
     standard normal distribution, 58        continuous, 171
                                             discrete, 155
Lagrange interpolation, 78              Numerical differentiation, 145
Least squares, 153                           three-point endpoint, 148
                                             three-point midpoint, 148
     continuous, 170                         backward-difference, 146
     discrete, 153                           forward-difference, 146
     Julia code                              noisy data, 148
                                             roundoff, 150
        Chebyshev, 182                       second derivative, 149
        discrete, 157                   Numerical quadrature, 121
        Legendre, 180                        midpoint rule, 125
     linearizing, 167                        Monte Carlo, 140
     non-polynomials, 162                    multiple integrals, 136
     normal equations, continuous, 171       Newton-Cotes, 121
     normal equations, discrete, 155         Simpson's rule, 123
     orthogonal polynomials, 173             trapezoidal rule, 122
Legendre polynomials, 174
     Julia code, 179                    Orthogonal functions, 172
Linear convergence, 45                  Orthogonal polynomials, 173

Machine epsilon, 31                          Chebyshev, 175
     alternative definition, 32              Julia code, 179
                                             Legendre, 174
Mean value theorem, 6                   Overflow, 25
Midpoint rule, 125
Monte Carlo integration, 140            Polynomial interpolation, 76
Muller's method, 61                          error theorem, 83
                                             Existence and uniqueness, 83
     convergence rate, 62                    high degree, 92
     Julia code, 63                          Lagrange basis functions, 78
Multiple integrals, 136                      monomial basis functions, 77
                                             Newton basis functions, 81
Newton interpolation
     Julia code, 89

Newton's method, 50
     error theorem, 54
INDEX                                                                                         190

Polynomials                              Taylor's theorem, 6
     nested form, 38                     Trapezoidal rule, 122
     standard form, 39                   Two's complement, 25

Power-law, 169                           Underflow, 25
Propagation of error, 33
                                         van der Monde matrix, 77
     adding numbers, 36
     alternating sum, 37                 Weight function, 173
     cancellation of leading digits, 33  Weighted mean value theorem for integrals, 122
     division by a small number, 34
     quadratic formula, 35
     sample variance, 36

Quadratic convergence, 45

Relative error, 30
Representation of integers, 25
Rhind papyrus, 41
Rolle's theorem, 96

     generalized, 96
Root-finding, 41
Rounding, 29
Runge's function, 92

Secant method, 58
     error theorem, 59
     Julia code, 60

Significant digits, 30
Simpson's rule, 123
Spline interpolation, 103

     clamped cubic, 106
     cubic, 105
     Julia code, 109
     linear, 104
     natural cubic, 106
     quadratic, 105
     Runge's function, 112
Stirling's formula, 136
Subnormal numbers, 24
Superlinear convergence, 45
