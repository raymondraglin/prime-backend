Introduction to GNU Octave

    A brief tutorial for linear algebra and calculus students

                                                                   Jason Lachniet
       Introduction to GNU Octave

A brief tutorial for linear algebra and calculus students

                          Jason Lachniet
               Wytheville Community College

                         Third Edition
iv
                                                                                                                            v

ฉ 2020 by Jason Lachniet (CC-BY-SA)

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International Li-
cense. To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.
0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

Edition 3

Download for free at:
https://www.wcc.vccs.edu/sites/default/files/Introduction-to-GNU-Octave.pdf.
vi
Contents

Contents                                             vii

Preface                                              ix

1 Getting started                                    1

1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

1.2 Navigating the GUI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

1.3 Matrices and vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

1.4 Plotting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

Chapter 1 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2 Matrices and linear systems                        17

2.1 Linear systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

2.2 Polynomial curve fitting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

2.3 Matrix transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

Chapter 2 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

3 Single variable calculus                           39

3.1 Limits, sequences, and series . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

3.2 Numerical integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

3.3 Parametric, polar, and implicit functions . . . . . . . . . . . . . . . . . . . . . . . 46

3.4 The symbolic package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

Chapter 3 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

4 Miscellaneous topics                               59

4.1 Complex variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

4.2 Special functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

4.3 Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

Chapter 4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

5 Eigenvalue problems                                73

5.1 Eigenvectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

5.2 Markov chains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

5.3 Diagonalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

5.4 Singular value decomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

5.5 Gram-Schmidt and the QR algorithm . . . . . . . . . . . . . . . . . . . . . . . . 88

Chapter 5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

6 Multivariable calculus and differential equations  97

6.1 Space curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

6.2 Surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

6.3 Multiple integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

6.4 Vector fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

6.5 Differential equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

Chapter 6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

                               vii
viii                       CONTENTS

7 Applied projects         127

      7.1 Digital image compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127

      7.2 The Gini index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

      7.3 Designing a helical strake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133

      7.4 3D-printing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136

      7.5 Modeling a cave passage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

      7.6 Modeling the spread of an infectious disease . . . . . . . . . . . . . . . . . . . . . 152

A MATLAB compatibility     157

B Octave command glossary  159

References                 163

Index                      165
Preface

This short book is not intended to be a comprehensive manual (for that refer to [3], which is
indispensable). Instead, what follows is a tutorial that puts Octave to work solving a selection
of applied problems in linear algebra and calculus. The goal is to learn enough of the basics
to begin solving problems with minimum frustration. Note that minimum frustration does not
mean no frustration. Be patient!

Above all, our objective is simply to enhance our understanding of calculus and linear algebra
by using Octave as a tool for computations. As we work through the mathematical concepts, we
will learn the basics of programming in Octave. Note that while we deal with plenty of useful
numerical algorithms, we do not address issues of accuracy and round-off error in machine
arithmetic. For more details about numerical issues, refer to [1].

How to use this book

To get the most out of this book, you should read it alongside an open Octave window where
you can follow along with the computations (you will want paper and pencil, too, as well as
your math books). To get started, read Chapter 1, without worrying too much about any of the
mathematics you don't yet understand. After grasping the basics, you should be able to move
into any of the later chapters or sections that interest you.

Every chapter concludes with a set of problems, some of which are routine practice, and some
of which are more involved. Chapter 7 contains a series of applied projects. Most examples
assume the reader is familiar with the mathematics involved. In a few cases, more detailed
explanation of relevant theorems is given by way of motivation, but there are no proofs. Refer
to the linear algebra and calculus books listed in the references for background on the underlying
mathematics. In the spirit of openness, all references listed are available for free under GNU or
Creative Commons licenses and can be accessed using the links provided.

MATLAB

The majority of the code shown in this book will work in Matlab as well as Octave. This guide
can therefore also be used an introduction to that software package. Refer to Appendix A for
some notes on Matlab compatibility.

                                                             ix
x                                                           PREFACE

Formatting

Blocks of Octave commands are indented and displayed with special formatting as follows.

     >> % example Octave commands :
     >> x = [-3 : 0 . 1 : 3 ] ;
     >> p l o t ( x , x . ^ 2 ) ;
     >> t i t l e ( ' Example p l o t ' )

The same formatting is used for commands that appear inline in the text. Comments used to
explain the code are preceded by a %-sign and shown in green. Function names are highlighted
in magenta. Strings (text variables) are highlighted in purple. The Octave prompt is shown as
">>". This color coding visible in the pdf e-book is not essential to understand the text. Thus
the print version is in black and white, which keeps the price reasonable.

Octave scripts and function files (.m-files) are shown between horizontal rules and are labeled
with a title, as in the following example. These are short programs in the Octave language.

                                  Octave Script 1: Example

1 % This i s an example Octave    script  ( . m- f i l e )
2 t = linspace (0 , 2*pi , 50) ;
3 x = cos (t) ;
4 y = sin (t) ;

5

6 % plot the graph of a unit c i r c l e
7 plot (x, y) ;

Note that line numbers are for reference purposes only and are not part of the code

If you are reading the electronic pdf version, there are numerous hyperlinks throughout the text
that link back to other parts of the text, or to external urls. There is a set of bookmarks to
each chapter and section that can be used to easily navigate from section to section. Open the
bookmark link in your pdf viewer to use this feature.

Theorems and example problems are numbered sequentially by chapter and section (e.g., The-
orem 5.3.4 is the fourth numbered item in Chapter 5, Section 3).

   Solutions to the many example problems are offset with a bar along the left side of the page,
   as shown here. A box signifies the end of the example.

Feedback

If you use the book and find it helpful, please consider leaving a review on the Amazon.com
product page or at the UMN Open Textbook Library listing. Send corrections and suggestions
to the author at jlachniet@wcc.vccs.edu.
                                                                                                                           xi

Revision history

2017 First edition
           ท Written for Octave version 4.0.

2019  Second edition
      ท Updated to reflect changes implemented in Octave through version 4.4, includ-

          ing the addition of a variable editor, migration of some statistical functions to
          the statistics package, and the addition of Matlab-compatible ODE solvers
          to the Octave core.
      ท New material added on implicit plots, complex variables, matrix transforma-
          tions, and symbolic operations.
      ท Addition of several new exercises and a new chapter containing a set of applied
          projects suitable for linear algebra and calculus students.

2020  Third edition
      ท Updated for Octave version 5.2.
      ท More extensive three-dimensional plotting examples.
      ท Increased coverage of the symbolic package.
      ท Numerous small edits throughout to improve clarity of exposition, based on

          reviewer and student feedback.
      ท Multiple new or revised exercises throughout, and one new project.
      ท A (slightly expanded) treatment of statistics has moved to a new Chapter 4,

          along with a few other miscellaneous topics, leaving only core single variable
          calculus topics in Chapter 3. Subsequent chapters are renumbered to ac-
          commodate this update. What is now Chapter 6 contains only multivariable
          calculus and differential equations.
xii  PREFACE
Chapter 1

Getting started

1.1 Introduction

1.1.1 What is GNU Octave?

GNU Octave is free software designed for scientific computing. It is intended primarily for
solving numerical problems. In linear algebra, we will use Octave's capabilities to solve systems
of linear equations and to work with matrices and vectors. Octave can also generate sophisticated
plots. For example, we will use it in vector calculus to plot vector fields, space curves, and
three dimensional surfaces. Octave is mostly compatible with the popular "industry standard"
commercial software package Matlab, so the skills you learn here can be applied to Matlab
programming as well. In fact, while this guide is meant to be an introduction to Octave, it can
serve equally well as a basic introduction to Matlab.
What is "GNU?" A gnu is a type of antelope, but GNU is a free, Unix-like computer operating
system. GNU is a recursive acronym that stands for "GNU's not Unix." GNU Octave (and
many other free programs) are licensed under the GNU General Public License: http://www.
gnu.org/licenses/gpl.html.
From www.gnu.org/software/octave:

       GNU Octave is a high-level interpreted language, primarily intended for numerical
       computations. It provides capabilities for the numerical solution of linear and non-
       linear problems, and for performing other numerical experiments. It also provides
       extensive graphics capabilities for data visualization and manipulation. Octave is
       normally used through its interactive command line interface, but it can also be
       used to write non-interactive programs. The Octave language is quite similar to
       Matlab so that most programs are easily portable.

Octave is a fully functioning programming language, but it is not a general purpose programming
language (like C++, Java, or Python). Octave is numeric, not symbolic; it is not a computer

                                                              1
2  CHAPTER 1. GETTING STARTED

                                        Figure 1.1: Windows Octave GUI

algebra system (like Maple, Mathematica, or Sage)1. However, Octave is ideally suited to all
types of numeric calculations and simulations. Matrices are the basic variable type and the
software is optimized for vectorized operations.

1.1.2 Installing Octave

It's free! Octave will work with Windows, Macs, or Linux. Go to https://www.gnu.org/
software/octave/download.html and look for the download that matches your system. For
example, Windows users can find an installer for the current Windows version at https:
//ftp.gnu.org/gnu/octave/windows/. Manual installation can be tricky, so look for the most
recent .exe installer file and run that. Installation in most Linux systems is easy. For exam-
ple, in Debian/Ubuntu, run the command sudo apt-get install octave. If you find Octave
useful, consider making a donation to support the project at https://www.gnu.org/software/
octave/donate.html.

Beginning with version 4.0, Octave uses a graphical user interface (GUI) by default. When you
start Octave, you should see something like Figure 1.1.

The user can customize the arrangement of windows. By default, you will have a large command
window, which is where commands are entered and run, a file browser, a workspace window
displaying the variables in the current scope, a command history, and beginning with version
4.4, a variable editor.

    1We will make use of the Octave Forge symbolic package where we find it particularly helpful, but the core
Octave program, and the focus of this book, is numeric.
1.2. NAVIGATING THE GUI  3

1.2 Navigating the GUI

1.2.1 Command history

In Octave, you can save variables that you defined in your session, but this does not save the
commands you used, or a whole worksheet. Octave does have a command history that persists
between sessions, so past commands can be brought up using the up arrow key, or using the
command history list in the GUI.

If you want to save a series of commands that can be reopened, edited, and run again, you
can create an Octave script, also known as an .m-file. This will be described in more detail in
Chapter 3 (see Section 3.2.2).

1.2.2 File browser

Within the Octave graphical user interface, you should see your current directory listed near the
top left. You can click the folder button to navigate to a different directory, such as the desktop,
a flash drive, or a folder dedicated to Octave projects. The default start-up directory (and many
other options) can be modified in the Octave start-up file .octaverc, or the Matlab-compatible
equivalent startup.m.

1.2.3 Workspace

Under the file menu, the option "save workspace as" will allow you to save all variables in the
current scope. The workspace panel lists the current variables. An individual variable can be
saved from the variable editor, described below. You can use the "load workspace" option under
the file menu to load previously saved variables. Alternately, a variable or workspace file can be
loaded by double-clicking on its name in the file browser.

Another approach is to use the manual save and load commands at the command line. If you
type save FILENAME var1 var2 ..., Octave will save the specified variables in the file FILENAME.
If you do not supply a list of variables, then all variables in the current scope will be saved. You
can then reload the saved variable(s) at another time by navigating to the appropriate directory
and using load FILENAME.

1.2.4 The variable editor

The variable editor allows displaying or editing a variable in a simple spreadsheet format. To use
it, double click on the name of the variable in the workspace panel. You can undock the variable
editor and maximize it is as a standalone window to facilitate working with larger arrays. If
you want to enter data in a variable that does not already exist, you will need to preallocate a
matrix of the correct size, for example using the command A = zeros(m, n) to create an m ื n
matrix of zeros. You can then open this in the variable editor and enter the data.
4                                             CHAPTER 1. GETTING STARTED

1.2.5 Getting help

The full Octave software manual is accessible by changing to the documentation tab at the
bottom of the screen, or the shell command help can be used at the Octave prompt. In particular,
if you know the name of the command you want to use, help NAME will give the correct syntax.
A basic command glossary is available in Appendix B.

Besides the present volume, here are two good free resources to help you get started quickly:

    Simple Examples (from the Octave Manual [3]):
      https://octave.org/doc/v4.0.1/Simple-Examples.html

    Wikibooks Tutorial:
      https://en.wikibooks.org/wiki/Octave_Programming_Tutorial

Additional help can be found with internet searches. Depending on what you are looking for,
searches for Octave commands and searches for Matlab commands can both be useful. Numer-
ous commercial user's guides and textbooks for Octave and/or Matlab are available. Linear
algebra textbooks sometimes contain Matlab code examples and these generally work in Octave
as well.

1.3 Matrices and vectors

1.3.1 Basic arithmetic

The best way to get started is to try some simple problems. Use the following examples as a
tutorial to learn your way around the program. Octave knows basic arithmetic and uses the
standard order of operations. Try some simple computations:

     >> 6/2 + 3 * ( 7 - 4 ) ^2
     ans = 30

Octave ignores white space, so 6/2 and 6 / 2 are interpreted the same way. You can't take
shortcuts and leave out implied operations, though. For example, 3(7 - 4) will give an error.
Use 3*(7 - 4).

Vectors and matrices are basic variable types, so it is easier to learn Octave syntax if you already
know a little linear algebra. Try this example to enter a row vector and name it u. You do not
need to enter the comments (indicated by the % sign).

   >> u = [ 1 -4 6 ]  % row vector
   u=                 % v a r i a b l e name

   1 -4 6             % output

The code u = . . . assigns the result of the operation that follows to the variable u, which can
then be recalled and used in further calculations.
1.3. MATRICES AND VECTORS                                 5

To create a column vector instead, use semicolons:

>> u = [ 1 ; -4; 6 ]    % column vector
u=                      % v a r i a b l e name

1                       % output

-4

6

Notice that the function of the semicolon is to begin a new row. The same basic syntax is used
to enter matrices. For example, here is how to define a 3 ื 3 matrix:

>> A = [ 1 2 -3; 2 4 0 ; 1 1 1 ]  % matrix
A=                                % v a r i a b l e name

1 2 -3                            % output
240
111

In Octave, all of the above variables are really just matrices of different dimensions. A scalar is
essentially a 1 ื 1 matrix. Similarly, a row vector is a 1 ื n matrix and a column vector is an
m ื 1 matrix. In the following sections we will take a closer look at the nuances of vector and
matrix operations.

1.3.2 Vector operations

We'll start with some simple examples. First, re-enter the column vector u from above, if it is
not already in memory.

     >> u = [ 1 ; -4; 6 ]

Now enter another column vector v and try the following vector operations which illustrate
linear combinations, dot product, cross product, and norm (length).

     >> v = [ 2 ; 1 ; -1]
     v=

  2
  1
-1

>> 2* v + 3*u           % linear combination
ans =

   7
-10

 16

>> dot ( u , v )        % dot product
ans = -8

>> c r o s s ( u , v )  % cross product
6                                                 CHAPTER 1. GETTING STARTED

   ans =                    % length of vector u

      -2
       13

         9

   >> norm ( u )
   ans = 7.2801

Try a few more operations:

    Find cross(v, u). How does that compare to u ื v?

    Calculate the length of v, ||v||, using norm(v).

    Normalize v by calculating v/||v||. This gives a unit vector that points in the same
      direction as v.

Now let's try a more complicated vector geometry problem, to see some of Octave's potential.

                                u จจจจ B
                                จจ
                            จจ
                                          E            E

                                projv(u)          v

                            Figure 1.2: Vector projection

The projection of u onto v, denoted projv(u), is the component of u that points in the direction
of v. This can be thought of as the shadow u casts onto v from a direction orthogonal to
v, as shown in Figure 1.2. To find the magnitude of the projection, use basic right-triangle
trigonometry:

                                                projv(u) = u cos()

Then, since u ท v = u v cos(),

                                projv(u)  = u cos()
                                          = u uทv u v
                                          = v uทv

This is known as the scalar projection of u onto v. The vector projection onto v is obtained by
multiplying the scalar projection by a unit vector that points in the direction of v. Thus,

                                                projv(u) = uทv v v v
                                                              = uทv v 2 (v)

Since v ท v = v 2, this can also be written as:
                                                                 uทv

                                                 projv(u) = v ท v (v)
1.3. MATRICES AND VECTORS                                                               7

The operations needed for vector projection are easily carried out in Octave. As an example,
we will find the projection of u = 3, 5 onto v = 7, 2 .

     >> u = [ 3 5 ]
     u=

           35

     >> v = [ 7 2 ]
     v=

           72

     >> dot ( u , v ) / ( norm ( v ) ) ^2* v
     ans =

           4.0943 1.1698

Thus projv(u) = 4.0943, 1.1698 . Later, in Example 5.5.2, we will see how to create our own
user-defined function to automate the above steps.

1.3.3 Matrix operations

Matrix operations are simple and intuitive in Octave. We'll start with multiplication.

        1 2 -3             1 2 34          

Let A =  2 4 0  and B =  0 -2 -4 6 . Find AB.

        11 1               1 -1 0 0

>> A = [ 1 2 -3; 2 4 0 ; 1 1 1 ]  % matrix
A=                                % v a r i a b l e name

1 2 -3                            % output
240
111

>> B = [ 1 2 3 4 ; 0 -2 -4 6 ; 1 -1 0 0 ]
B=

1234
0 -2 -4 6
1 -1 0 0

>> A*B                            % multiply A and B
ans =                             % result stored as ' ans '

-2 1 -5 16                        % answer
  2 -4 -10 32
  2 -1 -1 10

Notice that the result is stored in the temporary variable ans.
8                                              CHAPTER 1. GETTING STARTED

Arithmetic operations in Octave are always assumed to be matrix operations, unless otherwise
specified (see Section 1.4.1). Therefore, for A and B defined as above, we can compute things
like 4A or AB by entering, respectively, 4*A or A*B, but operations like B*A or A+B throw
errors (why?).

To get the transpose of a matrix, use the single quote2. For example, try calculating BT A.

   >> B' *A        % B' is the transpose of B
   ans =

   2         3 -2

   -3 -5 -7

   -5 -10 -9

   16 32 -12

To perform basic matrix arithmetic, we also need identity matrices, which are easy to generate
with the eye(n) command, where n is the dimension of the matrix. Let's find 2A - 4I.

   >> 2*A - 4* e y e ( 3 )  % eye (3) i s a 3x3 identity matrix
   ans =

   -2 4 -6
     440
     2 2 -2

Octave can also find determinants, inverses, and eigenvalues. For example, try these commands.

   >> d e t (A)                       % determinant
   ans = 6

   >> i n v (A)                       % matrix inverse
   ans =

   0.66667       -0.83333    2.00000
   0.33333        0.66667   -1.00000
   0.33333        0.16667
                             0.00000

   >> e i g (A)                       % eigenvalues
   ans =

   4.52510 + 0.00000 i
   0.73745 + 0.88437 i
   0.73745 - 0.88437 i

Notice that our matrix has one real and two complex eigenvalues. Octave handles complex
numbers, of course! Eigenvalues will be discussed in more detail in Chapter 5. Octave can also
compute many other matrix values, such as rank:

   >> rank (A)   % matrix rank
   ans = 3

    2Technically this gives the conjugate transpose, but for a matrix with real entries, there is no difference between
the conjugate transpose and the ordinary transpose.
1.4. PLOTTING  9

                              Figure 1.3: Default graph of y = sin(x) on [0, 2]

1.4 Plotting

Basic two-dimensional plotting of functions in Octave is accomplished by creating a vector for
the independent variable and a second vector for the range of the function. There are several
forms for the syntax and we will attempt to outline the simplest methods here3.

Let's start by plotting the graph of the function sin(x) on the interval [0, 2] (Figure 1.3). Like
a typical graphing calculator, Octave will simply plot a series of points and connect the dots
to represent the curve. The process is less automated in Octave (but in the end, much more
powerful). We begin by creating a vector of x-values.

     >> x = l i n s p a c e ( 0 , 2* pi , 5 0 ) ;

Notice the format linspace ( start val , end val, n). This creates a row vector of 50 evenly spaced
values beginning at 0 and going up to 2. The smaller the increment, the smoother the curve
will look. In this case, 50 points should be suitable. The semicolon at the end of the line is to
suppress the output to the screen, since we don't need to see all the values in the vector. Now,
we want to create a vector of the corresponding y-values. Use this command:

     >> y = s i n ( x ) ;

Now, to plot the function, use the plot command:
     >> p l o t ( x , y ) ;

    3See also http://www.gnu.org/software/octave/doc/interpreter/Plotting.html and http:
//en.wikibooks.org/wiki/Octave_Programming_Tutorial/Plotting
10  CHAPTER 1. GETTING STARTED

                             Figure 1.4: Improved graph of y = sin(x) on [0, 2]

You should see the graph of f (x) = sin(x) pop up in a new window.

Figure 1.3 shows the default graph. You may wish to customize it a little bit. For example,
the x-axis extends too far. We can set the window with the axis command. The window is
controlled by a vector of the form [Xmin Xmax Ymin Ymax]. Let's set the axes to match the
domain and range of the function.

     >> a x i s ( [ 0 2* p i -1 1 ] ) ;

We may want to change the color (to, say, red) or make the line thicker. We can add a grid to
help guide our eye. In addition, a graph should usually be labeled with a title, axis labels, and
legend. Try these options to get the improved graph shown in Figure 1.4.

     >> p l o t ( x , y , ' r ' , ' l i n e w i d t h ' , 3 )
     >> g r i d on
     >> x l a b e l ( ' x ' ) ;
     >> y l a b e l ( ' y ' ) ;
     >> t i t l e ( ' S i n e graph ' ) ;
     >> l e g e n d ( ' y=s i n ( x ) ' ) ;

Note that some adjustments, like zooming in, or turning on the grid, can be done within the
graph window using the controls provided. Some standard color options are red, green, blue,
cyan, and magenta, which can be specified with their first letter in single quotes.

Now, let's try plotting points. The procedure is essentially the same, but we use an option
to specify the marker we want. Some marker options are o, +, or *. We will plot the set of
points {(1, 1), (2, 2), (3, 5), (4, 4)} using circles as our marker. First, clear the variables from
1.4. PLOTTING                                                             11

               Figure 1.5: Scatter plot with regression line

the workspace and clear any existing graphs. Then define a vector of x-values and a vector of
y-values and use the plot command.

     >> c l e a r ; c l f ;
     >> x = [ 1 2 3 4 ]
     >> y = [ 1 2 5 4 ]
     >> p l o t ( x , y , ' o ' )

Now suppose we want to graph the line y = 1.2x on the same set of axes (this is the line of best
fit for this data). To add to our current graph we need to use the command hold on. Then any
new plots will be drawn onto the current axes. We can switch back later with hold off .

     >> h o l d on
     >> p l o t ( x , 1 . 2 * x )

Now we should see four points and the graph of the line. Alternately, we can create multiple
plots within a single plot command. Try this, for example:

>> c l e a r ; c l f ;                                         line ') ;
>> x = [ 1 2 3 4 ] ;
>> y1 = [ 1 2 5 4 ] ;
>> y2 = 1 . 2 * x ;
>> p l o t ( x , y1 , ' o ' , x , y2 )
>> a x i s ( [ 0 5 0 6 ] ) ;
>> g r i d on ;
>> l e g e n d ( ' data p o i n t s ' , ' r e g r e s s i o n

Notice that sets of input and output variables come in pairs, followed by any options that apply
to that pair. The result is shown in Figure 1.5.
12  CHAPTER 1. GETTING STARTED

                                        Figure 1.6: Graph of y = x2 sin(x)

1.4.1 Elementwise operations

An important consideration when working with a more complex function like, say, y = x2 sin(x),
is that Octave will regard the product and exponent as matrix operations, unless we indicate
otherwise. The same is true for division. To avoid errors when we are evaluating a function at a
numeric input vector, we need to use the elementwise versions of exponentiation, multiplication,
and division between variables. This is done by preceding the operation in question with a
period, as in .^ or .* or ./.

These commands are incorrect and will cause errors:
     >> x = l i n s p a c e ( -10 , 1 0 , 1 0 0 ) ;
     >> p l o t ( x , x ^2* s i n ( x ) ) % i n c o r r e c t s y n t a x : not e l e m e n t w i s e o p e r a t i o n s
     e r r o r : f o r A^b , A must be a s q u a r e matrix . Use . ^ f o r e l e m e n t w i s e power .
     e r r o r : evaluating argument l i s t element number 2

But this will do the trick:
     >> x = l i n s p a c e ( -10 , 1 0 , 1 0 0 ) ;
     >> p l o t ( x , x . ^ 2 . * s i n ( x ) ) % c o r r e c t : e l e m e n t w i s e exponent and p r o d u c t

The result is shown in Figure 1.6.

It is important to remember to use elementwise multiplication, exponentiation, and division,
except when you are actually intending to execute a matrix operation. Failing to do so is the
source of many errors and considerable frustration for beginning Octave users.
1.4. PLOTTING                                                                           13

1.4.2 Plot options

The following table summarizes some standard options that can be used with the plot command.

Plot options

marker         '+' crosshair                                  color 'k' black
               'o' circle                                                 ' r ' red
               '*' star                                                   'g' green
               ' . ' point                                                'b' blue
               ' s ' square                                               'm' magenta
               '^' triangle                                               'c' cyan

size           'linewidth' , n (n is some positive value)

               'markersize' , n

line style     ' -'   solid line (default)
               ' --'  dashed line
               ':'    dotted line

Several options may be combined. For example, plot(x, y, 'ro: ' ) indicates red color with circle
markers joined by dotted lines.

Here are several key functions for providing textual labels:

Plot labels                                      xlabel( ' axis name');
                                                 ylabel( ' axis name');
horizontal axis label . . . .                    legend('curve 1' , 'curve 2' , ...) ;
vertical axis label . . . . . .                  title ( ' plot title ' ) ;
legend . . . . . . . . . . . . . . . . . . .
title . . . . . . . . . . . . . . . . . . . . .

The position of the legend may be modified using the command legend(' location ' , ' position ' ),
where "position" is a string giving a compass position, like northeast (which is the default),
north, south, east, southwest, etc. Type help legend for a full list of options.

1.4.3 Saving plots

If we have created a good plot, we probably want to save it. The easiest option is to use copy
and paste from the plot window. You can also use the "save as" option under the file menu to
save the plot in various image formats.

An alternate method is to save the plot directly by "printing" it to a file. Octave supports
several image formats. In the example below, the png format is used. To save the current graph
as a png, use this syntax:

     >> p r i n t f i l e n a m e . png -dpng

Here filename.png is whatever file name you want (include the extension). You can replace
png with other image formats, such as jpg or eps. The file will be saved in your current working
directory.
14                                  CHAPTER 1. GETTING STARTED

Chapter 1 Exercises

Begin each problem with no variables stored. You can clear any previous results with the
command clear.

1. For practice saving and loading variables, try the following.

(a) Create a new directory called "octave projects".
(b) Change to the octave projects directory.
(c) Save the example matrices A and B from above in a text file named matrices.mat.
(d) Quit Octave.
(e) Restart Octave and reload the saved matrices.

2. Let u = 2, -4, 0 and v = 3, 1.5, -7 . Find each of the following.

(a) w = 2u + 5v
(b) d = u ท v
(c) l = ||u||
(d) u1 = a unit vector that points in the direction of u
(e) n = a vector orthogonal to both u and v
(f) p = projv(u)

Be sure to use the variable names indicated to store your answers. Save your workspace
including all of the required variables. What does the dot product reveal about u and v?
How did you produce a vector mutually orthogonal to u and v?

3. Enter the following matrices.

  1 -3 5                            1 -1 0 0                            100  

A =  2 -4 3  , B =  -3 0 7 -6  , and I3 =  0 1 0  .

  0 1 -1                            2 1 -2 -1                           001

Use Octave to compute each of the following.

 (a) d = det(A)
 (b) r = rank(B)
 (c) C = 2A + 4I
 (d) D = A-1
 (e) E = AB
 (f) F = BT AT

Use the variable names indicated to store your answers. Save your workspace including all
of the required variables. Did you notice anything about AB and BT AT ? If so, explain
the relationship between these quantities.
EXERCISES                                                                                  15

4. Plot the following set of points, using triangle markers:

           {(-1, 5), (1, 4), (2, 2.5), (3, 0)}

   Turn on the grid. Give the plot the title "Scatter plot" and save it as a png or jpg image
   file.

5. Modify the plot of y = x2 sin(x) given in Figure 1.6 as follows:

     (a) Make the graph of y = x2 sin(x) a thick red line.
    (b) Graph y = x2 and y = -x2 on the same axes, as thin black dotted lines.
     (c) Use a legend to identify each curve.
    (d) Add a title.
     (e) Add a grid.

   Save the plot as a png or jpg image file.
6. Let f (x) = 2 - ex-1.

(a) Plot a graph of the function as a thick blue line on [-3, 3] ื [-5, 5]. Note that exp(x)
     can be used for the exponential function.

(b) Add the function's horizontal asymptote to your figure as a dashed black line. The
     ones command provides a useful trick for the required constant term:

           >> % p l o t c o n s t a n t f u n c t i o n y = k
           >> p l o t ( x , k* o n e s ( s i z e ( x ) ) )

(c) Add a graph of the "parent function," y = ex, on the same axes as a thin red line.

(d) Add a legend to your figure identifying the three curves as "transformed exponential
     function," "horizontal asymptote," and "parent function."

(e) You have probably noticed that our graphs do not show the traditional x- and y-
     coordinate axes--and usually this is not a problem. But, for this graph we will add
     them. Here is one method that can be used:

           >> % p l o t x- and y-c o o r d i n a t e a x e s a s t h i n b l a c k  lines
           >> % [ a b ] = h o r i z o n t a l a x i s l i m i t s
           >> % [ c d ] = v e r t i c a l a x i s l i m i t s
           >> p l o t ( [ a b ] , [ 0 0 ] , ' k ' , [ 0 0 ] , [ c d ] , ' k ' )

With the coordinate axes plotted manually, we may now wish to turn off the default
box-format axes:

     >> a x i s o f f

(f) Showing the coordinate axes makes the intercepts more clearly apparent. Highlight
     them by adding circle markers at the x- and y-intercepts. Use the text function to
     label these points with their coordinates. This is the syntax to use:

          >> % add a t e x t l a b e l t o p l o t a t c o o r d i n a t e s ( x , y )
          >> t e x t ( x , y , ' l a b e l ' )

Save the plot as a png or jpg image file.
16                                           CHAPTER 1. GETTING STARTED

    7. The load command described in Section 1.2.3 works well for loading data that is in Octave
       format. But sometimes it is necessary to import data that is not already in Octave format.
       For data in a spreadsheet document (or that can be copied into a spreadsheet to manipu-
       late), the simplest option is to save your data as a csv file (comma-separated values) and
       load it in Octave using csvread('filename.csv' ). This really only works for purely numeric
       data, so if necessary, remove any special formatting and strip out text headings and labels.
       For practice with this useful method of importing data, try the following exercise:

       Enter the data matrix shown below in a spreadsheet program, like LibreOffice Calc4 (or
       Excel):

                                      A   BC

                                   1  1   2  3

                                   2  -1  0 0.2

                                   3 =A1+A2 =pi() =7/3

    The formulas on line 3 should evaluate to decimal values. Save the resulting data as
    example1.csv. Navigate to the appropriate directory and load the example matrix in
    Octave using this command:

         >> A = c s v r e a d ( ' example1 . c s v ' )

    Then, save A as an Octave-format data file, example1.mat.

    4https://www.libreoffice.org/
Chapter 2

Matrices and linear systems

Octave is a powerful tool for many problems in linear algebra. We have already seen some of the
basics in Section 1.3. In this chapter, we will consider systems of linear equations, polynomial
curve fitting, and matrix transformations.

2.1 Linear systems

2.1.1 Gaussian elimination

Octave has sophisticated algorithms built in for solving systems of linear equations, but it is
useful to start with the more basic process of Gaussian elimination. Using Octave for Gaus-
sian elimination lets us practice the procedure, without the inevitable arithmetic errors that
come when doing elimination by hand. It also teaches useful Octave syntax and methods for
manipulating matrices.
Row operations are easy to carry out. But first, we need to see how matrices and vectors are
indexed in Octave. Consider the following matrix.

     >> B = [ 1 2 3 4 ; 0 -2 -4 6 ; 1 -1 0 0 ]
     B=

           1234
           0 -2 -4 6
           1 -1 0 0

If we enter B(2, 3), then the value returned is -4. This is the scalar stored in row 2, column 3.
We can also pull out an entire row vector or column vector using the colon operator. A colon
can be used to specify a limited range, or if no starting or ending value is specified, it gives the
full range. For example, B(1, :) will give every entry out of the first row.

     >> B( 1 , : ) % from matrix B : row 1 , a l l columns
     ans =

                                                             17
18                    CHAPTER 2. MATRICES AND LINEAR SYSTEMS

    1234

Now, let's use this notation to carry out basic row operations on B to reach row echelon form.

Example 2.1.1. Consider the system of linear equations represented by the augmented matrix

                        12 34            

                      B =  0 -2 -4 6 

                        1 -1 0 0

Use row operations to put B into row echelon form, then solve by backward substitution. Com-
pare to the row-reduced echelon form computed by Octave.

    Solution. The first operation is to replace row 3 with -1 times row 1, added to row 3.

         >> % new row 3 = -1*row 1 + row 3
         >> B( 3 , : ) = ( -1) *B( 1 , : ) + B( 3 , : )
         ans =

               1234
               0 -2 -4 6
               0 -3 -3 -4

    Next, we will replace row 3 with -1.5 times row 2, added to row 3.

         >> % new row 3 = -1.5* row 2 + row 3
         >> B( 3 , : ) = -1.5*B( 2 , : ) + B( 3 , : )
         ans =

               123 4
               0 -2 -4 6
               0 0 3 -13

    The matrix is now in row echelon form. We could continue using row operations to reach
    row-reduced echelon form, but it is more efficient to simply write out the corresponding linear
    system on paper and solve by backward substitution. The solution vector is 173 , 173 , - 133 .

    Octave also has a built-in command, rref , to find the row-reduced echelon form of the matrix
    directly.

         >> r r e f (B)
         ans =

    1.00000  0.00000  0.00000   5.66667
    0.00000  1.00000  0.00000   5.66667
    0.00000  0.00000  1.00000  -4.33333

    From here, the solution to the system is evident. Notice that everything is now expressed
    as floating point numbers (i.e., decimals). Five decimal places are displayed by default. The
    variables are actually stored with higher precision and it is possible to display more decimal
    places, if desired (type: format long).
2.1. LINEAR SYSTEMS                                                  19

2.1.2 Left division

The built-in operation for solving linear systems of the form Ax = b in Octave is called left
division and is entered as A\b. This is "conceptually equivalent" to the product A-1b ([3]).
Let's try the left division operation on the system from the prior example, with augmented
matrix B.

Example 2.1.2. Use left division to solve the system of equations with augmented matrix B.

                       12 34                    

                     B =  0 -2 -4 6 

                       1 -1 0 0

Solution. To use left division, we need to extract the coefficient matrix and vector of right-
side constants. Let's call the coefficient matrix A and the right-side constants b. (You have
probably already noticed that Octave is case-sensitive.)

     >> B = [ 1 2 3 4 ; 0 -2 -4 6 ; 1 -1 0 0 ] % re-e n t e r B, i f n e c e s s a r y
     B=

1234
0 -2 -4 6
1 -1 0 0

>> A = B ( : , 1 : 3 ) % e x t r a c t c o e f f i c i e n t matrix
A=

123
0 -2 -4
1 -1 0

>> b = B ( : , 4 )   % extract right side constants
b=

4
6
0

>> A\b               % s o l v e system Ax = b
ans =

 5.6667
 5.6667
-4.3333

The solution vector matches what we found by Gaussian elimination.

2.1.3 LU decomposition

LU decomposition is a matrix factorization that encodes the results of the Gaussian elimination
algorithm. The goal is to write A = LU , where L is a unit lower triangular matrix and U is an
20                        CHAPTER 2. MATRICES AND LINEAR SYSTEMS

upper triangular matrix. We will see that this factored form can be used to easily solve Ax = b.

The process is best explained with an example. We will not attempt to justify why the algorithm
works; refer to [6] for the underlying theory.

Example 2.1.3. Find an LU decomposition for                          
                                                                 3
                                                                -4 
                                                          12
                                                                 0
                                                 A =  0 -2

                                                          1 -1

    Solution. This is the same coefficient matrix we row-reduced in Example 2.1.1. We proceed
    the same way, carefully noting the multiplier used to obtain each 0. The lower triangular
    L starts as an identity matrix, then the negative of each multiplier used in the elimination
    process is placed into the corresponding entry of L.

    The first zero in position (2, 1) is already there, so we put 0 for that multiplier in the corre-
    sponding position of L. Then we replace row 3 with -1 times row 1 plus row 3. The negative
    of this multiplier is -(-1) = 1, which is entered in L at the point where the 0 was obtained.

    At this point, we have two entries for L along with a partly reduced A:

                 12 3                          12 3                        100   

             A =  0 -2 -4    0 -2 -4  ; L =  0 1 0 

                 1 -1 0                        0 -3 -3                     1?1

    The next step is to replace row 3 using -1.5 times row 2. Thus we put -(-1.5) = 1.5 in
    the corresponding position of L. Once A has reached row echelon form, we have the desired
    upper triangular matrix U .

               12 3         12 3                                         12 3  

    A =  0 -2 -4    0 -2 -4    0 -2 -4  = U

               1 -1 0       0 -3 -3                                      00 3

                          100                                     12 3     

                 L =  0 1 0  , U =  0 -2 -4 

                          1 1.5 1                                 00 3

    So, to review, U is the row echelon form of A and L is an identity matrix with the negatives
    of the Gaussian elimination multipliers placed into the corresponding positions where they
    were used to obtain zeros.

    Let's check to see if it worked.

         >> L = [ 1 0 0 ; 0 1 0 ; 1 1 . 5 1 ]
         L=

    1.00000    0.00000    0.00000
    0.00000    1.00000    0.00000
    1.00000    1.50000    1.00000
2.1. LINEAR SYSTEMS                                                             21

>> U = [ 1 2 3 ; 0 -2 -4; 0 0 3 ]
U=

      123
      0 -2 -4
      003

>> L*U
ans =

      123
      0 -2 -4
      1 -1 0

It worked! In fact, the procedure outlined in this example will work anytime Gaussian elimi-
nation can be performed without row interchanges.

Now, let's see how the LU form can be used to solve linear systems Ax = b. If A = LU , then
the system Ax = b can be written as LU x = b. Let U x = y. Then we can proceed in two
steps:

1. Solve Ly = b.
2. Solve U x = y.

Since we are dealing with triangular matrices, each step is easy.
                                                                     
                                           12 3                         4

Example 2.1.4. Solve Ax = b, where A =  0 -2 -4  and b =  6 , using LU decom-

                                           1 -1 0                    0

position.

                                                                     100      

Solution. We already have the LU decomposition. Since L =  0 1 0  , the first step

                                                                     1 1.5 1

is to solve:                                  

                       100                 y1        4

                      0 1 0  ท  y2  =  6 

                       1 1.5 1             y3        0

The corresponding systems of equations is

                       y1                          =4

                                   y2              =6

                       y1 + 1.5y2 + y3 = 0

Starting with the first row and working down, this system is easily solved by forward substi-

tution. We can see that y1 = 4 and y2 = 6. Substituting these values into the thirdequation
                                                                                                        4

and solving for y3 gives y3 = -13. Thus the intermediate solution for y is  6 .
                                                                                                      -13
22                            CHAPTER 2. MATRICES AND LINEAR SYSTEMS

    Step two is to solve U x = y, which looks like:

                              12 3                              4  
                                                     x1
                             0 -2 -4  ท  x2  =  6 

                              00 3                   x3     -13

                                                                   17/3  

    This is easily solved by backward substitution to get x =  17/3 .

                                                                -13/3

If row interchanges are used, then A is multiplied by a permutation matrix and the decomposition
takes the form P A = LU . This is the default form of the LU decomposition given by Octave
using the command [L U P] = lu(A).

Example 2.1.5. Find an LU decomposition (with permutation) for

                                                              
                                       -7 -2         94

                              A =  -4 -9  -3 4       3   0  
                                                            
                                                     6 -2 

                                            6 7 -4 -8

    Solution. We will use Octave for this.

    >> A = [-7 -2 9 4 ; -4 -9 3 0 ; -3 4 6 -2; 6 7 -4 -8]
    A=

    -7 -2 9 4
    -4 -9 3 0
    -3 4 6 -2

      6 7 -4 -8

    >> [ L U P ] = l u (A)
    L=

     1.00000   0.00000        0.00000       0.00000
     0.57143   1.00000        0.00000       0.00000
    -0.85714  -0.67273        1.00000       0.00000
     0.42857  -0.61818        0.36000       1.00000

    U=

    -7.00000  -2.00000         9.00000       4.00000
     0.00000  -7.85714        -2.14286      -2.28571
     0.00000                                -6.10909
     0.00000   0.00000         2.27273      -2.92800
               0.00000         0.00000

    P=

    Permutation Matrix

    1000
    0100
2.2. POLYNOMIAL CURVE FITTING                                                             23

               0001
               0010

   Then we have the factorization P A = LU , where P A is a row-permutation of A.

Refer to Exercise 4 to see how P A = LU can be used to solve a linear system, using a method
almost to identical to what we did in Example 2.1.4.

LU decomposition is widely used in numerical linear algebra. In fact, it is the basis of how
Octave's left division operation works. It is especially efficient to use LU decomposition when
one is solving several systems of equations that all have the same coefficient matrix, but different
right side constants. The LU decomposition only needs to be done once for all of the systems
with that coefficient matrix.

2.2 Polynomial curve fitting

In statistics, the problem of fitting a straight line to a set of data is often considered. We tackle
the more general problem of fitting a polynomial to a set of points.

Example 2.2.1. Set-up and solve the normal equations to find the least-squares parabola for

the set of points in the following 6 ื 2 data matrix D.

                                       1 1 

                    2                  2
                                             
              D =  3                   5     
                    4                        
                    5                  4     
                                             
                                       2

                                       6 -3

The matrix shows x-values in column 1 and y-values in column 2.

Solution. Enter the data matrix in Octave and extract the x- and y-data to column vectors.
Then plot the points to get a sense of what the data look like.

>> D = [ 1 1 ; 2 2 ; 3 5 ; 4 4 ;       5 2; 6 -3]        segments  with  circle  markers
>> xdata = D( : , 1 )                   % plot line
>> ydata = D( : , 2 )
>> p l o t ( xdata , ydata , ' o- ' )

In this case, we are constructing a model of the form y = ax2 + bx + c, but it is easy to see

how our approach generalizes to polynomials of any degree (including linear functions). By

plugging in the given data to the proposed equation, we obtain the following system of linear

equations.   1 1 1                                       1

             4 2 1    2 
                                       a  
             9 3 1   16 4 1  ท  b  =  5   4 
                                       c                 
             25 5 1                                      2

              36 6 1                                     -3
24                          CHAPTER 2. MATRICES AND LINEAR SYSTEMS

    Notice the form of the coefficient matrix, which we'll call A. The third column is all ones, the
    second column is the x-values, and the first column is the square of the x-values (this column
    would not appear if we were using a linear model). The corresponding right-side constants
    are the y-values. There are several ways to construct the coefficient matrix in Octave. One
    approach is to use the ones command to create a matrix of ones of the appropriate size, and
    then overwrite the first and second columns with the correct data.

         >> A = o n e s ( 6 , 3 ) ;
         >> A( : , 1 ) = xdata . ^ 2 ;
         >> A( : , 2 ) = xdata
         A=

                111
                421
                931
               16 4 1
               25 5 1
               36 6 1

    Note the use of elementwise exponentiation to square each value of the x-data vector. Our

    system is inconsistent. It can be shown that the least-squares solution comes from solving
                                                                                      a

    the normal equations, AT Ap = AT y, where p is the vector  b  of polynomial coefficients.

                                                                                      c

    We can use Octave to construct the normal equations.

         >> A' *A
         ans =

    2275 441 91

    441            91 21

        91         21  6

    >> A' * ydata
    ans =

    60
    28
    11

    The corresponding augmented matrix is:

                            2275 441 91 60                

                           441 91 21 28 

                            91 21 6 11

    We can then solve the problem using Gaussian elimination. Here is one way to create the
    augmented matrix and row-reduce it:

         >> B = A' *A;
         >> B ( : , 4 ) = A' * ydata ;
2.2. POLYNOMIAL CURVE FITTING                       25

                Figure 2.1: Least-squares parabola

>> r r e f (B)  0.00000  0.00000   -0.89286
ans =           1.00000  0.00000    5.65000
                0.00000  1.00000
      1.00000                      -4.40000
      0.00000
      0.00000

Thus the correct quadratic equation is y = -0.89286x2 + 5.65x - 4.4.

Now we plot a graph of this parabola together with our original data points. These are the
commands used to create the graph:

     >> x = l i n s p a c e ( 0 , 7 , 5 0 ) ;
     >> y = -0.89286* x . ^ 2 + 5 . 6 5 * x - 4 . 4 ;
     >> p l o t ( xdata , ydata , ' o ' , x , y , ' l i n e w i d t h ' , 2 )
     >> g r i d on ;
     >> l e g e n d ( ' data v a l u e s ' , ' l e a s t -s q u a r e s p a r a b o l a ' )
     >> t i t l e ( ' y = -0.89286 x ^2 + 5 . 6 5 x - 4 . 4 ' )

The graph is shown in Figure 2.1.

You may be wondering if any of this process can be automated by built-in Octave functions.
Yes! If we want Octave to do all of the work for us, we can use the built-in function for
polynomial fitting, polyfit . The syntax is polyfit (x, y, order), where "order" is the degree of
the polynomial desired.

Octave is configured to work with polynomials by associating their coefficients with a simple
26  CHAPTER 2. MATRICES AND LINEAR SYSTEMS

                              Figure 2.2: Plot of original data vs. polyfit data

row vector. For example, [2 -3 4] corresponds to 2x2 - 3x + 4. The polyval function can be
used to evaluate an Octave-format polynomial using the syntax polyval(P, x).
Example 2.2.2. Use polyfit to find the least-squares parabola for the following data:

                                               x12345 6
                                               y 1 2 5 4 2 -3

Graph the original data and polyfit data together on the same axes.

   Solution. This is the same data as in Example 2.2.1. Re-enter the data values if necessary.
   We use polyfit to determine the equation, then the polyval function to evaluate the polyno-
   mial at the given x-values.

        >> P = p o l y f i t ( xdata , ydata , 2 ) % d e g r e e two p o l y n o m i a l f i t
         P=

             -0.89286 5.65000 -4.40000
        >> y = p o l y v a l (P , xdata ) ; % e v a l u a t e p o l y n o m i a l P a t i n p u t xdata
        >> p l o t ( xdata , ydata , ' o- ' , xdata , y , '+- ' ) ;
        >> g r i d on ;
        >> l e g e n d ( ' o r i g i n a l data ' , ' p o l y f i t data ' ) ;

   The graph is shown in Figure 2.2.
2.3. MATRIX TRANSFORMATIONS                            27

   T                         t
3                            d

2     t                         d
                                   d
                                      d
                                         dt

1

      t                         t                   E
                                                5
      1                      2  3            4
         Figure 2.3: House graph

2.3 Matrix transformations

Matrices and matrix transformations play a key role in computer graphics. There are several
ways to represent an image as a matrix. The approach we take here is to list a series of vertices
that are connected sequentially to produce the edges of a simple graph. We write this as a 2 ื n
matrix where each column represents a point in the figure. As a simple example, let's try to
encode a "house graph." First, we draw the figure on a grid and record the coordinates of the
points, as in Figure 2.3.

There are many ways to encode this in a matrix. An efficient method is to choose a path that
traverses each edge exactly once, if possible1. Here is one such matrix, starting from (1, 2) and
traversing counterclockwise.

                                           D= 1 1 3 3 2 1 3
                                                    2002322

Try plotting it in Octave and see if it worked.
     >> D = [ 1 1 3 3 2 1 3 ; 2 0 0 2 3 2 2 ]
     D=

           1133213
           2002322

     >> x = D( 1 , : ) ;
     >> y = D( 2 , : ) ;
     >> p l o t ( x , y ) ;

You may want to zoom out to see the origin. Then the graph appears correct.

    1This is called an Eulerian path. Such a path exists if the graph has exactly 0 or 2 vertices with odd degree.
28                        CHAPTER 2. MATRICES AND LINEAR SYSTEMS

2.3.1 Rotation

Now that we have a representation of a digital image, we consider various ways to transform it.
Rotations can be obtained using multiplication by a special matrix.

A rotation of the point (x, y) about the origin is given by

                          Rท x
                                 y

where

                R = cos() - sin()
                         sin() cos()

and  is the angle of rotation (measured counterclockwise).

For example, what happens to the point (1, 0) under a 90 rotation?

       cos(90) - sin(90)  1                                      0 -1            1  0
       sin(90) cos(90) ท 0 = 1 0 ท 0 = 1

The rotation appears to work, at least in this case. Try a few more points to convince your-
self. Notice that a rotation about the origin corresponds to moving along a circle, thus the
trigonometry is fairly straightforward to work out.

Now, to produce rotations of a data matrix D, encoded as above, we only need to compute the
matrix product RD.

Example 2.3.1. Rotate the house graph through 90 and 225.

Solution. Note that each  must be converted to radians. Here we go:

     >> D = [ 1 1 3 3 2 1 3 ; 2 0 0 2 3 2 2 ] ;
     >> x = D( 1 , : ) ;
     >> y = D( 2 , : ) ;

       >> % e x e c u t e a 90 d e g r e e r o t a t i o n       sin ( theta1 )  cos ( theta1 ) ] ;
       >> t h e t a 1 = 90* p i / 1 8 0 ;
       >> R1 = [ c o s ( t h e t a 1 ) -s i n ( t h e t a 1 ) ;
       >> RD1 = R1*D;
       >> x1 = RD1( 1 , : ) ;
       >> y1 = RD1( 2 , : ) ;

       >> % e x e c u t e a 225 d e g r e e r o t a t i o n      sin ( theta2 )  cos ( theta2 ) ] ;
       >> t h e t a 2 = 225* p i / 1 8 0 ;
       >> R2 = [ c o s ( t h e t a 2 ) -s i n ( t h e t a 2 ) ;
       >> RD2 = R2*D;
       >> x2 = RD2( 1 , : ) ;
       >> y2 = RD2( 2 , : ) ;

       >> % p l o t o r i g i n a l and r o t a t e d f i g u r e s
       >> p l o t ( x , y , ' bo- ' , x1 , y1 , ' ro- ' , x2 , y2 , 'mo- ' )
2.3. MATRIX TRANSFORMATIONS                                                                     29

                                Figure 2.4: Rotations of the house graph

     >> a x i s ([ -4 4 -4 4 ] , ' e q u a l ' ) ;
     >> g r i d on ;
     >> l e g e n d ( ' o r i g i n a l ' , ' r o t a t e d 90 deg ' , ' r o t a t e d 225 deg ' ) ;

Note the combined plot options to set color, marker, and line styles. The original and rotated
graphs are shown in Figure 2.4. Notice that the rotation is about the origin. For rotations
about an arbitrary point, see Exercise 14.

2.3.2 Reflection

If is a line through the origin, then a reflection of the point (x, y) in the line is given by

                             Rท x
                                    y

where                               R = cos(2) sin(2)
and  is the angle                             sin(2) - cos(2)

                   makes with the x-axis (measured counterclockwise).

For example, what matrix represents a reflection in the line y = x? Here  = 45.

cos(2 ท 45) sin(2 ท 45)      cos(90) sin(90)                           01
sin(2 ท 45) - cos(2 ท 45) = sin(90) - cos(90) = 1 0
30                                      CHAPTER 2. MATRICES AND LINEAR SYSTEMS

    Figure 2.5: Reflection of the house graph

What is the effect of this matrix on a point (x, y)?

                                        01 ท x = y
                                        10  y         x

We see that the point is indeed reflected in the line y = x.

Example 2.3.2. Reflect the house graph in the line y = x.

    Solution. With the data matrix D and the original x and y vectors already defined, and
    using R as determined above, we have:

         >> R = [ 0 1 ; 1 0 ]
         R=

               01
               10

         >> RD = R*D;
         >> x1 = RD( 1 , : ) ;
         >> y1 = RD( 2 , : ) ;
         >> p l o t ( x , y , ' o- ' , x1 , y1 , ' o- ' )
         >> a x i s ([ -1 4 -1 4 ] , ' e q u a l ' ) ;
         >> g r i d on ;
         >> l e g e n d ( ' o r i g i n a l ' , ' r e f l e c t e d ' )

    The result is shown in Figure 2.5.
2.3. MATRIX TRANSFORMATIONS                                                          31

                Figure 2.6: Dilation of the house graph

2.3.3 Dilation

Dilation (i.e., expansion or contraction) can also be accomplished by matrix multiplication. Let
                                                     T= k 0
                                                               0k

Then the matrix product T D will expand or contract D by a factor of k.
Example 2.3.3. Expand the house graph by a factor of 2.

Solution. To scale by a factor of 2, we only need to multiply D by the matrix  20 .
                                                                               02
     >> T = [ 2 0 ; 0 2 ]
     T=

20
02

>> TD = T*D;
>> x1 = TD( 1 , : ) ; y1 = TD( 2 , : ) ;
>> p l o t ( x , y , ' o- ' , x1 , y1 , ' o- ' )
>> a x i s ([ -1 7 -1 7 ] , ' e q u a l ' ) ;
>> g r i d on ;
>> l e g e n d ( ' o r i g i n a l ' , ' expanded ' )

The result is shown in Figure 2.6.
32  CHAPTER 2. MATRICES AND LINEAR SYSTEMS

2.3.4 Linear and nonlinear transformations

Rotation, reflection, and dilation are examples of linear transformations, and therefore can be
represented as matrix products. However, not all of the graphical operations we are interested
in are linear in this sense. In particular, translation is a nonlinear transformation which could
instead be accomplished by matrix addition. But, in fact even a translation can be completed
using a special kind of matrix product with homogeneous coordinates. Refer to Exercises 13-14
for some of the details and an example. This method preserves some of the properties of the
linear transformations of the preceding sections.

If we use only multiplication for transformations, the composition of several transformations
can be handled with the relatively simple operation of composing matrix multiplications. Fur-
thermore, inverse transformations are easily produced by inverting the original transformation
matrix2. For example, if T is a translation, R is a rotation, and S is a stretch, the combined
operations of first translating, then rotating, then stretching can be completed with the matrix
SRT and a data matrix D can be transformed with the product (SRT )D. The inverse of these
combined operations is (SRT )-1 = T -1R-1S-1. Note that order matters!

    2Rotation and reflection matrices, in particular, are easily inverted, since they are orthogonal (see Section 5.3.1).
EXERCISES                                                                   33

Chapter 2 Exercises

1. Solve the system of equations using Gaussian elimination row operations
                                            
                                             -x1 + x2 - 2x3 = 1
                                             x1 + x2 + 2x3 = -1
                                                  x1 + 2x2 + x3 = -2

To document your work in Octave, click "select all," then "copy" under the edit menu,
and paste your work into a Word or text document. After you have the row echelon form,
solve the system by hand on paper, using backward substitution.

2. Use the multipliers from Exercise 1 to write an LU decomposition for

                                      -1 1 -2  

                     A= 1 1 2 

                                      12 1

Use this factorization to solve the system Ax = b, where b = -3, 1, 4 .

3. Consider the system of linear equations Ax = b, where

                                                          
                              1 -3    5                   1

                     A =  2 -4        3  and b =  -1 

                     0 1 -1                               3

Solve the system using left division. Then, construct an augmented matrix B and use rref
to row-reduce it. Compare the results.

4. Use LU decomposition to solve the system from Exercise 3. Use Octave's [L U P] = lu(A)

command. To use P A = LU to solve Ax = b, first multiply through by P , then replace

P A with LU :

                                    Ax = b

                     P Ax = P b

                     LU x = P b

Solve Ly = P b using forward substitution. Then solve U x = y using back substitution.

5. If A is a singular matrix, Ax = b has no solutions or infinitely many solutions depending
   on b. How does Octave handle inconsistent systems, and in general, how does left division
   react to a singular coefficient matrix?

(a) To explore this question, let's turn our previous system into an inconsistent one. Let
     A and b be the matrices from Exercise 3. To construct an inconsistent system, we
     will make one row of the coefficient matrix into a linear combination of some other
     rows, without making the corresponding adjustment to the right-side constants. Do
     the following:

          >> A( 1 , : ) = 3*A( 2 , : ) - 4*A( 3 , : )

Now Ax = b should be an inconsistent system. Try to solve it using left division.
Does Octave provide a solution? Compare the results of left division with the row-
reduced echelon form. How can you see that the system is inconsistent?
34                                   CHAPTER 2. MATRICES AND LINEAR SYSTEMS

        (b) Now let's consider a consistent system with infinitely many solutions. Keep A as
              above and make the corresponding adjustments to the right-side constants, yielding
              a system with infinitely many solutions.

                    >> b ( 1 , : ) = 3*b ( 2 , : ) - 4*b ( 3 , : )

              Now solve Ax = b using left division. Compare to the row-reduced echelon form.

       The take away from these examples is that Octave will always give a solution when left
       division is used. If there are infinitely many solutions, a particular solution is given. If
       there are no solutions, Octave provides the least-squares (best-fitting) solution. It is always
       advisable to check the row-reduced echelon form of the coefficient matrix!

    6. Octave can easily solve large problems that we would never consider working by hand.
       Let's try constructing and solving a larger system of equations. We can use the command
       rand(m, n) to generate an mืn matrix with entries uniformly distributed from the interval
       (0, 1). If we want integer entries, we can multiply by 10 and use the floor function to chop
       off the decimal.

       Use this command to generate an augmented matrix M for a system of 25 equations in 25
       unknowns:

             >> M = f l o o r ( 1 0 * rand ( 2 5 , 2 6 ) ) ;

    Note the semicolon. This suppresses the output to the screen, since the matrix is now too
    large to display conveniently. Solve the system of equations using rref and/or left division
    and save the solution as a column vector x.

    7. Consider the following data.

         x2358
         y3445

    (a) Set up and solve the normal equations by hand to find the line of best fit, in y = mx+b
         form, for the given data. Check your answer using polyfit (x, y, 1).

    (b) Compare to the solution found using Octave's left division operation directly on the
         relevant (inconsistent) system:

                                       21    
                                                3

                                      3 1   5 1  m   ท b =  4   4 

                                       81    5

         (c) Plot a graph showing the data points and the regression line.

    8. Use following commands to generate a randomized sample of 21 evenly spaced points from
       x = 0 to x = 200 with a high degree of linear correlation. We start with a line through
       the origin with random slope m, then add some "noise" to each y-value.

             >> m = 2* rand - 1
             >> x = [ 0 : 10 : 2 0 0 ] '
             >> y = m*x + 10* rand ( s i z e ( x ) )
EXERCISES                    35

Use the polyfit function to find the least squares regression line for this data. Plot the
data and the best-fitting line on the same axes. Run the simulation several times, then
save two example plots which exhibit greater and lesser amounts of variation from the line
y = mx.

9. On July 4, 2006, during a launch of the space shuttle Discovery, NASA recorded the
   following altitude data3.

Time (s)    Altitude (ft)
         0                7
        10
        20             938
        30           4,160
        40           9,872
        50          17,635
        60          26,969
        70          37,746
        80          50,548
        90          66,033
                    83,966
      100         103,911
      110         125,512
      120         147,411

(a) Find the quadratic polynomial that best fits this data. Use Octave to set-up and
     solve the normal equations. After you have the equations set up, solve using either
     the rref command or the left-division operator.

(b) Plot the best-fitting parabola together with the given data points. Save or print the
     plot. Your plot should have labeled axes and include a legend.

(c) Use the first and second derivatives of the quadratic altitude model from part (a) to
     determine models for the vertical component of the velocity and acceleration of the
     shuttle. Estimate the velocity two minutes into the flight.

10. There are many situations where the polynomial models we have considered so far are
     not appropriate. However, sometimes we can use a simple transformation to linearize the
     data. For example, if the points (x, y) lie on an exponential curve, then the points (x, ln y)
     should lie on a straight line. To see this, assume that y = Cekx and take the logarithm of
     both sides of the equation:

                                                   y = Cekx
                                                ln y = ln Cekx

                                                        = ln C + ln ekx
                                                        = kx + ln C

    Make the change of variables Y = ln y and A = ln C. Then we have a linear function of
    the form

                                                       Y = kx + A

3https://www.nasa.gov/pdf/585034main_ALG_ED_SSA-Altitude.pdf
36            CHAPTER 2. MATRICES AND LINEAR SYSTEMS

    We can find the line that best fits the (x, Y )-data and then use inverse transformations to
    obtain the exponential model we need:

                                                         y = Cekx

    where

                                            C = eA

    Consider the following world population data4:

    x = year  y = population (in millions)  Y = ln y
      1900                   1650            7.4085
      1910                   1750
      1920                   1860
      1930                   2070
      1940                   2300
      1950                   2525
      1960                   3018
      1970                   3682
      1980                   4440
      1990                   5310
      2000                   6127
      2010                   6930

    (a) Fill in the blanks in the table with the values for ln y. Note that in Octave, the log(x)
         command is used for the natural logarithm. Make a scatter plot of x vs. Y . This is
         called a semi-log plot. Is the trend approximately linear?

    (b) Use the polyfit function to find the best-fitting line for the (x, Y )-data and add the
         graph of the line to your scatter plot from part (a). Save or print the plot. Your
         plot should have labeled axes and include a legend. Note that the vertical axis is the
         logarithm of the population. Give the plot the title "Semi-log plot."

    (c) Use the data from part (b) to determine the exponential model y = Cekx. Plot the
         original data and the exponential function on the same set of axes. Save or print the
         plot. Your plot should have labeled axes and include a legend. Give the plot the title
         "Exponential plot."

    (d) Use the model from part (c) to estimate the date when the global population reached
         7 billion.

    (e) Make a projection about when the global population will reach 10 billion.

11. Create a data matrix that corresponds to a picture of your own design, containing six or
     more edges. Plot it.

      (a) Rotate the image through 45 and 180. Plot the original image and the two rotations
            on the same axes. Include a legend.

      (b) Expand your figure by a factor of 2, then reflect the expanded figure in the x-axis.
            Plot the original image, the expanded image, and the reflected expanded image on
            the same axes. Include a legend.

 4https://esa.un.org/unpd/wpp/
EXERCISES                                                            37

12. Let f (x) = x2, where -3  x  3. Use a rotation matrix to rotate the graph of the
     function through an angle of 90. Plot the original and rotated graphs on the same axes.

Include a legend.

                                                                                    
                                                                                        x

13. Let the point (x, y) be represented by the column vector  y . These are known as

                                                                  1

homogeneous coordinates. Then the translation matrix

                              10h   

                     T = 0 1 k 

                              00 1

is used to move the point (x, y) to (x + h, y + k) as follows:

                                      x+h                       
                     10h      x

                    0 1 k ท y = y+k 

                     00 1     1                       1

Use a translation matrix and homogeneous coordinates to shift the graph you created in
problem 11 as follows: shift 3 units left and 2 units up.

14. The translation method described in problem 13 can be combined with a rotation matrix

to give rotations around an arbitrary point. Suppose for example that we wished to rotate

the house graph from Figure 2.3 about the center of the rectangular portion (coordinates

(2, 1) in the original figure). This can be done by using homogeneous coordinates and a

translation T to move the figure, then a rotation matrix R for the rotation. The form of

R is now                                                 

                       cos() - sin() 0

                     R =  sin() cos() 0 

                           0     01

The shifted and rotated figure is then given by (RT )D. To shift back to the original
position, an inverse transformation T -1 is used. Thus the rotated image can be found by
computing (T -1RT )D. Use this method to rotate the house graph 90 about the point
(2, 1). Show the combined transformation matrix T -1RT and the results.
38  CHAPTER 2. MATRICES AND LINEAR SYSTEMS
Chapter 3

Single variable calculus

3.1 Limits, sequences, and series

Octave is an excellent tool for many types of numerical experiments. Octave is a full-fledged
programming language supporting many types of loops and conditional statements. However,
since it is a vector-based language, some things that would be done using loops in Fortran or
other traditional languages can be "vectorized." As an example, let's construct some numerical
evidence to determine the value of the following limit:

lim 1 +                            1n

n                                  n

We need to evaluate the expression for a series of larger and larger n-values. Here is what we
mean by vectorized code: Instead of writing a loop to evaluate the function multiple times,
we will generate a vector of input values, then evaluate the function using the vector input.
This produces code that is easier to read and understand, and executes faster, due to Octave's
underlying efficient algorithms for matrix operations.

First, we need to define the function. There are a number of ways to do this. The method we
use here is known as an anonymous function. This is a good way to quickly define a simple
function.

     >> f = @( n ) ( 1 + 1 . / n ) . ^ n ; % anonymous f u n c t i o n

Note the use of elementwise operations1. We have named the function f . The input variable is
designated by the @-sign followed by the variable in parentheses. The expression that follows
gives the rule to be used when the function is evaluated. Now we can evaluate f at a single
input value, or for an entire vector of input values.

Next, we create an index variable, consisting of the integers from 0 to 9.

    1Elementwise operations are used throughout this chapter, since we are primarily evaluating functions element-
wise at a numeric input vector, not doing matrix operations. Refer to Section 1.4.1.

                                                             39
40                     CHAPTER 3. SINGLE VARIABLE CALCULUS

    >> k = [ 0 : 1 : 9 ] ' % i n d e x v a r i a b l e
    k=

          0
          1
          2
          3
          4
          5
          6
          7
          8
          9

The syntax [0 : 1 : 9] produces a row vector that starts at 0 and increases by an increment of
1 up to 9. If not otherwise specified, the default step size is 1, so we could write simply [0 : 9].
Notice that we have used the transpose operation, only because our results will be a little easier
to read as column vectors. Now, we'll take increasing powers of 10, which will be the input
values, then evaluate f (n).

     >> format l o n g % d i s p l a y a d d i t i o n a l d e c i m a l p l a c e s
     >> n = 1 0 . ^ k % s e q u e n c e o f i n c r e a s i n g i n p u t v a l u e s
     n=

                    1
                  10
                100
              1000
             10000
           100000
         1000000
       10000000
     100000000
    1000000000

    >> f ( n )         % sequence of function values
    ans =

    2.00000000000000
    2.59374246010000
    2.70481382942153
    2.71692393223552
    2.71814592682436
    2.71826823719753
    2.71828046915643
    2.71828169398037
    2.71828178639580
    2.71828203081451

    >> format          % r e t u r n t o s t a n d a r d 5- d i g i t d i s p l a y

This is good evidence that the limit converges to a finite value that is approximately 2.71828 . . .
You (hopefully!) recognize the number as e.
3.1. LIMITS, SEQUENCES, AND SERIES                                  41

Similar methods can be used for numerical exploration of sequences and series, as we show in
the following examples.

                              1
Example 3.1.1. Let an be the series whose nth term is an = n(n + 2) . Find the first ten

                                        n=2

terms, the first ten partial sums, and plot the sequence and partial sums.

Solution. To do this, we will define an index vector n from 2 to 11, then calculate the terms.

>> n = [ 2 : 1 1 ] ' ;  % index

>> a = 1 . / ( n . * ( n + 2 ) ) % terms o f t h e s e q u e n c e

a=

    0.1250000
    0.0666667
    0.0416667
    0.0285714
    0.0208333
    0.0158730
    0.0125000
    0.0101010
    0.0083333
    0.0069930

If we want to know the 10th partial sum, we need only type sum(a). If we want to produce
the sequence of partial sums, we need to make careful use of a loop. We will use a for loop
with index i from 1 to 10. For each i, we produce a partial sum of the sequence an from the
first term to the ith term. The output is a 10-element vector of these partial sums.

     >> f o r i = 1 : 1 0
              s ( i ) = sum ( a ( 1 : i ) ) ;

           end
     >> s ' % s e q u e n c e o f p a r t i a l sums , d i s p l a y e d a s a column v e c t o r
     ans =

           0.12500
           0.19167
           0.23333
           0.26190
           0.28274
           0.29861
           0.31111
           0.32121
           0.32955
           0.33654

Finally, we will plot the terms and partial sums, for 2  n  11.

     >> p l o t ( n , a , ' o ' , n , s , '+ ' )
     >> g r i d on
     >> l e g e n d ( ' terms ' , ' p a r t i a l sums ' )

The result is shown in Figure 3.1.
42                         CHAPTER 3. SINGLE VARIABLE CALCULUS

    Figure 3.1: Plot of a sequence and its partial sums

An advantage of using a language like Octave is that it is simple to determine the sum of many
terms of a series. If the series is known to converge, this can help give an estimate for the sum.

Example 3.1.2. Find the sum of the first 1000 terms of the harmonic series.

                                                           1000 1
                                                           n=1 n

    Solution. We only need to generate the terms as a vector, then take its sum. Recall that
    ending a command with a semicolon prevents the output from being displayed on screen,
    done here since our sequence is now much too long to display conveniently.

         >> n = [ 1 : 1 0 0 0 ] ;
         >> a = 1 . / n ;
         >> sum ( a )
         ans = 7.4855

    This is of course not an estimate for the sum of the infinite series, since, by the integral test,
    we know the series diverges. However, we can explore just how slowly this particular series
    diverges. The first 1000 terms sum to only about 7.5. Let's try adding more terms:

    >> n = [ 1 : 1 e6 ] ;  % using s c i e n t i f i c notation for upper limit
    >> a = 1 . / n ;
    >> sum ( a )
    ans = 14.393

    The sum of the first million terms is still under 15!
3.2. NUMERICAL INTEGRATION                                                                       43

3.2 Numerical integration

3.2.1 Quadrature

Octave has several built-in functions to calculate definite integrals. We will use the built-in quad
command. "Quad" is short for quadrature, which is a historical term referring to the process of
calculating area by dividing into rectangles.

/2 Example 3.2.1. Estimate ex2 cos(x) dx using Octave's quad algorithm.

                                                    0

   Solution. The correct syntax is quad('f ' , a, b). We need to first define the function.
        >> f u n c t i o n y = f ( x )
                  y = exp (x .^2) .* cos (x) ;
               end
        >> quad ( ' f ' , 0 , p i / 2 )
         ans = 1.8757

   Note that the function exp(x) is used for ex. In this example, we used the function . . . end
   construction to define f . This is a versatile format that allows for multiple operations and
   outputs. We could have instead used an anonymous function, but note that no quotes are
   used around the name f if using an anonymous function with quad.

3.2.2 Octave scripts

Now suppose we want to write our own code for numeric integration. The midpoint rule,
trapezoid rule, and Simpson's rule are common algorithms used for numerical integration. These
types of algorithms are easily implemented in Octave script files.

Let {a = x0, x1, x2, . . . , xn = b} be a partition of [a, b] into n subintervals, each of width

     b-a           b

x =  n    . Then f (x) dx can be approximated as follows.

                a

Midpoint rule:

                      x [f (m1) + f (m2) + ท ท ท + f (mn)]

where mi is the midpoint of the ith subinterval.

Trapezoid rule:
                          x
                            2 [f (x0) + 2f (x1) + 2f (x2) + ท ท ท + 2f (xn-1) + f (xn)]

 Simpson's rule:
            x
              3 [f (x0) + 4f (x1) + 2f (x2) + 4f (x3) + ท ท ท + 2f (xn-2) + 4f (xn-1) + f (xn)]

 where xi = a + ix.
44                                                      CHAPTER 3. SINGLE VARIABLE CALCULUS

Octave script files are plain text files containing a series of Octave commands. A script file needs
to have a ".m" extension (not the .txt used by default in Windows for text files) and cannot
begin with the keyword function. You can use any text editor, such as Notepad, Notepad++, or
Emacs, but the Octave GUI has its own built-in text editor which can be accessed by changing
to the "Editor" tab option displayed below the main command window. The built-in editor is
ideal for creating, editing, and running .m files and will automatically color code comments and
key words.

Example 3.2.2. Write an Octave script to calculate a midpoint rule approximation of

                 /2 ex2 cos(x) dx

                0

using n = 100.

    Solution. The basic strategy is to use a for loop that adds an additional function value to
    a running total with each iteration. Then the final answer is found by multiplying the sum
    by x.

    The following code can be used. Switch to the editor tab and enter the code in a plain text
    file. Save it as midpoint.m. It must be placed in your working directory, then it can be run
    by typing midpoint at the command prompt, or by clicking the "save and run" button on the
    editor toolbar (be sure to switch back to the command window to see the output).

                Octave Script 3.1: Midpoint rule approximation

1 % f i l e ' midpoint .m'
2 % calculates a midpoint rule approximation of
3 % the integral from 0 to pi /2 of f (x) = exp (x^2) cos (x)
4 % --t r a d i t i o n a l l o o p e d code

 5

 6 % s e t l i m i t s of i n t e g r a t i o n , number of terms and d e l t a x
 7a=0
 8 b = pi /2
 9 n = 100
10 dx = ( b - a ) /n

11

12 % d e f i n e f u n c t i o n t o i n t e g r a t e
13 f u n c t i o n y = f ( x )
14 y = exp ( x . ^ 2 ) . * c o s ( x ) ;
15 end

16

17 msum = 0 ;   % i n i t i a l i z e sum

18 m1 = a + dx / 2 ; % f i r s t midpoint

19

20 % l o o p t o c r e a t e sum o f f u n c t i o n v a l u e s
21 f o r i = 1 : n
22 m = m1 + ( i - 1 ) *dx ; % c a l c u l a t e midpoint
23 msum = msum + f (m) ; % add t o midpoint sum
24 end

25

26 % midpoint a p p r o x i m a t i o n t o t h e i n t e g r a l
27 approx = msum*dx
3.2. NUMERICAL INTEGRATION  45

Now run midpoint.m.

     >> midpoint
     a=0
     b = 1.5708
     n = 100
     dx = 0.015708
     approx = 1.8758

The traditional code works fine, but because Octave is a vector-based language, it is also possible
to write vectorized code that does not require any loops.

Example 3.2.3. Write a vectorized Octave script to calculate a midpoint rule approximation
of

                                                     /2 ex2 cos(x) dx

                                                                       0

using n = 100.

   Solution. Now our strategy is to create a vector of the x-coordinates of the midpoints. Then
   we evaluate f over this midpoint vector to obtain a vector of function values. The midpoint
   approximation is the sum of the components of the vector, multiplied by x.

                        Octave Script 3.2: Midpoint rule approximation - vectorized

  1 % f i l e ' midpoint2 .m'
  2 % calculates a midpoint rule approximation of
  3 % the integral from 0 to pi /2 of f (x) = exp (x^2) cos (x)
  4 % --v e c t o r i z e d code

    5

  6 % s e t l i m i t s of i n t e g r a t i o n , number of terms and d e l t a x
  7a=0
  8 b = pi /2
  9 n = 100
 10 dx = ( b - a ) /n

  11

 12 % d e f i n e f u n c t i o n t o i n t e g r a t e
 13 f u n c t i o n y = f ( x )
 14 y = exp ( x . ^ 2 ) . * c o s ( x ) ;
 15 end

  16

 17 % c r e a t e v e c t o r o f m i d p o i n t s
 18 m = [ a + dx /2 : dx : b - dx / 2 ] ;

  19

 20 % c r e a t e v e c t o r o f f u n c t i o n v a l u e s a t m i d p o i n t s
 21 M = f (m) ;

  22

 23 % midpoint a p p r o x i m a t i o n t o t h e i n t e g r a l
 24 approx = dx*sum (M)

   This code will give the same results as the traditional looped code, but it executes faster, and
   is arguably more intuitive.
46                                                CHAPTER 3. SINGLE VARIABLE CALCULUS

3.3 Parametric, polar, and implicit functions

3.3.1 Parametric and polar plots

Curves defined by parametric and polar equations are usually studied in Calculus II. Such curves
can be difficult to graph by hand! The plotting methods we used in Section 1.4 carry over easily
to these new settings. For example, parametric equations for a cycloid are given by

                                          x = r(t - sin(t))
                                          y = r(1 - cos(t))

Example 3.3.1. Graph three periods of a radius 2 cycloid.

    Solution. The functions have period 2, so we need 0  t  6 to see three full cycles. We
    need to define the parameter t as a vector over this range, then we calculate x and y, and
    plot x vs. y.

    >> t = l i n s p a c e ( 0 , 6* pi ,  50) ;
    >> x = 2 * ( t - s i n ( t ) ) ;
    >> y = 2 * ( 1 - c o s ( t ) ) ;
    >> p l o t ( x , y )
    >> a x i s ( ' e q u a l ' )
    >> a x i s ( [ 0 12* p i 0 4 ] )

    The command axis( 'equal') is used to force an equal aspect ratio between the x- and y-axes.
    The result is shown in Figure 3.2. To see a simple animation of this plot, try comet(x, y).

    Figure 3.2: Graph of a cycloid

Polar graphs are handled in a similar way. For a function r = f (), we start by defining the
independent variable , then we calculate r. To plot the graph, we calculate x and y using the
standard polar identities x = r cos(), y = r sin(), then plot x vs. y.

Example 3.3.2. Plot the limacธon r = 1 - 2 sin().

    Solution. The needed commands are shown below and the graph is shown in Figure 3.3.

    >> t h e t a = l i n s p a c e ( 0 , 2* pi ,  100) ;
    >> r = 1 - 2* s i n ( t h e t a ) ;
    >> x = r . * c o s ( t h e t a ) ;
    >> y = r . * s i n ( t h e t a ) ;
    >> p l o t ( x , y )

    Again, viewing an animation can be helpful. Just use the command comet(x, y).
3.3. PARAMETRIC, POLAR, AND IMPLICIT FUNCTIONS  47

                           Figure 3.3: Graph of a limaธcon on a rectangular grid

It is also possible to plot a function r = f () on a set of polar axes using the polar command.
For example, the following commands will produce a graph of the limaธcon shown above on a
polar grid. Try it! See Figure 3.4.

     >> t h e t a = l i n s p a c e ( 0 , 2* pi , 5 0 ) ;
     >> r = 1 - 2* s i n ( t h e t a ) ;
     >> p o l a r ( t h e t a , r )

3.3.2 Implicit plots

Sometimes we need to plot a function defined implicitly by an equation of the form f (x, y) = 0.
The easiest way to do this in Octave is with the ezplot command.
Example 3.3.3. Plot the curve defined by the equation

                                             -x2 - xy + x + y2 - y = 1
   Solution. To define the function as f (x, y) = 0, we subtract 1 from both sides of the equation.

        >> f = @( x , y ) -x . ^ 2 - x . * y + x + y . ^ 2 - y - 1
         f=

         @( x , y ) -x . ^ 2 - x . * y + x + y . ^ 2 - y - 1

        >> e z p l o t ( f )

   Run the ezplot command to see the results. Do you recognize the curve (see Figure 3.5)?
48  CHAPTER 3. SINGLE VARIABLE CALCULUS

    Figure 3.4: Graph of a limacธon on a polar grid

    Figure 3.5: Implicit plot of a hyperbola
3.3. PARAMETRIC, POLAR, AND IMPLICIT FUNCTIONS                     49

Figure 3.6: Implicit plot of a circle with tangent line

Example 3.3.4. Find the equation of the line tangent to the graph of the circle (x-2)2+y2 = 25,
at the point (-1, 4). Plot a graph of the circle and the tangent line on the same axes.

   Solution. To plot the circle, we'll first define it as a function of the form f (x, y) = 0.
        >> f = @( x , y ) ( x - 2 ) . ^ 2 + y . ^ 2 - 2 5 ;

The center of the circle is at (2, 0) and the radius is 5. We will set the axes of our plot to
extend a few units beyond the circumference of the circle.

     >> % i m p l i c i t p l o t o f f ( x , y ) = 0 o v e r domain [ -6 , 1 0 ] x [ -8 , 8 ]
     >> e z p l o t ( f , [-6 10 -8 8 ] )

Using implicit differentiation, the derivative is y =  2-x         . At the point (-1, 4), the slope is

                                                                y

thus 3/4. The equation of the tangent line is

                                                          3 19
                                                    y= x+

                                                          44

Now, add the tangent line to the graph.

     >> x = [-6 : 1 0 ] ;
     >> y = 3/4* x + 1 9 / 4 ;
     >> h o l d on
     >> p l o t ( x , y , ' r-- ' )

The result is shown in Figure 3.6.
50                        CHAPTER 3. SINGLE VARIABLE CALCULUS

3.4 The symbolic package

While Octave is primarily numeric software, the Octave Forge Symbolic package allows Octave
to function as a computer algebra system.

3.4.1 Installation

The package relies on the Python SymPy library, so installation can be a little tricky. But, if
you already have a Python interpreter and SymPy, installation of the package in Octave only
requires the command pkg install -forge symbolic.

If you don't want to do a separate installation of Python, a standalone installer for Windows users
is available from the package developers that includes all dependencies. To install the package us-
ing the standalone Windows installer, download the file symbolic-win-py-bundle-2.8.0.tar.gz
(or more recent version) from https://github.com/cbm755/octsympy/releases. Navigate to
your download directory (the current working directory can be changed by clicking the folder
icon at the top of the screen in the Octave GUI). Then in Octave, type:

     >> pkg i n s t a l l symbolic -win-py-bundle - 2 . 9 . 0 . t a r . gz
     >> pkg l o a d s y m b o l i c

To see if it is working, try declaring a symbolic variable. You should get a message indicating a
Python communication link.

     >> syms x
     Symbolic pkg v2 . 8 . 0 : Python communication l i n k a c t i v e , SymPy v1 . 3 .

If you have trouble with the package installer, a "manual" installation is not too difficult, as
follows:

   1. Download and install Python (https://www.python.org/downloads/). Use one of the
       installer files appropriate for your system. Keep the default settings (includes PIP), and,
       if prompted, select the option to add Python to path.

   2. At the system command prompt, navigate to the Python scripts folder (for example, some-
       thing like Programs\Python\Python37-32\Scripts, depending on where it was installed)
       and type: pip install symbolic.

   3. Then, in Octave, type: pkg install -forge symbolic. Test the installation by attempting
       to declare a symbolic variable as indicated above.

Once installed and operating, the package works much like Matlab's Symbolic Toolbox.

3.4.2 Symbolic operations

A few basic examples showing the use of Octave as a computer algebra system are included
below.
3.4. THE SYMBOLIC PACKAGE                                                               51

Example 3.4.1. Let f (x) = x3 + 3x2 - 10x.

(a) Evaluate f ( 12 ).

(b) Factor the expression and find all real zeros.

(c) Simplify the difference quotient and evaluate the limit lim  f (x + h) - f (x)  .

                                                    h0           h

Solution. The first step is to declare x as a symbolic variable with the command syms.

>> syms x                  % declare symbolic variable x

Now we define the expression. Notice that we do not need to worry about using elementwise
operations here.

     >> f = x ^3 + 3* x ^2 - 10* x % d e f i n e f a s a s y m b o l i c e x p r e s s i o n
     f = ( sym )

3          2

x + 3*x - 10*x

The command to evaluate a symbolic expression is subs(f , x). In Octave, 1/2 evaluates
to a decimal, hence a warning that floating-point values should not be passed to symbolic
functions is raised if we enter subs(f , 1/2):

     >> s u b s ( f , 1 / 2 )
     warning : p a s s i n g f l o a t i n g -p o i n t v a l u e s to sym i s dangerous , s e e ' h e l p sym '
     warning : called from

             double to sym heuristic at l i n e 50 column 7
            sym at l i n e 379 column 13
             subs at l i n e 178 column 9

To avoid this, we can enter 1/2 as a symbolic variable by using sym(1)/2, which keeps the
fraction as an exact symbolic expression.

     >> s u b s ( f , sym ( 1 ) / 2 )
     ans = ( sym ) -33/8

Factoring is straightforward:

     >> f a c t o r ( f )
     ans = ( sym ) x *( x - 2) *( x + 5)

To solve f (x) = 0, we use the solve command with the equality comparison, "==".

     >> s o l v e ( f == 0 , x )
     ans = ( sym 3x1 matrix )

           [ -5]
           [ 0]
           [ 2]

The solutions are easily seen to correspond to the factors in the factored form above.
52                                              CHAPTER 3. SINGLE VARIABLE CALCULUS

    We could create the difference quotient using the subs command described above. But, it is
    somewhat easier to instead redefine f as a symbolic function. Here is how:

    >> syms f ( x )                             % declare f as a symbolic function of x
    >> f ( x ) = x ^3 + 3* x ^2 - 10* x         % define f (x)
    f (x) = ( symfun )

    3  2

    x + 3*x - 10*x

    Now we can evaluate f at individual x-values, arrays of values, or at symbolic expressions.
    This makes it quite easy to build the difference quotient.

         >> syms h
         >> dq = ( f ( x + h ) - f ( x ) ) /h
         dq = ( sym )

          3         2                    3         2

    -10*h - x - 3*x + ( h + x ) + 3*( h + x )

    -----------------------------------------

                       h

    Now let's try to simplify that expression.

         >> s i m p l i f y ( dq )
         ans = ( sym )

    2                     2

    h + 3*h*x + 3*h + 3*x + 6*x - 10

    From here it is easy to see that lim f (x + h) - f (x) = 3x2 + 6x - 10.
                       h0                       h

In cases where a limit is less obvious, we may wish to try the symbolic limit function, but
caution is required. In particular, as it is currently implemented2, note that by default, only a
right-hand limit is evaluated. For example, consider the following:

     >> f ( x ) = x/ abs ( x ) ;
     >> l i m i t ( f , x , 0 , ' l e f t ' )
     ans = ( sym ) -1

     >> l i m i t ( f , x , 0 , ' r i g h t ' )
     ans = ( sym ) 1

The left and right limits do not agree. Clearly then lim f (x) does not exist. But, without

                                                                                                    x0

qualifying the direction, limit ( f , x, 0) gives the answer 1.

     >> l i m i t ( f , x , 0 )
     ans = ( sym ) 1

    2Symbolic pkg v2.9.0, as of this writing.
3.4. THE SYMBOLIC PACKAGE                                                    53

This behavior is counterintuitive, at best. A more sensible result would be NaN (not a number).
When in doubt, check both left- and right-hand limits.

Next we will look at symbolic derivatives, as well as antiderivatives and definite integrals.
Example 3.4.2. Let f (x) = x2 sin x. Find each of the following:

(a) f (x)

(b) f (x) dx

        /4

(c)         f (x) dx

     0

Solution. First we define the expression.
     >> f = x ^2* s i n ( x )
     f = ( sym )

            2
           x *sin (x)

Now, calculate the derivative using the diff command.
     >> d i f f ( f , x )
     ans = ( sym )

            2
           x * cos (x) + 2*x* sin (x)

Next, calculate the integrals using int.

     >> i n t ( f , x )
     ans = ( sym )

             2
        - x * cos (x) + 2*x* sin (x) + 2* cos (x)

     >> i n t ( f , x , 0 , sym ( p i ) / 4 )
     ans = ( sym )

                          2

            \/ 2 * pi        \/ 2 * pi

        -2 - --------- + -------- + \/ 2

                      32     4

If you want to see the answer as a decimal approximation, type double(ans):

     >> d o u b l e ( ans )
     ans = 0.088755

This converts the result to a double-precision floating point value.
54                                      CHAPTER 3. SINGLE VARIABLE CALCULUS

Example 3.4.3. Show that                 r

                                           2 r2 - x2 dx = r2

                                        -r

    Solution. The integral, of course, represents the area of circle of radius r.

    >> syms x r
    >> f = 2* s q r t ( r ^2 - x ^ 2 )
    f = ( sym )

           /2 2
    2*\/ r - x

    >> i n t ( f , -r , r )

    If you run these commands as shown, you will get a rather complicated and unexpected
    answer. The problem is that we have implicitly assumed r > 0, but Octave does not know
    this. We can fix the problem by setting an assumption on r.

         >> assume ( r , ' p o s i t i v e ' )
         >> i n t ( f , -r , r )
         ans = ( sym )

                      2
               pi*r

    Now the result is as expected. Various other assumptions on symbolic variables are also
    possible (e.g., integer, nonzero, real, etc.).

3.4.3 Plotting

The ezplot method we used in Section 3.3.2 for plotting implicit functions is also the easiest
way to plot a symbolic function.

Example 3.4.4. Let f (x) = x3 + 3x2 - 10x. Graph f , f , and f on the same axes.

    Solution. Once we've defined f , plotting the function is as simple as typing ezplot( f ).

         >> syms x
         >> f = x ^3 + 3* x ^2 - 10* x
         f = ( sym )

    3           2

    x + 3*x - 10*x

    >> e z p l o t ( f )

    The default plot is over [-2, 2]. If we want to see the function over a wider range, we can
    use ezplot( f , [a b]) to set the domain. In this case, the default domain covers the region of
    interest, but it will be helpful to adjust the viewpoint using the axis function. We would also
    like to change the line width. To do that, we will name the plot, then use that handle as a
3.4. THE SYMBOLIC PACKAGE  55

                       Figure 3.7: Graph of a polynomial and its derivatives

reference to the set function. Similar syntax can be used to adjust line width, color, and line
style options.

     >> h = e z p l o t ( f ) ;
     >> s e t ( h , ' l i n e w i d t h ' , 2 ) ;

Now we just need to add the graphs of the first two derivatives.
     >> h o l d on
     >> e z p l o t ( d i f f ( f , x ) )
     >> e z p l o t ( d i f f ( f , x , 2 ) )
     >> a x i s ([ -6 5 -20 4 0 ] )
     >> g r i d on
     >> x l a b e l ( ' x ' )
     >> y l a b e l ( ' y ' )
     >> t i t l e ( ' ' ) % remove d e f a u l t e z p l o t t i t l e
     >> l e g e n d ( ' f u n c t i o n ' , ' f i r s t d e r i v a t i v e ' , ' s e c o n d d e r i v a t i v e ' )
     >> l e g e n d ( ' l o c a t i o n ' , ' s o u t h e a s t ' ) % move l e g e n d t o l o w e r r i g h t

To more clearly show the relationship between these curves, it will be helpful to make the
coordinate axes explicitly visible. We can use the method described in Chapter 1 Exercise 6.

     >> p l o t ([ -6 5 ] , [ 0 0 ] , ' k ' , [ 0 0 ] , [ -20 4 0 ] , ' k ' )
     >> a x i s o f f

The graph is shown in Figure 3.7.
56             CHAPTER 3. SINGLE VARIABLE CALCULUS

3.4.4 Options

Notice that the output of symbolic operations in this section is displayed in a plain text ap-
proximation of standard mathematical notation. There are multiple display options available.
The ascii format is shown above. For a "prettier" format, you can change to a unicode pretty
print format using the command sympref display unicode. But, this option does not work on
all systems. For plain text without special formatting, use sympref display flat . Note that
in this plain text mode, exponents are displayed as x**n instead of x^n, following the Python
convention.

It is important to note that when the symbolic package is loaded, some commands shadow
(override) a core library function of the same name. For instance, the normal operation of the
command diff is taking the difference of adjacent elements in a vector (an operation useful for
approximating derivatives numerically), but when the symbolic package is loaded, it becomes the
symbolic differentiation operator. For help with symbolic functions, type help @sym/diff, help
@sym/int, etc. For a complete list of available functions and options, refer to the documentation
for the package3.

    3https://octave.sourceforge.io/symbolic/overview.html
EXERCISES                                                         57

Chapter 3 Exercises

1. Show (numerically) that lim  sin       = 1.

                     0 

                                                                    11
2. Let an be the series whose nth term is an = 2n - 3n , n  1. Find the first ten terms,

   the first ten partial sums, and plot the sequence and partial sums. Do you think the series
   converges? If so, what is the sum?

3. How many terms need to be included in the harmonic series to reach a partial sum that
   exceeds 10?

/2 4. Write an Octave script based on a for-loop to calculate ex2 cos(x) dx using the trape-

                                                                                                          0

   zoid rule with n = 100. Compare your answer to the midpoint approximation given in
   Examples 3.2.2 and 3.2.3. (Use the command format long to see more decimal places.)

                                                                   2 1 -x2
5. Write a vectorized Octave script to calculate  e 2 dx using Simpson's rule with

                                                                  -2 2
   n = 100. Compare your answer to the midpoint approximation using Script 3.2. Which
   approximation seems to be most accurate, judged against Octave's quad algorithm?

6. Graph each equation.

     (a) x = t3, y = t2
    (b) x = sin(t), y = 1 - cos(t)
     (c) r = 
    (d) r = sin(2)
     (e) r = cos(7/3)
     (f) x2 = y3 - 10y

7. Octave scripts can be used for many problems in numerical analysis. Newton's method

for root finding is a good example. Newton's method is an iterative process based on the

formula                                   xi+1 = xi - f (xi)
                                                          f (xi)

Starting from an initial guess of x1, a sequence of approximations xi is generated (refer to
[1, ง2.4] and [5, ง4.1]).

(a) The function f (x) = x3 + 5x2 + x - 1 has one positive root. Write an Octave script
     to find it using Newton's method.

(b) Compare your answer to the result obtained with Octave's fsolve command.

           >> f s o l v e ( ' f ' , x1 )  % solve f (x) = 0 numerically using initial
                 guess x1

(c) How many iterations of Newton's method were needed to obtain agreement with the
     fsolve result to five decimal places (using the same initial guess)?

(d) Plot the function and its tangent lines at x1, x2, and x3.
58         CHAPTER 3. SINGLE VARIABLE CALCULUS

 8. Let f (x) = x3 + 3x2 - 10x. Find the coordinates of any relative extrema and inflection
     points. Add markers and text labels to the graph in Figure 3.7 to highlight these points
     and their correspondence to the zeros of f and f , respectively.

 9. The general logistic growth equation is

                                                                    C
                                                     f (t) = 1 + Ae-kt

      (a) Let A = 50 and k = 0.1. Graph the logistic curves with C = 100, C = 500, and
            C = 1000 on a single set of axes. Include a legend. What does C represent?

      (b) Now, let A = 50 and C = 100. Graph the curves with k = 0.1, k = 0.4, and k = 1.
            How does the parameter k affect the shape of the curve?

      (c) Notice that in each case, the curve has a single inflection point. Find its coordinates,
            in terms of the parameters A, C, and k, using symbolic operations.

10. Recall that for y = f (x), the arc length from x = a to x = b is given by

    s=     b dy 2                                            dx
           1+
               dx
        a

    (see [5, ง7.4]).
    Let f (x) = x2. Use symbolic functions to find an exact value for the arc length from x = 0
    to x = 1.

11. The Taylor series for an infinitely differentiable function f at x = a is given by

     T (x) = f (k)(a) (x - a)k
                      k!

                  k=0

    where f (k) is the kth derivative of f (see [5, ง8.8]).
    Let f (x) = ex2.

    (a) Find (by hand) the first three nonzero terms of the Taylor series for f at x = 0.

    (b) Check your answer to part (a) by defining f as a symbolic function and using the
         taylor function:

               >> syms x
               >> f = exp ( x ^ 2 )
               >> T5 = t a y l o r ( f , x , ' o r d e r ' , 5 )

    (c) Plot the function and the Taylor polynomial on the same axes.
    (d) Use the Taylor polynomial to approximate 01 ex2 dx.
Chapter 4

Miscellaneous topics

4.1 Complex variables

Complex variables are ubiquitous in some engineering fields. Even if we attempt to limit our
attention to real variables, some mathematical subjects cannot be fully understood without
extending into the field of complex numbers. Examples include the eigenvalues and eigenvectors
of matrices and the roots of polynomial equations.
The study of complex numbers begins with one basic definition:

                                                              
                                                         i = -1
The number i is called an imaginary number. A complex number z = a + bi has real part a and
imaginary part b. We will illustrate complex number arithmetic in Octave using some simple
examples.
Example 4.1.1. Let z1 = 1 + 2i and z2 = 2 - 3i. Find each of the following:
                                         z1 + z2, z2 - z1, z1 ท z2, and z1/z2
   Solution. Octave has no difficulty dealing with complex arithmetic. The variables i and j
   (not case-sensitive) are both by default recognized as the imaginary unit -1.
   First define the variables:
        >> z1 = 1 + 2 i ;
        >> z2 = 2 - 3 i ;

   Now carry out the indicated operations:
        >> z1 + z2
         ans = 3 - 1 i
        >> z2 - z1
         ans = 1 - 5 i

                                                             59
60  CHAPTER 4. MISCELLANEOUS TOPICS

         >> z1 * z2
         ans = 8 + 1 i

         >> z1 / z2
         ans = -0.30769 + 0.53846 i

    Each result is expressed in the standard a + bi format. The commands real (z) and imag(z)
    can be used to extract the real part a and complex part b, if needed.

We can plot numbers in the complex plane using the compass command.

Example 4.1.2. Let z1 = 1 + 2i and z2 = 2 - 3i. Plot z1, z2, and the sum z1 + z2 in the complex
plane.

   Solution. We will show both variables and their sum on one set of axes.

        >> z1 = 1 + 2 i ;
        >> z2 = 2 - 3 i ;
        >> compass ( z1 , ' b ' )
        >> h o l d on
        >> compass ( z2 , ' r ' )
        >> compass ( z1 + z2 , ' k-- ' )
        >> l e g e n d ( ' z 1 ' , ' z 2 ' , ' z 1+z 2 ' )

   The plot is shown in Figure 4.1. The horizontal axis is real and the vertical axis is imaginary.

   It is interesting to note that the sum of the two variables in the complex plane is equivalent
   to the sum of two vectors in R2. Thus the compass command can also be used to illustrate
   vector arithmetic. The only difference is how we interpret the axes.

Sometimes Octave will return complex results unexpectedly. For example, suppose we want to
evaluate 3 -8:

     >> ( -8) ^ ( 1 / 3 )
     ans = 1.0000 + 1.7321 i

While we probably expected the answer -2, we can also easily verify that the cube of the given
answer is indeed -8 (at least up to some minor round-off error1):

     >> ans ^3
     ans = -8.0000 e+00 + 2 . 2 2 0 4 e -15 i

There are actually three cube roots of -8, and by default, Octave will return the one with the
smallest argument (angle). See Exercise 2. If we simply want the real root, we can use the
nthroot command.

     >> % r e a l cube r o o t o f -8
     >> n t h r o o t ( -8 , 3 )
     ans = -2

    1Notice the format used for scientific notation: 2.2204e-15 = 2.2204 ื 10-15, effectively 0.
4.2. SPECIAL FUNCTIONS  61

                                  Figure 4.1: Addition in the complex plane

4.2 Special functions

Octave has many common special functions available, such as Bessel functions (bessel), the error
function ( erf ), and the gamma function (gamma), to name a few.

For example, the gamma function is defined by

                                                                                  

                                                 (x) = tx-1e-t dt

                                                                                 0

This is an extension of the factorial function, since for positive integers n, the gamma function
satisfies

                                                    (n) = (n - 1)!
Example 4.2.1. Graph (x + 1) together on the same set of axes with the factorial function
x!, for corresponding nonnegative integer values of x.

   Solution. Both the gamma function and factorial function grow quite large very quickly, so
   we need to take care in selecting the domain. The gamma function is defined for positive and
   negative real numbers, while the factorial function is of course defined only for nonnegative
   integers. We will try the graph for x  -5 for the gamma function and n = 0, 1, 2, 3, 4 for
   the factorial.

   Trial and error shows that a fine increment is needed for a smooth graph of the gamma
   function.
62  CHAPTER 4. MISCELLANEOUS TOPICS

                 Figure 4.2: Improved graph of gamma function and factorial function

    These are the basic commands needed:
         >> n = [ 0 : 4 ] ;
         >> x = l i n s p a c e ( -5 , 5 , 5 0 0 ) ;
         >> p l o t ( n , f a c t o r i a l ( n ) , ' * ' , x , gamma( x + 1 ) )
         >> a x i s ([ -5 5 -10 3 0 ] ) ;
         >> g r i d on ;
         >> l e g e n d ( ' n ! ' , 'gamma( n+1) ' , ' l o c a t i o n ' , ' s o u t h e a s t ' )

    Notice the vertical asymptotes at each negative integer. If you run the plot commands as
    shown above, you will see vertical line segments that are not a true part of the graph. If we
    don't want to see these, we can divide the domain into separate intervals with breaks at the
    discontinuities. This is somewhat tedious, but produces a more accurate graph, as shown in
    Figure 4.2.

    Define the x-values as follows:
         x1 = l i n s p a c e (-5, -4, 200) ;
         x2 = l i n s p a c e (-4, -3, 200) ;
         x3 = l i n s p a c e (-3, -2, 200) ;
         x4 = l i n s p a c e (-2, -1, 200) ;
         x5 = linspace (-1, 5 , 200) ;

    Then, plot x1 vs. (x1 + 1), x2 vs. (x2 + 1), etc., on the same set of axes.
4.3. STATISTICS                                                        63

4.3 Statistics

4.3.1 Distribution of sample means

Octave has good capabilities for statistical analysis, and if you are proficient with Octave syntax,
you will find it quite easy to solve many common statistical problems.

We'll start with something simple. Let's try rolling a six-sided die. The rand function returns
a random value from the interval (0, 1). To get integer values from 1 through 6, we multiply by
6 and add 1, then use the floor function to chop off the trailing decimal:

     >> f l o o r ( 6 * rand + 1 )
     ans = 6 % the answer i s random - your r e s u l t s w i l l vary !

With the syntax rand(m, n), an m ื n matrix of values is returned. Now let's try repeating the
above experiment 100 times, storing the results in a column vector. We can analyze the results
by looking at the sample mean, variance, and a histogram.

     >> A = f l o o r ( 6 * rand ( 1 0 0 , 1 ) + 1 ) ;
     >> mean (A)
     ans = 3.4100
     >> var (A)
     ans = 2.9514
     >> h i s t (A, [ 1 2 3 4 5 6 ] )

Your results will vary, but you should see something that looks close to a uniform distribution,
such as in Figure 4.3. The vector [1 2 3 4 5 6] specifies the midpoints of the bins.

Now, let's use a loop to generate a distribution of 100 sample means.

>> f o r i = 1 : 1 0 0                1) + 1) ;
           A = floor (6* rand (100 ,
           d ( i ) = mean (A) ;

      end
>> h i s t ( d )

Notice that the distribution of the sample means is approximately normal (Figure 4.4), even
though the underlying distribution is not. We have just demonstrated the central limit theorem!

4.3.2 The standard normal distribution

We have seen that the rand function corresponds to a uniform distribution. Octave has many
other discrete and continuous distributions available. For example, the function randn returns
a matrix with normally distributed elements with mean 0 and standard deviation 1.

Example 4.3.1. Create a vector Z of 1000 elements from the standard normal distribution. Use
the transformation X = Z + ต to generate a vector X of elements from a normal distribution
with mean 400 and standard deviation 50. Compare the means and variances of X and Z. Plot
histograms of Z and X.
64  CHAPTER 4. MISCELLANEOUS TOPICS

    Figure 4.3: Results from 100 6-sided die trials

    Figure 4.4: Distribution of sample means
4.3. STATISTICS  65

                                         Figure 4.5: X-distribution

Solution. Here are the commands we need:
     >> % sample 1000 e l e m e n t s from a s t a n d a r d normal d i s t r i b u t i o n
     >> Z = randn ( 1 0 0 0 , 1 ) ;

     >> % t r a n s f o r m t h e mean and s t a n d a r d d e v i a t i o n
     >> mu = 4 0 0 ; sigma = 5 0 ;
     >> X = Z* sigma + mu ;

     >> % r e v i e w r e s u l t i n g sample mean and v a r i a n c e
     >> format f r e e ;
     >> mean ( [ Z X ] )
     ans =

           -0.00116119 399.942

     >> var ( [ Z X ] )
     ans =

           1.04291 2607.28

     >> % p l o t h i s t o g r a m s
     >> h i s t ( Z )
     >> h i s t (X)

The command format free changes from the default short form scientific notation. We can
see Z has mean and variance near 0 and 1, respectively, while X has a mean near 400 and
variance near 2500, as expected. The histograms are identical, except for the scale on the
horizontal axis (see, for example, Figure 4.5).
66                       CHAPTER 4. MISCELLANEOUS TOPICS

4.3.3 Linear regression

The polyfit command used in Section 2.2 (see Example 2.2.2) can be applied to linear regression
problems. A linear function is a degree 1 polynomial, so we use the syntax polyfit (x, y, 1).
To quantify the degree of linear correlation, we can calculate the correlation coefficient using
corr(x, y).

Example 4.3.2. Let x = {5, 9, 18, 25, 32, 40, 53} and y = {32, 28, 23, 20, 19, 18, 9}. Create a
scatter plot of the data and calculate the correlation coefficient. Find the equation of the
regression line and add it to the scatter plot.

   Solution. First we enter the data and create the scatter plot.

        >> x = [ 5 9 18 25 32 40 5 3 ] ;
        >> y = [ 3 2 28 23 20 19 18 9 ] ;
        >> p l o t ( x , y , ' o ' ) ;

    Now, calculate the regression line and correlation coefficient.
         >> P = p o l y f i t ( x , y , 1 )
         P=

               -0.42312 32.28685

         >> r = c o r r ( x , y )
         r = -0.97394

    The r-value suggests a strong negative linear correlation.

    The equation of the regression line is y^ = -0.42312x + 32.28685. We can add this to the plot
    using the polyval function to evaluate our regression equation at each x-value.

         >> h o l d on ;
         >> y h a t = p o l y v a l (P , x ) ;
         >> p l o t ( x , y h a t )

    The scatter plot and regression line are shown in Figure 4.6.

We can easily wrap these operations into our own user-defined regression function. Octave
function files will be explained in more detail in Section 6.3. Enter the code in Script 4.1 in
the text editor and save it as linReg.m in your current working directory. Test the function by
running linReg(x, y), using x and y as given in Example 4.3.2.

Here are the results:

     >> l i n R e g ( x , y ) ;
     y=ax+b
     a=-0.423121
     b=32.2869
     r ^2=0.948556
     r =-0.973939
4.3. STATISTICS  67

                                    Figure 4.6: Scatter plot with regression line

                                   Octave Script 4.1: Linear regression function
 1 % f u n c t i o n f i l e ' l i n R e g .m' runs a s t a n d a r d l i n e a r r e g r e s s i o n a n a l y s i s
 2 % syntax : [P r ] = linReg (x , y)
 3 % dis play s r e g r e s s i o n equation and c o r r e l a t i o n data , draws s c a t t e r plot
 4 % optional return values P: regression equation , r : correlation

          coefficient

 5

 6 function [P r ] = linReg (x, y)
 7 % c a l c u l a t e r e g r e s s i o n and c o r r e l a t i o n
 8 P = polyfit (x , y , 1) ;
 9 r = corr (x, y) ;

10

11 % p l o t data and r e g r e s s i o n l i n e
12 f i g u r e ( )
13 p l o t ( x , y , ' o ' , x , p o l y v a l (P , x ) ) ;
14 l e g e n d ( ' data v a l u e s ' , ' r e g r e s s i o n l i n e ' )
15 g r i d on ;

16

17 % d i s p l a y r e s u l t s
18 d i s p ( ' y=ax+b ' )
19 p r i n t f ( '%s%d\n ' , ' a= ' , P( 1 ) )
20 p r i n t f ( '%s%d\n ' , ' b= ' , P( 2 ) )
21 p r i n t f ( '%s%d\n ' , ' r ^2= ' , r ^ 2 )
22 p r i n t f ( '%s%d\n ' , ' r= ' , r )
23 end

  Notice that Octave supports C-style formatted output strings using printf (and its relatives
  sprintf and fprintf ). Refer to [3] for details.
68  CHAPTER 4. MISCELLANEOUS TOPICS

                          Figure 4.7: Binomial distribution with n = 10, p = 0.8

4.3.4 The binomial distribution

In a binomial experiment, we have a fixed number of independent trials. In each trial there are
two possible outcomes, commonly designated success or failure. The probability of success on
each trial is constant. Refer to [2] and [4] for details, as needed.

Example 4.3.3. Plot binomial distributions for n = 10, 25, and 50 trials with probability of
success p = 0.8. What happens to the shape of the distribution as n increases?

   Solution. The function binopdf(x, n, p) gives the probability of x successes in n trials of
   a binomial experiment with a probability of success p on each trial. Load the statistics
   package to access this function. The distributions can be plotted with the command bar(x,
   B), where x is the vector of possible outcomes and B is the corresponding vector of binomial
   probabilities.

   First we generate a plot with n = 10.
        >> pkg l o a d s t a t i s t i c s
        >> n = 1 0 ; p = 0 . 8 ; x = [ 0 : n ] ;
        >> B = b i n o p d f ( x , n , p ) ;
        >> bar ( x , B) ;

   The graph is shown in Figure 4.7. Repeat the above steps for n = 25 and n = 50. You should
   see distributions whose shapes become progressively more normal.
4.3. STATISTICS                                                                           69

4.3.5 Hypothesis testing

Octave can handle many other statistical functions. As a final example, we will consider a simple
hypothesis test. See [2] for background on the basic theory of statistical tests. To perform a
t-test, we need to again ensure that the statistics package is loaded.

Example 4.3.4. Consider the following set of sample data, assumed to be from a normally
distributed population:

                                         {24.9, 22.8, 16.2, 10.8, 32.0, 19.2}

Test the following hypotheses at significance level  = 0.01:

                                                    H0 : ต = 30
                                                    Ha : ต < 30

   Solution. Enter the data and calculate the mean.

        >> x = [ 2 4 . 9 2 2 . 8 1 6 . 2 1 0 . 8 3 2 . 0 1 9 . 2 ] '
         x=

               24.900
               22.800
               16.200
               10.800
               32.000
               19.200

        >> mean ( x )
         ans = 20.983

Is x = 20.983 good evidence that ต < 30? We can use the ttest command. The basic
format is ttest (X, mu), which will return 1 if the null hypothesis is rejected, 0 otherwise.
The default options are for a two-tailed test using significance level  = 0.05. Options are set
using name-value string pairs. For this problem, we need to specify a left-tailed test and set a
lower significance level. Here we ask for both the conclusion and the P -value, but additional
output values are also possible (use help ttest for more details).

     >> pkg l o a d s t a t i s t i c s
     >> [ h p v a l ] = t t e s t ( x , 3 0 , ' t a i l ' , ' l e f t ' , ' a l p h a ' , 0 . 0 1 ) ;

         h=0
         pval = 0.014932

We can see that the P -value is greater than  and we fail to reject the null hypothesis.
70                   CHAPTER 4. MISCELLANEOUS TOPICS

Chapter 4 Exercises

1. The polar form of a complex number is:
                                                         z = rei

where

                     rei = r (cos() + i sin())

Octave can determine the magnitude (modulus) r and angle (argument)  of a complex
number z using the commands abs(z) and angle(z), respectively.

(a) Write the polar form of z1 = 3 - 7i and z2 = 1 + 5i.

(b) Find z1z2 in both polar and a + bi form. How are the magnitudes and angles of each
     number related to the magnitude and angle of the product?

(c) Find z1/z2 in both polar and a + bi form. How are the magnitudes and angles of each
     number related to the magnitude and angle of the quotient?

2. A nonzero number (real or complex) x has n distinct nth roots. These are evenly spaced
                                                                       n

   on a circle about the origin with radius equal to r, where r is the absolute value (or
   modulus) of x. Find the three complex cube roots of -8 and show them on a complex
   plane compass plot.

3. Graph the Bessel functions of the first kind J0(x), J1(x), and J2(x) on [0, 20].
4. The gamma function can be used to calculate the "volume" (or "hypervolume") of an

   n-dimensional sphere. The volume formula is

                                                Vn(a) = n ท a n/2 n
                                                            ( 2 + 1)

   where a is the radius, n is the dimension, and (n) is the gamma function.

(a) Write a user-defined Octave function Vn = f (n, a) that gives the volume of an n-
     dimensional sphere of radius a. Test it by computing the volumes of 2- and 3-
     dimensional spheres of radius 1. The answers should be  and 4/3, respectively.

(b) Use the function to calculate the volume of a 4-dimensional sphere of radius 2 and a
     12-dimensional sphere of radius 1/2.

(c) For a fixed radius a, the "volume" is a function of the dimension n. For n =
     1, 2, . . . , 20, graph the volume functions for three different radii, a = 1, a = 1.1,
     and a = 1.2 (all on the same axes). Your graph should show points only for integer
     values of n and should have axis labels and a legend. Use the graph to determine the
     following limit:
                                                         lim Vn

                                                                             n

     Does the answer surprise you?

5. Consider the following sample data: {46, 50, 66, 41, 47, 48, 48, 48, 48, 51, 48, 49, 47, 53, 50}.
   Plot a histogram using six bins. Find the mean and standard deviation.
EXERCISES  71

6. Find the least-squares line y^ = ax + b that best fits the given set of points.

                                           {(-1, 5), (1, 4), (2, 2.5), (3, 0)}

   Include a plot of the data values and the least-squares line.

7. It is estimated that 7% of all patients using a particular drug will experience a mild side
   effect. A random sample of 12 patients using the drug is selected. Calculate the binomial
   distribution for n = 12 and p = 0.07. Plot a graph of the distribution. By summing
   various ranges of values from the distribution, determine each of the following:

     (a) The probability that no patients will have the mild side effect.
    (b) The probability that at most one patient will have the mild side effect.
     (c) The probability that no more than two patients will have the mild side effect.
    (d) The probability that at least three patients will have the mild side effect.

8. A manufacturer claims the life of a certain tire is greater than 50,000 miles. To test this
   claim, a sample of ten tires is tested. The following data are obtained from the sample:
     Tread life (miles)
            45,754
            47,749
            54,113
            47,027
            42,134
            44,423
            51,336
            50,220
            43,876
            49,869
   Test the manufacturer's claim using significance level  = 0.05.

     (a) State the hypotheses you would use to test this claim.
    (b) Calculate the P -value and state your conclusion regarding the null hypothesis (i.e.,

          reject or do not reject).
     (c) What do you conclude regarding the manufacturer's claim? State your answer in the

          context of the problem.
72  CHAPTER 4. MISCELLANEOUS TOPICS
Chapter 5

Eigenvalue problems

5.1 Eigenvectors

We showed in Section 1.3.3 the use of eig(A) to find the eigenvalues of a square matrix A.
You may have wondered about the corresponding eigenvectors. To find those, we use the eig
command with two output arguments. Now the correct syntax is [v lambda] = eig(A). The
first output will be a matrix whose columns represent the eigenvectors and the second output
value will be a diagonal matrix with the eigenvalues on the diagonal.

     >> A = [ 1 2 -3; 2 4 0 ; 1 1 1 ] ;
     A=

1 2 -3
240
111

>> [ v lambda ] = e i g (A)   % 2-ouput form o f e i g command
v=

-0.23995+0.00000 i            -0.79195+0.00000 i            -0.79195-0.00000 i
-0.91393+0.00000 i             0.45225+0.12259 i             0.45225-0.12259 i
-0.32733+0.00000 i             0.23219+0.31519 i             0.23219-0.31519 i

lambda =

Diagonal Matrix

4.52510+0.00000 i                                        0                             0
                           0  0.73745+0.88437 i                                        0
                           0                                0.73745-0.88437 i
                                                         0

Perhaps we would like to see a matrix with real eigenvalues. We can construct a symmetric
matrix (which must have real eigenvalues, as will be explained in Section 5.3.1) by multiplying
a matrix and its transpose. For example:

     >> C = A' *A

                                                             73
74                                               CHAPTER 5. EIGENVALUE PROBLEMS

    C=

      6 11 -2
    11 21 -5
    -2 -5 10

    >> [ v lambda ] = e i g (C)
    v=

     0.876137        0.188733     -0.443581
    -0.477715        0.216620     -0.851390
    -0.064597        0.957839
                                   0.279949

    lambda =

    Diagonal Matrix

        0.14970                0              0
                  0  8.47515                  0
                  0               28.37516
                               0

Here again the diagonal entries of  are the eigenvalues and the corresponding columns of V
are the associated eigenvectors. Each eigenvalue actually corresponds to an infinite family of
eigenvectors, so Octave is only providing a representative vector, chosen according to criteria
we will explore shortly. But first notice that they are normalized to unit length, and moreover,
where possible, the collection is linearly independent.

5.2 Markov chains

Consider a sequence of random events, subject to the following conditions:

     A finite number of states are possible.
     At regular intervals an observation is made and the state of the system is recorded.
     For each state, we assign a probability of moving to each of the other states, or staying

       the same. The essential assumption is that these probabilities depend only on the current
       state.

Such a system is known as a Markov chain. Our problem is to predict the probability of future
states of the system.

Suppose, for example, that we walk randomly along a four-block stretch of road in the following
manner1. At intersections 2, 3, or 4 we either move to the left or to the right at random. Upon
reaching the end of the road (intersections 1 or 5), we stop.

    1The idea for this example comes from [4], which is an excellent open reference for more details about Markov
chains and probability.
5.2. MARKOV CHAINS                                                 75

stop                ?                    ?         ?         stop
    y                    y                    y         y       y
   1                                                           5
                        2                    3         4

                    Figure 5.1: Random walk

Our goal is to predict where we will end up. We begin with a probability vector. For exam-
ple, suppose we could start at any point with equal probability. Then the initial vector is
 0.2, 0.2, 0.2, 0.2, 0.2 . On the other hand, we may know the initial state. Suppose we begin
at intersection 3. Then the initial vector is 0, 0, 1, 0, 0 . In any case, we want to predict our
location after k moves.

This is done by constructing a transition matrix. Form an n ื n array whose ijth entry is the
probability of moving from state i to j. Let T (for transition matrix) be the transpose of this
matrix. The matrix product T x gives the new probability distribution after one time period.
Continued left-multiplication by T gives the probabilities for future states. Thus, for any initial
probability vector x and any positive integer k, the probability vector after k time periods is
y = T kx.

Example 5.2.1. For our random walk example, find the probability vector after five steps for
each of these initial probability vectors:

   a = 0.2, 0.2, 0.2, 0.2, 0.2

   b = 0.5, 0, 0, 0, 0.5

   c = 0, 1, 0, 0, 0

   d = 0, 0, 1, 0, 0

Solution. We first form an array that records the probability of moving between positions.

                                                     To
                                                      12345
                                      F rom 1 1 0 0 0 0
                                                 2 0.5 0 0.5 0 0
                                                 3 0 0.5 0 0.5 0
                                                 4 0 0 0.5 0 0.5
                                                 50 0 0 0 1

The transition matrix is the transpose.

                            1 0.5 0 0 0                    

                            0            0    0.5  0    0  
                                                           
                    T  =    0            0.5  0    0.5  0  
                                                           
                           0 0 0.5 0 0 

                            0 0 0 0.5 1

Notice that the sum of each column is 1. Now, the future state probabilities are easily
computed as T kx, where x is the initial probability vector (expressed as a column).
76  CHAPTER 5. EIGENVALUE PROBLEMS

         >> T = [ 1 0 . 5 0 0 0 ; 0 0 0 . 5 0 0 ; 0 0 . 5 0 0 . 5 0 ; 0 0 0 . 5 0 0 ; 0 0 0
               0.5 1];

         >> a = [ 0 . 2 ; 0 . 2 ; 0 . 2 ; 0 . 2 ; 0 . 2 ] ;
         >> b = [ 0 . 5 ; 0 ; 0 ; 0 ; 0 . 5 ] ;
         >> c = [ 0 ; 1 ; 0 ; 0 ; 0 ] ;
         >> d = [ 0 ; 0 ; 1 ; 0 ; 0 ] ;
         >> T^5* a
         ans =

               0.450000
               0.025000
               0.050000
               0.025000
               0.450000

         >> T^5* b
         ans =

               0.50000
               0.00000
               0.00000
               0.00000
               0.50000

         >> T^5* c
         ans =

               0.68750
               0.00000
               0.12500
               0.00000
               0.18750

         >> T^5* d
         ans =

               0.37500
               0.12500
               0.00000
               0.12500
               0.37500

    Notice that b is an equilibrium vector for which there is no change in future states.

A probability vector x is an equilibrium vector if x = T x where T is the transition matrix for the
Markov chain. An equilibrium vector is one which results in no change moving to future states.
Every Markov chain has at least one equilibrium vector and the eigenvalues of the transition
matrix are the key to finding it.

Theorem 5.2.2. Let T be the transition matrix for a Markov chain. Then  = 1 is an eigenvalue
of T . If x is an eigenvector for  = 1 with nonnegative components that sum to 1, then x is an
equilibrium vector for T .
5.2. MARKOV CHAINS                                                                           77

Example 5.2.3. Find an equilibrium vector for the Markov chain with transition matrix

                                         0.48 0.51 0.14  

                             T =  0.29 0.04 0.52 

                                         0.23 0.45 0.34

Solution.

     >> T = [ 0 . 4 8 0 . 5 1 0 . 1 4 ; 0 . 2 9 0 . 0 4 0 . 5 2 ; 0 . 2 3 0 . 4 5 0 . 3 4 ]
     T=

0.480000     0.510000        0.140000
0.290000     0.040000        0.520000
0.230000     0.450000        0.340000

>> [ v lambda ] = e i g (T)
v=

-0.64840     -0.80111         0.43249
-0.50463      0.26394        -0.81601
-0.57002      0.53717
                              0.38351

lambda =

Diagonal Matrix

1.00000                0                 0
          0  0.21810                     0
          0                  -0.35810
                       0

>> x = v ( : , 1 ) /sum ( v ( : , 1 ) )
x=

0.37631
0.29287
0.33082

Thus x = 0.37631, 0.29287, 0.33082 is an equilibrium vector. Let's test it.
     >> T^10* x
     ans =

           0.37631
           0.29287
           0.33082

     >> T^50* x
     ans =

           0.37631
           0.29287
           0.33082

There is no change evident, so it seems to work!
78                                            CHAPTER 5. EIGENVALUE PROBLEMS

5.3 Diagonalization

Diagonal matrices have important properties. Some matrices can be transformed into a spe-
cial diagonal matrix that shares some properties with the original matrix, in particular, its
eigenvalues. The diagonalization problem is to find a matrix S such that

                                                       S-1AS = 

where  is a diagonal matrix.

Theorem 5.3.1. Let A be an n ื n matrix with n linearly independent eigenvectors. Form an
n ื n matrix S whose columns are the eigenvectors of A. Then S is invertible and S-1AS = ,

where                                                       

                                      1                     
                                                            
                              =            2                

                                              ..  .         

                                                     n

and i is the eigenvalue associated with the ith column of S. It follows that A can be written as
A = SS-1.

Theorem 5.3.1 tells us how to diagonalize a square matrix. Notice that this can be done only
for matrices that have enough independent eigenvectors. We need one more result.

Theorem 5.3.2. If A is an n ื n diagonalizable matrix and A = SS-1 and k is a positive

integer, then                            k                       
                                                                 
                                           1  k                   -1
                                                                 S
               k              k -1                2              
               A = S S = S 
                                                     .  ..

                                                            k

                                                              n

Theorem 5.3.2 shows how the diagonalized form can be used to simplify a particular computa-
tional problem, namely raising a matrix to a high power.

Example 5.3.3. Let A = 7 8 . Find A100.
                                      -4 -5

   Solution. Octave can solve such a problem easily.
        >> A = [ 7 8 ; -4 -5]
         A=

               78
            -4 -5

        >> A^100
         ans =

               1.0308 e+048 1.0308 e+048
             -5.1538 e+047 -5.1538 e+047
5.3. DIAGONALIZATION                                                     79

But how does Octave do this? Not by brute force, but by using Theorem 5.3.2. Here's
how. First we need to calculate the eigenvalues and associated eigenvectors. Verify that the
eigenvalues and eigenvectors are

                                               1 = 3, v1 = -2
                                                                      1

                                              2 = -1, v2 = -1
                                                                       1

Then  = 3 0 . We form the matrix S using the eigenvectors:
                 0 -1
                                                 S = -2 -1
                                                             11

Now we need to calculate the inverse matrix. It is
                                                S-1 = -1 -1
                                                              12

Therefore the diagonalized form is

     A = SS-1

                      = -2 -1 ท 3 0 ท -1 -1
                                    11  0 -1                      12

So,

     A100 = S100S-1

                      -2 -1             3 0 100 -1 -1
                      = 1 1 ท 0 -1 ท 1 2

                      -2 -1             3100 0                    -1 -1
                      = 1 1 ท 0 1ท 1 2

                      -2 ท 3100 -1      -1 -1
                      = 3100 1 ท 1 2

                              2 ท 3100 - 1 2 ท 3100 - 2
                      = -3100 + 1 -3100 + 2

Compare to the earlier Octave result:
     >> [2*3^100 -1 2*3^100 -2; -3^100+1 -3^100+2]
     ans =

           1.0308 e+048 1.0308 e+048
         -5.1538 e+047 -5.1538 e+047

This example shows some of the computational power of diagonalization.
80                                CHAPTER 5. EIGENVALUE PROBLEMS

5.3.1 Orthogonal diagonalization

We have already observed that not all square matrices can be diagonalized. However, a cer-
tain class of square matrices always has a diagonalization, and this diagonalization has special
properties. First, we need to recall a few definitions.

     A symmetric matrix is a square matrix A such that AT = A. Recall that a matrix with
       real entries may have complex eigenvalues. That cannot happen with symmetric matrices.
       A real symmetric matrix has all real eigenvalues.

     An orthogonal matrix is a square matrix whose columns are orthonormal (orthogonal and
       length 1). An important property of orthogonal matrices is that their inverse is equal to
       their transpose: If A is orthogonal, then A-1 = AT .

All symmetric matrices are diagonalizable. Moreover, we can say the following:
Theorem 5.3.4. Let A be a symmetric matrix. Then A can be diagonalized as

                                                       A = QQT

where Q is an orthogonal matrix whose columns are eigenvectors of A and  is a diagonal matrix
with the associated eigenvalues on the diagonal.

Example 5.3.5. Find an orthogonal diagonalization for A = 2 -1 .
                                                                                     -1 2

    Solution. A has eigenvalues 3 and 1. The eigenvectors are 1 and 1 . Notice that
                                                                                       -1 1 

    these are orthogonal. They are normalized by dividing by their length (both have length 2).
    Then A can be diagonalized as

    A = QQT

       1 1                        ท 30 ท  1 -1
       22                             01    22
    =  -1 1
                                          1 1
       22                                   22

    The eigenvectors in this example were orthogonal since the eigenvalues were distinct. If
    the matrix A is symmetric, but has repeated eigenvalues, then the problem is a bit more
    difficult and finding a set of orthonormal eigenvectors requires the Gram-Schmidt process
    (see Section 5.5.1). We won't show the details here, but note that even in those cases, an
    orthonormal set of eigenvectors can still be found.

Now, with these ideas in mind, let's take another look at the output of Octave's eig command.
     >> A = [ 2 -1; -1 2 ]
     A=

           2 -1
5.3. DIAGONALIZATION                                               81

   -1 2

>> [ v lambda ] = e i g (A)
v=

    -0.70711 -0.70711
    -0.70711 0.70711

lambda =

Diagonal Matrix

      10
      03

While the matrices are arranged slightly differently (the diagonalization is not unique), you
should see that results given by Octave are precisely what is needed for the orthogonal diago-
nalization problem.

Example 5.3.6. Use Octave to orthogonally diagonalize A = 3 3 .
                                                                                      3 -1

Solution. If an orthogonal diagonalization is possible, Octave will return the output of the
eig(A) command in that format. This explains why Octave chooses normalized vectors that
form an orthogonal set, when possible.

     >> A = [ 3 3 ; 3 -1]
     A=

33
3 -1

>> [Q L ] = e i g (A)
Q=

 0.47186 -0.88167
-0.88167 -0.47186

L=

Diagonal Matrix

-2.6056              0
          0  4.6056

>> Q*L*Q'    % check the f a c t o r i z a t i o n by multiplying
ans =

    3.00000   3.00000
    3.00000  -1.00000

The reader can verify that Q is indeed orthogonal as required.
82                                               CHAPTER 5. EIGENVALUE PROBLEMS

5.4 Singular value decomposition

We are now prepared to tackle the singular value decomposition (SVD). This factorization is
something of a generalized version of what we just did for symmetric matrices in Section 5.3.1.
But, the singular value decomposition exists for any matrix; the matrix need not even be square.
The key is to consider the matrices AT A and AAT . These are always square symmetric matrices,
and so, can be orthogonally diagonalized.

There are many applications associated with the SVD. For example, Netflix recently sponsored
a competition with a one million dollar prize to improve their movie recommendation algorithm.
The team that won used a method based in part on the SVD2, which can be used to discover
hidden relationships among variables. We will consider applications to least-squares problems
(Section 5.4.1) and image compression (Section 7.1).

Theorem 5.4.1. Let A be an m ื n matrix. The square roots of the nonzero eigenvalues of
AT A and AAT (they are the same) are called the singular values of A,denoted 1, 2, . . . , r.
Then A can be factored as

                                                       A = U V T

where the columns of U are eigenvectors of AAT , the columns of V are eigenvectors of AT A,
and the r singular values of A are on the diagonal of . This factorization is called the singular
value decomposition of A.

     U is m ื m and orthogonal

     V is n ื n and orthogonal

      is m ื n and diagonal of the special form

                                 .. 
                                 1               .
                                     2           0  
                                                    
                                 =               . . . ... 
                                                 r 

                                     ททท 0 ททท   0

If all the eigenvalues of AT A are distinct, then the associated eigenvectors are "automatically"
orthogonal. We only need to make them unit vectors. If there are repeated eigenvalues, it is
still possible to choose orthogonal eigenvectors, but more advanced methods are needed (see
Section 5.5.1). Our procedure starts with eigenvectors of AT A, then appropriate orthogonal
unit eigenvectors for AAT are calculated using a simple formula. The number of singular values
(nonzero eigenvalues) corresponds to the rank of the original matrix A. We will only consider
examples where the number of singular values r is equal to m, the number of rows of A, otherwise,
again, more advanced methods are required. We will consider a simple example using a 2 ื 2

    2http://buzzard.ups.edu/courses/2014spring/420projects/math420-UPS-spring-2014-gower-netflix-
SVD.pdf
5.4. SINGULAR VALUE DECOMPOSITION                                                     83

matrix, then see how Octave commands can be used to find the SVD for larger or more difficult
matrices.

Here is the simplified procedure we will use:

1. Find AT A.
2. Find the eigenvalues of AT A. The square roots of these are the singular values 1, 2, . . .,

   r, arranged in decreasing order.
3. Find the corresponding eigenvectors and make them unit vectors v1, v2, . . . , vn.

                                                         1
4. Find the vectors ui by computing ui = i Avi.
5. Then A = U V T , where 1, 2, . . . , r are on the diagonal of  and

                                             U = u1 u2 ท ท ท um

                                              V = v1 v2 ท ท ท vn

 Remember to transpose V when you write the factorization.
 Remember to keep the eigenvalues and eigenvectors in their correct order.
 This simplified procedure only works if AT A has no repeated eigenvalues and r = m.

Example 5.4.2. Let A = 4 4 . Find the SVD via the simplified procedure outlined
                                       -3 3

above, then compare to the results obtained using the Octave function svd.

Solution. We can readily verify that rank(A) = 2, so the matrix should have two singular
values.

     >> A = [ 4 4 ; -3 3 ]
     A=

  44
-3 3

>> ATA = A' *A
ATA =

25        7

7 25

>> [ v lambda ] = e i g (ATA)
v=

-0.70711        0.70711
 0.70711        0.70711

lambda =
84                                                     CHAPTER 5. EIGENVALUE PROBLEMS

    Diagonal Matrix

    18  0

    0 32

    Notice that the given eigenvectors are orthogonal unit vectors. However, the eigenvalues are
    not in decreasing order. So, we need to switch the order of both eigenvectors and singular
    values (they must be in decreasing order) as we build V and .

         >> Sigma = z e r o s ( 2 , 2 ) ;
         >> Sigma ( 1 , 1 ) = s q r t ( lambda ( 2 , 2 ) )
         Sigma =

    5.65685  0.00000
    0.00000  0.00000

    >> Sigma ( 2 , 2 ) = s q r t ( lambda ( 1 , 1 ) )
    Sigma =

    5.65685  0.00000
    0.00000  4.24264

    >> V( : , 1 ) = v ( : , 2 )
    V=

    0.70711
    0.70711

    >> V( : , 2 ) = v ( : , 1 )
    V=

    0.70711  -0.70711
    0.70711   0.70711

    Now we build U to complete the factorization.

         >> U( : , 1 ) = 1/ Sigma ( 1 , 1 ) *A*V( : , 1 )
         U=

    1.00000
    0.00000

    >> U( : , 2 ) = 1/ Sigma ( 2 , 2 ) *A*V( : , 2 )
    U=

    1.00000  0.00000
    0.00000  1.00000

    Now, let's verify that U V T = A.

         >> U* Sigma *V'
         ans =
5.4. SINGULAR VALUE DECOMPOSITION                                   85

        4.0000        4.0000
       -3.0000        3.0000

Now that we have a rough sense of how an SVD is determined, let's try the built-in Octave
function. The command [U S V] = svd(A) computes the SVD of a matrix A and stores the
result in matrices U , S, and V . Let's use this command to find the SVD of the matrix A and
verify that U SV T = A.

       >> [U S V] = svd (A)      % 3-output format o f svd command
       U=

       -1 0
         01

       S=

       Diagonal Matrix

           5.6569             0
                   0  4.2426

       V=

       -0.70711 -0.70711
       -0.70711 0.70711

       >> U*S*V'
       ans =

        4.0000        4.0000
       -3.0000        3.0000

Notice that the factorization returned by svd is slightly different than we obtained above.
This is normal: The SVD is not unique, due to variations in how representative eigenvectors
are chosen.

5.4.1 The pseudoinverse

In Section 2.2, we used the normal equations, AT Ax = AT b, to solve least-squares problems. A
potential problem with this approach is that the normal equations are typically ill-conditioned.
This means that a small change in the data can lead to a large change in the numeric solution.
This is bad! One way to avoid this computational problem is to use a generalized inverse known
as the pseudoinverse, based on the SVD.

Theorem 5.4.3. For an m ื n matrix A with singular value decomposition A = U V T , the
least-squares solution to the system Ax = b is given by

                                                        x = A+b

where

                                 A+ = V +U T
86                           CHAPTER 5. EIGENVALUE PROBLEMS

         Figure 5.2: Regression line and original data

and + is the n ื m matrix found by transposing  and taking the reciprocals of the singular

values:     .. 

            1/1                                                 .
                        1/2                                 0       
                                                                    
         + =                 ...                                ..  
                                                                .   
           
                                                    1/r 

                        ททท 0 ททท                           0

The matrix A+ is called the pseudoinverse or Moore-Penrose inverse of A.

Example 5.4.4. Consider the following sample data.

           x 5 10 12 18 21
           y 42 24 30 18 15

Find a linear equation of the form y = ax + b to model this data.

    Solution. The given points yield a system Ap = y, with

           51                                                   
                                                                   42

           10      1                                                24  
         A =  12 1   18 1  , p = a , and y =   b  30   18               

           21 1                                                     15

    Enter x, y, and A in Octave. We need to find the SVD of A:
5.4. SINGULAR VALUE DECOMPOSITION                                            87

>> [U S V] = svd (A)
U=

-0.156839          -0.767088    -0.379243  -0.354748  -0.342501
-0.311700          -0.407114    -0.118019   0.444130   0.725204
-0.373645          -0.263125
-0.559478                        0.877307  -0.107405  -0.099761
-0.652394           0.168843    -0.176557   0.585728  -0.533129
                    0.384827    -0.203488
                                           -0.567705   0.250187

S=

Diagonal Matrix

    32.22136                 0
                0  0.88546
                0
                0            0
                0            0
                             0

V=

-0.997966 0.063748
-0.063748 -0.997966

Next, we construct + by taking the transpose and reciprocal of :

>> Sp = ( 1 . / S ) ' ;         % note : d i v i s i o n by 0 returns i n f
>> Sp ( i s i n f ( Sp ) ) = 0  % set all the instances of inf to 0
Sp =

    0.03104        0.00000      0.00000    0.00000  0.00000
    0.00000        1.12936      0.00000    0.00000  0.00000

Note the "trick" used to handle the reciprocal operation. Now calculate the pseudoinverse:

>> Ap = V*Sp*U'                 % pseudoinverse
Ap =

-0.0503686 -0.0196560 -0.0073710 0.0294840 0.0479115
 0.8648649 0.4594595 0.2972973 -0.1891892 -0.4324324

Finally, we are prepared to solve the original system of equations. The least-squares solution
is now simply A+y (note that this is the matrix product A+ times y, not the sum A + y).

     >> Ap*y
     ans =

           -1.5590
           46.3784

So, the correct linear equation is y = -1.5590x + 46.3784. Plot the original data and best-
fitting line. The result is shown in Figure 5.2.
88                                   CHAPTER 5. EIGENVALUE PROBLEMS

5.5 Gram-Schmidt and the QR algorithm

5.5.1 The Gram-Schmidt process

Let u and v be two linearly independent vectors. Then the vector u-projv(u) will be orthogonal
to v.

                                 ' -projv(u)
                                 T จจจ B
                   u - projv(u)      u จจจ

                                 จจ            EE

                                     projv(u)  v

                   Figure 5.3: Orthogonal projection

Notice that the set {v, u - projv(u)} is now an orthogonal set which has the same span as the
original set {v, u}. This use of orthogonal projections to make a linearly independent set into
an orthogonal set is the basis of the famous Gram-Schmidt process.

Theorem 5.5.1. The Gram-Schmidt process
Let {u1, u2, . . . , un} be a linearly independent set. Then the following procedure will produce an
orthogonal set {v1, v2, . . . , vn} with the same span.

                        v1 = u1
                        v2 = u2 - projv1 (u2)
                        v3 = u3 - projv1 (u3) - projv2 (u3)

                              ..
                              .
                       vn = un - projv1 (un) - projv2 (un) - ท ท ท - projvn-1 (un)

To normalize, set  wi = vi
                            vi

Then the set {w1, w2, . . . , wn} is an orthonormal set with the same span as {u1, u2, . . . , un} and
{v1, v2, . . . , vn}.

Example 5.5.2. Find an orthonormal set with the same span as

                   { 10, 9, -3, 0 , -7, 7, -3, 4 , 9, 1, -8, -1 }

    Solution. Since we are going to make extensive use of vector projections, it would be a good
    idea to write a function that handles that part of the computation. This can be entered at
    the command line, or better yet, it can be saved in a function file proj.m and reused in future
    problems.

         >> f u n c t i o n v e c t = p r o j ( u , v )
                  vect = dot (u , v)/dot (v , v)*v ;

               end

    As defined, proj(u, v) now computes the projection of u onto v.
    Now, we will enter the original set of vectors as columns in a matrix U .
5.5. GRAM-SCHMIDT AND THE QR ALGORITHM                               89

>> U = [ 1 0 9 -3 0 ; -7 7 -3 4 ; 9 1 -8 -1] '     % note transpose
U=

      10 -7 9
       971

     -3 -3 -8
       0 4 -1

Next, we go through the steps of the Gram-Schmidt process to create a matrix V whose
columns are an orthogonal set with the same span as the original set.

     >> V = z e r o s ( 4 , 3 ) ;
     >> V( : , 1 ) = U( : , 1 ) ;
     >> V( : , 2 ) = U( : , 2 ) - p r o j (U( : , 2 ) , V( : , 1 ) ) ;
     >> V( : , 3 ) = U( : , 3 ) - p r o j (U( : , 3 ) , V( : , 1 ) ) - p r o j (U( : , 3 ) , V( : , 2 ) )
     V=

10.00000  -7.10526   0.37157
 9.00000   6.90526  -2.73222
                    -6.95810
-3.00000  -2.96842
 0.00000   4.00000   0.21304

These vectors are orthogonal, but not yet unit vectors, so we normalize. The final output
matrix W should have columns that are orthogonal unit vectors with the same span as the
original set.

>> W = z e r o s ( 4 , 3 ) ;              1) ) ;
>> W( : , 1 ) = V( : , 1 ) /norm (V( : ,  2) ) ;
>> W( : , 2 ) = V( : , 2 ) /norm (V( : ,  3) )
>> W( : , 3 ) = V( : , 3 ) /norm (V( : ,
W=

 0.72548  -0.64071   0.04962
 0.65293   0.62268  -0.36490
-0.21764            -0.92929
 0.00000  -0.26768
           0.36070   0.02845

The columns of W are the desired orthonormal set.

We might want to verify that the process worked. As a spot check, we can look at the dot
product of any two columns and we should get 0. Also, each column should have norm 1.

     >> dot (W( : , 1 ) , W( : , 3 ) )
     ans = 2.2204 e -016
     >> norm (W( : , 2 ) )
     ans = 1

The results are as expected, the usual minor round-off error in the dot product notwithstanding.
90                                                CHAPTER 5. EIGENVALUE PROBLEMS

5.5.2 QR decomposition

We have already seen several important matrix factorizations. The Gram-Schmidt process is the
key to another, one that turns out to provide a good means for finding eigenvalues numerically.
This is known as the QR decomposition.

Theorem 5.5.3. Let A be a nonsingular square matrix. Then there exists an orthogonal matrix
Q and an upper triangular matrix R such that A = QR.

Here's how to find Q and R.

    1. Apply the Gram-Schmidt process to the columns of A. Use the resulting orthonormal

    vectors as columns of Q.

                     q1 ท a1 q1 ท a2 q1 ท a3 ท ท ท q1 ท an  

                     0    q2 ท a2   q2 ท a3  ททท  q2 ท an   
                                                            
                     0    0         q3 ท a3  ททท  q3 ท an   
    2. Let R =                                              ,  where  qi  is  the  ith  column  of  Q  and
                     ..       ..    ..       ...   ..       
                       .     .        .           .         

                     0    0         0        0 qn ท an

    aj is the jth column of A.

                                                                          57 0          

Example 5.5.4. Find the QR decomposition of the matrix A =  10 8 0 .

                                                                          5 6 -5

    Solution. First we apply the Gram-Schmidt process to A.

         >> A = [ 5 7 0 ; 10 8 0 ; 5 6 -5]
         A=

     570
    10 8 0

     5 6 -5

    >> Q = z e r o s ( 3 , 3 ) ;                        Q(: ,  1));                     3) , Q(: ,     2));
    >> Q( : , 1 ) = A( : , 1 ) / norm (A( : , 1 ) ) ;   Q(: ,  1 )) - proj (A( : ,
    >> Q( : , 2 ) = A( : , 2 ) - p r o j (A( : , 2 ) ,
    >> Q( : , 2 ) = Q( : , 2 ) / norm (Q( : , 2 ) ) ;
    >> Q( : , 3 ) = A( : , 3 ) - p r o j (A( : , 3 ) ,
    >> Q( : , 3 ) = Q( : , 3 ) / norm (Q( : , 3 ) )
    Q=

    0.40825                0.72900   0.54944
    0.81650               -0.56077   0.13736
    0.40825                         -0.82416
                           0.39254

    Notice that we normalized each vector as we went through the process to find Q. Now, let's
    verify that Q is orthogonal. For an orthogonal matrix, Q-1 = QT , so a good way to check
    for orthogonality is to compute QT Q, which should be an identity matrix.
5.5. GRAM-SCHMIDT AND THE QR ALGORITHM                                            91

>> Q' *Q
ans =

 1.00000  -0.00000                0.00000
-0.00000   1.00000               -0.00000

 0.00000  -0.00000                1.00000

This looks correct (some round-off error can be seen if we check more digits than displayed
here). Now, we build R using the appropriate dot products of columns of Q and A.

>> R = z e r o s ( 3 , 3 ) ;     1) , A(: ,  1) ) ;
>> R( 1 , 1 ) = dot (Q( : ,      1) , A(: ,  2) ) ;
>> R( 1 , 2 ) = dot (Q( : ,      1) , A(: ,  3) ) ;
>> R( 1 , 3 ) = dot (Q( : ,      2) , A(: ,  2) ) ;
>> R( 2 , 2 ) = dot (Q( : ,      2) , A(: ,  3) ) ;
>> R( 2 , 3 ) = dot (Q( : ,      3) , A(: ,  3) )
>> R( 3 , 3 ) = dot (Q( : ,
R=

12.24745               11.83920  -2.04124
 0.00000                2.97209  -1.96270
 0.00000                0.00000
                                  4.12082

Of course, for a larger problem, we would use loops to compute the entries in R. Finally we
check to see that QR = A.

     >> Q*R
     ans =

 5.00000               7.00000    0.00000
10.00000               8.00000    0.00000
                       6.00000   -5.00000
 5.00000

It works as expected.

5.5.3 The QR algorithm

The QR decomposition is the basis of a numerical method for finding eigenvalues.
Theorem 5.5.5. The QR algorithm
Let A be an n ื n matrix with n real eigenvalues.

       Set A1 = A.
       For each k = 1, 2, 3, . . . do the following:

         (i) Find the QR decomposition of Ak, Ak = QkRk.
        (ii) Set Ak+1 = RkQk.
       Repeat steps (i) and (ii).
92                                       CHAPTER 5. EIGENVALUE PROBLEMS

As k increases, the matrices Ak approach an upper triangular form with the eigenvalues of A on

the diagonal.

                                           57 0                                   

Example 5.5.6. Apply three iterations of the QR algorithm to the matrix A =  10 8 0 .

                                           5 6 -5

    Solution. We will use the built-in QR-decomposition function, [Q R] = qr(A).

         >> A1 = A
         A1 =

     570
    10 8 0

     5 6 -5

    >> [ Q1 R1 ] = qr (A1) ;
    >> A2 = R1*Q1
    A2 =

    13.8333    -1.4881        10.0378
    -1.6254    -2.4371        -2.0258
               -1.6176        -3.3962
     1.6823

    >> [ Q2 R2 ] = qr (A2) ;
    >> A3 = R2*Q2
    A3 =

    15.159187   4.145301      -6.805968
    -0.013431  -4.054621       1.168669

     0.430485   1.750645      -3.104566

    >> [ Q3 R3 ] = qr (A3) ;
    >> A4 = R3*Q3
    A4 =

    14.959822   6.640881       5.216123
     0.065351  -4.860028      -0.375929
     0.064287  -0.846029      -2.099794

    It turns out that the correct eigenvalues of A are 15, -5, and -2. These values are already
    evident on the diagonal after only three iterations.

It is a simple matter to codify the algorithm into a loop, which allows easily running a large
number of iterations. This is left as an exercise for the reader (see Exercise 11).
EXERCISES                                                            93

Chapter 5 Exercises

             20 0                   2 -2    1             1 -1 0   
                                    1 -1
1. Let A =  0 1 -1  , B =                   1  , and C =  1 1 0 .

             02 4           -3 2 -2                       0 02

For each matrix, do the following:

(a) Find the eigenvalues and eigenvectors by hand. First give a parametric description
     for the set of eigenvectors for each eigenvalue, then choose representative eigenvectors
     with integer (or Gaussian/complex integer) components for each eigenvalue.

(b) Use Octave to find the eigenvalues and eigenvectors. Compare the Octave solution
     to your by hand solution.

(c) How many linearly independent eigenvectors does each matrix have?

2. Suppose a hypothetical state is divided into four regions, A, B, C, and D. Each year, a
   certain number of people will move from one region to another, changing the population
   distribution. The initial populations are given below:

                                    Region  Population
                                       A        719
                                       B        910
                                       C        772
                                       D        807

The following table records how the population moved in one year.

                                     To
                                     ABCD
                     From A 624 79 2 14
                               B 79 670 70 91
                               C 52 6 623 91
                               D 77 20 58 652

For example, we see that A began with 624 + 79 + 2 + 14 = 719 residents. Of these, 624
stayed in A, 79 moved to B, 2 moved to C, and 14 moved to D. From this empirical data,
we can give approximate probabilities for moving from A. Of the 719 residents, 624 stayed
in A, so the probability of "moving" from A to A is 624/719 = 0.8678720. The probability
of moving from A to B is 79/719 = 0.1098748, and so on.

(a) Find the transition matrix T for this Markov chain. This is done by converting each
     entry in the table above to a probability, then transposing.

(b) Express the initial population distribution as a probability vector x. Remember, the
     components must add to 1.

(c) Find the population distribution (expressed as percentages) in 5 years and in 10 years.

(d) Compute the eigenvalues and eigenvectors for T and use the eigenvector for  = 1 to
     construct an equilibrium vector q for this Markov chain. This represents a population
     distribution for which there is no further change from year to year. Verify that the
     distribution is in equilibrium by computing several future states, such as T 25q and
     T 50q. Is there any change in the distribution?
94                 CHAPTER 5. EIGENVALUE PROBLEMS

    3. Refer to the random walk Markov chain from Example 5.2.1. Set up the transition matrices
       for the following modified scenarios and find an equilibrium vector for each case.

    (a) At intersections 2, 3, or 4, move to the left or right with equal probability. At
         intersections 1 or 5, move back to where you came from.

    (b) At intersections 2, 3, or 4, move to the left with probability 0.4 or to the right with
         probability 0.6. At intersections 1 or 5, either stop or move back to where you came
         from with equal probability.

    4. Which of the matrices in Exercise 1 can be diagonalized? For each matrix, give a diago-
       nalization if possible, or explain why no diagonalization is possible.

    5. Diagonalize the matrix A = 1 4 as A = SS-1 and use this to calculate A50. Show
                                               1 -2

       all the steps needed to find the eigenvalues, eigenvectors, etc.

    6. Orthogonally diagonalize each symmetric matrix. Verify that the matrix equals QQT
       and show that Q is orthogonal by verifying that QQT = QT Q = I.

                                                           113        

    A = 1 -2       and B =  1 1 3 
             -2 0
                                                           339

    Solve by hand first, then check your work with Octave. (Note that B requires the Gram-
    Schmidt process.)

    7. Find the SVD of the matrix 2 3 without using the svd command. Show all the steps
                                                02

       needed to find the eigenvalues, eigenvectors, etc. Verify that A = U V T .

    8. Use the pseudoinverse to find the least-squares line y = ax + b through the given set of
       points.
                                               {(-1, 5), (1, 4), (2, 2.5), (3, 0)}

       You may use the svd command, but show all the rest of the details, including construction
       of the pseudoinverse. Include a plot of the data values and the least-squares line.

    9. Write an Octave script that takes a matrix U with linearly independent columns and
       outputs a matrix V with orthonormal columns. The core loop could look like this (or use
       your own formulation):

    V( : , 1) = U( : , 1) /norm (U( : , 1) ) ;           V(: ,  j));
    for i = 2:n

       V(: , i ) = U(: , i ) ;
        f o r j = 1 : i -1

           V( : , i ) = V( : , i ) - proj (U( : , i ) ,
        end
       V( : , i ) = V( : , i ) /norm (V( : , i ) ) ;
    end

    You will need to determine m and n and from the dimensions of U and the function
    proj(u,v) must be defined. Test your code on the vectors from Example 5.5.2.
EXERCISES                                       95

10. Use your code from Exercise 9 as the starting point of a user-defined function, stored in
     a function file, that computes the QR decomposition of an n ื n matrix A. Test your
     function on a randomly generated 4ื4 matrix, A = rand(4, 4). Check Q for orthogonality
     by computing QT Q, which should be an identity matrix, and verify that A = QR.

11. Using Octave's built-in [Q R] = qr(A) function for the QR decomposition, write a script

to approximate the eigenvalues of the matrix

             1 -1 2                           

           A =  -1 1 -2 

             2 -2 0

Run your loop through ten iterations. The actual eigenvalues are integers. Were you able
to determine the correct values from the QR algorithm?
96  CHAPTER 5. EIGENVALUE PROBLEMS
Chapter 6

Multivariable calculus and
differential equations

6.1 Space curves

Plotting a curve in 3-dimensions is similar to the 2-dimensional plotting explained in Section 1.4.
To plot space curves, we use the command plot3(x, y, z), where x, y, and z correspond to the
parametric equations for the function. For example, let's plot a simple helix, with vector equation
r(t) = sin(t)i+cos(t)j+tk. First we generate a row vector for the parameter t, then we calculate
the range for x, y, and z.

>> t = l i n s p a c e ( 0 ,  2* pi ,  30) ;
>> x = s i n ( t ) ;
>> y = c o s ( t ) ;
>> z = t ;
>> p l o t 3 ( x , y , z )

The graph is shown in Figure 6.1.
Now consider a more complicated curve, like

                         x = (5 + sin 25t) cos t, y = (5 + sin 25t) sin t, z = cos 25t

This is a "toroidal spiral." We will need to use a much finer increment for t to get a smooth
picture.

>> t = l i n s p a c e ( 0 , 2* pi , 5 0 0 ) ;      % elementwise product
>> x = ( 5 + s i n ( 2 5 * t ) ) . * c o s ( t ) ;  % elementwise product
>> y = ( 5 + s i n ( 2 5 * t ) ) . * s i n ( t ) ;
>> z = c o s ( 2 5 * t ) ;
>> p l o t 3 ( x , y , z )

These types of graphs are not easy to draw without a computer! See Figure 6.2. Note the
elementwise operations, which we utilize throughout this chapter (see Section 1.4.1).

                                                             97
98 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS
                                                   Figure 6.1: Helix

                                             Figure 6.2: Toroidal spiral
6.2. SURFACES                              99

               Figure 6.3: Saddle surface

6.2 Surfaces

How about plotting surfaces rather than curves? In this case, we use a two-dimensional "mesh"
of input values and calculate the range using a function of two variables. For example, let's
graph the familiar saddle surface shown in Figure 6.3, defined by f (x, y) = x2 - y2.

First we define the domain over which the function will be plotted.
     >> x = l i n s p a c e ( -2 , 2 , 4 0 ) ;
     >> y = l i n s p a c e ( -2 , 2 , 4 0 ) ;

Then, we use the meshgrid command to create a mesh of all possible combinations of x and y in
the domain. We will adopt the useful convention of distinguishing the meshgrid variables from
their linear counterparts by naming them with corresponding capital letters, X and Y .

     >> [X Y] = meshgrid ( x , y ) ;

Now calculate the range using these meshgrid variables.
     >> Z = X. ^ 2 - Y. ^ 2 ;

Finally, we can plot the surface with the surf command.
     >> s u r f (X, Y, Z )

The default surface graph is color coded by elevation; type help colormap for a list of alternative
color schemes. The graph can be rotated in space by clicking the rotate icon on the graph window
100 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

Figure 6.4: Contour plot of saddle surface

toolbar. To see a graph of the mesh without the surface filled in, use mesh(X, Y, Z). Also try
contour(X, Y, Z) to see a contour plot of the surface, as shown in Figure 6.4.

Example 6.2.1. Graph the surface f (x, y) = (1 + xy)(x + y).

Solution. We begin using the same basic procedure outlined above, this time choosing to
plot the function over [-5, 5] ื [-5, 5].

>> % d e f i n e t h e domain      30) ;
>> x = l i n s p a c e ( -5 , 5 ,  30) ;
>> y = l i n s p a c e ( -5 , 5 ,  y) ;
>> [X Y] = meshgrid ( x ,

>> % c a l c u l a t e t h e r a n g e
>> Z = ( 1 + X. *Y) . * (X + Y) ;

>> % p l o t t h e s u r f a c e
>> s u r f (X, Y, Z )

The graph as shown in Figure 6.5 appears unremarkable. However, an analysis of the partial
derivatives shows the existence of two critical points, at (1, -1) and (-1, 1), each of which
corresponds to a saddle point (the reader should verify this). To see these features clearly,
we need to manually adjust the viewpoint.

     >> % manually s e t new a x i s l i m i t s
     >> a x i s ([ -5 5 -5 5 -10 1 0 ] )

The two saddle points are now apparent (Figure 6.6). Notice that the axis command takes a
6-element vector as its argument, of the form [Xmin Xmax Ymin Ymax Zmin Zmax].
6.2. SURFACES                                                      101

               Figure 6.5: Graph of f (x, y) = (1 + xy)(x + y)

               Figure 6.6: Revised view showing two saddle points
102 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

6.2.1 Change of variables

To plot a surface defined over a restricted, nonrectangular domain it may be necessary to make
a change of variables. Typical examples include surfaces defined in terms of polar/cylindrical or
spherical coordinates, but more general changes of variable are also possible.

Example 6.2.2. Graph the surface f (x, y) = 9 - x2 - y2.

Solution. The function corresponds to the upper half of a radius-3 sphere. If we naively
attempt to plot the function over [-3, 3] ื [-3, 3], we will run into trouble:

>> x = l i n s p a c e ( -3 , 3 , 3 0 ) ;   be real
>> y = x ;                                  column 9
>> [X Y] = meshgrid ( x , y ) ;
>> Z = s q r t ( 9 - X. ^ 2 - Y. ^ 2 ) ;
>> s u r f (X, Y, Z )
e r r o r : mesh : X, Y, Z arguments must
error : called from

        surface> s u r f a c e at line 123
        surface at l i n e 63 column 19
        surf at l i n e 72 column 10

Of course the problem is that over parts of the rectangular region of interest, the func-
tion is undefined (or more precisely, the function values are imaginary). A quick-and-dirty
workaround is to simply plot the real part of Z. This gives a satisfactory result in this case,
but in general, this method is less than ideal.

     >> s u r f (X, Y, r e a l ( Z ) )

The graph restricted to the real component of the function is shown in Figure 6.7.

A better approach would be to graph the function using polar/cylindrical coordinates. To do
so, we create an r-meshgrid, with 0  r  3 and 0    2.

     >> r = l i n s p a c e ( 0 , 3 , 2 5 ) ;
     >> t h e t a = l i n s p a c e ( 0 , 2* pi , 2 5 ) ;
     >> [R T ] = meshgrid ( r , t h e t a ) ;

                                                    
In terms of cylindrical coordinates, z = 9 - r2.

     >> Z = s q r t ( 9 - R. ^ 2 ) ;

Now, calculate x and y using the standard polar to rectangular identities, x = r cos(),
y = r sin(). Be sure to use the meshgrid variables.

     >> X = R. * c o s (T) ;
     >> Y = R. * s i n (T) ;

Finally, graph the surface.
     >> s u r f (X, Y, Z )

The improved graph of the hemisphere is shown in Figure 6.8.
6.2. SURFACES                                                         103

Figure 6.7: Graph showing real part of a radius-3 hemisphere

               Figure 6.8: Radius-3 hemisphere graphed in polar form
104 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

               Figure 6.9: Graph of f (x, y) = ln(x + y - 1) using a change of variables
Example 6.2.3. Graph the function f (x) = ln(x + y - 1).

   Solution. This function is defined only on the half-plane x + y > 1. To graph such a function
   in Octave we must make a suitable change of variables. In this case, the domain of the function
   suggests the substitution u = x + y. We first create a ux-meshgrid, where u > 1. Then, using
   this change of variables, z = ln(u - 1) and y = u - x.

        >> % d e f i n e t h e ux-mesh
        >> u = l i n s p a c e ( 1 , 5 , 3 0 ) ;
        >> x = l i n s p a c e ( -2 , 2 , 3 0 ) ;
        >> [U X] = meshgrid ( u , x ) ;
        >> % c a l c u l a t e y and z u s i n g t h e change o f v a r i a b l e s s u b s t i t u t i o n
        >> Z = l o g (U - 1 ) ;
        >> Y = U - X;
        >> % p l o t t h e s u r f a c e
        >> s u r f (X, Y, Z )
   The resulting graph is shown in Figure 6.9.
Example 6.2.4. The function

                                          1
                                = 1 + sin(5) cos(6), 0    2, 0    

                                          4
in spherical coordinates is known as a bumpy sphere. Graph this function.
6.2. SURFACES  105

                                            Figure 6.10: Bumpy sphere

   Solution. We use a -meshgrid to calculate . Then we can calculate x, y, and z using the
   standard spherical to rectangular coordinate identities.

        >> % d e f i n e p h i (P) and t h e t a (T)
        >> t h e t a = l i n s p a c e ( 0 , 2* pi , 3 0 ) ;
        >> p h i = l i n s p a c e ( 0 , pi , 3 0 ) ;
        >> [ T P ] = meshgrid ( t h e t a , p h i ) ;

        >> % c a l c u l a t e rho (R)
        >> R = 1 + 1/4* s i n ( 5 *P) . * c o s ( 6 *T) ;

        >> % u s e s p h e r i c a l i d e n t i t i e s f o r X, Y, Z
        >> X = R. * s i n (P) . * c o s (T) ;
        >> Y = R. * s i n (P) . * s i n (T) ;
        >> Z = R. * c o s (P) ;

        >> % p l o t t h e s u r f a c e
        >> s u r f (X, Y, Z )

   The graph is shown in Figure 6.10.

6.2.2 Parametric surfaces

Some surfaces are most easily described parametrically. We can graph such a surface in Octave
by generating meshgrid arrays for the parameters, then calculating x, y, and z.
106 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

                                                  Figure 6.11: Torus
Example 6.2.5. The curve in Figure 6.2 lies on the surface of a torus, defined parametrically
as

                                              x = (5 + cos(u)) cos(v)
                                              y = (5 + cos(u)) sin(v)
                                              z = sin(u),

where u, v  [0, 2]. Graph this surface.
   Solution. We begin by defining the parameters.
        >> u = l i n s p a c e ( 0 , 2* pi , 2 5 ) ;
        >> v = u ;
        >> [U V] = meshgrid ( u , v ) ;
   Calculate x, y, and z:
        >> X = ( 5 + c o s (U) ) . * c o s (V) ;
        >> Y = ( 5 + c o s (U) ) . * s i n (V) ;
        >> Z = s i n (U) ;
   Now, plot the surface.
        >> s u r f (X, Y, Z )
        >> a x i s ( ' e q u a l ' )
   The result is shown in Figure 6.11. Note the use of axis( 'equal') to force an equal aspect
   ratio.
6.2. SURFACES                                                         107

                               Figure 6.12: Solid of revolution

Solids of revolution can also be graphed as parametrically defined surfaces. For example, para-
metric equations for the surface formed by rotating the graph of y = f (x) about the x-axis
are

                               x=x                                    (6.1)
                               y = f (x) cos(t)                       (6.2)
                               z = f (x) sin(t)                       (6.3)

where 0  t  2 and a  x  b.

Equations 6.1-6.3 can be modified as needed to produce rotations around the other axes.

Example 6.2.6. Graph the solid obtained by rotating f (x) = x2 - 4x + 5, for 1  x  4, about
the x-axis.

Solution. These commands will graph the surface.

>> x = l i n s p a c e ( 1 , 4 , 2 5 ) ;      % define the domain
>> f = @( x ) x . ^ 2 - 4* x + 5 ;            % define the function
>> t = l i n s p a c e ( 0 , 2* pi , 2 5 ) ;  % define the parameter
>> [X T ] = meshgrid ( x , t ) ;              % xt-mesh
>> Y = f (X) . * c o s (T) ;                  % calculate Y
>> Z = f (X) . * s i n (T) ;                  % calculate Z
>> s u r f (X, Y, Z )                         % graph surface

The result is in Figure 6.12.
108 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

6.3 Multiple integrals

We showed methods for evaluating single integrals numerically in Chapter 3. We now consider
multiple integrals. The commands dblquad and triplequad can be used to evaluate double and
triple integrals over a rectangle or rectangular box.

For example, let's evaluate:

                                 32

                                     (x2y + 2y) dx dy

                              -1 0

>> % d o u b l e i n t e g r a l u s i n g dblquad
>> f u n c t i o n z = f ( x , y )

         z = x .^2.* y + 2*y ;
      end
>> dblquad ( ' f ' , 0 , 2 , -1, 3 )
ans = 26.667

Evaluating over a nonrectangular domain is a trickier problem. Let's give it a try.

Example 6.3.1. Evaluate
                                                       (x2y + y2x) dA

                                                                      R

over the region R bounded by the graphs of y = x2 and y = x.

   Solution. An analysis of the region of integration (Figure 6.13) shows that we need to
   evaluate the following iterated integral:

                                                                         
                                                                     1x

                                                        (x2y + y2x) dy dx

                                                                    0 x2

We need to evaluate over only part of the rectangle [0, 1] ื [0, 1]. One approach is to define
the integrand to be 0 for values outside of the region of integration. We do this using logical
functions. Logical functions simply test whether a statement is true and return a value of
1 if true or 0 if false. For example 2 + 3 < 4 returns 0, since the inequality is false. We
can also use Boolean operators, like and (&) and or (|). Our region demands that we meet

                                            
two conditions, y > x2 and y < x, so we use these conditions to define the function. By
multiplying the integrand by the correct logical operator, it is set to 0 outside the region of
interest.

>> % d o u b l e i n t e g r a l o v e r a n o n r e c t a n g u l a r domain  sqrt (x))) ;
>> f u n c t i o n z = f ( x , y )

         z = (x.^2.*y + y.^2.*x) .* ((y > x.^2) & (y <
      end
>> dblquad ( ' f ' , 0 , 1 , 0 , 1 )
ans = 0.10701
6.3. MULTIPLE INTEGRALS                                          109

           Figure 6.13: Region of integration for Example 6.3.1

         
      1x

Thus  (x2y + y2x) dx dy  0.10701. This is reasonably close to the exact value of 3/28,

          0 x2

but not in perfect agreement. The problem is that we have defined f as a discontinuous

function (see Figure 6.14), but the quadrature algorithm works best on a smooth integrand.

Besides its relative simplicity, the approach in Example 6.3.1 is nice for two further reasons: It
illustrates the formal definition of a double Riemann integral over a nonrectangular domain (see
[7, ง5.2]), and it also allows us to plot the surface over the region of interest (Figure 6.14).

     >> x = l i n s p a c e ( 0 , 1 , 3 0 ) ;
     >> y = x ;
     >> [X Y] = meshgrid ( x , y ) ;
     >> Z = f (X, Y) ;
     >> s u r f (X, Y, Z )

If we are unsatisfied with the numerical accuracy of this method for the double integral, another
approach is to use a change of variables to transform to a rectangular region of integration as
follows:

                          y = y1 + u(y2 - y1)                    (6.4)
                         dy = (y2 - y1) du                       (6.5)
110 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

                   Figure 6.14: Solid volume for Example 6.3.1

Then as y ranges from y1 to y2, u ranges from 0 to 1 and the integrand becomes

           x2 y2                    x2 1

                  f (x, y) dy dx =        f (x, y1 + u(y2 - y1))(y2 - y1) du dx      (6.6)

           x1 y1                    x1 0

This is a bit cumbersome to enter in Octave. We'll use a series of anonymous functions (see
page 39) to define the integrand, then try dblquad again.

Example 6.3.2. Use the change of variable formulas in Equations 6.4-6.6 to evaluate

                                                                       
                                                                   1x

                                                      (x2y + y2x) dy dx

                                                                 0 x2

Solution.

>> f 1 = @( x , y ) x . ^ 2 . * y + y . ^ 2 . * x ;

>> y1 = @( x ) x . ^ 2 ;

>> y2 = @( x ) s q r t ( x ) ;

>> f 2 = @( x , u ) f 1 ( x , y1 ( x ) + u . * ( y2 ( x ) - y1 ( x ) ) ) . * ( y2 ( x ) - y1 ( x ) ) ;

>> format l o n g                   % display additional decimal places

>> dblquad ( f2 , 0 , 1 , 0 , 1 ) % no q u o t e s around anonymous f u n c t i o n name

ans = 0.107142857143983

>> 3/28                             % compare r e s u l t to known exact answer

ans = 0.107142857142857

This approach gives a more satisfactory result.
6.3. MULTIPLE INTEGRALS                        111

If one wishes to evaluate many integrals of this form, writing a function file to automate the
above steps would be a good idea.

Example 6.3.3. Write an Octave function file that computes

                                                          f (x, y) dA

                                                                          R

over the region R bounded by the graphs of y = y1(x), y = y2(x), x = a, and x = b, using the
change of variables in Equations 6.4-6.6.

   Solution. A function file is similar to a script; it is a plain text .m-file containing a series
   of Octave commands. To be recognized as a function file, the first line of code (excluding
   comments and white space) must be function. With the file placed in the load path, it can
   then be run from the command line like any other Octave function. The function name
   should match the file name. A well-written function file will include details like help text and
   provisions for error checking. Refer to [3]. We will give a minimal example that accomplishes
   our change of variables procedure. Use the text editor to enter the following code:

                                 Octave Script 6.1: Double integral function file
  1 % f u n c t i o n f i l e ' d b l i n t .m'
  2 % evaluates dblquad ( f , x1 , x2 , y1 , y2 )
  3 % where f i s an anonymous function of x and y
  4 % y1 and y2 are anonymous functions of x
  5 % x1 and x2 are r e a l numbers

    6

  7 function val = d blin t ( f , x1 , x2 , y1 , y2 )
  8 f 2 = @( x , u ) f ( x , y1 ( x ) + u . * ( y2 ( x ) - y1 ( x ) ) ) . * ( y2 ( x ) - y1 ( x ) ) ;
  9 val = dblquad ( f2 , x1 , x2 , 0 , 1) ;
 10 end

Note that the comment lines at the top of our function file will be displayed if we type
help dblint. Thus we should strive to put a good description of the syntax in those lines.
Now, to use this function, saved in our working directory as dblint.m, we need to define the
integrand and the functions representing the limits of integration on y. Then we pass these
to our function dblint. Let's try it on the integral from Example 6.3.1.

>> f = @( x , y ) x . ^ 2 . * y    + y.^2.*x;
>> y1 = @( x ) x . ^ 2 ;           y2 )
>> y2 = @( x ) s q r t ( x ) ;
>> d b l i n t ( f , 0 , 1 , y1 ,
ans = 0.10714

It works!

6.3.1 Double Riemann sums

We have seen a little about how Octave's built-in multiple integration functions work. Now
suppose that instead we want to write our own algorithms. It is straightforward to write an
    112 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

    Octave script that will estimate a double integral over a rectangle using a double Riemann
    sum, taking sample points to be, say, the upper right hand corners of the subrectangles in the
    partition.

    For our example, we'll use the function f (x, y) = x + 2y2, defined on R = [0, 2] ื [0, 4], using
    m = n = 1000. Use the text editor to enter the following code. Save the file with the name
    dbl_Rsum.m in your current working directory.

                               Octave Script 6.2: Nested loop double integral

1 % f i l e ' dbl Rsum .m'
2 % approximates a double i n t e g r a l using upper r i g h t hand corners of
3 % subrectangles as sample points
4 % --n e s t e d l o o p v e r s i o n

 5

 6 % define region of integration
 7 a = 0;
 8 b = 2;
 9 c = 0;
10 d = 4 ;

11

12 % d e f i n e f u n c t i o n
13 f u n c t i o n z = f ( x , y )
14 z = x + 2* y . ^ 2 ;
15 end

16                  partition

17 % d e f i n e
18 m = 1000
19 n = 1000

20                             initialize  Riemann sum  total

21 % c a l c u l a t e dA and
22 dx = ( b - a ) /m
23 dy = ( d - c ) /n
24 dA = dx* dy ;
25 rsum = 0 ;

26

27 % compute d o u b l e Riemann sum

28 f o r i = 1 :m

29 f o r j = 1 : n

30      rsum = rsum + dA * f ( a + dx* i ,  c + dy* j ) ;

31 end

32 end

33                  result

34 % d i s p l a y
35 rsum

    Now, run the script:

         >> dbl Rsum
         m = 1000
         n = 1000
         dx = 0.0020000
         dy = 0.0040000
         rsum = 93.469
6.3. MULTIPLE INTEGRALS                                                          113

The estimate is reasonably close to the correct value of 93.333. However, the script is very slow,
due to the inefficiency of running the calculation via nested loops. Notice that the program
needs to compute one million function values in this example!

The routine can be sped up dramatically by using vectorized code, which takes advantage of
Octave's fast algorithms for executing matrix and vector calculations. The new strategy is to
generate a meshgrid array of the sample points, which is then used to define an m ื n matrix
containing the function values at the sample points. Finally, the Riemann sum is simply dA
times the sum of all entries in the matrix. The vectorized script is shown below.

                             Octave Script 6.3: Vectorized double integral

1 % f i l e ' dbl Rsum v2 .m'
2 % approximates a double i n t e g r a l using upper r i g h t hand corners of
3 % subrectangles as sample points
4 % --v e c t o r i z e d v e r s i o n

 5

 6 % define region of integration
 7 a = 0;
 8 b = 2;
 9 c = 0;
10 d = 4 ;

11

12 % d e f i n e f u n c t i o n
13 f u n c t i o n z = f ( x , y )
14 z = x + 2* y . ^ 2 ;
15 end

16                partition

17 % d e f i n e
18 m = 1000
19 n = 1000

20

21 % c a l c u l a t e dA
22 dx = ( b - a ) /m
23 dy = ( d - c ) /n
24 dA = dx* dy ;

25

26 % c a l c u l a t e x and y v a l u e s i n p a r t i t i o n
27 x = [ a + dx : dx : b ] ;
28 y = [ c + dy : dy : d ] ;

29                                                values

30 % c r e a t e m a t r i x o f f u n c t i o n
31 [X Y] = meshgrid ( x , y ) ;
32 A = f (X, Y) ;

33

34 % c a l c u l a t e Reimann sum
35 rsum = dA*sum ( sum (A) )

This version gives the same result and executes significantly faster (try it!). But it is still not
particularly accurate, considering the rather large values for m and n. The problem is that
taking the upper right hand corners as sample points generally does not give the best estimate.
The code can easily be improved by taking sample points at the midpoints of each rectangle.
This minor adjustment is left as an exercise for the reader (see Exercise 10).
114 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

                   Figure 6.15: Vector field plot

6.4 Vector fields

A vector field assigns vectors to points in space. Vector fields are used to describe things like
wind speed, fluid flow, electric charge, or gravitational force. A vector field is conveniently
visualized by drawing a directed line segment for a series of representative points in the space.
As any archer knows, a collection of arrows is called a quiver. Thus the command for plotting a
vector field is quiver. The simplest form of the command is quiver(X, Y, U, V), where X and Y
are meshgrid variables over which the field is plotted, and U and V are the x- and y-component
functions, respectively.

Example 6.4.1. Graph the vector field F(x, y) = -x, y .

   Solution.

        >> x = l i n s p a c e ( -2 , 2 , 1 0 ) ;
        >> y = x ;
        >> [X Y] = meshgrid ( x , y ) ;
        >> q u i v e r (X, Y, -X, Y) ;
        >> g r i d on

   See Figure 6.15. Some experimentation may be needed to determine the correct grid spacing.
   Too many points will result in an array of vectors too dense to interpret.

We can also plot vector fields in three dimensions with quiver3 or add a vector field plot to the
contour graph of a surface. We will illustrate these ideas with two more examples.
6.4. VECTOR FIELDS  115

                                  Figure 6.16: Three dimensional vector field

Example 6.4.2. Plot the vector field F(x, y, z) = 1, 1, z .

   Solution.
        >> x = l i n s p a c e ( -3 , 3 , 1 0 ) ;
        >> y = x ;
        >> z = x ;
        >> [X Y Z ] = meshgrid ( x , y , z ) ;
        >> q u i v e r 3 (X, Y, Z , o n e s ( s i z e (X) ) , o n e s ( s i z e (Y) ) , Z )

   Note the use of the ones command to produce the constant terms. The result is in Figure 6.16.

Example 6.4.3. Graph a contour plot of the Octave function "peaks" and its gradient field.

   Solution. The command peaks plots an example graph of a surface with a number of max-
   imums and minimums. Type help peaks for details, or just peaks to see the graph (Fig-
   ure 6.17). It will be instructive to see its contours plotted together with its gradient field.
   We can use the built-in gradient function for this.

        >> [X Y Z ] = peaks ;
        >> [DX DY] = g r a d i e n t ( Z ) ;
        >> c o n t o u r (X, Y, Z )
        >> h o l d on
        >> q u i v e r (X, Y, DX, DY)
        >> a x i s ([ -2 2 -2 2 ] )
        >> h o l d o f f

   See the results in Figure 6.18.
116 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS
                                        Figure 6.17: The "peaks" surface

                                 Figure 6.18: Gradient field with contour plot
6.5. DIFFERENTIAL EQUATIONS                                                                             117

6.5 Differential equations

6.5.1 Slope fields

The quiver function we used to plot vector fields in Section 6.4 can also be used to plot the slope
field of a differential equation. The key is recognizing that a differential equation of the form
dy/dx = f (x, y) is a function that gives us slopes, which we can interpret as vectors. This will
be illustrated with a simple example.

Example 6.5.1. Plot the slope field along with several solutions of the differential equation

                                                          dy
                                                              =x

                                                          dx
   Solution. The solution is y = 12 x2 + C. For differential equations that cannot be solved so
   easily, plotting the slope field can be used to get a sense of the solutions. In this example,
   since we know the solution, we can show how the solutions follow the slope field.

We need to define the input range as a meshgrid, define the function, then use the function
to calculate slopes. To get a good looking graph, we then scale these slope vectors to a unit
length. Finally, we plot some solutions for different values of C.

     >> % d e f i n e i n p u t v a l u e s
     >> x = l i n s p a c e ( -5 , 5 , 3 0 ) ;
     >> y = x ;
     >> [X Y] = meshgrid ( x , y ) ;

>> % d e f i n e f u n c t i o n
>> f = @( x , y ) x ;

>> % d e l t a -y , r e l a t i v e t o 1 u n i t d e l t a -x
>> dY = f (X, Y) ;
>> dX = o n e s ( s i z e (dY) ) ;

>> % f a c t o r t o s c a l e t o u n i t l e n g t h
>> L = s q r t ( 1 + dY . ^ 2 ) ;

>> % p l o t t h e f i e l d ( n o t e : s c a l e f a c t o r 0 . 5 f o r s h o r t e r a r r o w s )
>> q u i v e r (X, Y, dX . / L , dY . / L , 0 . 5 )
>> a x i s ([ -4 4 -4 4 ] )
>> g r i d on
>> x l a b e l ( ' x ' )
>> y l a b e l ( ' y ' )

>> % add some p a r t i c u l a r s o l u t i o n s t o graph f o r  comparison
>> h o l d on
>> f o r C = -4:3

         plot (x , 0.5*x.^2 + C, ' r ' , ' linewidth ' , 2)
      end

The results are shown in Figure 6.19.
118 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

                      Figure 6.19: Slope field and solutions

6.5.2 Euler's method

Euler's method is probably the simplest numerical technique for solving an ordinary differential
equation.

Given a differential equation y = f (x, y) with initial condition y(x0) = y0, Euler's method gives
approximate solutions:

                                   yi+1 = yi + hf (xi, yi)    (6.7)

The value of h is the step size. If the interval [x0, b] is divided into n equally spaced subintervals,
then h = b - x0 . To see how this works, let's look at an example.

                n

Example 6.5.2. Solve

                                   y = e-3x - 3y, y(0) = 1

on [0, 3] using a step size of 1.

Solution. We will generate a series of approximate y-values at x = 0, 1, 2, 3. The value y0 is
given. We compute the remaining values using Equation 6.7. Here is the first step:

                                              y1 = y0 + hf (x0, y0)
                                                   = 1 + (1)f (0, 1)
                                                   = 1 + (1)(-2)
                                                   = -1
6.5. DIFFERENTIAL EQUATIONS                                                119

    This is then used to compute y2.

                                                y2 = y1 + hf (x1, y1)
                                                      = -1 + (1)f (1, -1)
                                                      = 2.0498

    One more step:

                                     y3 = y2 + hf (x2, y2)
                                          = 2.0498 + (1)f (2, 2.0498)
                                          = -4.0971

    Our approximate solutions are summarized in the following table.

                                          x          y

                                          0 1.0000

                                          1 -1.0000

                                          2 2.0498

                                          3 -4.0971

    Unfortunately, these solutions are not very accurate. But, we can do much better by decreas-
    ing the step size, as shown in the next example.

These repetitive computations are best implemented in an Octave script. This allows using
a smaller step size, which gives a finer range of solution values and also improves the overall
accuracy. Refer to [8] for a fuller discussion of the accuracy of Euler's method and a range of
more sophisticated algorithms.

Example 6.5.3. Solve                 y = e-3x - 3y, y(0) = 1
on [0, 3] using a step size of 0.1.

    Solution. We will write a fairly general Octave script that can be easily modified for different
    functions, intervals, and step sizes.

                                     Octave Script 6.4: Euler's method

1 % Euler ' s method s o l u t i o n f o r
2 % dy/dx = e^(-3x ) - 3y , y (0) = 1 on [ 0 , 3 ]

3             function and i n i t i a l  condition
              y ) exp(-3*x ) - 3*y ;
4 % define
5 f = @( x ,
6 y0 = 1;

 7

 8 % defi ne i n t e r v a l and step s i z e
 9 a = 0;
10 b = 3 ;
11 h = 0 . 1 ; % n o t e : s t e p s i z e must d i v i d e b-a
12 n = ( b - a ) /h ;

13
120 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

Figure 6.20: Euler's method solution for Example 6.5.3

14 % d e f i n e x-v a l u e s
15 x = [ a : h : b ] ;

16                                           y( i )) ;

17 % c a l c u l a t e y-v a l u e s
18 y ( 1 ) = y0 ;
19 f o r i = 1 : n
20 y ( i + 1 ) = y ( i ) + h* f ( x ( i ) ,
21 end

22

23 % p l o t s o l u t i o n s
24 >> p l o t ( x , y , ' o : ' , ' l i n e w i d t h ' , 2 )

Figure 6.20 shows the approximated solution compared to the exact solution, which is known
to be y = e-3x(x + 1).

6.5.3 The Livermore solver

Octave has a built-in function for solving differential equations numerically, called lsode, which
implements the Fortran routine of the same name (Livermore solver for ordinary differential
equations). The command lsode( f , x 0, t) solves differential equation dx/dt = f (x, t) with
initial condition x(t0) = x0 over the range specified by t. Notice that the initial value x0 needs
to correspond to the first value of the vector t. Refer to the documentation for further details.
6.5. DIFFERENTIAL EQUATIONS                                                                    121

                                       Figure 6.21: lsode numeric solution

Example 6.5.4. Use lsode to solve the differential equation
                                                     dx = x(t2 + 1)
                                                     dt

on [0, 2], with initial condition x(0) = 1.

Solution. To solve using lsode, we define the function listing x first, then t.

>> % d e f i n e t h e f u n c t i o n , i n p u t v a l u e s , and i n i t i a l  condition
>> f = @( x , t ) x . * ( t . ^ 2 + 1 ) ; % x f i r s t , then t
>> t = l i n s p a c e ( 0 , 2 , 5 0 ) ;
>> x0 = 1 ;

>> % c a l c u l a t e t h e s o l u t i o n s
>> x s o l = l s o d e ( f , x0 , t ) ;

>> % p l o t t h e s o l u t i o n s
>> p l o t ( t , x s o l , ' l i n e w i d t h ' , 2 )
>> g r i d on
>> x l a b e l ( ' t ' )
>> y l a b e l ( ' x ' )

The solution is shown in Figure 6.21.
122 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

             Figure 6.22: ode45 vs lsode numeric solutions

6.5.4 ODE45

For compatibility with Matlab, several other solvers are available. Let's revisit Example 6.5.4
and solve using the Matlab-equivalent command ode45.

Example 6.5.5. Use ode45 to solve the differential equation

                                                     dx = x(t2 + 1)
                                                     dt
on [0, 2], with initial condition x(0) = 1. Compare to the lsode solution from Example 6.5.4.

Solution. We need to redefine the function. Matlab convention requires giving the inde-
pendent variable first, the opposite of what lsode required.

>> % d e f i n e t h e f u n c t i o n , i n p u t v a l u e s , and i n i t i a l  condition
>> f = @( t , x ) x . * ( t . ^ 2 + 1 ) ; % t f i r s t , then x
>> t s p a n = [ 0 2 ] ;
>> x0 = 1 ;

>> % c a l c u l a t e t h e s o l u t i o n s
>> [ t s o l , x s o l ] = ode45 ( f , tspan , x0 ) ;

>> % p l o t t h e s o l u t i o n s
>> p l o t ( t s o l , x s o l , ' o- ' )

Figure 6.22 compares the lsode and ode45 solutions. The solutions seem to agree.
6.5. DIFFERENTIAL EQUATIONS                                                           123

6.5.5 Exact solutions

The dsolve function, part of the symbolic package, provides a method for finding exact solutions
to differential equations. To demonstrate the syntax, we revisit the equation from Example 6.5.3.

Example 6.5.6. Find the general solution for y = e-3x - 3y. Then, find the particular solution
if y(0) = 1.

   Solution. First, the symbolic package must be installed and loaded. Refer to Section 3.4 for
   details.

   To set things up, we declare y as a symbolic function of x.
        >> pkg l o a d s y m b o l i c
        >> syms y ( x )

Now, define the differential equation. We do this using the equality operator, "==".

     >> ode = d i f f ( y , x )==exp (-3*x ) - 3* y
     ode = ( sym )

d                              -3*x

--(y ( x ) ) = -3*y ( x ) + e

dx

The general solution can now be determined:
     >> d s o l v e ( ode )
     ans = ( sym )

                                        -3*x
         y ( x ) = ( C1 + x ) * e

To find the particular solution, we simply need to provide the initial condition.
     >> d s o l v e ( ode , y ( 0 ) ==1)
     ans = ( sym )

                                      -3*x
         y(x) = (x + 1)*e

This is in good agreement with the numeric solutions determined earlier with Euler's method.
124 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

Chapter 6 Exercises

   1. Let r(t) = e-t, t, sin(t) .

        (a) Graph the function on the interval [0, 2].
        (b) Graph the function over the interval [0, 6] and explain the behavior of the graph in

              the limit as t  . The command comet3(x, y, z) may be helpful.
   2. Let r(t) = t cos(t), t sin(t), t2 .

        (a) Graph the function for t  [0, 2].
        (b) Find the equation of the line tangent to the curve at (-, 0, 2). Plot the tangent

              line on the same axes with the curve.

   3. Graph each surface.
        (a) f (x, y) = x2 + y2 - 4x + 2y - 1
        (b) f (x, y) = sin(xy) + 1
         (c) f (x, y) = 1/(1 - x2 - y2)
        (d) f (x, y) = ln(xy - 1)

   4. Let f (x, y) = sin(x) + cos(y).

        (a) Graph the surface on [-2, 2] ื [-2, 2].
        (b) Identify any maximums, minimums, or saddle points on the region (-, ) ื (-, ).
         (c) Graph a contour plot of the surface on [-, ] ื [-, ] and plot markers at any

              critical points identified in part (b).
        (d) Calculate f (x, y) and add a plot of the gradient field to the contour plot.

   5. Find a vector function that represents the curve of intersection of the circular cylinder
       x2 + y2 = 4 and the parabolic cylinder z = x2. Graph the two surfaces and the curve of
       intersection.
       The command [X Y Z] = cylinder([2 2]) can be used to obtain a cylinder of radius 2. The
       output is a cylinder with height 1, which can be stretched as needed to an arbitrary height.
       For example, if you need height 4, set Z = 4*Z.
                           4

   6. Let f (x, y) = . Find the equation of the tangent plane at (2, 2, 1). Graph the surface
                          xy

       and tangent plane on the same axes over an appropriate domain.

   7. Calculate the volume of the bumpy sphere from Example 6.2.4.

   8. A cylindrical drill with radius 1 is used to bore a hole through the center of a sphere of
       radius 5. Graph the ring shaped solid that remains and find its volume.

   9. Use dblquad to evaluate the double integral

                                                              x cos y dA

                                                                               D

       where D is bounded by y = 0, y = x2, x = 0, and x = 2.
EXERCISES                                                                              125

10. Let f (x, y) = x + 2y2, defined on R = [0, 2] ื [0, 4]. Write a vectorized script to compute
     a double Riemann sum using midpoints of each subrectangle as the sample points. Use a
     partition with m = n = 1000. Compare your results to the value computed using dblquad
     ('f' , 0, 2, 0, 4) and to the estimate using upper right hand corner sample points, as in
     Scripts 6.2 and 6.3.

11. Write a function file to implement the vectorized midpoint rule algorithm from Exercise 10.

Your function should take as inputs an anonymous two variable function, limits of inte-

gration, and a constant term for the number of subdivisions in the partition (let m = n).
1 2 Name the function dblMid and test the code on the integral ex2 cos(y) dx dy, using

                                                    -1 0

various values for m. For example,

>> f = @( x , y ) exp(-x . ^ 2 ) . * c o s ( y ) ;
>> m = 1 0 0 ;
>> dblMid ( f , 0 , 2 , -1, 1 , m)
ans = 1.4845

Compare to the result using dblquad. How large does m need to be before the midpoint
algorithm matches Octave's quadrature algorithm, to five significant figures?

12. Let F(x, y) = -y, x .

(a) Plot the field on [-2, 2] ื [-2, 2].

(b) Try to determine visually if the curl of the field is positive, negative, or zero. Confirm
     your answer using the command curl(X, Y, U, V). This determines the curl at each
     point in the meshgrid used for the quiver plot. Or load the symbolic package and use
     the following syntax:

           >> syms x y z
           >> F = [-y x 0 ]
           >> c u r l (F , {x , y , z } )

(c) Try to determine visually if the divergence of the field is positive, negative, or zero.
     Confirm your answer numerically using the command divergence(X, Y, U, V), or
     symbolically using divergence(F, {x, y, z}), with F defined as above.

(d) Calculate the curl and divergence by hand and compare to the numeric results from
     Octave.

13. Let F(x, y) = tan-1  y  i + ln(x2)j.
                         x

(a) Plot the field on [-2, 2] ื [-2, 2].
(b) Determine visually if the curl is positive or negative. (Hint: the sign of the curl is

     different for positive and negative x-values.)
(c) Confirm your answer to part (b) by calculating the curl of the field.

                            -x            -y        -z
14. Let F(x, y, z) = (x2 + y2 + z2)3/2 i + (x2 + y2 + z2)3/2 j + (x2 + y2 + z2)3/2 k.

(a) Plot the vector field.
(b) Show that the field is conservative.
126 CHAPTER 6. MULTIVARIABLE CALCULUS AND DIFFERENTIAL EQUATIONS

  15. Let dx = x(t2 + 1) with initial condition x(0) = 1.
             dt

        (a) Use Euler's method to solve the differential equation on [0, 2] using a step size h = 0.1.
              Compare to the lsode and ode45 solutions shown in Figure 6.22.

        (b) Use dsolve to find the exact solution.

                                                dy
  16. Consider the logistic equation = y(1 - y).

                                                dx
        (a) Graph the slope field for this equation on [-6, 6].
        (b) Use lsode or ode45 to solve the equation if y(0) = 0.5. Graph the solution over the

              slope field.
         (c) Use dsolve to find first the general solution, then the particular solution given y(0) =

              0.5.
Chapter 7

Applied projects

What is any of this stuff good for? Lots! This chapter contains several extended projects suitable
for calculus and linear algebra students. Major mathematical topics include the singular value
decomposition, nonlinear curve-fitting, cubic splines, triangulation, arc length and curvature,
space curves and surfaces, and systems of differential equations.

Some projects require packages from Octave Forge. To see a list of your installed packages, type
pkg list . If you do not already see the package you need listed, type pkg install -forge NAME.
Once installed, the package is loaded with the command: pkg load NAME.

7.1 Digital image compression

How do we reduce large images to manageable file sizes? One approach uses the singular
value decomposition (SVD). A digital image can be represented as a matrix, where each entry
represents a pixel and we assign a numeric value to each color. The singular values of the matrix
are the key. Typically some of these are large, but many are very small. By keeping only the
significant singular values and throwing out the rest, we can significantly reduce the amount
data that we need to store.

To illustrate the idea, we have imported a small grayscale image file. It is 133 ื 150, which
means the matrix has 19, 950 entries. The SVD is then used to generate several approximations
at significantly reduced file sizes. The original and reduced images are shown in Figure 7.1 (the
original, exact image is at the far right).

The first approximation uses only three singular values. That means we keep three s, plus
three columns of U and three columns of V . We can simply set the other values to 0 (then we
don't need to store that data), or delete them. We then multiply these smaller matrices back
together to obtain a full size approximation of the original image. The upshot is we only have to
store 3 + (3 ื 133) + (3 ื 150) = 852 data values, compared to the original total of 19, 950. That
is only 4% of the original size! Keeping a few more singular values, the second approximation
uses 10 singular values and is 14% of the original size. The image quality is not bad, considering
how much of the original data we threw away. The third approximation, with 30 singular values,

                                                            127
128                                                            CHAPTER 7. APPLIED PROJECTS

                                         Figure 7.1: SVD approximations

looks almost as good as the original. But, it is only 43% of the original size. For comparison,
the exact image is shown on the far right.

Octave supports several image file types. We will use jpg files, which are loaded as RGB (red,
green, blue) images, represented as a set of three m ื n matrices containing the color values for
each pixel. For simplicity, we will convert this to a single m ื n grayscale matrix. Some of the
Octave commands needed for basic image processing are listed in the table below.

     Image processing commands

     Syntax                                       Description

     pkg install -forge image . . . install the image package from Octave Forge

     pkg load image . . . . . . . . . . . . .     load the image package
     im = imread('filename.jpg');                 load an image
     name = imresize(im, 0.5); . .                reduce image size by a specified factor (e.g., 0.5)

     name = rgb2gray(im); . . . . . . convert to grayscale

     imshow(im) . . . . . . . . . . . . . . . . display an image

     imagesc(im) . . . . . . . . . . . . . . . .  display a matrix as a scaled image
     colormap('gray') . . . . . . . . . . . .     set colormap to grayscale
     colormap('default') . . . . . . . . .        restore colormap to default

Problems

   1. For this problem, you will use the SVD to produce a compressed image using k singular
       values. You choose k (something between 5 and 50 would be suitable). To begin, you will
       need a digital photo in jpg format. Make sure you have loaded the image package.

        (a) Load the image in Octave as "imcolor," then convert to a grayscale image.
        (b) Check the size of your grayscale image and if it is larger than approximately 320ื280,

              determine an appropriate reduction factor and reduce it. Reducing to a modest size
              makes it easier to open the variables in the variable editor to inspect their values.
              Name the reduced, grayscale format image "im." This is the image that will be
              compressed via the SVD method. Display the reduced grayscale image using imagesc
              and verify that it still looks like the original. Include a copy of this grayscale image
              with your problem solutions and state its size.
7.1. DIGITAL IMAGE COMPRESSION                                                         129

     (c) Find the SVD of the matrix representation "im."

    (d) Use the SVD to calculate an approximation using k singular values. That means you
          should only keep the first k columns of U , the k largest values of , and the first
          k columns of V . Set the other values to 0 (or delete the extra columns altogether),
          then compute U V T to recover an approximation of the original image. Save it as
          "im2" and display it using imagesc. Include a copy of the reduced image with your
          problem solution.

     (e) How many nonzero values are saved in the compressed factorization compared to the
          original?

2. Using the "outer product" expansion of A = U V T , the matrix A can be calculated
   column-by-column as

                                     A = 1u1v1T + 2u2v2T + ท ท ท + rurvrT

   where each term is an m ื n matrix. For any k < r, the sum of the first k terms will be
   an approximation using km + kn + k data values.

     (a) Use the steps outlined in problem 1 to load a grayscale image matrix.

    (b) Write a for-loop to generate an outer product expansion using k singular values.

     (c) Run the loop through 1, 5, 10, 20, and 30 iterations, saving a copy of the output
          image each time.

    (d) How many singular values do you think are needed before the quality of the reduced
          image is "good enough"?

     (e) At what k-value does the SVD approximation actually require saving more data than
          the original image?

3. Use the iterative outer product method of problem 2 to create a slide show showing the
   progressive quality improvement as the number of singular values increases from 1 up to
   the point where the approximation and original are indistinguishable.

   You will need to use a loop that produces an approximation for each i from 1 to k. Some
   special formatting is needed to create a series of file names that increment as you cycle
   through the loop. Load your grayscale image and find the SVD. Then use the code below
   as a template to generate a series of progressively better approximations.

         >> % i n i t i a l i z e a p p r o x i m a t i o n and s e t number o f s i n g u l a r v a l u e s
         >> approx = z e r o s ( s i z e ( im ) ) ;
         >> k = 25

>> % l o o p t o c r e a t e a p p r o x i m a t i o n s and s a v e a s image  files
>> f o r i = 1 : k
>> approx = approx + S ( i , i ) *U( : , i ) *V( : , i ) ' ;
>> h = i m a g e s c ( approx ) ;
>> name = s p r i n t f ( '%s%d . png ' , ' approx ' , i ) ;
>> s a v e a s ( h , name )
>> end
130                                      CHAPTER 7. APPLIED PROJECTS

7.2 The Gini index

The subject of wealth and income inequality has featured prominently in the media and political
campaigns recently. Is there a fair, mathematically quantifiable method to describe income
inequality and track how it changes over time? This project will look at how Lorenz curves and
the Gini index are used to measure inequality and make comparisons.

The US Census Bureau reports shares of aggregate income by quintile. Quintiles divide the
population into equal fifths. For example, in 2018, the bottom quintile or poorest 20% of the
population earned 3.1% of the total income. In a perfectly egalitarian society (equal income
distribution), each 20% of the population would earn 20% of the income. The table below shows
the share of the total income at various income levels as reported by US Census Bureau for
20181.

Income distribution         Mean Income  Share of Income  Cumulative Share
                                         3.1%             3.1%
Shares of Aggregate Income  $13,775      8.3%
Lowest Quintile             $37,293      14.1%            100%
Second Quintile             $65,572      22.6%
Third Quintile              $101,570     52.0%
Fourth Quintile             $233,895
Highest Quintile

Problems

   1. Fill in the column for cumulative share of income in the table above. This gives the share
       of total income earned by the bottom 20%, the bottom 40%, the bottom 60%, the bottom
       80%, and finally by 100%.

   2. A Lorenz curve is obtained by plotting (a/100, b/100) if the bottom a% earn at most b%
       of the income. Fill in the table below with the decimal form of the cumulative shares, then
       plot the points and sketch in a smooth curve.
         x L(x)
         0.00 0.000
         0.20
         0.40
         0.60
         0.80
         1.00 1.000

       Notice that the curve passes through (0, 0) and (1, 1). The curve is also increasing and
       concave up (it never crosses above the line y = x or drops below the line y = 0). It lies in
       between the curve of perfect equality, y = x, and perfect inequality. Maximum inequality
       would be when the top income earner earns 100% of the income and everyone else earns
       0. This is the line y = 0 for 0 < x < 1, then a jump to the point (1, 1). Plot the curves of
       perfect equality and inequality.

    1Source: Income and Poverty in the United States: 2018, US Census Bureau (September, 2019). Retrieved
from https://www.census.gov/content/dam/Census/library/publications/2019/demo/p60-266.pdf.
7.2. THE GINI INDEX                                                        131

                     Figure 7.2: Lorenz curves

3. Lorenz functions satisfy these four properties:

(i) L(0) = 0         (iii) L (x) > 0 for 0 < x < 1
(ii) L(1) = 1        (iv) L (x) > 0 for 0 < x < 1

Show that each of the following functions are Lorenz functions by verifying properties i-iv.

(a) L(x) = x2
(b) L(x) = xn, where n  2
(c) L(x) = a(ex - 1), where a = 1/(e - 1)
(d) L(x) = a(ekx - 1), where a = 1/(ek - 1), k > 0

4. The Gini index (or Gini coefficient), G, measures how much a given income distribution

differs from perfect equality. Specifically, it is defined to be the area between the line of

perfect equality and the Lorenz curve, divided by the total area under the line of perfect

equality. Show that

                                    1

                     G = 2 [x - L(x)] dx

                                  0

What are the values of G for perfect equality and for maximum inequality?

5. Load the optimization package. Then use the data from problem 2 and the nonlinear curve-
   fitting function nonlin curvefit to approximate the Lorenz curve for 2018 U.S. income as
   a function of the form L(x) = xn. Use this model to calculate the Gini index. The US
   Census Bureau reports the Gini index as 0.486. How well does your answer agree?

   The following code shows the basic syntax, assuming xdata and ydata contain the x- and
   L(x)-values from the income distribution.
132  CHAPTER 7. APPLIED PROJECTS

         >> % l o a d t h e optim package ( must a l r e a d y be i n s t a l l e d )
         >> pkg l o a d optim

         >> % d e f i n e t h e model
         >> % power f u n c t i o n y = x^n
         >> f = @( n , x ) x . ^ n ;

         >> % i n i t i a l g u e s s f o r parameter n
         >> i n i t = 2 ;

         >> % c a l c u l a t e t h e model
         >> [ n , m o d e l v a l u e s ] = n o n l i n c u r v e f i t ( f , i n i t , xdata , ydata )

   Plot the data values and the Lorenz function together on the same axes. Include a legend
   and axis labels.

6. Repeat problem 5 using a Lorenz function of the form L(x) = a(ekx - 1), where a =
   1/(ek - 1). How does the value of G compare to the result from problem 5 and the US
   Census Bureau figure?

7. How has income inequality in the U.S. changed in past 50 years? The following table gives
   values of the Lorenz function for the U.S. every ten years starting in 1970 (derived from
   US Census Bureau figures). Fill in the final column with either the 2018 data listed above
   or the most recent data available on the US Census Bureau website.

     x 1970 1980 1990 2000 2010 current data
     0.00 0.000 0.000 0.000 0.000 0.000 0.000
     0.20 0.041 0.042 0.038 0.036 0.033
     0.40 0.149 0.144 0.134 0.125 0.118
     0.60 0.323 0.312 0.293 0.273 0.264
     0.80 0.568 0.559 0.533 0.503 0.498
     1.00 1.000 1.000 1.000 1.000 1.000 1.000
   Plot the Lorenz functions together on the same set of axes. Is a trend evident? Use the
   power function method of problem 5 to calculate the Gini index for each of those years.
   How has the Gini index changed since 1970? If it has gone up, by what percent has it
   increased from 1970 to the present?

8. How has income inequality in the U.S. changed in the last century? Do some research and
   cite reputable sources to describe how the Gini index has changed over the last 100 years.

9. How does income inequality in the U.S. compare to the rest of the world? Again, do some
   basic research and cite reputable sources to back up your assessment of how the U.S. Gini
   index compares to other nations.
7.3. DESIGNING A HELICAL STRAKE  133

7.3 Designing a helical strake

In this project, we will tackle a real engineering problem. First, you will calculate the dimensions
necessary to build a "helical strake" and construct a computer model to visualize it. Then you
will build a physical model to test whether our methods work in the real world. A strake is a
metal strip, used to reduce vibrations due to wind shear, attached on edge to the outside of a
smokestack or other cylinder in a spiral. See Figure 7.32.

                                    Figure 7.3: Chimney with helical strake

There are two basic mathematical problems that must be solved to construct this. First, we
need to know the (inside) linear length of the metal strip - that is the arc length of the helix:

                                                                                 b

                                                   s = r (t) dt

                                                                                a

Secondly, the circular metal strips are cut out of flat metal sheets, then twisted into shape.
What inside radius will make the strake fit flush against the smokestack? The correct approach

    2Steel chimney with spiral, by "StomBer" (CC-BY). https://commons.wikimedia.org/wiki/File:
SchornsteinwendelSKL.jpg
134  CHAPTER 7. APPLIED PROJECTS

is to build the strake with the right radius of curvature3. The radius of curvature is  = 1/,
where  is the curvature, defined as the rate of change of the unit tangent with respect to arc
length:

                                                               dT
                                                        =

                                                                ds

Refer to [5, ง11.5] for easier-to-use computational formulas for curvature.

Problems

Choose a cylinder. You could use something as small as an empty paper towel roll or something
as large as a cardboard concrete pier form. Measure the height and the radius of your cylinder.
We want the helix to make exactly one revolution over the height of the tube. Before building
the actual model, we will construct a virtual model.

   1. Determine the equations of your cylinder and the helix that fits flush against it.

   2. Plot a graph of the cylinder and helix on the same axes. Decide on a width for your strake
       and then plot the outside radius on the same axes to complete the model. Here are some
       commands that will help you plot the cylinder:

             >> [X Y Z ] = c y l i n d e r ( [ r r ] ) ;
             >> Z = h*Z ;
             >> s u r f (X, Y, Z )

       This generates the X, Y , and Z meshgrid arrays for a cylinder with radius r and height 1.
       The values of r are for the radii at the top and the bottom. For an ordinary right-circular
       cylinder, both numbers are the same. To stretch the height out to match the height of your
       cylinder, we multiply the Z-coordinate by h. If you don't like the way the plot from the
       surf command looks, try mesh(X, Y, Z). Once you have the cylinder plotted, use hold on
       and add a plot of the helix, with radius r. That represents the inside of the strake. To plot
       the outside edge, plot another helix of radius r + w, where w is the width of the strake.
       Optionally, add two line segments to join the two helixes at the ends.

   3. Calculate the arc length of the helix.

   4. Calculate the radius of curvature of the helix.

   5. Build a physical model. You can use construction paper, poster board, cardboard, or foam
       board. The material needs to be flexible enough to be twisted into the correct shape. To
       attach the spiral to your cylinder, you can use tape or glue. Duct tape or packaging tape
       should work, but a stout glue will show the interface between the strake and cylinder more
       clearly. In any case, we don't need something attractive; we just need to know whether
       the pieces fit.
       Choose an appropriate outside radius for the strake, then cut out the pieces and build the
       model. You may need to use a nail or thumb tack and a measured length of string to mark
       your radius before cutting.

    3Morgan, Frank. Riemannian Geometry: A Beginner's Guide (Second Edition). AK Peters, Ltd., Wellesley,
MA (1998).
7.3. DESIGNING A HELICAL STRAKE  135

                                        Figure 7.4: Computer model

6. Do the calculations agree with the reality of the physical model?

     (a) Does the inside length of strake, as measured with a string, equal the calculated arc
          length?

    (b) Do the pieces fit flush against the cylinder?
     (c) Does the helix make exactly one revolution?

   If something did not work out correctly, try to explain what you think went wrong.

7. Many chimneys have a wider base and narrow as the height increases. How does the
   problem change if we wish to wrap our strake around a more complex shape?

     (a) Find the correct equations and create a computer model of a strake wrapped around
          a frustum of a cone with lower base radius 5, upper radius of 1, and height 10.

    (b) Construct the computer model to illustrate the strake.
     (c) Calculate the arc length of the helix.
    (d) Calculate the curvature of the strake for t = 0, /2, , 3/2, and 2, where t  [0, 2]

          corresponds to one complete revolution.
     (e) You do not need to construct a physical model, but briefly discuss what difficulties

          would be encountered if we wished to construct this model.
136              CHAPTER 7. APPLIED PROJECTS

7.4 3D-printing

If z = f (x, y) is nonnegative on D, then D f (x, y) dA represents the volume under the graph
of f , above the region D in the xy-plane. We have already seen to how to calculate such
volumes and how to visualize the surfaces by using three dimensional graphs in Octave. In this
project, we will convert 3D-surfaces into solid blocks which can be printed in three dimensions.
In addition to allowing us a more concrete means of modeling a mathematical surface, we can
physically measure the volume of the object (by displacement) and compare to the theoretical
results as predicted by calculus.

These printers require closed, "water tight" solids, typically produced using a triangular mesh
and saved in an stl file format (STereoLithography). There are several Matlab script files
available in the MathWorks File Exchange for producing the figures and stl-output we need.
While these scripts may run in Octave, it is a violation of the terms of service to use content from
the Mathworks File Exchange in non-Mathworks software. If you are using a licensed version of
Matlab, try:

     http://www.mathworks.com/matlabcentral/fileexchange/30709-surf2solid
        surf2solid takes a function of two variables and turns it into a solid block by adding a
       "curtain" from the boundary of the surface down to the xy-plane and joining this to a flat
       plane below

     http://www.mathworks.com/matlabcentral/fileexchange/4512-surf2stl
        surf2stl takes a solid rectangular meshgrid and converts into a triangulated stl-format
       surface

Inspired by these functions, we will write our own Octave function for this project. We have
two goals:

   1. For a surface z = f (x, y), create a solid block that represents the volume below the surface
       and above a rectangular domain.

   2. For any surface defined by meshgrid variables X, Y, Z, generate a triangulation and write
       an stl file.

STeroLithography files in ascii format have a simple structure:

    solid name
       facet normal n1 n2 n3
           outer loop
              vertex v1 v2 v3
              vertex v1 v2 v3
              vertex v1 v2 v3
           endloop
       endfacet

    endsolid name
    7.4. 3D-PRINTING                                                                            137

    If we start from a rectangular grid, as we do with a surface generated from meshgrid variables,
    to produce a triangulation we merely need to split each subrectangle of the partition into two
    triangles. The stl-format requires the vertices of these triangles, plus a unit normal vector for
    each of the triangular facets. Despite the requirement for a normal vector in the file standard, it
    is redundant, as the vertices alone uniquely determine the solid. Thus some software ignores the
    normal vectors. But, we will attempt to include correct unit normals calculated using a cross
    product.

    In the mesh2stl.m function file below, lines 12-29 are all that is needed to triangulate an
    (X, Y, Z)-surface from Octave. Lines 92-123 will write the output in the standard file format.
    But, if we pass the function a minimum thickness, delta, then additional code is used. Assuming
    z = f (x, y) is a function over a rectangular domain, it is relatively simple to produce a solid
    block by dropping a "curtain" from the edge of the surface down to the xy-plane and closing off
    the solid with a flat plane for the base. Lines 31-90 handle this.

    This function file can be downloaded from https://gist.github.com/jalachniet/.

                        Octave Script 7.1: mesh2stl function file

1 function mesh2stl ( filename , X, Y, Z, delta )

2 %MESH2STL w r i t e s an . s t l ( STereoLithography ) f i l e from meshgrid v a r i a b l e s

3 % mesh2stl ( ' filename ' , X, Y, Z)

4%          produces a t r i a n g u l a t e d mesh from meshgrid v a r i a b l e s X, Y, Z

5%          and writes output to ' filename ' in s t l format

6 % --X, Y, Z must be two d i m e n s i o n a l a r r a y s o f t h e same s i z e

7 % --o p t i o n a l : i f d e l t a i s pr ovided , produce a s o l i d b l o c k from t h e graph

8%                      of surface z = f (x, y)

9%                      where ' d e l t a ' g i v e s minimum t h i c k n e s s between base o f b l o c k

10 %                    and graph of surface

11                      dimensions
                        1) ;
12 % d e t e r m i n e  2) ;
13 m = s i z e ( Z ,
14 n = s i z e ( Z ,

15

16 % c o n s t r u c t t r i a n g u l a r f a c e t s f o r s u r f a c e

17 k = 0 ;

18 f o r i = 1 :m-1

19 f o r j = 1 : n-1

20      k = k + 1;

21      F ( : , : , k ) = [X( i , j ) ,  Y( i , j ) ,                       Z( i , j ) ;
                                                                            Z( i , j +1) ;
22                      X( i , j +1) , Y( i , j +1) ,                       Z( i +1, j +1) ] ;

23                      X( i +1, j +1) , Y( i +1, j +1) ,                   Z( i +1, j +1) ;
                                                                            Z( i +1, j ) ;
24      k = k + 1;                                                          Z( i , j ) ] ;

25      F ( : , : , k ) = [X( i +1, j +1) , Y( i +1, j +1) ,

26                      X( i +1, j ) , Y( i +1, j ) ,

27                      X( i , j ) ,     Y( i , j ) ,

28 end

29 end

30

31 i f ( n a r g i n > 4 )
32 % c a l c u l a t e e l e v a t i o n and midpoint o f b a s e
33 z b a s e = min ( min ( Z ) ) - d e l t a ;
34 x mid = ( min ( min (X) ) + max(max(X) ) ) / 2 ;
    138                                              CHAPTER 7. APPLIED PROJECTS

35 y mid = ( min ( min (Y) ) + max(max(Y) ) ) / 2 ;

36

37 % c o n s t r u c t t r i a n g u l a r f a c e t s f o r ' c u r t a i n ' and b a s e

38 f o r i = 1 : n-1

39       k = k + 1;

40       F( : , : , k) = [X(1 , i ) , Y(1 , i ) , Z(1 , i ) ;

41                    X(1 , i ) , Y(1 , i ) , z base ;

42                    X(1 , i +1) , Y(1 , i +1) , Z(1 , i +1) ] ;

43       k = k + 1;

44       F ( : , : , k ) = [X(1 , i +1) , Y(1 , i +1) , Z(1 , i +1) ;

45                    X(1 , i ) , Y(1 , i ) , z base ;

46                    X(1 , i +1) , Y(1 , i +1) , z base ] ;

47       k = k + 1;

48       F( : , : , k) = [ x mid ,  y mid ,          z base ;

49                    X(1 , i ) , Y(1 , i ) , z base ;

50                    X(1 , i +1) , Y(1 , i +1) , z base ] ;

51       k = k + 1;

52       F ( : , : , k ) = [X(m, i ) , Y(m, i ) , Z ( 1 , i ) ;

53                    X(m, i ) , Y(m, i ) , z b a s e ;

54                    X(m, i +1) , Y(m, i +1) , Z ( 1 , i +1) ] ;

55       k = k + 1;

56       F ( : , : , k ) = [X(m, i +1) , Y(m, i +1) , Z ( 1 , i +1) ;

57                    X(m, i ) , Y(m, i ) , z b a s e ;

58                    X(m, i +1) , Y(m, i +1) , z b a s e ] ;

59       k = k + 1;

60       F( : , : , k) = [ x mid ,  y mid ,          z base ;

61                    X(m, i ) , Y(m, i ) , z b a s e ;

62                    X(m, i +1) , Y(m, i +1) , z b a s e ] ;

63 end

64

65 f o r j = 1 :m-1

66       k = k + 1;

67       F ( : , : , k ) = [X( j , 1) , Y( j , 1) , Z( j , 1) ;

68                    X( j , 1) , Y( j , 1) , z base ;

69                    X( j +1, 1) , Y( j +1, i ) , Z( j +1, 1) ] ;

70       k = k + 1;

71       F ( : , : , k ) = [X( j +1, 1) , Y( j +1, 1) , Z( j +1, 1) ;

72                    X( j , 1) , Y( j , 1) , z base ;

73                    X( j +1, 1) , Y( j +1, 1) , z base ] ;

74       k = k + 1;

75       F( : , : , k) = [ x mid ,  y mid ,          z base ;

76                    X( j , 1) , Y( j , 1) , z base ;

77                    X( j +1, 1) , Y( j +1, 1) , z base ] ;

78       k = k + 1;

79       F ( : , : , k ) = [X( j , n) , Y( j , n) , Z( j , n) ;

80                    X( j , n) , Y( j , n) , z base ;

81                    X( j +1, n) , Y( j +1, n) , Z( j +1, n) ] ;

82       k = k + 1;

83       F ( : , : , k ) = [X( j +1, n) , Y( j +1, n) , Z( j +1, n) ;

84                    X( j , n) , Y( j , n) , z base ;

85                    X( j +1, n) , Y( j +1, n) , z base ] ;

86       k = k + 1;

87       F( : , : , k) = [ x mid ,  y mid ,          z base ;

88                    X( j , n) , Y( j , n) , z base ;
     7.4. 3D-PRINTING                                                                                         139

89                           X( j +1, n) , Y( j +1, n) , z base ] ;

90 end
91 end

92                                   facets

93 % number o f t r i a n g u l a r
94 n u m f a c e t s = k ;

 95                                                                             d a t e s t r ( now ) ) ;

 96 % s a v e i n s t l f o r m a t
 97 f i d = f o p e n ( f i l e n a m e , 'w ' ) ;
 98 t i t l e s t r = s p r i n t f ( ' Created with GNU Octave %s ' ,
 99 f p r i n t f ( f i d , ' s o l i d %s \ r \n ' , t i t l e s t r ) ;
100 f o r k = 1 : n u m f a c e t s
101 % v e r t i c e s
102 p1 = [ F ( 1 , 1 , k ) F ( 1 , 2 , k ) F ( 1 , 3 , k ) ] ;
103 p2 = [ F ( 2 , 1 , k ) F ( 2 , 2 , k ) F ( 2 , 3 , k ) ] ;
104 p3 = [ F ( 3 , 1 , k ) F ( 3 , 2 , k ) F ( 3 , 3 , k ) ] ;

105

106 % normal v e c t o r

107      i f ( ( p1 ~= p2 ) & ( p1 ~= p3 ) & ( p2 ~= p3 ) )

108      n = c r o s s ( p2-p1 , p3-p1 ) . / norm ( c r o s s ( p2-p1 , p3-p1 ) ) ;

109      else

110      n = [0 0 0 ] ; % unable to calculate normal vector

111      end

112

113 % w r i t e f a c e t s

114      f p r i n t f ( f i d , ' f a c e t normal %.7E %.7E %.7E\ r \n ' , n ( 1 ) , n ( 2 ) , n ( 3 ) ) ;

115      f p r i n t f ( fid , ' outer loop\r\n ' ) ;

116      f p r i n t f ( f i d , ' v e r t e x %.7E %.7E %.7E\ r \n ' , p1 ) ;

117      f p r i n t f ( f i d , ' v e r t e x %.7E %.7E %.7E\ r \n ' , p2 ) ;

118      f p r i n t f ( f i d , ' v e r t e x %.7E %.7E %.7E\ r \n ' , p3 ) ;

119      f p r i n t f ( fid , ' endloop\r\n ' ) ;

120      f p r i n t f ( fid , ' endfacet \r\n ' ) ;

121 end

122                          ' e n d s o l i d %s \ r \n ' ,  title str );

123 f p r i n t f ( f i d ,
124 f c l o s e ( f i d ) ;

125

126 d i s p ( ' Number o f t r i a n g u l a r f a c e t s : ' ) , d i s p ( n u m f a c e t s )

     Let's try producing a solid printable block with a modified version of the "sombrero" function,

                                     f (x, y) = 10            sin( x2 + y2)  +3

                                                              x2 + y2

     >> [X Y Z ] = sombrero ;
     >> Z = 10*Z + 3 ;
     >> s u r f (X, Y, Z ) ;

     Now, we use mesh2stl to produce a solid figure and stl file.

          >> m e s h 2 s t l ( ' sombrero . s t l ' , X, Y, Z , 2 ) ;
          Number o f t r i a n g u l a r f a c e t s :

            3680
140  CHAPTER 7. APPLIED PROJECTS

The output file is readable by most 3D-printer software. The option delta = 2 tells the function
to attempt to produce a solid block with a minimum thickness of 2. Note that units in stl files
are arbitrary, but most 3D printer software will interpret 1 unit in Octave as 1 mm. Thus our
figure has a minimum thickness of 2 mm, measured between the base and the lowest point on
the surface.

Use your 3D printer software or an online stl viewer to preview the results and check the size
in millimeters. Our figure is quite small, only 16 ื 16 ื 14 mm. It is generally an easy matter
to resize to the desired final dimensions using printer software. Alternately, you can manually
scale X, Y , and Z before writing the file.

                                      Figure 7.5: stl file ready for printing

Problems

   1. Use integration to determine the volume of the modified sombrero function generated
       above. You will need to take into account the difference in elevation between the base of
       the block and the lowest point on the surface.

   2. Consider the example Octave surface "peaks."
             >> [ X, Y, Z ] = peaks ;

       Scale Z by a factor of 1/5 and shift up 2 units.
             >> Z = Z/5 + 2 ;

       Now convert the X, Y, Z-meshgrid variables to a printable stl-format solid block. Calcu-
       late the volume of the resulting solid figure.
7.4. 3D-PRINTING                                                             141

3. Let f (x, y) = sin(xy) + 1.

     (a) Compute (by hand) the volume under the graph of f over the region [-, ]ื[-, ].
    (b) Graph the function over the appropriate domain.
     (c) Convert the resulting [X, Y, Z] meshgrid variables to a solid block, saved in stl-

          format.

4. Consider the "bumpy sphere" from Example 6.2.4,

                                                         1
                                               = 1 + sin(5) cos(6)

                                                         4

   where 0    2, 0    .

     (a) Set-up a triple integral in spherical coordinates to find the volume of this solid.
    (b) Evaluate the integral to find a decimal approximation for the volume. You may use

          technology. Complete the first trivial integration by hand. Then define  = f (, )
          and use dblquad command on the remaining double integral.
     (c) Use the symbolic package to find the exact volume of the bumpy sphere. Compare
          to the answer from part (b).
    (d) Graph the solid. You will need to create a -meshgrid, then calculate  using these
          meshgrid variables. Finally, X, Y , and Z are calculated using the standard spherical
          to rectangular coordinate identities. To scale the size up, multiply each X, Y, and Z
          matrix by a factor of 50.
     (e) Convert to stl-format. Note that this figure is already a closed solid, so do not use
          the delta option.

5. Suppose we have a solid radius-3 hemisphere and drill a radius-2 cylinder through the
   center. What volume remains? In rectangular coordinates, this is the volume under
   z = 9 - x2 - y2 and above a washer shaped region in the xy-plane with inner radius 2
   and outer radius 3.

     (a) Sketch the region and calculate the volume by hand. Use polar coordinates.
    (b) Use an r-polar meshgrid to produce a 3D graph.
     (c) As written, our mesh2stl function does not work to produce a solid block for a surface

          defined in polar coordinates. So, instead, use the following code to produce a version
          of the solid in rectangular coordinates:

                >> % d e f i n e f t o be 0 o u t s i d e o f r e l e v a n t washer shaped r e g i o n
                >> f = @( x , y ) s q r t ( 9 - x . ^ 2 - y . ^ 2 ) . * ( ( x . ^ 2 + y . ^ 2 < 9 ) & ( x

                       .^2 + y.^2 > 4) ) ;

>> x = l i n s p a c e ( -3 , 3 , 1 0 0 ) ;  % define the domain
>> y = x ;
>> [X Y] = meshgrid ( x , y ) ;

>> Z = f (X, Y) ; % e v a l u a t e t h e f u n c t i o n and p l o t graph
>> s u r f (X, Y, Z )

>> % c o n v e r t t o . s t l format
>> m e s h 2 s t l ( ' r i n g 2 . s t l ' , 50*X, 50*Y, 50*Z , 0 )
142  CHAPTER 7. APPLIED PROJECTS

6. 3D printing can also help with visualizing space curves. However, a curve, on its own, has
   no thickness and therefore cannot be printed. A typical approach is to replace the curve
   with a thin tube. Script files are available to do this, for example tubeplot.m available
   from http://www.aleph.se/Nada/Ray/Tubeplot/tubeplot.html.
   Even if you do not plan to 3D-print, a tubeplot can help with visualizing some complex
   space curves.

     (a) Let r(t) = cos(t)i + sin(t)j + 0.3 sin(2t)k. Graph the curve over the interval [0, 2).
          This is called the "Roller Coaster Curve" ([7, ง3.1 Exercise 37]).

    (b) Create a 0.1-radius tube plot of the curve. Here is the correct syntax for the tubeplot
          script:

                >> [X Y Z ] = t u b e p l o t ( x , y , z , 0 . 1 ) ;

     (c) View the plot using surf (X, Y, Z), then save in stl-format. The figure is essentially
          already a closed solid, so no option is needed for delta.

7. Here is your chance to be creative! Create a mathematically defined 3D-solid of your
   own design. You can use a rectangular function of two variables, or you may wish to try
   something in polar, cylindrical, or spherical form. In the end, it must be a closed solid
   that you can convert to a printer-ready stl-format. You may get ideas from your calculus
   book, experimentation in Octave, and/or online image searches.

     (a) Define your function and state its domain (over which you will print the object).
    (b) Graph it.
     (c) Scale to a modest size (base roughly 50 ื 50 mm) and convert to stl.
    (d) Give a description of any interesting mathematical properties of the object and include

          any relevant computations. Examples:
              The volume calculated by integration
              Location of maximums, minimums, or saddle points
              A point where the limiting value is different along different lines of approach
              A discontinuity

8. After one of your solid objects from problems 1-4 is printed, take it to the lab and measure
   its volume directly by fluid displacement. How does the measured volume compare to the
   calculated volume? Be sure to take into account any scaling factor used for the printed
   version. Give the absolute and relative volume errors and comment on any discrepancies.
7.5. MODELING A CAVE PASSAGE                                         143

7.5 Modeling a cave passage

In a cave survey, three dimensional data is collected between survey points. There are three
measurements: distance, compass bearing (0 to 360 azimuth), and inclination (-90 to 90
vertical angle). The first step in producing a cave map is to reduce this data to rectangular
coordinates and generate line plots of the survey. We will then construct mathematical models
for the walls, floor and ceiling, and use these to set-up integrals to estimate the floor area,
average passage height, and overall volume of the cave. This information might be useful, for
example, to a scientist who wished to determine the amount of limestone that dissolved during
the formation of the cave, or the size of the stream which once flowed through it.

Survey data for Skunk Cave (Smyth County, Virginia) was collected during fieldwork by members
of the Walker Mountain Grotto caving club and the Wytheville Community College Outdoor
Club. The raw data is given below.

Distance (ft)                 Azimuth ()  Inclination ()
    30.05                         248.5        -15.5
    10.30                         237.5        -25.5
     3.20                         245.0         11.0
    17.00                         269.0         -5.0
    10.00                         271.0        -10.0
    14.35                         280.0          3.0
    11.50                         308.5          6.0
    49.65                         296.0         12.5
     5.30                         315.0        -23.0

Converting this spherical data to rectangular coordinates is accomplished with the following
transformations:

                                             
                                              x = d cos() sin()
                                              y = d cos() cos()

                                                  z = d sin()

P (0, 0, 0)   z (elevation)                                E
             T                                            y (north)

                                        จsQ(x, y, z)
                                  จจ
                           dจจ
                      จจ
                จจ
              จs 
                
                   
                               

ฉ x (east)
         Figure 7.6: Spherical coordinates
144  CHAPTER 7. APPLIED PROJECTS

Note that these formulas are slightly different from the standard spherical to rectangular iden-
tities, to reflect how the measurements are actually taken in the field. To apply these formulas,
we must use an iterative process. Start from the point (0, 0, 0). The (x, y, z)-coordinates of the
next point are found using the given formulas. Then, this becomes the starting point for the
next transformation. Thus, for each i = 2, 3, 4, . . . , 10, the relationship is:

     xi = xi-1 + di-1 cos(i-1) sin(i-1)
     yi = yi-1 + di-1 cos(i-1) cos(i-1)
     zi = zi-1 + di-1 sin(i-1)

Part 1: The survey line

   1. Determine rectangular coordinates for each point in the survey. These should be in the
       form of 10 ื 1 column vectors for x, y, and z. You can carry out each step one a time,
       but using a loop in Octave will be more efficient. Note that you must convert the degree
       angle measures to radians to obtain correct results.

   2. Plot the overhead plan view using the command plot(x, y). For a more accurate perspec-
       tive, you can force equal x- and y-axis scales by using the command axis( 'equal').

   3. Notice that the passage is aligned primarily in an east-west direction. Plot an east-west
       profile view by using the command plot(x, z). Force equal axes for a more accurate view.

   4. Plot a 3-dimensional model using the command plot3(x, y, z).

     Figure 7.7: 3-dimensional model of survey line
7.5. MODELING A CAVE PASSAGE                                          145

Part 2: Passage modeling with cubic splines

We need additional data to model the passage outline. During the survey, estimates of the
distances to the left wall, right wall, ceiling (up), and floor (down) were collected at each point.
Cave surveyors call this "LRUD" data (i.e., left, right, up, down). There are ten survey stations
and nine passage segments. Here is a table containing the LRUD data. The stations have been
indexed 1 through 10, with 1 representing the entrance.

Station index  Left wall      Right wall  Ceiling (up)  Floor (down)
        1         10.0            8.0           5.0           0.0
        2         3.0             5.0           3.0           2.0
        3         3.0             0.0           1.5           0.5
        4         0.0             1.0           0.5           1.5
        5         3.0             0.5           4.0           2.0
        6         4.0             0.0           5.0           2.0
        7         0.0             3.0           5.0           3.0
        8         6.0             2.0           4.0           2.0
        9         3.0             2.0           0.0           3.0
       10         1.0             0.5           3.0           0.5

  Since the cave segment consists of a single passage, oriented in an east-west direction, we can
  simplify things by partitioning the x-axis at the coordinates determined in problem 1. We use
  a model based on cubic splines4.

  The following script will generate cubic "Hermite" spline models for the walls, floor, and ceiling.
  The script and all required data files can be downloaded from https://gist.github.com/
  jalachniet/.

                                        Octave Script 7.2: Cubic spline model

 1 % s c r i p t f i l e ' c a v e s p l i n e .m'
 2 % generates s p l i n e curves f o r walls , c e i l i n g , and f l o o r
 3 % p l o t s plan and p r o f i l e views of survey l i n e and s p l i n e model
 4 % r e q u i r e s 10x1 s t a t i o n coordinate vectors x , y , and z ( from part 1)
 5 % and 10x4 lrud data matrix ( a v a i l a b l e in the f i l e csurvey data . txt )

 6

 7 % e x t r a c t l e f t , r i g h t , up , down from l r u d data matrix
 8 load csurvey data . txt
 9 L = lrud (: , 1) ;
10 R = l r u d ( : , 2 ) ;
11 U = l r u d ( : , 3 ) ;
12 D = l r u d ( : , 4 ) ;

13

14 % c a l c u l a t e l e f t and r i g h t w a l l s , f l o o r and c e i l i n g
15 y l e f t = y - L ;
16 y r i g h t = y + R ;
17 z down = z - D;
18 z u p = z + U;

       4see http://mathworld.wolfram.com/CubicSpline.html and https://en.wikipedia.org/wiki/Cubic_
  Hermite_spline
146                                                                   CHAPTER 7. APPLIED PROJECTS

19                              spline models as piecewise            polynomials
                                y l e f t , ' pchip ' , ' pp ' ) ;
20 % g e n e r a t e c u b i c  y r i g h t , ' pchip ' , ' pp ' ) ;
21 pp1 = i n t e r p 1 ( x ,    z down , ' pchip ' , ' pp ' ) ;
22 pp2 = i n t e r p 1 ( x ,    z up , ' pchip ' , ' pp ' ) ;
23 pp3 = i n t e r p 1 ( x ,
24 pp4 = i n t e r p 1 ( x ,

25

26 % e x t r a c t and d i s p l a y b r e a k s and c o e f f i c i e n t s
27 [ b r e a k s 1 , c o e f f s 1 ] = unmkpp ( pp1 ) ;
28 [ b r e a k s 2 , c o e f f s 2 ] = unmkpp ( pp2 ) ;
29 [ b r e a k s 3 , c o e f f s 3 ] = unmkpp ( pp3 ) ;
30 [ b r e a k s 4 , c o e f f s 4 ] = unmkpp ( pp4 ) ;
31 d i s p ( ' Breaks = ' ) , d i s p ( b r e a k s 1 ( 1 : s i z e ( b r e a k s 1 , 2 ) - 1 ) ' )
32 d i s p ( ' L e f t w a l l c o e f f i c i e n t s = ' ) , d i s p ( c o e f f s 1 )
33 d i s p ( ' Right w a l l c o e f f i c i e n t s = ' ) , d i s p ( c o e f f s 2 )
34 d i s p ( ' F l o o r c o e f f i c i e n t s = ' ) , d i s p ( c o e f f s 3 )
35 d i s p ( ' C e i l i n g c o e f f i c i e n t s = ' ) , d i s p ( c o e f f s 4 )

36

37 % p l o t p l a n view
38 f i g u r e ( 1 ) ;
39 xx = l i n s p a c e ( min ( x ) , max( x ) , 5 0 ) ;
40 yy1 = p p v a l ( pp1 , xx ) ;
41 yy2 = p p v a l ( pp2 , xx ) ;
42 p l o t ( x , y , ' ro- ' , xx , yy1 , ' l i n e w i d t h ' , 2 , ' b ' , xx , yy2 , ' l i n e w i d t h ' , 2 , ' b

          ');
43 g r i d on ;
44 a x i s ( ' e q u a l ' ) ;
45 t i t l e ( ' Skunk Cave - Plan View ' )
46 l e g e n d ( ' s u r v e y l i n e ' , ' c u b i c s p l i n e model ' )
47 x l a b e l ( ' East ( f e e t ) ' )
48 y l a b e l ( ' North ( f e e t ) ' )

49

50 % p l o t p r o f i l e view
51 f i g u r e ( 2 ) ;
52 z z 1 = p p v a l ( pp3 , xx ) ;
53 z z 2 = p p v a l ( pp4 , xx ) ;
54 p l o t ( x , z , ' ro- ' , xx , zz1 , ' l i n e w i d t h ' , 2 , ' b ' , xx , zz2 , ' l i n e w i d t h ' , 2 , ' b

          ');
55 g r i d on ;
56 a x i s ( ' e q u a l ' ) ;
57 t i t l e ( ' Skunk Cave - P r o f i l e View ' )
58 l e g e n d ( ' s u r v e y l i n e ' , ' c u b i c s p l i n e model ' )
59 x l a b e l ( ' East ( f e e t ) ' )
60 y l a b e l ( ' E l e v a t i o n ( f e e t ) ' )

This code will produce piecewise polynomials for the walls, floor, and ceiling as shown in Fig-
ures 7.8 and 7.9. These consist of 36 individual cubic polynomials for the walls, floor and ceiling,
each with the form:

                                  y = a(x - x0)3 + b(x - x0)2 + c(x - x0) + d

where the x0-values correspond to the x-coordinate breaks.
7.5. MODELING A CAVE PASSAGE           147

Figure 7.8: Cubic spline plan view

Figure 7.9: Cubic spline profile view
148                                       CHAPTER 7. APPLIED PROJECTS

5. For each passage segment, the floor area can be calculated as

                                                                b

                                                 [right wall - left wall] dx

                                                              a

     Use integration to calculate the floor area of each passage segment, and the total floor
     area. You may want to define the integrand using the ppval function, then integrate using
     quad.

6. The average height can be found using

                        h=  1b            [ceiling - floor] dx

                            b-a a

     Calculate the average passage height in each segment.

7. A volume estimate for each segment can be calculated as floor area times average passage
   height, V = Ah. Use the floor area and passage height estimates to estimate the total
   volume of the entire passage.

8. A double integral can be used to directly calculate the volume between the floor and ceiling

     functions over the irregular plane region defined by the walls of the passage. Write a script

     to evaluate:       9 b right wall

                                                 [ceiling - floor] dA
                        i=1 a left wall

Part 3: 3D-solid model

                                     Figure 7.10: Kite-shaped cross section

Our goal now is to produce a true three-dimensional model, suitable for 3D-printing. Modeling
a cave in three dimensions is a serious challenge because the passage not only winds around
through space, its size and shape is also changing as you move along the passage. The most
rudimentary approach is a "kite" shaped cross section, as shown above, obtained by fixing points
in space to the left and right and above and below each station on the survey line.
7.5. MODELING A CAVE PASSAGE  149

                                     Figure 7.11: Skunk Cave - solid model

To graph the 3D model in Octave, we use an irregular meshgrid defined by the points outlined
in Figure 7.10. Load the LRUD data file and extract the columns for L, R, U , and D. Then
the mesh we need is built as:

     >> X = [ x x x ] ;
     >> Y = [ y - L , y , y + R ] ;
     >> Z1 = [ z , z + U, z ] ;
     >> Z2 = [ z , z - D, z ] ;

Here Z1 is the ceiling and Z2 is the floor. Now we merge these into a single set of meshgrid
variables.

     >> XX = [X X ] ;
     >> YY = [Y Y ] ;
     >> ZZ = [ Z1 Z2 ] ;

Now surf or mesh can be used to plot the model using the XX, Y Y , and ZZ arrays. To show
the survey line and passage wall model together, plot the walls with mesh and the following
options.

     >> mesh (XX, YY, ZZ) ;
     >> hidden o f f ;
     >> a x i s ( ' e q u a l ' )
     >> h o l d on ;
     >> p l o t 3 ( x , y , z , ' o- ' ) ;

The result should look something like Figure 7.11.
150  CHAPTER 7. APPLIED PROJECTS

 9. Follow the steps outlined above to create a 3D-model of the passage.

10. Use the methods shown in Section 7.4 to convert the resulting meshgrid variables into a
     printable stl file.

11. Pick a single passage segment and use double integration to calculate its volume. Start by
     producing a 3D model that shows just the single section of the cave. You can do this by
     repeating the steps shown above for the complete model, but selecting only the data for
     the relevant segment, from i to j:

          >> X = [ x ( i : j ) x ( i : j ) x ( i : j ) ] ;
          >> Y = [ y ( i : j ) - L( i : j ) , y ( i : j ) , y ( i : j ) + R( i : j ) ] ;
          >> Z1 = [ z ( i : j ) , z ( i : j ) + U( i : j ) , z ( i : j ) ] ;
          >> Z2 = [ z ( i : j ) , z ( i : j ) - D( i : j ) , z ( i : j ) ] ;
          >> XX = [X X ] ;
          >> YY = [Y Y ] ;
          >> ZZ = [ Z1 Z2 ] ;

     Then plot your section using the mesh command. For example, the section from 1 to 2 is
     shown in Figure 7.12. At first glance, you might think that the floor and ceiling sections
     could be modeled by planes. However, further investigation reveals that the boundaries of
     the "faces" are actually skew lines and therefore not contained in a plane.

     Next, look closely at the plan view. This can be plotted as x vs. y, or you can simply
     rotate the 3D block to the proper orientation. This view will be used to determine the
     limits of integration. As an example, the relevant domain for the segment from station 1
     to 2 is shown in Figure 7.13.

     As noted, the two regions of the domain are not bounded above and below by planes
     (the four corners are not coplanar). To overcome this problem, you must further split the
     domain into four triangular subregions. Label the coordinates of each vertex and determine
     the equations in the xy-plane for the five sloping lines that divide the region into the union
     of four Type I regions. These should be reduced to y = f (x) form.

     The volumes we need to compute are bounded between planar triangular floor and ceiling
     elements. You must determine the equations of planes representing the floor and the
     ceiling over each of the four regions. To write the equations, you will need to construct
     a pair of vectors in each plane, then use their cross product to write the normal vector.
     After simplifying, the equations should be written in the form z = f (x, y). We have now
     effectively "triangulated" our irregular solid.

     The subvolume for each of the four regions can now be calculated using a double integral
     as follows:

                                             fceiling(x, y) - ffloor(x, y) dy dx

                                                     R

     The inner limits are determined by the lines that divide the domain and the outer limits
     are determined by the partition of the x-axis at each survey station.

     Calculate the four integrals to determine the volume enclosed.

12. Write a script that repeats the above steps for each passage segment, totaling the sub-
     volumes to obtain an estimate for the full volume of the passage. (This is not a simple
     problem!)
7.5. MODELING A CAVE PASSAGE                          151

Figure 7.12: Skunk Cave - station 1 to 2 solid model

Figure 7.13: Skunk Cave - station 1 to 2 plan view
152  CHAPTER 7. APPLIED PROJECTS

7.6 Modeling the spread of an infectious disease

Given the devastating impacts of the recent coronavirus pandemic, the mathematical models
used to study the spread of infectious disease have lately been receiving considerable attention.
The tools we have developed to this point are adequate for us to do some interesting simulations,
as well as solve the standard differential equations model that is the basis of the widely circulated
graphs depicting the outcome of "flattening the curve" through social distancing measures.

Unconstrained exponential growth

The simplest model is based on the so-called basic reproduction number. This is the number
of new infections caused by each infected individual, commonly designated R0. Its value is
of critical importance in the study of the spread of infectious diseases. Suppose a disease is
spreading through a population. One individual is infected initially and causes another R0
infections, each of whom goes on to cause another R0 infections, and so on. Supposing it takes
t units of time for an individual to cause another R0 infections, and with no further constraints,
the number of infections will grow according to the model f (t) = (R0)t. Thus, for any disease
with R0 > 1, growth will be exponential.

   1. Suppose a new disease enters a large population. Begin with one infection and assume
       that once infected, it takes one week for an individual to cause another two infections.
       How many infections are expected after six weeks? If growth continues unchecked, how
       long will it take until the number of cases exceeds 1000?

   2. Suppose news reports indicate that in a certain locality the number of cases of a new
       disease is doubling every five days. Again assuming it takes one week for an individual
       to cause another R0 infections, estimate the value of R0. If there are currently 500 cases,
       project how many cases are expected in one month.

Simulation: constrained logistic growth

Nothing in nature can continue to grow exponentially without bound. If the population is
finite, there is a limited carrying capacity and the exponential growth will lag, asymptotically
approaching the carrying capacity. The characteristic curve is described by the logistic growth
equation we considered in Chapter 3 Exercise 9.

Here is the scenario we will model: Suppose that a (benign) disease has entered a population of
size N . The disease spreads according to following simplified assumptions:

     To begin, one person is chosen at random and infected.
     Once infected, an individual remains infectious indefinitely.
     In each subsequent time period, each infected individual comes into contact with one other

       person, chosen at random, and infects them (if they are not already infected).
7.6. MODELING THE SPREAD OF AN INFECTIOUS DISEASE                                         153

The maximum number of infections is constrained by the population size N . In a classroom
setting, it is instructive to run this simulation live among the population of students, tracking
as the number of infections increases until the entire class is afflicted. But for now, we will use
Octave to run a computer simulation, choosing a population size N = 100.

3. Start by creating a 1 ื 100 vector of zeros, then randomly assign a value of 1 to a single
   position in the vector. Here we are using 0 to mean susceptible (not yet infected) and 1
   to mean infected.

>> x = z e r o s ( 1 , 1 0 0 ) ;  % vector of zeros

>> x ( f l o o r ( rand * 1 0 0 ) + 1 ) = 1 ; % s e t a random e n t r y e q u a l t o 1

We can count the number of infected individuals by counting the number of 1s in our
population vector. A convenient way to do this is with the equality logical test and a sum
function.

     >> I = sum ( x==1) % count t o t a l number o f e n t r i e s e q u a l t o 1
     I= 1

Now, we need to develop a loop such that each infected person comes into contact with
someone at random, infecting them (if they are susceptible). We can use a while loop that
cycles until the number infected reaches the upper limit of 100, along with a for loop to
generate each new random case. To facilitate editing the code and making modifications
to the parameters, it is advisable to put your code in an .m-file.

     >> d i s p ( I )
     >> w h i l e I <100

               for k = 1: I
                  x( floor ( rand *100) + 1) = 1;
                  I = sum ( x==1) ;

              end
              disp ( I )
           end

The disp statement will display the current number of infections at the end of each itera-
tion. Enter the code and view the results.

4. We can improve the algorithm by adding a counter and a variable length vector that tracks
   the number of infections through each iteration. First reset the population vector x. Then
   try the following:

         >> I = sum ( x==1) ;
         >> j = 1 ; a ( j ) = I ;
         >> w h i l e I <100

                   j = j + 1;
                   for k = 1: I

                      x( floor ( rand *100) + 1) = 1;
                      I = sum ( x==1) ;
                  end
                  a(j) = I ;
               end

Run the simulation. The number of infections in each time period is recorded in the vector
a. Create a plot showing the number of infections in each time period. Does the pattern
appear to be logistic?
154                           CHAPTER 7. APPLIED PROJECTS

5. Use the nonlinear curve-fitting method explained in Section 7.2 Exercise 5 to fit a logistic
   model of the form
                                                                  C
                                                   f (t) = 1 + Ae-kt

   for the number of infections.

   Here is the basic syntax to use, assuming vector a contains the results of your simulation.
   Its length is variable, depending on the random simulation, so in the code below we use
   the numel function for the upper limit on our input vector.

         >> % l o a d t h e optim package
         >> pkg l o a d optim

         >> % d e f i n e t h e model e q u a t i o n ; p has t h r e e components (C, A, k )
         >> f = @( p , t ) p ( 1 ) . / ( 1 + p ( 2 ) . * exp(-p ( 3 ) * t ) ) ;

         >> % i n i t i a l g u e s s e s f o r C, A, and k
         >> i n i t = [ 1 0 0 ; 2 0 0 ; 1 ] ;

         >> % c a l c u l a t e t h e model
         >> [ p , y ] = n o n l i n c u r v e f i t ( f , i n i t , [ 1 : numel ( a ) ] , a )

   Plot the logistic curve on the same axes as the simulation data. Include a legend. Is the
   model a good fit?

The SIR model

With most diseases, an infected individual will not remain infectious indefinitely. They will
either recover or succumb to the illness. In either case, they are removed from the population
of susceptible individuals, at least assuming recovery provides a measure of immunity. Thus we
now track three groups in the population: those susceptible, those infected, and those recovered
(or removed). This is known as the SIR model.5

In a population of size N , let S be the number of individuals susceptible, I the number infected,
and R the number recovered. If the infectious rate is  and the recovery rate is , then the SIR
model corresponds to the following set of ordinary differential equations.

               dS  =-  SI          (7.1)
                                   (7.2)
               dt          N       (7.3)

               dI  =  SI      - I

               dt     N

               dR
                      = I

               dt

In this model,  corresponds to the frequency of contact between individuals in the population
and  = 1/d, where d is the duration of the infection.

    5https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology#The_SIR_model
7.6. MODELING THE SPREAD OF AN INFECTIOUS DISEASE                                      155

Figure 7.14: SIR model

6. Suppose we begin with one infection in a population of size N = 100 and the disease
   spreads according to the Equations 7.1-7.3 with  = 2 and  = 0.5. Solve the system of
   differential equations over a 30-day period using ode45.

   We need to define y as a three-component vector function. Here is the syntax to use:

         >> % e n t e r t h e p a r a m e t e r s
         >> n = 1 0 0 ; b = 2 ; g = 0 . 5 ;

>> % d e f i n e t h e ODE system               b*y (1) .* y (2) /n - g*y (2) ;  g*y(2) ] ;
>> f = @( t , y ) [-b*y ( 1 ) . * y ( 2 ) /n ;
>> % y ( 1 ) = s u s c e p t i b l e
>> % y ( 2 ) = i n f e c t e d
>> % y ( 3 ) = r e c o v e r e d

>> % s o l v e t h e ODE system                                                        graph
>> t s p a n = [ 0 : 0 . 1 : 3 0 ] ; % r e d u c e d s t e p s i z e f o r a smoother
>> i n i t = [ n - 1 , 1 , 0 ] ; % b e g i n with one i n f e c t i o n
>> [ t , y ] = ode45 ( f , tspan , i n i t ) ;

Plot a graph of the solution showing each of the three groups, labeled with a legend. You
should get a result similar to Figure 7.14. Estimate the maximum number of infections
and when it occurs.

7. Solve the system again, keeping N and  as above, but changing  to 4. This corresponds
   to doubling the contact between individuals (that is, reduced social distancing). Plot a
   graph of the solution showing each of the three groups. Estimate the maximum number
   of infections and when it occurs.
156                                                      CHAPTER 7. APPLIED PROJECTS

8. What is effect of increased social distancing? Solve the model again, this time with  = 1
   (keeping N = 100 and  = 0.5). Plot a graph of the solution showing each of the three
   groups. Estimate the maximum number of infections and when it occurs.

9. Now plot a comparative graph showing only the number of infections, with  = 1,  = 2,
   and  = 4. Include a legend. The graph should clearly illustrate the effect reduced contact
   between individuals has on the timing and magnitude of the peak number of infections.

   In the context of this model, the basic reproduction number is R0 = /. Give the basic
   reproduction number for each of the three models under consideration.

10. Write a function file that solves the SIR model equations for any user-inputted values of
     N , , and . You will also need to specify the interval over which the equations are solved.

     Your function should have the following basic structure:

                     Octave Script 7.3: SIR model function file

     1 f u n c t i o n y = SIRmodel ( n , b , g , maxT)

     2 % SIR model f o r spread of i n f e c t i o u s d i s e a s e

     3 % y = SIRmodel ( n , b , g , maxT)

     4 % parameters :

     5%      n = population size

     6%      b = transmission rate ( beta )

     7%      g = r e c o v e r y r a t e (gamma)

     8%      maxT = number o f i t e r a t i o n s t o s i m u l a t e

     9%

     10 % example :

     11 %    SIRmodel (100 , 3 , 0.5 , 20)

     12

     13 ---body o f function---

     14

     15 end

     The output should be a matrix showing the values for S, I, and R in three columns.
     Also, generate a plot, labeled with a legend and title (like Figure 7.14). Run the function
     for various values of the parameters to explore their effect on the solution. Try to find
     scenarios where the disease runs its course without affecting the entire population.
Appendix A

MATLAB compatibility

Octave and Matlab use similar syntax, but the programs are not identical. Matlab, especially
when extended with its various toolboxes, has many functions not available in Octave. However,
most code in this book will work in Matlab, so what you've learned here will easily transfer to
more advanced Matlab programming.
Octave allows some flexibility in syntax that Matlab does not. This book has been written with
Matlab compatibility in mind, so generally, when multiple forms of a command or operation
are possible, the Matlab-compatible option has been used. Here is a summary of a few of the
potential coding differences.

     Comments in Octave can be preceded by # or %. Matlab uses %.
     Octave recognizes single quotes and double quotes around strings. Matlab requires single

       quotes.

     Blocks in Octave can be terminated with statements based on the initial command (endfor,
       endfunction, etc.). Matlab uses only end.

     The not-equal comparison can be written as != or ~= in Octave. Matlab requires ~=.
     Octave supports C-style increment operators. For example, in Octave, ++n is equivalent

       to n = n+1, but in Matlab, increment operators like ++ are not available.
     Octave allows user-defined functions to be entered at the command line or in scripts.

       Matlab requires the use of separate function files (recent releases now allow defining
       functions in scripts).

     Matlab users may prefer fplot and fimplicit over the ezplot function used in Sec-
       tions 3.3.2 and 3.4.3. However, fimplicit is not (yet) implemented in Octave and the
       current implementation of fplot does not handle symbolic functions. Octave's fplot does
       work for plotting functions of the form y = f (x).

     Matlab does not allow the formatted output command printf . Use fprintf .

                                                            157
158  APPENDIX A. MATLAB COMPATIBILITY

      For systems that are over or underdetermined, and those with a singular coefficient matrix,
        left division in Octave will always return a minimum norm solution, equivalent to solving
        using the pseudoinverse. The result may not be consistent with Matlab's solution (refer
        to Matlab documentation for details on how Matlab-left division handles these cases).

      The lsode command is not implemented in Matlab. For Matlab-compatibility, ode45
        and several other Matlab-compatible solvers are available in Octave (some require loading
        the package odepkg).

      There are significant differences between Matlab Toolboxes and Octave Forge packages,
        though many Octave packages use syntax similar or identical to the corresponding Mat-
        lab functions. In particular, the packages used used in this text have good correlation to
        Matlab Toolboxes: the Octave symbolic package is similar to Matlab's Symbolic Tool-
        box, the optim package has capabilities similar to the Curve Fitting Toolbox, the image
        package is similar to the Image Processing Toolbox, and the statistics package is similar
        to the Statistics Toolbox.
Appendix B

Octave command glossary

The names and basic syntax for many common commands are provided below. Many commands
have additional options. Type help NAME at the Octave prompt or refer to [3] for more details.
Note that some commands listed here require Octave Forge packages, including statistics and
symbolic.

List of Octave commands                                      Description
Syntax
                                                             vector from a to b by increment 1 unit
[a:b] . . . . . . . . . . . . . . . . . . . . . . . . . .    vector from a to b by increment "step"
[a : step : b] . . . . . . . . . . . . . . . . .             (conjugate) transpose of A
A' . . . . . . . . . . . . . . . . . . . . . . . . . . . .   transpose of A
A.' . . . . . . . . . . . . . . . . . . . . . . . . . . . .  matrix product AB
A*B . . . . . . . . . . . . . . . . . . . . . . . . . .      left division, solves system Ax = b
A\b . . . . . . . . . . . . . . . . . . . . . . . . . . .    matrix power
A^n . . . . . . . . . . . . . . . . . . . . . . . . . . .    sum A + B
A + B ........................                               less than comparison
x < y .........................                              greater than comparison
x > y .........................                              equality comparison
x == y . . . . . . . . . . . . . . . . . . . . . . .         not equal comparison
x ~= y . . . . . . . . . . . . . . . . . . . . . . . .       elementwise product
x.*y . . . . . . . . . . . . . . . . . . . . . . . . . .     elementwise quotient
x./y . . . . . . . . . . . . . . . . . . . . . . . . . .     elementwise exponent
x.^n . . . . . . . . . . . . . . . . . . . . . . . . . .     logical AND
a & b .........................                              logical NOT
~a . . . . . . . . . . . . . . . . . . . . . . . . . . . .   logical OR
a | b .........................                              anonymous function of x1, x2, . . . given by rule
f = @(x1, x2, ...) rule . . . . . . . . .                    absolute value or modulus of x
abs(x) . . . . . . . . . . . . . . . . . . . . . . . . .     inverse cosine of x in radians
acos(x) . . . . . . . . . . . . . . . . . . . . . . . .      angle of complex variable z
angle(z) . . . . . . . . . . . . . . . . . . . . . . .       result of last calculation
ans . . . . . . . . . . . . . . . . . . . . . . . . . . .    inverse sine of x in radians
asin(x) . . . . . . . . . . . . . . . . . . . . . . . .      assume symbolic x has property (positive, integer, etc.)
assume(x, 'property') . . . . . . . . . . .                  inverse tangent of x in radians
atan(x) . . . . . . . . . . . . . . . . . . . . . . . .      set axis limits
axis ([ Xmin Xmax Ymin Ymax])                                bar graph of y vs. x
bar(x, y) . . . . . . . . . . . . . . . . . . . . . .        order n Bessel functions of the first kind
besselj (n, x) . . . . . . . . . . . . . . . . . .           binomial probability of x successes
binopdf(x, n, p) . . . . . . . . . . . . . . .                x , the least integer greater than or equal to x
ceil (x) . . . . . . . . . . . . . . . . . . . . . . . .
                                                                                                                           continued . . .

                                                             159
160                                                            APPENDIX B. OCTAVE COMMAND GLOSSARY

. . . continued                                                Description
 Syntax
                                                               clear command window
 clc . . . . . . . . . . . . . . . . . . . . . . . . . . . .   clear variables (clear all if no variable listed)
 clear var1 var2 ... . . . . . . . . . . . . .                 clear plot window
  clf . . . . . . . . . . . . . . . . . . . . . . . . . . . .  set colormap to "type" (e.g., gray, default)
 colormap('type') . . . . . . . . . . . . . . .                comet plot animation of a plane curve
 comet(x, y) . . . . . . . . . . . . . . . . . . . .           comet plot animation of a space curve
 comet3(x, y, z) . . . . . . . . . . . . . . . .               compass plot of variable z in the complex plane
 compass(z) . . . . . . . . . . . . . . . . . . . .            contour plot of surface
 contour(X, Y, Z) . . . . . . . . . . . . . . .                linear correlation coefficient r
 corr(x, y) . . . . . . . . . . . . . . . . . . . . .          cosine of x (x in radians)
 cos(x) . . . . . . . . . . . . . . . . . . . . . . . . .      hyperbolic cosine of x
 cosh(x) . . . . . . . . . . . . . . . . . . . . . . . .       cross product of vectors u and v
 cross(u, v) . . . . . . . . . . . . . . . . . . . .           load a csv-format data file
 csvread('filename.csv' ) . . . . . . . . .                    write a numeric matrix A to a csv-format data file
 csvwrite( 'filename.csv' , A) . . . . .                       curl of vector field with components U and V
 curl(X, Y, U, V) . . . . . . . . . . . . . . .                cylinder of radius r
 cylinder ([ r r ]) . . . . . . . . . . . . . . . .            double integral over rectangle
 dblquad('f' , a, b, c, d) . . . . . . . .                     determinant of A
 det(A) . . . . . . . . . . . . . . . . . . . . . . . .        differentiate symbolic function with respect to x
  diff (f , x) . . . . . . . . . . . . . . . . . . . . .       list files in current directory
 dir . . . . . . . . . . . . . . . . . . . . . . . . . . . .   display the value of x
 disp(x) . . . . . . . . . . . . . . . . . . . . . . . .       divergence of vector field with components U and V
 divergence(X, Y, U, V) . . . . . . . . .                      dot product of vectors u and v
 dot(u, v) . . . . . . . . . . . . . . . . . . . . . .         convert x to double precision floating point
 double(x) . . . . . . . . . . . . . . . . . . . . . .         solve symbolic differential equation with initial condition
 dsolve(ode, ic ) . . . . . . . . . . . . . . . .              the number e
 e .............................                               find eigenvalues and eigenvectors
 [v lambda] = eig(A) . . . . . . . . . . . .                   the error function
 erf (x) . . . . . . . . . . . . . . . . . . . . . . . . .     natural exponential function
 exp(x) . . . . . . . . . . . . . . . . . . . . . . . .        expand a symbolic expression
 expand(f) . . . . . . . . . . . . . . . . . . . . . .         n ื n identity matrix
 eye(n) . . . . . . . . . . . . . . . . . . . . . . . . .      implicit plot of f (x, y) = 0 over domain [a, b] ื [c, d]
 ezplot(f , [a b c d]) . . . . . . . . . . . .                 factor a symbolic expression
 factor (f) . . . . . . . . . . . . . . . . . . . . . .        n!, factorial of n
  factorial (n) . . . . . . . . . . . . . . . . . . .           x , the greatest integer less than or equal to x
  floor (x) . . . . . . . . . . . . . . . . . . . . . . .      for loop
 for k = 1:n ... end . . . . . . . . . . . .                   decimal format, options = short, long, free, bank, etc.
 format opt . . . . . . . . . . . . . . . . . . . . .          plot of y = f (x) over domain [a, b]
 fplot (f , [a b]) . . . . . . . . . . . . . . . .             solve f (x) = 0, initial guess x1
  fsolve ( ' f ' , x1) . . . . . . . . . . . . . . . .         define a function
 function y = f(x) ... end . . . . . . .                       the gamma function
 gamma(x) . . . . . . . . . . . . . . . . . . . . .            gradient of a vector field
 [DX DY] = gradient(Z) . . . . . . . . .                       toggle plot grid
 grid on/off . . . . . . . . . . . . . . . . . . . .
                                                                                                                             continued . . .
                                                             161

. . . continued                                              Description
 Syntax
                                                             get documentation for command "NAME"
 help NAME . . . . . . . . . . . . . . . . . . .             histogram of X, optional B specifies bins
 hist (X, B) . . . . . . . . . . . . . . . . . . . . .       add to current plot toggle on/off
 hold on/off . . . . . . . . . . . . . . . . . . . .         the imaginary unit
 i/I/j/J . . . . . . . . . . . . . . . . . . . . . . . .     imaginary part of z
 imag(z) . . . . . . . . . . . . . . . . . . . . . . .       display matrix as scaled image
 imagesc(A) . . . . . . . . . . . . . . . . . . . .          integrate symbolic function (optional limits)
 int (f , x, a, b]) . . . . . . . . . . . . . . .            interpolate using type "method" (linear, cubic, pchip, etc.)
 interp1(x, y, 'method') . . . . . . . .                     inverse of matrix A
 inv(A) . . . . . . . . . . . . . . . . . . . . . . . .      plot legend
 legend('plot1 ' , ' plot2 ' , ...) . . .                    vector of n evenly spaced points from a to b
 linspace (a, b, n) . . . . . . . . . . . . . .              load saved variables
 load filename . . . . . . . . . . . . . . . . . .           natural logarithm
 log(x) . . . . . . . . . . . . . . . . . . . . . . . . .    solves dx/dt = f (x, t), x(0) = x0
 lsode( ' f ' , x0, t) . . . . . . . . . . . . . .           LU decomposition of A, with permutation
 [L U P] = lu(A) . . . . . . . . . . . . . . .               maximum of vector, or column-wise maximums of a matrix
 max(A) . . . . . . . . . . . . . . . . . . . . . . .        mean of x
 mean(x) . . . . . . . . . . . . . . . . . . . . . . .       surface plotted as a mesh
 mesh(X, Y, Z) . . . . . . . . . . . . . . . . .             generate xy-meshgrid
 [X Y] = meshgrid(x, y) . . . . . . . . .                    minimum of vector, or column-wise minimums of a matrix
 min(A) . . . . . . . . . . . . . . . . . . . . . . . .      norm (length) of vector u
 norm(u) . . . . . . . . . . . . . . . . . . . . . . .       area under normal curve to the left of x
 normcdf(x, mu, sigma) . . . . . . . . . .                   inverse normal distribution given area a
 norminv(a, mu, sigma) . . . . . . . . . .                   real nth root
 nthroot(number, index) . . . . . . . . .                    number of elements in a vector or matrix
 numel(v) . . . . . . . . . . . . . . . . . . . . . .        solve dx/dt = f (t, x) with initial condition x(0) = x0
 [ t x] = ode45('f' , tspan, x0) . . .                       m ื n matrix of ones
 ones(m, n) . . . . . . . . . . . . . . . . . . . . .        example 3d graph of a surface with many local extrema
 peaks . . . . . . . . . . . . . . . . . . . . . . . . .     the number 
 pi . . . . . . . . . . . . . . . . . . . . . . . . . . . .  pseudoinverse of A
 pinv(A) . . . . . . . . . . . . . . . . . . . . . . .       download and install a package from Octave Forge
 pkg install -forge NAME . . . . . .                         list installed packages
 pkg list . . . . . . . . . . . . . . . . . . . . . . .      load an installed package
 pkg load NAME . . . . . . . . . . . . . . .                 plot of x vs. y
 plot(x, y) . . . . . . . . . . . . . . . . . . . . .        plot space curve
 plot3(x, y, z) . . . . . . . . . . . . . . . . .            polar plot of radial distance  vs. angle  (in radians)
 polar(theta, rho) . . . . . . . . . . . . . .               polynomial fit x vs. y of degree "order"
  polyfit (x, y, order) . . . . . . . . . . . .              evaluate polynomial P at x
 polyval(P, x) . . . . . . . . . . . . . . . . . .           evaluate piecewise polynomial P at x
 ppval(P, x) . . . . . . . . . . . . . . . . . . . .         save plot as png (substitute jpg, eps, etc.)
 print -dpng filename.png . . . . . .                        print (list) current working directory
 pwd . . . . . . . . . . . . . . . . . . . . . . . . . . .   QR decomposition of A
 [Q R] = qr(A) . . . . . . . . . . . . . . . . .             definite integral of f from a to b
 quad('f ' , a, b) . . . . . . . . . . . . . . . .
                                                                                                                           continued . . .
162                                                        APPENDIX B. OCTAVE COMMAND GLOSSARY

. . . continued                                            Description
 Syntax
                                                           plot vector field with components U and V
 quiver(X, Y, U, V) . . . . . . . . . . . . .              plot 3d vector field with components U , V , W
 quiver3(X, Y, Z, U, V, W) . . . . . .                     m ื n random matrix (uniformly distributed entries)
 rand(m, n) . . . . . . . . . . . . . . . . . . . .        m ื n random matrix (normally distributed entries)
 randn(m, n) . . . . . . . . . . . . . . . . . . .         rank of A
 rank(A) . . . . . . . . . . . . . . . . . . . . . . .     real part of z
 real (z) . . . . . . . . . . . . . . . . . . . . . . . .  save variables A, B, ...
 save filename A B ... . . . . . . . . . . .               set properties of graphics object h
 set(h, 'property', 'value' ) . . . . .                    simplify a symbolic expression
 simplify(f) . . . . . . . . . . . . . . . . . . . .       sine of x (x in radians)
 sin(x) . . . . . . . . . . . . . . . . . . . . . . . . .  hyperbolic sine of x
 sinh(x) . . . . . . . . . . . . . . . . . . . . . . . .   dimensions of A; dimension option: 1=rows, 2=cols
 size (A, opt) . . . . . . . . . . . . . . . . . . .       solve a symbolic equation
 solve(a == b) . . . . . . . . . . . . . . . . .           principal square root of x
 sqrt(x) . . . . . . . . . . . . . . . . . . . . . . . .   standard deviation of x
 std(x) . . . . . . . . . . . . . . . . . . . . . . . . .  evaluate symbolic expression f at x
 subs(f , x) . . . . . . . . . . . . . . . . . . . . .     sum of vector components or column-wise sum of matrix A
 sum(A) . . . . . . . . . . . . . . . . . . . . . . .      surface plot
 surf (X, Y, Z) . . . . . . . . . . . . . . . . . .        singular value decomposition of A
 [U S V] = svd(A) . . . . . . . . . . . . . .              define symbolic variables
 syms x y z ... . . . . . . . . . . . . . . . . .          tangent of x (x in radians)
 tan(x) . . . . . . . . . . . . . . . . . . . . . . . . .  hyperbolic tangent of x
 tanh(x) . . . . . . . . . . . . . . . . . . . . . . .     degree n Taylor polynomial of f about a
 taylor ( f , x, a, 'order' , n) . . . . .                 Students t-distribution CDF with degrees of freedom n
 tcdf(x, n) . . . . . . . . . . . . . . . . . . . . .      add a text label to plot at coordinates (x, y)
 text(x, y, ' label ' ) . . . . . . . . . . . . .          inverse t-distribution with degrees of freedom n
 tinv(a, n) . . . . . . . . . . . . . . . . . . . . .      assign plot title
  title ( 'name') . . . . . . . . . . . . . . . . . .      triple integral over a rectangular box
 triplequad( ' f ' , a, b, c, d, e, f )                    t-test, name-value pairs set alpha and tail (left, right, both)
 ttest (X, mu, 'name', 'value' ) . . .                     extract components of piecewise polynomial P
 [x, p] = unmkpp(P) . . . . . . . . . . .                  variance of x
 var(x) . . . . . . . . . . . . . . . . . . . . . . . . .  while loop
 while (condition) ... end . . . . . . .                   list variables in current scope
 whos . . . . . . . . . . . . . . . . . . . . . . . . . .  horizontal axis label
 xlabel( 'name') . . . . . . . . . . . . . . . . .         vertical axis label
 ylabel( 'name') . . . . . . . . . . . . . . . . .         m ื n matrix of zeros
 zeros(m, n) . . . . . . . . . . . . . . . . . . . .

Note that most commands which accept a function as an argument expect the name to be in
quotes (' f ') if it is defined as a named function (using the function ... end construction, whether
so-defined at the command line, in a script, or in a function file), but if f is a function handle
(e.g., defined as anonymous function), then no quotes are used.
References

 [1] Brin, Leon Q, Tea Time Numerical Analysis, 2nd edition. CC-BY-SA, 2016.
      http://lqbrin.github.io/tea-time-numerical/

 [2] Diez, David M, Christopher D Barr, and Mine Cธ etinkaya-Rundel, OpenIntro Statistics, 3rd
      edition. CC-BY-SA, 2015.
      https://www.openintro.org/stat/textbook.php

 [3] Eaton, John W, David Bateman, S๘ren Hauberg, and Rik Wehbring, GNU Octave Manual:
      Edition 5. GNU FDL, 2019.
      https://www.gnu.org/software/octave/octave.pdf

 [4] Grinstead, Charles M, and J Laurie Snell, Introduction to Probability, 2nd Edition.
      American Mathematical Society. GNU FDL, 2006.
      http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_
      book/book.html

 [5] Hartman, Gregory, et al, Apex Calculus, Version 4.0. CC-BY-NC, 2018.
      http://www.apexcalculus.com/

 [6] Nicholson, W Keith, Linear Algebra with Applications, Open Edition (Revision 2019A).
      Lyryx. CC-BY-NC-SA, 2019.
      https://lyryx.com/products/mathematics/linear-algebra-applications/

 [7] Strang, Gilbert, Edwin Herman, et al, Calculus Volume 3. OpenStax. CC-BY-NC-SA, 2016.
      https://openstax.org/details/books/calculus-volume-3

 [8] Trench, William F, Elementary Differential Equations. Trinity University, Digital Com-
      mons. CC-BY-NC-SA, 2013.
      http://digitalcommons.trinity.edu/mono/8/

                                                            163
164  REFERENCES
Index                                cycloid, 46
                                     cylinder, 124, 134
antiderivative, 53                   cylindrical coordinates, 102
arc length, 58, 133
assumption on variable, 54           dblquad, 108
axis                                 derivative, 53
                                     determinant, 8
     equal aspect ratio, 46          diagonalization, 78
     grid, 10                        difference quotient, 51
     implicit plot limits, 49        differential equation, 117, 120, 154, 158
     labels, 10                      dilation, 31
     limits, 10, 100                 disp statement, 153
     off, 15                         display format, 40, 65
                                     divergence, 125
bar graph, 68                        dot product, 5, 89, 91
Bessel function, 61
binomial distribution, 68            eigenvalues/eigenvectors, 8, 73, 81
Boolean operators, 108               elementwise operations, 12, 24, 39, 97
bumpy sphere, 104, 141               equality comparison, 51
                                     equilibrium vector, 76
central limit theorem, 63            error function, 61
change of variables, 102             Euler's method, 118
clear                                Eulerian path, 27
                                     evaluating symbolic expressions, 51
     plot window, 11                 exponential function, base e, 15, 43
     variables, 14
code listing, format, x              factorial, 61
color map, 99                        factoring, 51
command history, 3                   file browser, 3
comments, x, 4                       floating point format
compass plot, 60
complex number, 8, 59                      free, 65
computer algebra system, 2, 50             long, 18
constant function, 15                floor function, 34, 63
contour plot, 100                    for loop, 41, 44, 153
correlation coefficient, 66          formatted output, 67, 157
cross product, 5, 137                fsolve, 57
curl, 125                            function
curvature, 134                             anonymous, 39, 110
curve-fitting                              file, x, 66, 88, 111, 137
     exponential, 36                       symbolic, 52
     general nonlinear, 131, 154           user-defined, 43
     linear, 11, 23, 66, 86
     polynomial, 25               165
166                                                                               INDEX

gamma function, 61, 70                         matrix
Gaussian elimination, 17                            definition, 5
Gini index, 131                                     dilation, 31
GNU, 1                                              identity, 8
gradient field, 115                                 indexing, 17
Gram-Schmidt process, 88                            inverse, 8
graphing, see plotting                              lower triangular, 20
                                                    multiplication, 7
harmonic series, 42                                 of ones, 15, 24, 115
helix, 97, 133                                      of zeros, 3
histogram, 63                                       orthogonal, 80
hold on/off, 11                                     permutation, 22
homogeneous coordinates, 32, 37                     random, 34
hypothesis test, 69                                 reflection, 29
                                                    rotation, 28
identity matrix, 8                                  row echelon form, 18, 20
ill-conditioned system, 85                          row-reduced echelon form, 18
image processing, 128                               singular, 33, 158
imaginary number, 59                                symmetric, 80
implicit function, 47                               transpose, 8
import data, see load                               upper triangular, 20
integral
                                               mean, 63
     multiple, 108                             mesh, 100
     numeric, 43                               mesh2stl, 137
     symbolic, 53                              meshgrid, 99
interpolation, 145                             midpoint rule, 43, 125

least-squares solution, 24, 34, 85             natural logarithm, 36
left division, 19, 33, 158                     nested loops, 113
length of vector, 5                            Newton's method, 57
limaธcon, 46                                   nonrectangular domain, 102, 108
limit, 39                                      norm, 5
linear regression, see curve-fitting,linear    normal distribution, standard, 63
linear system, see system of linear equations  normal equations, 24
linear transformation, 32                      normalize a vector, 6
linspace, 9                                    nth root (real), 60
load                                           numerical integration, 43, 108

     comma-separated data, 16                  Octave
     Octave workspace, 3                            graphical user interface, 2
     saved variable(s), 3                           installation, 2
logical function, 108, 153                          octaverc file, 3
logistic growth, 58, 126, 152                       script, x, 3, 43, 44
Lorenz curve, 130
lsode, 120                                     ODE, see differential equation
LU decomposition, 19, 33                       ode45, 122
                                               order of operations, 4
m file, see Octave script                      orthogonal diagonalization, 80
Markov chain, 74                               orthonormal set, 88
MATLAB, ix, 1, 157
INDEX                                                                                               167

packages                                   quadrature (definite integral), 43
     image, 128                            quiver, 114, 117
     installing, 127                       quiver3, 114
     loading, 127
     optimization, 131                     rand function, 34
     ordinary differential equations, 158  random integer, 34, 63
     statistics, 68, 69, 159               rank, 8
     symbolic, 50, 125, 141, 159           reflection, 29
                                           regression, see curve-fitting
parametric surface, 105                    Riemann sum, 112
partial sums, sequence of, 41              rotation, 28
pchip, 145                                 rref command, 18
peaks, 115, 140
permutation matrix, 22                     save variable(s), 3
plotting, 9                                scientific notation, 42, 60, 65
                                           script, see Octave script
     comet animation, 46                   semi-log plot, 36
     coordinate axes, 15                   sequence, 41
     ezplot, 47, 54, 157                   set function, 55
     fplot, 157                            Simpson's rule, 43
     implicit, 47                          singular value decomposition, 82, 127
     legend, 10                            singular values, 82, 127
     plot options, 10, 13                  SIR model, 154
     plot title, 10                        slope field, 117
     plotting points, 11                   solid of revolution, 107
     polar, 47                             solve symbolic equation, 51
     set function, 55                      sombrero function, 139
     surface, 99                           space curve, 97
     symbolic, 54                          special functions, 61
     text labels, 15                       spherical coordinates, 104
     three-dimensional, 97                 spline curve, 145
     vector field, 114                     startup.m, 3
polar coordinates, 46, 102                 statistics package, 68, 69
polynomial                                 STL (STereoLithography), 136
     format, 26                            string variables, x
     interpolation, 23, 25                 suppress output, 9, 34, 42
     piecewise, 146                        surf command, 99
     polyfit function, 25, 66              surface, 99
     polyval function, 26, 66
printf, 67                                      triangulation, 137, 150
printing to file, 13                       svd command, 85
probability vector, 75                     symbolic package, 50
projection
     scalar, 6                                  help function, 56
     vector, 6, 88                         SymPy, 50
pseudoinverse, 85, 158                     system of linear equations, 17, 19, 21, 23, 86
Python, 1, 50, 56
                                                backward substitution, 18
QR algorithm, 91                                forward substitution, 21
QR decomposition, 90                            ill-conditioned, 85
                                                inconsistent, 33
168                                 INDEX

     infinitely many solutions, 34
     left division, 19
     LU decomposition, 19
     over/underdetermined, 158

t-test, 69
Taylor series, 58
text function, 15
three-dimensional printing, 136
transition matrix, 75
transpose, 8

     conjugate, 8
trapezoid rule, 43
triplequad, 108
tube plot, 142

uniform distribution, 34, 63

variable
     assignment, 4
     editor, 3
     symbolic, 51

variance, 63
vector field, 114
vectorized code, 39, 45, 113

while loop, 153
workspace, 3
This text provides a brief, noncomprehensive introduction to GNU Octave, a free
software alternative to MATLAB. The basic syntax and usage is explained through
concrete examples from the mathematics courses a math, computer science, or
engineering major encounters in the first two years of college: linear algebra, calculus,
differential equations, and statistics.

Copyright 2020 by Jason Lachniet.

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0
International License.

Download for free at:
       https://www.wcc.vccs.edu/sites/default/files/Introduction-to-GNU-Octave.pdf
