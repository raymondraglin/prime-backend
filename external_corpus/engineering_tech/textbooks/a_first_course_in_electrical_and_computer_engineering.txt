1. Dedication of "A First Course in Electrical and Computer
   Engineering"

2. Preface to "A First Course in Electrical and Computer
   Engineering"

3. Complex Numbers
     1. Complex Numbers: Introduction
     2. Complex Numbers: Geometry of Complex Numbers
     3. Complex Numbers: Algebra of Complex Numbers
     4. Complex Numbers: Roots of Quadratic Equations
     5. Complex Numbers: Representing Complex Numbers in a
        Vector Space
     6. Complex Numbers: An Electric Field Computation
     7. Complex Numbers: Numerical Experiment (Quadratic
        Roots)

4. The Functions e^x and e^j
     1. The Functions e^x and e^j: Introduction
     2. The Functions e^x and e^j: The Function e^x
     3. The Functions e^x and e^j: The Function e^j and the
        Unit Circle
     4. The Functions e^x and e^j: The Euler and De Moivre
        Identities
     5. The Functions e^x and e^j: Roots of Unity and Related
        Topics
     6. The Functions e^x and e^j: Second-Order Differential
        and Difference Equations
     7. The Functions e^x and e^j: Numerical Experiment
        (Approximating e^j)

5. Phasors
     1. Phasors: Introduction
     2. Phasors: Phasor Representation of Signals
     3. Phasors: Beating between Tones
     4. Phasors: Multiphase Power
     5. Phasors: Lissajous Figures
     6. Phasors: Sinusoidal Steady State and the Series RLC

        Circuit
     7. Phasors: Light Scattering by a Slit
     8. Phasors: Numerical Experiment (Interference Patterns)
6. Linear Algebra
     1. Linear Algebra: Introduction
     2. Linear Algebra: Vectors
     3. Linear Algebra: Inner Product and Euclidean Norm
     4. Linear Algebra: Direction Cosines
     5. Linear Algebra: Projections
     6. Linear Algebra: Other Norms
     7. Linear Algebra: Matrices
     8. Linear Algebra: Solving Linear Systems of Equations
     9. Linear Algebra: Circuit Analysis
   10. Linear Algebra: Numerical Experiment (Circuit Design)
7. Vector Graphics
     1. Vector Graphics: Introduction
     2. Vector Graphics: Two-Dimensional Image Representation
     3. Vector Graphics: Two-Dimensional Image

        Transformations
     4. Vector Graphics: Composition of Transformations
     5. Vector Graphics: Homogeneous Coordinates
     6. Vector Graphics: Three-Dimensional Homogeneous

        Coordinates
     7. Vector Graphics: Projections
     8. Vector Graphics: Numerical Experiment (Star Field)
8. Filtering
     1. Filtering: Introduction
     2. Filtering: Simple Averages
     3. Filtering: Weighted Averages
      4. Filtering: Moving Averages
      5. Filtering: Exponential Averages and Recursive Filters
      6. Filtering: Test Sequences
      7. Filtering: Numerical Experiment (Frequency Response of

         First-Order Filter)
 9. Binary Codes

      1. Binary Codes: Introduction
      2. Binary Codes: The Communication Paradigm
      3. Binary Codes: From Symbols to Binary Codes
      4. Binary Codes: Huffman Codes for Source Coding
      5. Binary Codes: Hamming Codes for Channel Coding
      6. Binary Codes: Numerical Experiment (Huffman Codes)
10. An Introduction to MATLAB
      1. An Introduction to MATLAB: Introduction
      2. An Introduction to MATLAB: Running MATLAB

         (Macintosh)
      3. An Introduction to MATLAB: Running MATLAB (PC)
      4. An Introduction to MATLAB: Interactive Mode
      5. An Introduction to MATLAB: Variables
      6. An Introduction to MATLAB: Complex Variables
      7. An Introduction to MATLAB: Vectors and Matrices
      8. An Introduction to MATLAB: The Colon
      9. An Introduction to MATLAB: Graphics
     10. An Introduction to MATLAB: Editing Files and Creating

         Functions (Macintosh)
     11. An Introduction to MATLAB: Editing Files and Creating

         Functions (PC)
     12. An Introduction to MATLAB: Loops and Control
11. The Edix Editor
12. Useful Mathematical Identities
Dedication of "A First Course in Electrical and Computer Engineering"

                Louis Scharf dedicates this book to
       his wife Carol, son Greg, and daughter Heidi,

                         for love and inspiration;
                  his parents Louis Sr. and Ann,
 in celebration of their 50th wedding anniversary.

              Richard Behrens dedicates this book to
            his wife Debbie, and child as yet unborn,

                       for love and encouragement;
                     his parents Richard and Elsie,
                  in gratitude for a good education.
Preface to "A First Course in Electrical and Computer Engineering"

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

This book was written for an experimental freshman course at the
University of Colorado. The course is now an elective that the majority of
our electrical and computer engineering students take in the second
semester of their freshman year, just before their first circuits course. Our
department decided to offer this course for several reasons:

   1. we wanted to pique student' interest in engineering by acquainting
      them with engineering teachers early in their university careers and by
      providing with exposure to the types of problems that electrical and
      computer engineers are asked to solve;

   2. we wanted students entering the electrical and computer engineering
      programs to be prepared in complex analysis, phasors, and linear
      algebra, topics that are of fundamental importance in our discipline;

   3. we wanted students to have an introduction to a software application
      tool, such as MATLAB, to complete their preparation for practical and
      efficient computing in their subsequent courses and in their
      professional careers;

   4. we wanted students to make early contact with advanced topics like
      vector graphics, filtering, and binary coding so that they would gain a
      more rounded picture of modern electrical and computer engineering.

In order to introduce this course, we had to sacrifice a second semester of
Pascal programming. We concluded that the sacrifice was worth making
because we found that most of our students were prepared for high-level
language computing after just one semester of programming.
We believe engineering educators elsewhere are reaching similar
conclusions about their own students and curriculums. We hope this book
helps create a much needed dialogue about curriculum revision and that it
leads to the development of similar introductory courses that encourage
students to enter and practice our craft.

Students electing to take this course have completed one semester of
calculus, computer programming, chemistry, and humanities. Concurrently
with this course, students take physics and a second semester of calculus, as
well as a second semester in the humanities. By omitting the advanced
topics marked by asterisks, we are able to cover Complex Numbers through
Linear Algebra, plus two of the three remaining chapters. The book is
organized so that the instructor can select any two of the three. If every
chapter of this book is covered, including the advanced topics, then enough
material exists for a two-semester course.

The first three chapters of this book provide a fairly complete coverage of
complex numbers, the functions ex and ej, and phasors. Our department
philosophy is that these topics must be understood if a student is to succeed
in electrical and computer engineering. These three chapters may also be
used as a supplement to a circuits course. A measured pace of presentation,
taking between sixteen and eighteen lectures, is sufficient to cover all but
the advanced sections in Complex Numbers through Phasors.

The chapter on "linear algebra" is prerequisite for all subsequent chapters.
We use eight to ten lectures to cover it. We devote twelve to sixteen lectures
to cover topics from Vector Graphics through Binary Codes. (We assume a
semester consisting of 42 lectures and three exams.) The chapter on vector
graphics applies the linear algebra learned in the previous chapter to the
problem of translating, scaling, and rotating images. "Filtering" introduces
the student to basic ideas in averaging and filtering. The chapter on "Binary
Codes" covers the rudiments of binary coding, including Huffman codes
and Hamming codes.

If the users of this book find "Vector Graphics" through "Binary Codes" too
confining, we encourage them to supplement the essential material in
"Complex Numbers" through "Linear Algebra" with their own course notes
on additional topics. Within electrical and computer engineering there are
endless possibilities. Practically any set of topics that can be taught with
conviction and enthusiasm will whet the student's appetite. We encourage
you to write to us or to our editor, Tom Robbins, about your ideas for
additional topics. We would like to think that our book and its subsequent
editions will have an open architecture that enables us to accommodate a
wide range of student and faculty interests.

Throughout this book we have used MATLAB programs to illustrate key
ideas. MATLAB is an interactive, matrix-oriented language that is ideally
suited to circuit analysis, linear systems, control theory, communications,
linear algebra, and numerical analysis. MATLAB is rapidly becoming a
standard software tool in universities and engineering companies. (For more
information about MATLAB, return the attached card in the back of this
book to The MathWorks, Inc.) MATLAB programs are designed to develop
the student's ability to solve meaningful problems, compute, and plot in a
high-level applications language. Our students get started in MATLAB by
working through "An Introduction to MATLAB," while seated at an IBM
PC (or look-alike) or an Apple Macintosh. We also have them run through
the demonstration programs in "Complex Numbers". Each week we give
three classroom lectures and conduct a one-hour computer lab session.
Students use this lab session to hone MATLAB skills, to write programs, or
to conduct the numerical experiments that are given at the end of each
chapter. We require that these experiments be carried out and then reported
in a short lab report that contains (i) introduction, (ii) analytical
computations, (iii) computer code, (iv) experimental results, and (v)
conclusions. The quality of the numerical results and the computer graphics
astonishes students. Solutions to the chapter problems are available from
the publisher for instructors who adopt this text for classroom use.

We wish to acknowledge our late colleague Richard Roberts, who
encouraged us to publish this book, and Michael Lightner and Ruth
Ravenel, who taught "Linear Algebra" and "Vector Graphics" and offered
helpful suggestions on the manuscript. We thank C. T. Mullis for allowing
us to use his notes on binary codes to guide our writing of "Binary Codes".
We thank Cédric Demeure and Peter Massey for their contributions to the
writing of "An Introduction to MATLAB" and "The Edix Editor". We thank
Tom Robbins, our editor at Addison-Wesley, for his encouragement,
patience, and many suggestions. We are especially grateful to Julie
Fredlund, who composed this text through many drafts and improved it in
many ways. We thank her for preparing an excellent manuscript for
production.

L. L. Scharf
R. T. Behrens
Boulder, Colorado

To the Teacher:

An incomplete understanding of complex numbers and phasors handicaps
students in circuits and electronics courses, and even more so in advanced
courses such as electromagnetics. optics, linear systems, control, and
communication systems. Our faculty has decided to address this problem as
early as possible in the curriculum by designing a course that drills complex
numbers and phasors into the minds of beginning engineering students. We
have used power signals, musical tones, Lissajous figures, light scattering,
and RLC circuits to illustrate the usefulness of phasor calculus. "Linear
Algebra" through "Binary Codes" introduce students to a handful of modern
ideas in electrical and computer engineering. The motivation is to whet
students' appetites for more advanced problems. The topics we have chosen
- linear algebra, vector graphics, filtering, and binary codes - are only
representative.

At first glance, many of the equations in this book look intimidating to

beginning students. For this reason, we proceed at a very measured pace. In

our lectures, we write out in agonizing detail every equation that involves a

                                                N -1

sequence  or  series.  For  example,  the  sum                                                                                                     n  is  written  out  as

                                                                                                                                               z

                                                                                                                                          n=0

Equation:

                                      2                                                                                                        N -1

                            1+z+z ++z                                                                                                                 ,
and then it is evaluated for some specific value of z before we derive the

analytical result                     N  Similarly, an infinite sequence like

                   1-z

                   1-z

                           xn

lim (1 + ) is written out as

n          n

Equation:

                         x2                    x3                  x           100
                             ),                    ),
   (1 + x),        (1 +                  (1 +          ...,  (1 +       ),          ...,
                         2                     3
                                                                   100

and then it is evaluated for some specific x and for several values of n
before the limit is derived. We try to preserve this practice of pedantic
excess until it is clear that every student is comfortable with an idea and the
notation for coding the idea.

To the Student:

These are exciting times for electrical and computer engineering. To
celebrate its silver anniversary, the National Academy of Engineering
announced in February of 1990 the top ten engineering feats of the previous
twenty-five years. The Apollo moon landing, a truly Olympian and protean
achievement, ranked number one. However, a number of other
achievements in the top ten were also readily identifiable as the products of
electrical and computer engineers:

   1. communication and remote sensing satellites,
   2. the microprocessor,
   3. computer-aided design and manufacturing (CADCAM),
   4. computerized axial tomography (CAT scan),
   5. lasers, and
   6. fiber optic communication.

As engineering students, you recognize these achievements to be important
milestones for humanity; you take pride in the role that engineers have
played in the technological revolution of the twentieth century.
So how do we harness your enthusiasm for the grand enterprise of
engineering? Historically, we have enrolled you in a freshman curriculum
of mathematics, science, and humanities. If you succeeded, we enrolled you
in an engineering curriculum. We then taught you the details of your
profession and encouraged your faith that what you were studying is what
you must study to be creative and productive engineers. The longer your
faith held, the more likely you were to complete your studies. This seems
like an imperious approach to engineering education, even though
mathematics, physics, and the humanities are the foundation of engineering,
and details are what form the structure of engineering. It seems to us that a
better way to stimulate your enthusiasm and encourage your faith is to
introduce you early in your studies to engineering teachers who will share
their insights about some of the fascinating advanced topics in engineering,
while teaching you the mathematical and physical principles of engineering.
But you must match the teacher's commitment with your own commitment
to study. This means that you must attend lectures, read texts, and work
problems. You must be inquisitive and skeptical. Ask yourself how an idea
is limited in scope and how it might be extended to apply to a wider range
of problems. For, after all, one of the great themes of engineering is that a
few fundamental ideas from mathematics and science, coupled with a few
principles of design, may be applied to a wide range of engineering
problems. Good luck with your studies.
Complex Numbers: Introduction

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Notes to Teachers and Students:

When we teach complex numbers to beginning engineering students, we
encourage a geometrical picture supported by an algebraic structure. Every
algebraic manipulation carried out in a lecture is accompanied by a care-
fully drawn picture in order to fix the idea that geometry and algebra go
hand-in-glove to complete our understanding of complex numbers. We
assign essentially every problem for homework.

We use the MATLAB programs in this chapter to illustrate the theory of
complex numbers and to develop skill with the MATLAB language. The
numerical experiment introduces students to the basic quadratic equation of
electrical and computer engineering and shows how the roots of this
quadratic equation depend on the coefficients of the equation.

"Representing Complex Numbers in a Vector Space," is a little demanding
for freshmen but easily accessible to sophomores. It may be covered for
additional insight, skipped without consequence, or covered after Chapter 4.
"An Electric Field Computation," is well beyond most freshmen, and it is
demanding for sophomores. Nonetheless, an expert in electromagnetics
might want to cover the section "An electric Field Computation" for the
insight it brings to the use of complex numbers for representing two-
dimensional real quantities.

Introduction
It is hard to overestimate the value of complex numbers. They first arose in
the study of roots for quadratic equations. But, as with so many other great
discoveries, complex numbers have found widespread application well
outside their original domain of discovery. They are now used throughout
mathematics, applied science, and engineering to represent the harmonic
nature of vibrating systems and oscillating fields. For example, complex
numbers may be used to study

   i. traveling waves on a sea surface;
  ii. standing waves on a violin string;
  iii. the pure tone of a Kurzweil piano;
  iv. the acoustic field in a concert hall;
   v. the light of a He-Ne laser;
  vi. the electromagnetic field in a light show;
 vii. the vibrations in a robot arm;
viii. the oscillations of a suspension system;
  ix. the carrier signal used to transmit AM or FM radio;
   x. the carrier signal used to transmit digital data over telephone lines; and
  xi. the 60 Hz signal used to deliver power to a home.

In this chapter we develop the algebra and geometry of complex numbers.
In Chapter 3 we will show how complex numbers are used to build phasor
representations of power and communication signals.
Complex Numbers: Geometry of Complex Numbers

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The most fundamental new idea in the study of complex numbers is the
"imaginary number" j. This imaginary number is defined to be the square
root of -1:
Equation:

Equation:  j = -1

               2

           j = -1.

The imaginary number j is used to build complex numbers x and y in the
following way:
Equation:

                                                                          z = x + jy.

We say that the complex number z has "real part" x and "imaginary part" y:
Equation:

                                                                z = Re[z] + j Im[z]

Equation:

                                                            Re[z] = x; Im[z] = y.
In MATLAB, the variable x is denoted by real(z), and the variable y is
denoted by imag(z). In communication theory, x is called the "in-phase"
component of z, and y is called the "quadrature" component. We call z =
x + jy the Cartesian representation of z, with real component x and
imaginary component y. We say that the Cartesian pair (x, y)codes the
complex number z.

We may plot the complex number z on the plane as in [link]. We call the
horizontal axis the "real axis" and the vertical axis the "imaginary axis."
The plane is called the "complex plane." The radius and angle of the line to
the point z = x + jy are
Equation:

Equation:    r = x2 + y2

                                         y

                                    -1

            =tan ( ).
                                         x

See [link]. In MATLAB, r is denoted by abs(z), and  is denoted by
angle(z).

Cartesian and Polar Representations of the Complex Number z
The original Cartesian representation is obtained from the radius r and
angle  as follows:
Equation:

                                                                            x = rcos

Equation:

                                                                         y = r sin .

The complex number z may therefore be written as
Equation:

z=  x + jy

=   rcos + jrsin

= r ( cos  + j sin ).

The complex number cos + jsin is, itself, a number that may be
represented on the complex plane and coded with the Cartesian pair
(cos , sin). This is illustrated in [link]. The radius and angle to the point
z =cos  + jsin are 1 and . Can you see why?

The Complex Number cos  + j sin 
The complex number cos + jsin is of such fundamental importance to
our study of complex numbers that we give it the special symbol ej :
Equation:

                                                                                                j

                                                                 e =cos  + jsin.

As  illustrated  in  [link],  the   complex  number              j  has  radius  1  and  angle   .

                                                              e

With the symbol ej, we may write the complex number z as

Equation:

                                                           j

                                    z = re .

We  call  z  =         j  a  polar  representation  for       the  complex  number       z.  We  say

                re

that the polar pair rcodes the complex number z. In this polar

representation, we define |z| = r to be the magnitude of z and arg (z) = 

to be the angle, or phase, of z:

Equation:

                                    |z| = r

Equation:

                                    arg (z) = .

With these definitions of magnitude and phase, we can write the complex
number z as
Equation:

                                    z = |z|e jarg(z)          .

Let's summarize our ways of writing the complex number z and record the
corresponding geometric codes:
Equation:

                                                                            ()
                 z = x + jy = re          j       =   zej arg(z) .

                                          
                           (x, y)      r

In "Roots of Quadratic Equations" we show that the definition

   j  =  cos  +  jsin  is  more  than  symbolic.  We  show,  in  fact,  that     j  is  just

e                                                                             e

the familiar function ex evaluated at the imaginary argument x = j. We

call ej a "complex exponential," meaning that it is an exponential with an

imaginary argument.

Exercise:

Problem:

   Prove (j) = (-1) 2n n and (j) = (-1) j 2n+1 n . Evaluate j3, j4, j5.
Exercise:

   Problem:

   Prove ej[(/2)+m2] = j, ej[(3/2)+m2] = -j, ej(0+m2) = 1, and
   ej(+m2) = -1. Plot these identities on the complex plane. (Assume
   m is an integer.)

Exercise:

   Problem:

Find the polar representation z = rej for each of the following
complex numbers:

      a. z = 1 + j0;
      b. z = 0 + j1;
      c. z = 1 + j1;
      d. z = -1 - j1.

   Plot the points on the complex plane.
Exercise:
   Problem:

   Find the Cartesian representation z = x + jy for each of the following
   complex numbers:

      a. z = 2ej/2 ;
      b. z = 2ej/4;
      c. z = ej3/4 ;
      d. z = 2ej3/2.

   Plot the points on the complex plane.
Exercise:

   Problem:

   The following geometric codes represent complex numbers. Decode
   each by writing down the corresponding complex number z:

      a. (0. 7, -0. 1) z = ?
      b. (-1. 0, 0. 5) z = ?
      c. 1. 6/8 z =?
      d. 0. 47/8 z =?

Exercise:
Problem:

Show that Im[jz] = Re[z] and Re[-jz] = Im[z]. Demo 1.1
(MATLAB). Run the following MATLAB program in order to
compute and plot the complex number ej for
 = i2/360, i = 1, 2, ..., 360: j=sqrt(-1) n=360 for
i=1:n,circle(i)=exp(j*2*pi*i/n);end;
axis('square') plot(circle) Replace the explicit for loop
of line 3 by the implicit loop circle=exp(j*2*pi*[1:n]/n);
to speed up the calculation. You can see from [link] that the complex
number ej, evaluated at angles  = 2/360, 2(2/360), ..., turns out
complex numbers that lie at angle  and radius 1. We say that ej is a
complex number that lies on the unit circle. We will have much more
to say about the unit circle in Chapter 2.
The  Complex  Numbers     j  for  0        2  (Demo  1.1)

                       e
Complex Numbers: Algebra of Complex Numbers

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The complex numbers form a mathematical "field" on which the usual
operations of addition and multiplication are defined. Each of these
operations has a simple geometric interpretation.

Addition and Multiplication.

The complex numbers z1 and z2 are

added according to the rule
Equation:

                                          z1 + z2 = (x1 + jy1 ) + (x2 + jy2 )
                                                                 = (x1 + x2 ) + j(y1 + y2 ).

We say that the real parts add and the imaginary parts add. As illustrated in
[link], the complex number z1 + z2 is computed from a "parallelogram
rule," wherein z1 + z2 lies on the node of a parallelogram formed from z1
and z2.
Exercise:

   Problem:

   Let z1 = r1ej1 and z2 = . r2ej2 Find a polar formula z3 =r3ej3 for
   z3 = z1 + z2 that involves only the variables r1, r2, 1, and 2. The
   formula for r3 is the "law of cosines."
The product of z1 and z2 is
Equation:

z1z2 =                       (x1 + jy1 )(x2 + jy2 )

= (x1 x2 - y1 y2 ) + j(y1 x2 + x1 y2 ).

                     Adding Complex Numbers

If the polar representations for z1 and z2 are used, then the product may be
written as [footnote]
We have used the trigonometric identities cos (1 + 2) =cos 1 cos 2-
sin 1 sin 2 and sin (1 + 2) =sin 1 cos 2+ cos 1 sin 2 to derive this
result.
Equation:
z1z2 =  r1 ej1 r2 ej2

= (r1 cos 1 + jr1 sin 1 )(r2 cos 2 + jr2 sin 2 )

=       ( r1 cos 1 r2 cos 2 - r1 sin 1 r2 sin 2 )

+ j( r1 sin 1 r2 cos 2 + r1 cos 1 r2 sin 2 )

=       r1 r2 cos (1 + 2 ) + jr1 r2 sin (1 + 2 )

=       r1r2e  j(1 +2 )  .

We say that the magnitudes multiply and the angles add. As illustrated in
[link], the product z1z2 lies at the angle (1 + 2).

                  Multiplying Complex Numbers

Rotation. There is a special case of complex multiplication that will become
very important in our study of phasors in the chapter on Phasors. When z1
is the complex number z1 = r1ej1 and z2 is the complex number
z2 = ej2 , then the product of z1 and z2 is
Equation:

                       z1z2 = z1e         j 2       = r1e  j(1 +2 )  .

As illustrated in [link], z1z2 is just a rotation of z1 through the angle 2.

             Rotation of Complex Numbers

Exercise:
   Problem:

Begin with the complex number z1 = x + jy = rej. Compute the

complex number z2 = jz1 in its Cartesian and polar forms. The

complex number z2 is sometimes called perp(z1). Explain why by

writing  perp(z1)  as             j 2  .  What  is  2?  Repeat  this    problem  for

                       z1e

z3 = -jz1.
Powers. If the complex number z1 multiplies itself N times, then the result
is
Equation:

                                                       N         N jN 1

                                                   (z1 ) = r1 e              .

This result may be proved with a simple induction argument. Assume

    k  =      . rk ejk1  (The      assumption          is  true  for  k   =  1.)   Then  use  the  recursion
                  1
z

    1

z1 = z1z1 = r1 e k+1 k k+1 j(k+1)1 . Iterate this recursion (or induction) until

k + 1 = N . Can you see that, as n ranges from n = 1, ..., N , the angle of

z§ranges         from           1  to  21 ,  ...,  to  N 1   and  the     radius   ranges  from    r 1  to  r2,    ...,

                                                                                                                1

to         N  ?  This  result      is   explored       more  fully    in  Problem  1.19.

       r

           1

Complex Conjugate. Corresponding to every complex number z =

x   +  jy        =          j  is  the  complex       conjugate

                    re

Equation:

                                                   *                      -j
                                             z = x - jy = re                    .

The complex number z and its complex conjugate are illustrated in [link].
The recipe for finding complex conjugates is to "change jto - j. This
changes the sign of the imaginary part of the complex number.
A Complex Variable and Its Complex Conjugate

Magnitude Squared. The product of z and its complex conjugate is called
the magnitude squared of z and is denoted by |z|2 :
Equation:

       2          *                                2                                                                 2  -j     j       2

|z| = z z = (x - jy) (x + jy) = x + y = re                                                                                     re = r .

Note that |z| = r is the radius, or magnitude, that we defined in "Geometry
of Complex Numbers".
Exercise:

   Problem:

Write      *  as      *  =  zw.  Find  w  in  its  Cartesian  and                                                       polar  forms.

       z          z

Exercise:

                                                                                                                  *

   Problem: Prove that angle (z2z1) = 2 - 1.
Exercise:
Problem:

Show that the real and imaginary parts of z = x + jy may be written
as
Equation:

                                  1                    *
           Re [z] =
                                     z+z
                                  2

Equation:

                                                                           *

           Im [z] = 2j z - z .

Commutativity, Associativity, and Distributivity. The complex numbers
commute, associate, and distribute under addition and multiplication as
follows:
Equation:

           z1 + z2 = z2 + z1

           z1z2           =          z2z1

Equation:

           (z1 + z2 ) + z3 = z1 + (z2 + z3 )

           z1 (z2 z3 )    =          (z1 z2 )z3

           z1 (z2 + z3 )  =          z1z2 + z1z3.

Identities and Inverses. In the field of complex numbers, the complex
number 0 + j0 (denoted by 0) plays the role of an additive identity, and the
complex number 1 + j0 (denoted by 1) plays the role of a multiplicative
identity:
Equation:
                               z+0 = z = 0+z

                                  z1     =z=                    1z.

In this field, the complex number -z = -x + j(-y) is the additive inverse

of z, and the complex number z = + j -1 x                                                              -y      is the
                                                                                                  x2 + y2
                                                                                         x2 + y2

multiplicative inverse:
Equation:

                                  z + (-z) = 0

                                                 -1  = 1.

                                         zz

Exercise:
   Problem:

   Show that the additive inverse of z = rej may be written as rej(+).
Exercise:

Problem: Show that the multiplicative inverse of z may be written as
Equation:

                           -1       1*                       1
                                           z=        x2 + y2
                        z      =                                (x - jy).
                                  z*z

Show  that       *  is  real.  Show   that       -1  may  also  be                                written  as

             zz                              z

Equation:

                                         -1          -1 -j

                                      z      =r e           .

   Plot z and z-1 for a representative z.
Exercise:
   Problem: Prove (j) = -j -1 .
Exercise:

   Problem: Find z-1 when z = 1 + j1.
Exercise:

   Problem:

   Prove (z ) -1 = *      *  -1                           z 1 . Plot z and (z-1)* for a
   representative z.                                -1 j
Exercise:             z
   Problem:                         =r e =

                                                          z*z

Find all of the complex numbers z with the property that jz = -z*.
Illustrate these complex numbers on the complex plane.

Demo 1.2 (MATLAB). Create and run the following script file (name it
Complex Numbers)[footnote]
If you are using PC-MATLAB, you will need to name your file cmplxnos.m.

clear, clg
j=sqrt(-1)
z1=1+j*.5,z2=2+j*1.5
z3=z1+z2,z4=z1*z2
z5=conj(z1),z6=j*z2
avis([-4 4 -4 4]),axis('square'),plot(z1,'0')
hold on
plot(z2,'0'),plot(z3,'+'),plot(z4,'*'),
plot(z2,'0'),plot(z3,'+'),plot(z4,'*'),
plot(z5,'x'),plot(z6,'x')
           Complex Numbers (Demo 1.2)

With the help of Appendix 1, you should be able to annotate each line of
this program. View your graphics display to verify the rules for add,
multiply, conjugate, and perp. See [link].
Exercise:

Problem:   Prove  that      0  =  1.

                        z

Exercise:
Problem:

(MATLAB) Choose z1 = 1.05ej2/16 and z2 = 0.95ej2/16. Write a

MATLAB    program  to  compute  and  plot      n  and      n  for  n  =  1,  2,  ...,  32.

                                           z           z

                                               1           2

You should observe a figure like [link].

                       Powers of z
Complex Numbers: Roots of Quadratic Equations

You probably first encountered complex numbers when you studied values
of z (called roots or zeros) for which the following equation is satisfied:
Equation:

                                                                                                       2

                                                                  az + bz + c = 0.

For a  0 (as we will assume), this equation may be written as
Equation:

                  2b c

                  z + z+                                = 0.

                     a                               a

Let's denote the second-degree polynomial on the left-hand side of this
equation by p(z):
Equation:

                                                  2  b       c
                                                         z+      .
                  p (z) = z +
                                                     a       a

This is called a monic polynomial because the coefficient of the highest-
power term (z2) is 1. When looking for solutions to the quadratic equation

z + z+ = 0 2 b c , we are really looking for roots (or zeros) of the

a          a

polynomial p(z). The fundamental theorem of algebra says that there are

two such roots. When we have found them, we may factor the polynomial

p(z) as follows:

Equation:

                  2b c

              p (z) = z + z +                        = (z - z1 ) (z - z2 ).

                  a            a

In this equation, z1 and z2 are the roots we seek. The factored form p(z) =
(z - z1) (z - z2) shows clearly that p (z1) = p (z2) = 0, meaning that the
quadratic equation p(z) = 0 is solved for z = z1 and z = z2. In the process
of factoring the polynomial p(z), we solve the quadratic equation and vice
versa.

By  equating  the  coefficients  of      2  z1,  and  z 0  on                              the  left-and  right-hand

                                     z,

sides of [link], we find that the sum and the product of the roots z1 and z2

obey the equations

Equation:

                                                                                        b

                                 z1 + z2 = - a
                                                                           .

                                                                                     c

                                    z1z2 = a

You should always check your solutions with these equations.

Completing the Square. In order to solve the quadratic equation

z2 + z + = 0 b c (or, equivalently, to find the roots of the polynomial

    a         a

z2+ z + ) b c , we "complete the square" on the left-hand side of [link]:

    a      a

Equation:

                                        2             2

                          b                      b                                         c

                    (z +         ) -(                 )+                                        = 0.

                          2a                     2a                                        a

This equation may be rewritten as
Equation:

                                     2                2

                          b                      1         2
                               )
                    (z +                =(           ) (b - 4ac).

                          2a                     2a

We may take the square root of each side to find the solutions
Equation:

                                        b
                                          b        1

                              z1,2 = - ± b2 - 4ac.

                                          2a       2a

Exercise:
   Problem:

     With the roots z1 and z2 defined in Equation 1.29, prove that

     (z - z1) (z - z2) is, indeed, equal to the polynomial z + z + 2 b c .

                                                                                       a          a

                                     b                   c
     Check that z1 + z2 = - and z1z2 =

                                     a                   a

In   the  equation  that  defines    the  roots  z1  and  z2,   the  term        2  -  4ac    is  critical

                                                                              b

because it determines the nature of the solutions for z1 and z2. In fact, we

may  define  three  classes      of  solutions     depending    on      2  -  4ac.

                                                                     b

(i)  Overdamped            2  -  4ac  >   0).  In  this  case,  the  roots    z1    and   z2  are

                    (b

Equation:

                                          b        1

                              z1,2 = - ± b2 - 4ac.

                                          2a       2a

These two roots are real, and they are located symmetrically about the point

       b

- . When b = 0, they are located symmetrically about 0 at the points

      2a

       1

± -4ac. (In this case, -4ac > 0.) Typical solutions are illustrated in

      2a

[link].

          Typical Roots in the Overdamped Case; (a)
b/2a > 0,         4ac > 0, (b) b/2a > 0, 4ac < 0, and
                   (c) b/2a = 0, 4ac < 0

Exercise:
   Problem:

Compute and plot the roots of the following quadratic equations:

      a. z2 + 2z + = 0 1 ;

                                       2

      b. z + 2a - = 0 2 1 ;

                                       2

      c. z - = 0 2 1 .

                          2

                                                                 b              c
For each equation, check that z1 + z2 = - and z1z2 =

                                                                 a              a

(ii)  Critically  Damped         2        -  4ac  =  0).  In  this  case,  the  roots  z1  and  z2

                          (b

are equal (we say they are repeated):

Equation:

                                                              b

                                          z1 = z2 = -            .

                                                          2a

These solutions are illustrated in [link].
       Roots in the Critically Damped Case; (a)
              b/2a > 0, and (b) b/2a < 0

Exercise:
   Problem:
   Compute and plot the roots of the following quadratic equations:

       a. z2 + 2z + 1 = 0;
       b. z2 - 2z + 1 = 0;
       c. z2 = 0.

                                                   b                  c
For each equation, check that z1 + z2 = - and z1z2 =

                                                   a                  a

(iii)  Underdamped         2  -  4ac  <  0).  The  underdamped  case  is,  by                           far,  the

                    (b

most fascinating case. When b2 - 4ac < 0, then the square root in the

solutions for z1 and z2 ([link]) produces an imaginary number. We may

write b2 - 4ac as -(4ac - b2) and write z1,2 as

Equation:

           z1,2 = - ± b 1 -(4ac - b2 )
                                  2a          2a

                                      b       1 j 4ac - b2 .

                              =-  2a     ±         2a

These complex roots are illustrated in [link]. Note that the roots are

purely imaginary when b = 0, producing the result
Equation:

                                                                                                     c
                                                                      z1,2 = ±j .

                                                                                                     a
Figure 1.12: Typical Roots in the Underdamped Case; (a)
        b/2a > 0, (b)b/2a < 0, and (c) b/2a = 0

In this underdamped case, the roots z1 and z2 are complex conjugates:
Equation:

                                                                                                                                      *

                                                                              z2 = z1.

Thus the polynomial p (z) = z + z + = (z - z1) (z - z2) 2 b c also

                           a  a

takes the form

Equation:

                p(z) =                                                         *

                           (z - z1 )(z - z1 )

                        2                                                         2

                = z - 2 Re [z1 ]z + |z1 | .

Re[z1] and |z1|2 are related to the original coefficients of the polynomial as
follows:
Equation:

                                                                                                        b
                                                                     2 Re [z1 ] = -

                                                                                                        a
Equation:                             2c

                               z1 =
                                                  a

Always check these equations.

Let's explore these connections further by using the polar representations
for z1 and z2 :
Equation:

                                          ±j

                               z1,2 = re             .

Then [link] for the polynomial p(z) may be written in the "standard form"
Equation:

               p(z) = (z - rej )(z - re-j )

                               2                                              2
               = z - 2r cos z + r .

[link] is now
Equation:

                                                                       b

               2r cos  = -

                                                                      a

                                   2                     c

                               r      =

                                                        a

These equations may be used to locate z1,2 = re±j
Equation:

               r=                               c

                                      

                                                a

                = ± cos               -1                -b                ).

                                          (

                                                     4ac

Exercise:
Problem:

   Prove that p(z) may be written as p (z) = z2 - 2r cos z + r2 in the
   underdamped case.
Exercise:
   Problem:

Prove the relations in [link]. Outline a graphical procedure for locating

z1 = rej and z2 = re-j from the polynomial z2+ z + b c .

                        a  a

Exercise:

Problem:

Compute and plot the roots of the following quadratic equations:

a. z2 + 2z + 2 = 0;
b. z2 - 2z + 2 = 0;
c. z2 + 2 = 0.

                                                                                                            b 2c

For each equation, check that 2 Re [z1,2] = - and z1,2 = .

                     a                                    a
Complex Numbers: Representing Complex Numbers in a Vector Space

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

So far we have coded the complex number z = x + jy with the Cartesian
pair (x, y) and with the polar pair (r). We now show how the complex
number z may be coded with a two-dimensional vector z and show how this
new code may be used to gain insight about complex numbers.

Coding a Complex Number as a Vector. We code the complex number

                                                                                                                        x

z = x + jy with the two-dimensional vector z = [ ]:

                                                                                                                        y

Equation:

                                                                                                              x
                                                           x + jy = z  z = [ ].

                                                                                                              y

We plot this vector as in [link]. We say that the vector z belongs to a
"vector space." This means that vectors may be added and scaled according
to the rules
Equation:

           x1 + x2

           z1 + z2 = [  ]

           y1 + y2

Equation:
                                                                       ax
                                                      az = [ ].

                                                                       ay

The Vector z Coding the Complex Number z

Furthermore, it means that an additive inverse -z, an additive identity 0,
and a multiplicative identity 1 all exist:
Equation:

                                                                        z + (-z) = 0

Equation:

                                                                               lz = z.

                                                   0

The vector 0 is 0 = [ ].

                                                   0

Prove that vector addition and scalar multiplication satisfy these properties
of commutation, association, and distribution:
Equation:

                                                      z1 + z2 = z2 + z1

Equation:
Equation:  (z1 + z2 ) + z3 = z1 + (z2 + z3 )
Equation:                         a(bz) = (ab)z

                   a (z1 + z2 ) = az1 + az2 .

Inner Product and Norm. The inner product between two vectors z1 and
z2 is defined to be the real number
Equation:

                                                           (z1 , z2 ) = x1 x2 + y1 y2 .

We sometimes write this inner product as the vector product (more on this
in Linear Algebra)
Equation:

           (z1 , z2 ) =                  T

                                     z1 z2

                                            x2
           = [x1 y1 ][ ] = (x1 x2 + y1 y2 ).

                                            y2

Exercise:

Problem: Prove (z1, z2) = (z2, z1).

When z1 = z2 = z, then the inner product between z and itself is the norm
squared of z:
Equation:

                         2           2      2

           ||z|| = (z, z) = x + y .
These properties of vectors seem abstract. However, as we now show, they
may be used to develop a vector calculus for doing complex arithmetic.

A Vector Calculus for Complex Arithmetic. The addition of two complex
numbers z1 and z2 corresponds to the addition of the vectors z1 and z2 :
Equation:

                 x1 + x2

z1 + z2  z1 + z2 = [                                     ]

                 y1 + y2

The scalar multiplication of the complex number z2 by the real number x1
corresponds to scalar multiplication of the vector z2 by x1 :
Equation:

           x2    x1x2

x1z2  x1[ ] = [        ].

           y2    x1y2

Similarly, the multiplication of the complex number z2 by the real number
y1 is
Equation:

           x2  y1x2

y1z2  y1[ ] = [        ].

           y2  y1y2

The complex product z1z2 = (x1 + jy1)z2 is therefore represented as
Equation:

        x1x2 - y1y2

z1z2    [             ].

        x1y2 + y1x2

This representation may be written as the inner product
Equation:
                                                                     (v, z1 )

              z1z2 = z2z1  [                                                   ]

                                                                     (w, z1 )

                                                               x2                          y2
where v and w are the vectors v = [ ] and w = [ ]. By defining the

                                                               -y 2                        x2

matrix

Equation:

                                                           x2  -y 2
                                                        [                ],

                                                           y2  x2

we can represent the complex product z1z2 as a matrix-vector multiply
(more on this in Linear Algebra):
Equation:

                                                     x2              -y 2      x1
           z1z2 = z2z1  [
                                                                             ][ ].
                                                     y2
                                                                     x2        y1

With this representation, we can represent rotation as
Equation:

           j                                         j  cos          - sin  x1
                                                                                       ][ ].
           ze = e z  [

                                                        sin          cos                   x2

                                               cos   - sin 

We call the matrix [                                          ] a "rotation matrix."

                                               sin   cos 

Exercise:

Problem: Call R() the rotation matrix:
Equation:

                                       cos                           - sin 
              R () = [                                                                 ].

                                       sin                           cos 
   Show that R(-) rotates by (-). What can you say about R(-)w
   when w = R()z?

Exercise:

   Problem: Represent the complex conjugate of z as
   Equation:

                                                    a   b        x

                                  *                         ][ ]

                              z [                       d        y

                                                    c

   and find the elements a, b, c, and d of the matrix.

Inner Product and Polar Representation. From the norm of a vector, we

derive  a  formula  for  the  magnitude  of          z  in  the  polar  representation  z  =          j

                                                                                              re

:

Equation:

                              2 2 1/2                                   1/2

                    r=        x +y       = ||z|| = (z, z) .

                                                            1                 0
If we define the coordinate vectors e1 = [ ] and e2 = [ ], then we can

                                                            0                 1

represent the vector z as
Equation:

                              z = (z, e1 )e1 + (z, e2 )e2 .

See [link]. From the figure it is clear that the cosine and sine of the angle 
are
Equation:

                         cos  =  (z, e1 )              sin  =       (z, e2 )
                                                  ;                    ||z||

                                    ||z||
Representation of z in its Natural Basis

This gives us another representation for any vector z:
Equation:

                                                 z = ||z|| cos e1 + ||z|| sin e2 .

The inner product between two vectors z1 and z2 is now
Equation:

              T  T                        (z2 , e1 )e1

(z1 , z2 ) =  (z1 , e1 )e1 (z1 , e2 )e2   [                                         ]

                                          (z2 , e2 )e2

=             (z1 , e1 ) (z2 , e1 ) + (z1 , e2 ) (z2 , e2 )

= ||z1 || cos 1 ||z2 || cos 2 + ||z1 || sin 1 ||z2 || sin 2 .

It follows that cos (2 - 1) =cos 2 cos 1+ sin 1 sin 2 may be
written as
Equation:
           cos (2 - 1 ) =          (z1 , z2 )
                              ||z1 || ||z2 ||

This formula shows that the cosine of the angle between two vectors z1 and

                                                                                                                                                                                *

z2, which is, of course, the cosine of the angle of z2z1, is the ratio of the
inner product to the norms.
Exercise:

   Problem:

Prove the Schwarz and triangle inequalities and interpret them:
Equation:

                           2  2                   2

           (Schwarz) (z1 , z2 )  ||z1 || ||z2 ||

Equation:

(triangle) I z1 - z2 ||  ||z1 - z3 || + ||z2 - z3 ||.
Complex Numbers: An Electric Field Computation

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

We have established that vectors may be used to code complex numbers.
Conversely, complex numbers may be used to code or represent the
orthogonal components of any two-dimensional vector. This makes them
invaluable in electromagnetic field theory, where they are used to represent
the components of electric and magnetic fields.

The basic problem in electromagnetic field theory is to determine the
electric or magnetic field that is generated by a static or dynamic
distribution of charge. The key idea is to isolate an infinitesimal charge,
determine the field set up by this charge, and then to sum the fields
contributed by all such infinitesimal charges. This idea is illustrated in
[link], where the charge , uniformly distributed over a line segment of
length dx at point -x, produces a field dE(x) at the test point (0, h). The
field dE(x) is a "vector" field (as opposed to a "scalar" field), with
components E1 (x) and E2 (x). The intensity or field strength of the field
dE(x) is
Equation:

            dx

|dE (x)| =

            2   2
            40 (h + x )
Infinitesimal Charge dx Producing Field dE(x)

But the field strength is directed at angle (x), as illustrated in [link]. The
field dE(x) is real with components dE1 (x) and dE2 (x), but we code it
as a complex field. We say that the "complex" field at test point (0, h) is
Equation:

          dx              j(x)

dE (x) =               e

          2   2
          40 (h + x )

with components dE1 (x) and dE2 (x). That is,
Equation:

                                                    dE (x) = dE1 (x) + jdE2 (x)
Equation:                       dx
Equation:
           dE1 (x) =                                                          cos  (x)

                                                                     2     2
                      40 (h + x )

                               dx

           dE2 (x) =                                                          sin  (x).

                                                                     2     2
                      40 (h + x )

For charge uniformally distributed with density  along the x-axis, the total
field at the test point (0, h) is obtained by integrating dE:
Equation:

                

                             

     dE (x) =                                                              [cos  (x) + jsin (x)]dx.

                             2                                          2
                   40 (h + x )
  -             -

The functions cos (x) and sin (x) are
Equation:

  cos  (x) =                 x                                          sin  (x) =               h
                                                ;                                   (x2 + h2 1/2 )

                (x2 + h2 1/2 )

We leave it as a problem to show that the real component E1 of the field is
zero. The imaginary component E2 is
Equation:

                                                                       h               dx
                                                                     40    (x2 + h2 3/2 )
           E = jE2 = j 

                                                                -

Equation:

                          h                  x                                
              =j             h2 (x2 + h2 1/2 )                                -

                        40
Equation:              h                                                       1      1                             
Equation:  =j                                                                                       =j
                                                                                   +
                     40                                                                                       20 h
                                                                               h2     h2

                          E2 =                                                          
                                                                                                   .

                                                                                   20 h

We emphasize that the field at (0, h) is a real field. Our imaginary answer
simply says that the real field is oriented in the vertical direction because
we have used the imaginary part of the complex field to code the vertical
component of the real field.
Exercise:

   Problem:

   Show that the horizontal component of the field E is zero. Interpret
   this finding physically.

From the symmetry of this problem, we conclude that the field around the
infinitely long wire of [link] is radially symmetric. So, in polar coordinates,
we could say
Equation:

           E (r, ) =                                                                       
                                                                                      20 r

which is independent of . If we integrated the field along a radial line
perpendicular to the wire, we would measure the voltage difference
Equation:

                                                                           r1                             log r1 - log r0 .
                                                                                              dr =  20
V (r1 ) - V (r0 ) = 
                                                                               20 r
                                                                       r0
An electric field has units of volts/meter, a charge density  has units of
coulombs/meter, and 0 has units of coulombs/volt-meter; voltage has units
of volts (of course).
Complex Numbers: Numerical Experiment (Quadratic Roots)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

There is a version of the quadratic equation that will arise over and over
again in your study of electrical and mechanical systems:
Equation:

2       2
s + 20 s + 0 = 0.

For reasons that can only become clear as you continue your study of
engineering, the parameter 0 is called a resonant frequency, and the
parameter   0 is called a damping factor. In this experiment, you will
begin by

   1. finding the "underdamped" range of values   0 for which the roots
      s1 and s2 are complex;

   2. finding the "critically damped" value of   0 that makes the roots s1
      and s2 equal; and

   3. finding the "overdamped" range of values   0 for which s1 and s2
      are real.

   4. For each of these ranges, find the analytical solution for s1,2 as a
      function of 0 and ; write your solutions in Cartesian and polar forms
      and present your results as
      Equation:

s1,2 =  , 0    c
        ,  = c
        ,   c
       where c is the critically damped value of . Write a MATLAB
       program that computes and plots s1,2 for 0 fixed at 0 = 1 and 
       variable between 0.0 and 2.0 in steps of 0.1. Interpret all of your

       findings.

Now organize the coefficients of the polynomial s2 + 2s + 1 into the
array [121]. Imbed the MATLAB instructions

r=roots([1 2*e 1]);
plot(real(r(1)),imag(r(1)),'o')
plot(real(r(2)),imag(r(2)),'o')

in  a  for  loop  to  compute  and  plot  the  roots  of      2  +  2s  +  1  as    ranges

                                                          s

from 0.0 to 2.0. Note that r is a 1 × 2 array of complex numbers. You

should observe [link]. We call this "half circle and line" the locus of roots

for the quadratic equation or the "root locus" in shorthand.
Roots of Quadratic Equation
The Functions e^x and e^j: Introduction

Note: This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Notes to Teachers and Students

It is essential to write out, term-by-term, every sequence and sum in this

chapter. This demystifies the seemingly mysterious notation. The example

on compound interest shows the value of limiting arguments in everyday

life  and  gives     x  some  real  meaning.  The  function  ej,  covered  in  the

                  e

section "The Function of ej and the Unit Circle and "Numerical

Experiment (Approximating ej, must be understood by all students before

proceeding to "Phasors" . The Euler and De Moivre identities provide every

tool that students need to derive trigonometric formulas. The properties of

roots of unity are invaluable for the study of phasors in "Phasors" .

The MATLAB programs in this chapter are used to illustrate sequences and

series and to explore approximations to sin  and cos . The numerical
experiment in "Numerical Experiment (Approximating ej illustrates,

geometrically     and   algebraically,  how   approximations  to     j  converge.

                                                                  e

"Second-Order Differential and Difference Equations" is a little demanding

for freshmen, but we give it a once-over-lightly to illustrate the power of
quadratic equations and the functions ex and ej. This section also gives a

sneak preview of more advanced courses in circuits and systems.

Introduction
It  is  probably  not  too  strong  a  statement       to  say  that  the  function     x  is  the

                                                                                     e

most important function in engineering and applied science. In this chapter

we  study  the  function       x  and  extend    its  definition  to  the  function  ej.       This

                            e

study   clarifies  our  definition     of     j  from  "Complex       Numbers"  and        leads    us

                                           e

to  an  investigation   of  sequences      and   series.   We   use   the  function     j  to

                                                                                     e

derive the Euler and De Moivre identities and to produce a number of

important trigonometric identities. We define the complex roots of unity

and study their partial sums. The results of this chapter will be used in

"Phasors" when we study the phasor representation of sinusoidal signals.
The Functions e^x and e^j: The Function e^x

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Many of you know the number e as the base of the natural logarithm, which
has the value 2.718281828459045. . . . What you may not know is that this
number is actually defined as the limit of a sequence of approximating
numbers. That is,
Equation:

                    e = lim fn

                                 n

Equation:

                                      n

                         1

              fn = (1 +     ) , n = 1, 2, ...

                         n

This means, simply, that the sequence of numbers

              2          3

(1 + 1) , (1 + ) , (1 + ) 1 1 1 , . . . , gets arbitrarily close to

           2     3

2.718281828459045. . . . But why should such a sequence of numbers be so

important? In the next several paragraphs we answer this question.

Exercise:
   Problem:

   (MATLAB) Write a MATLAB program to evaluate the expression

                                                                n

                                    1

   fn = (1 + ) for n = 1, 2, 4, 8, 16, 32, 64 to show that fn  e

                                    n

   for large n.

                                                                                                                                                                                                                n

                                                                                                                                          1

Derivatives and the Number e. The number fn = (1 + ) arises in

                                                                                                                                         n

the study of derivatives in the following way. Consider the function
Equation:

                                                                                                                               x

                                                                 f (x) = a , a > 1

and ask yourself when the derivative of f(x) equals f(x). The function
f(x) is plotted in [link] for a > 1. The slope of the function at point x is
Equation:

df (x)  =    lim  ax+x -ax
   dx   =                 x
           x0

                x          x -1

            lim                          .

                       x0      x
           The  Function  f  (x)   =             x

                                             a

If there is a special value for a such that
Equation:

                             a  x  -1

                     lim                            = 1,

                   x0           x

              d

then f (x) would equal f(x). We call this value of a the special (or

            dx

exceptional) number e and write

Equation:

                          f (x) = ex

                      d                             x
                          f (x) = e .

                      dx

The number e would then be e = f(1). Let's write our condition that

 ax - 1

            converges to 1 as

       x

Equation:

                   x

                e     - 1  x, xsmall

or as
Equation:

                                             1/x

                   e  (1 + x)                          .

                                   1/n

                             1                                       1
Our definition of e = lim (1 + ) amounts to defining x =

           n                 n                                       n

and allowing n   in order to make x  0. With this definition for e,
it  is  clear  that  the  function              x  is  defined    to    be                x  :

                                            e                                   (e)

Equation:

                                            x                                   x/x

                                           e = lim (1 + x)                                   .

                                                   x0

                                          x

By letting x = we can write this definition in the more familiar form

                                          n

Equation:

                                                x                            xn
                                                                                  )
                                            e = lim (1 +
                                                                             n
                                                             n

This is our fundamental definition for the function ex. When evaluated at
x = 1, it produces the definition of e given in [link].

The     derivative   of       x  is,    of  course,

                          e

Equation:

                            dx                                       x n-1 1                                 x
                                  e = lim n(1 +
                                                                        )                       =e .

                          dx                   n                     n                  n

This means that Taylor's theorem[footnote] may be used to find another

characterization       for           x  :

                                 e

Taylor's theorem says that a function may be completely characterized by

all of its derivatives (provided they all exist).

Equation:

                                                               d  n                          1

                                 ex                                          x                  n
                                            =      n=0 [ dxn x=0 e ] n! x
                                            =
                                                                                     n

                                                                                x

                                                                        n=0          .

                                                                                n!

When    this   series  expansion               for      x  is  evaluated        at      x       =  1,  it       produces  the

                                                    e

following series for e:

Equation:
                     1
                          .
e=
                    n!
               n=0

In this formula, n! is the product n(n - 1)(n - 2)  (2)1. Read n! as "n
factorial."
Exercise:

Problem: (MATLAB) Write a MATLAB program to evaluate the sum
Equation:

SN              N    1
                    n!
    =

             n=0

   for N = 1, 2, 4, 8, 16, 32, 64 to show that SN e for large N .
   Compare S64 with f64 from [link]. Which approximation do you
   prefer?

Compound Interest and the Function . There is an example from your
everyday life that shows even more dramatically how the function ex arises.
Suppose you invest V0 dollars in a savings account that offers 100x%
annual interest. (When x = 0. 01, this is 1%; when x = 0. 10, this is 10%
interest.) If interest is compounded only once per year, you have the simple
interest formula for V1, the value of your savings account after 1 compound
(in this case, 1 year):

V1 = (1 + x)V0. This result is illustrated in the block diagram of Figure
2.2(a). In this diagram, your input fortune V0 is processed by the "interest
block" to produce your output fortune V1. If interest is compounded
monthly, then the annual interest is divided into 12 equal parts and applied
12 times. The compounding formula for V12, the value of your savings after
12 compounds (also 1 year) is
Equation:
            x   12

V12 = (1 +      ) V0.

            12

This result is illustrated in [link]. Can you read the block diagram? The
general formula for the value of an account that is compounded n times per
year is
Equation:

Vn = (1 +   xn

                 ) V0.
            n

Vn is the value of your account after n compounds in a year, when the
annual interest rate is 100x%.

   Block Diagram for Interest Computations; (a) Simple Annual Interest,
                           and (b) Monthly Compounding

Exercise:

   Problem:

   Verify in [link] that a recursion is at work that terminates at Vn. That

                                                                       x

   is, show that Vi+1 = (1 + )V1 for i = 0, 1, ..., n - 1 produces the

                                                                       n
                                                  xn

   result Vn = (1 + ) V0.

                                                  n
Bankers have discovered the (apparent) appeal of infinite, or continuous,
compounding:
Equation:

                           V = lim (1 +           xn

                                               n       ) V0.
                                                  n

We know that this is just
Equation:

                                                      x

                           V = e V0.

So, when deciding between 100x1 % interest compounded daily and
100x2% interest compounded continuously, we need only compare
Equation:

                           x1      365

(1 +                            )       versus               x2

                                                         e.

                           365

We suggest that daily compounding is about as good as continuous
compounding. What do you think? How about monthly compounding?
Exercise:

   Problem:

   (MATLAB) Write a MATLAB program to compute and plot simple
   interest, monthly interest, daily interest, and continuous interest versus
   interest rate 100x. Use the curves to develop a strategy for saving
   money.
The Functions e^x and e^j: The Function e^j and the Unit Circle

Note:This module is part of the collection, A First Course in Electrical and
Computer Engineering. The LaTeX source files for this collection were created
using an optical character recognition technology, and because of this process
there may be more errors than usual. Please contact us if you discover any
errors.

Let's  try    to  extend  our  definitions                   of  the  function             x                  to  the  argument  x  =  j.

                                                                                       e

Then ej is the function

Equation:

                                                      j  = lim                                             n

                                                  e            n                      
                                                                   (1 + j )

                                                                                     n

                                                                  

The complex number 1 + j is illustrated in [link]. The radius to the point

                                                                 n

                                                                                2 1/2

1 + j  is r = (1 + )  and the angle is  =tan-1  This means that

              n n2 n

                     of                     2 n/2
the       th  power                        has radius rn = (1 + 2 )                                               and angle
                         1  +  j
     n

                                           n n

n = n tan-1  (Recall our study of powers of z.) Therefore the complex

                                      n

                                                                   n

                                      

number (1 + j ) may be written as

                                      n

Equation:

                                        n      2        n/2  [cos  (n              -1   -1                                             
                                                                                            ) + j sin (n tan                                )].
                                                  )                    tan
(1 + j ) = (1 +                            n2                                          n                                               n

                  n
                        2 n/2
For n large, (1 + ) 2 1  , and n tan n =  -1   . Therefore
                   n2
                                                                    n         n

                                        n

                   

(1 + j ) is approximately

                  n

Equation:

                                                                n

                                           
                        (1 + j ) = 1(cos  + j sin ).

                                          n

                                        n

                   

(1 + j ) = 1( cos  + j sin ).

                  n

This  finding  is  consistent  with        our  previous      definition  of      j  !

                                                                              e

                   The  Complex      Number     1         +   j  
                                                                 n

The   series  expansion  for      j  is    obtained       by  evaluating  Taylor's      formula  at

                              e

x = j:

Equation:

                                         j                1         n

                                     e      =                 (j) .

                                                     n=0  n!

When this series expansion for ej is written out, we have the formula
Equation:
               j                   1                   2n                                           1     2n+1

           e      =                          (j)           +                                        (j)
                  =
                              n=0  (2n)!                                    n=0     (2n+1)!

                                      n                                                                  n

                                   (-1)                2n                            (-1) 2n+1 .
                                    (2n)!
                                            + j                                n=0  (2n+1)!

                              n=0

It is now clear that cos  and sin  have the series expansions
Equation:

                                                                                     n

                     cos  =                                         (-1)

                                                              n=0                               2n

                                                                                    

                                                                     (2n)!

Equation:

                                                                            n      2n+1

                                   =                       (-1)

                     sin                          n=0                                                  .

                                                       (2n + 1)!

When these infinite sums are truncated at N - 1, then we say that we have N-
term approximations for cos  and sin :
Equation:

                                                              N -1                   n

                     cos                                            (-1)

                                                              n=0                               2n

                                                                                    

                                                                     (2n)!

Equation:

                                                 N -1                       n      2n+1

                     sin                                   (-1)

                                                  n=0                                               .

                                                       (2n + 1)!

The ten-term approximations to cos  and sin  are plotted over exact
expressions for cos  and sin  in [link]. The approximations are very good
over one period (0    2), but they diverge outside this interval. For more
accurate approximations over a larger range of s, we would need to use more
terms. Or, better yet, we could use the fact that cos  and sin  are periodic in 
. Then we could subtract as many multiples of 2 as we needed from  to bring
the result into the range [0, 2] and use the ten-term approximations on this new
variable. The new variable is called -modulo 2.
          Ten-Term Approximations to cos  and sin 

Exercise:

   Problem:

   Write out the first several terms in the series expansions for cos  and
   sin .

Demo 2.1 (MATLAB). Create a MATLAB file containing the following demo
MATLAB program that computes and plots two cycles of cos  and sin 
versus . You should observe [link]. Note that two cycles take in 2(2) radians,
which is approximately 12 radians.

clg;
j = sqrt(-1);
theta = 0:2*pi/50:4*pi;
s = sin(theta);
c = cos(theta);
plot(theta,s);
elabel('theta in radians');
ylabel('sine and cosine');
hold on
plot(theta,c);
hold off
                The Functions cos  and sin 

Exercise:

   Problem:

   (MATLAB) Write a MATLAB program to compute and plot the ten-term
   approximations to cos  and sin  for  running from 0 to 2(2) in steps
   of 2/50. Compute and overplot exact expressions for cos  and sin .
   You should observe a result like [link].

The Unit Circle. The unit circle is defined to be the set of all complex numbers

z whose magnitudes are 1. This means that all the numbers on the unit circle

may be written as z = ej. We say that the unit circle consists of all numbers

generated   by  the  function  z  =      j  as    varies  from   0  to  2.  See  [link].

                                     e

A Fundamental Symmetry. Let's consider the two complex numbers z1 and

1                                           1
   , illustrated in [link]. We call the "reflection of z through the unit circle"

*                                           *

z1 z1

(and vice versa). Note that z1 = r1ej1 and = e 1 1 j1 . The complex

                                                      *          r1

                                                  z1

numbers z1 - ej and  1                j  are    illustrated  in  [link].  The  magnitude  squared

                               -  e

                     *

                     z

                         1

of each is

Equation:
Equation:                       2*
                             j                            j                               -j

       z1 - e                   = (z1 - e ) (z1 - e                                           )

                         2

1                                            1                                1    -e     -j     ).
                                =(
                      j                                          j

      -e                                             - e )(

    *                                             *                            z1

z1                                            z1

The ratio of these magnitudes squared is
Equation:

                                                     j *                       -j
                                (z1 - e ) (z1 - e
                                                                                   )

            2

       =

                                        1  - ej ) ( 1                          - e-j )

                                (*                                         z1

                                       z1

This ratio may be manipulated to show that it is independent of , meaning that

                                           1

the points z1 and maintain a constant relative distance from every point on

                                                                *

                                          z1

the unit circle:

Equation:

                                           j  -j             * j                   -j
                                e (e                 z1 -1)(z1 e -1)e
       2
                         =                           j *
                         =                 1                                   -j 1
                                           zi (1-e z1 )(1-z1 e                   )

                                                                                      z1

                                            2

                                |z1 | , independent of !

This result will be of paramount importance to you when you study digital
filtering, antenna design, and communication theory.
                       The Unit Circle

Exercise:

Problem:   Write  the  complex  number  z  -      j  as  re j .  What  are  r  and  ?

                                              e
The Functions e^x and e^j: The Euler and De Moivre Identities

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The Euler and De Moivre identities are the fundamental identities for

deriving  trigonometric   formulas.  From       the   identity      j  =cos    +  jsin    and

                                                                e

the  conjugate  identity  e -j  =          j *  =cos    -   jsin  ,    we  have  the  Euler

                                   (e )

identities for cos  and sin :
Equation:

                                cos  =          ej +e-j
                                sin  =                   2

                                                ej -e-j
                                                        2j

These identities are illustrated in [link].
                        Euler's Identities

The identity ej =cos  + j sin  also produces the De Moivre identity:
Equation:

                                             n              j n       jn

                   (cos  + j sin )              =           (e ) = e

                                                                              .

                                                = cos n + j sin n

When the left-hand side of this equation is expanded with the binomial
expansion, we obtain the identity
Equation:

               n                   n-k                   k

                        n  )            (j   sin  )         =cos  n + j  sin  n.

           ( )(cos

                        k

           k=0

Binomial Coefficients and Pascal's Triangle. The binomial coefficients

    n  in  [link]  are  shorthand  for  the  number

()

    k
Equation:

                      n                n!

                     ( )=                     k = 0, 1, ..., n.

                      k         (n - k)!k!

This number gives the coefficient of xn-kyk in the expansion of (x + y)n.

How  do    we  know  that  there  are      n  terms  of  the  form  xn-k yk ?  One  way  to

                                       ()

                                           k

answer this question is to use Pascal's triangle, illustrated in [link]. Each

node on Pascal's triangle shows the number of routes that terminate at that

node. This number is always the sum of the number of routes that terminate

at the nodes just above the node in question. If we think of a left-hand path

as an occurrence of an x and a right-hand path as an occurrence of a y, then

we see that Pascal's triangle keeps track of the number of occurrences of

xn-k yk .

     Pascal's Triangle and the Binomial Coefficients

Exercise:

Problem:       Prove      n  =      n  ).

                      ()        (
                      k           n-k

Exercise:
Problem:   Find  an  identity  for     n-1     +  (k ).
                                                      n-1
                                    (  k-1  )

Exercise:

   Problem: Find "half-angle" formulas for cos 2 and sin 2.
Exercise:

Problem: Show that

  A. cos 3 =cos2  - 3cos sin 2;
  B. sin 3 = 34 cos 2sin - sin3 .

Exercise:
   Problem:

   Use ej(1+2) = ej1 ej2 = (cos 1 + j sin 1 ) (cos 2 + j sin 2 ) to
   prove

      a. cos (1 + 2) =cos 1 cos 2 sin 1 sin 2 ;
      b. sin (1 + 2) =sin 1 cos 2+ sin 2 cos 1 .
The Functions e^x and e^j: Roots of Unity and Related Topics

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The  complex           number  z  =      j2/N  is  illustrated  in  [link].     It  lies  on  the  unit

                                     e

circle at angle  = 2/N. When this number is raised to the nth power, the

result   is      n  =   . j2n/N   This  number     is  also  illustrated        in  [link].  When    one

             z         e

of  the  complex       numbers        j2n/N    is  raised  to  the          th  power,  the  result  is

                                  e                                 N

Equation:

                                                   N

                                      j2n/N                j2n

                                  (e           )      =e        = 1.
         The Complex Numbers ej2/N and ej2n/N

We  say  that      j2n/N  is  one  of  the          th  roots  of  unity,  meaning  that      j2n/N

               e                            N                                             e

is one of the values of z for which

Equation:

                                            N

                                        z - 1 = 0.

There are N such roots, namely,
Equation:

                                 j2n/N

                              e         , n = 0, 1, ..., N - 1.
As  illustrated  in  [link],  the          th  roots  of  unity  are  uniformly  distributed

                                   12

around the unit circle at angles 2n/12. The sum of all of the N th roots of

unity is zero:

Equation:

                                               N -1

                                                      j2n/N

                              SN =  e                        = 0.

                                               n=0

This property, which is obvious from [link], is illustrated in [link], where

                                                                           k-1

the partial sums Sk =  ej2n/N are plotted for k = 1, 2, ..., N .

                                                                           n=0

                            Roots of Unity

These partial sums will become important to us in our study of phasors and
light diffraction in "Phasors" and in our discussion of filters in "Filtering".
Partial Sums of the Roots of Unity

Geometric Sum Formula. It is natural to ask whether there is an analytical
expression for the partial sums of roots of unity:
Equation:

k-1

Sk =  e  j2n/N  .

n=0

We can imbed this question in the more general question, is there an
analytical solution for the "geometric sum"
Equation:
                                   k-1
                                                    n

              Sk =  z ?

                                   n=0

The answer is yes, and here is how we find it. If z = 1, the answer is
Sk = k. If z  1, we can premultiply Sk by z and proceed as follows:
Equation:

              k-1 n+1                                                            k       m

           zSk = n=0 z                                                     =     m=1  z

                k-1                                                        m     k

           =    m=0                                                   z +z -1

           =                                                                  k
                Sk + z - 1.

From this formula we solve for the geometric sum:
Equation:

                                                                   k       z1
                                                                           z = 1.
                                        1-z
                                         1-z

           Sk = {
                              k,

This basic formula for the geometric sum Sk is used throughout
electromagnetic theory and system theory to solve problems in antenna
design and spectrum analysis. Never forget it.
Exercise:

                                                                      k-1                   k-1

Problem: Find formulas for Sk =  ejn and for Sk =  e . j2/Nn

                                                                      n=0                   n=0

Exercise:

                                                                N -1

   Problem: Prove  ej2n/N = 0.

                                                                 n=0

Exercise:
   Problem:

   Find formulas for the magnitude and phase of the partial sum

                             k-1

                 . j2n/N

     Sk =  e

                             n=0

Exercise:
   Problem:

   (MATLAB) Write a MATLAB program to compute and plot the partial

                                             k-1

   sum Sk =  ej2n/N for k = 1, 2, ..., N . You should observe [link].

                                             n=0

Exercise:

Problem:   Solve  the  equation  (z   +         3  =  z3.

                                         1)

Exercise:

Problem:   Find  all  roots  of  the  equation         3  +      2  +  3z  -  15  =  0.

                                                   z         z

Exercise:

Problem:

Find c so that (1 + j) is a root of the equation z17 + 2z15 - c = 0.
The Functions e^x and e^j: Second-Order Differential and Difference
Equations

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

With our understanding of the functions ex, ej, and the quadratic equation

z2 +  b      c  = 0, we can undertake a rudimentary study of differential
             a
         z+

      a

and difference equations.

Differential Equations. In your study of circuits and systems you will
encounter the homogeneous differential equation
Equation:

                    d2 d

                           x (t) + a1  x (t) + a2 = 0.

                    dt2 dt

Because the function est reproduces itself under differentiation, it is
plausible to assume that x (t) = est is a solution to the differential
equation. Let's try it:
Equation:

                d2 st d st st
                    2 (e ) + a1 (e ) + a2 (e ) = 0
                dt            dt

                           2           st
                           (s + a1 s + a2 )e = 0.

If this equation is to be satisfied for all t, then the polynomial in s must be
zero. Therefore we require
Equation:
                                        2

                                    s + a1s + a2 = 0.

As we know from our study of this quadratic equation, the solutions are
Equation:

                                           a1                 1
                                                         ± a2 - 4a2 .
                              s1,2 = -                                                            1

                                           2                  2

This means that our assumed solution works, provided s = s1 or s2. It is a
fundamental result from the theory of differential equations that the most
general solution for x(t) is a linear combination of these assumed solutions:
Equation:

                                                              s1t                                     s2t
                                    x (t) = A1 e                   + A2e .

If      2  -  4a 2  is  less  than  zero,  then          the  roots                               s1  and  s2  are  complex:

    a

        1

Equation:

                                                    a1        1                                        2
                              s1,2 = -
                                                         ±j        4a2 - a .
                                                      2                                                    1
                                                              2

Let's rewrite this solution as
Equation:

                                                                       s1,2 =  ± j

where  and  are the constants
Equation:

                                                                                              a1
                                                                            =-

                                                                                               2

Equation:
=  1
       4a2 - a2 .

                                             1

   2

With this notation, the solution for x(t) is
Equation:

   t jt                                       t -jtt

x (t) = A1 e e  + A2e e                               .

If this solution is to be real, then the two terms on the right-hand side must

                                                                                                                                                                  *

be complex conjugates. This means that A2 = A1 and the solution for x(t)
is
Equation:

   t jt                                       * t -J t
x (t) = A1 e e  +A e e

                               1

=                                             t jt
   2 Re{A1 e e }.

The constant A1 may be written as A1 = |A|ej. Then the solution for x(t)
is
Equation:

                                                                                                                         t

                                                    x (t) = 2|A|e cos (t + ).

This "damped cosinusoidal solution" is illustrated in [link].
The Solution to a Second-Order Differential Equation

Exercise:
   Problem:

Find the general solutions to the following differential equations:

a.  d2 d                x (t) + 2 = 0;

          X (t) + 2

    dt2 dt

    d  2             d

b.        x (t) + 2     x (t) - 2 = 0;

    dt2 dt

    d  2

c.  dt 2  x (t) + 2 = 0.

Difference Equations. In your study of digital filters you will encounter
homogeneous difference equations of the form
Equation:
                                                      xn + a1 xn-1 + a2 xn-2 = 0.

What this means is that the sequence{xn} obeys a homogeneous recursion:
Equation:

                                                        xn = -a1 xn-1 - a2 xn-2 .

A plausible guess at a solution is the geometric sequence xn = zn. With
this guess, the difference equation produces the result
Equation:

                            n      n-1          n-2    =0
                        z + a1z          + a2z

                        (1 + a1 z  -1    -2         n
                                       + a2 z )z = 0.

If this guess is to work, then the second-order polynomial on the left-hand
side must equal zero:

1 + a1z  -1  + a2z  -2  =0

Equation:

                            1 + a1z  -1  + a2z  -2  =0

                                   2

                               z + a1 z + a2 = 0.

The solutions are
Equation:

                                     a1  1                 2
                        z1,2 = - 2 ± j  2 4a2 - a1

                               = rej .

The general solution to the difference equation is a linear combination of
the assumed solutions:
Equation:

                                                                                                                                                              *
xn =                n *n

      A1 z1 + A2 (z1 )

                                   n * *n

= A1 z1 + A1 (z1 )

                                                               n

= 2 Re{A1 z1 }

                                 n

= 2|A|r cos (n + ).

This general solution is illustrated in [link].

     The Solution to a Second-Order Difference Equation

Exercise:
   Problem:
   Find the general solutions to the following difference equations:
      a. xn + 2xn-1 + 2 = 0;
      b. xn - 2xn-1 + 2 = 0;
      c. xn + 2xn-2 = 0.
The Functions e^x and e^j: Numerical Experiment (Approximating e^j)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

We  have  demonstrated    that  the           function      j  has  two  representations:

                                                        e

                                           n

1. e = lim (1 + ) j j ; and

          n               n

2. ej     = lim        n                k

                n         (j)

                   k=0           .

                             k!

In this experiment, you will write a MATLAB program to evaluate the two
functions fn and Sn for twenty values of n:

                                                                      n
                                                          j

   1. fn = (1 + ) , n = 1, 2, ..., 20; and
                                                          n
                                                                                                     k

   2. Sn = n , n = 1, 2, ..., 20k (j) .
                                              k=0 k!

Choose  = /4(= pi/4). Use an implicit for loop to draw and plot a
circle of radius 1. Then use an implicit for loop to compute and plot fn and
an explicit for loop to compute and plot Sn for n = 1, 2, ..., 100. You
should observe plots like those illustrated in [link]. Interpret them.
Plots for Convergence;(a) of fn, and (b) of Sn
Phasors: Introduction

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Notes to Teachers and Students:

Phasors! For those who understand them, they are of incomparable value
for the study of elementary and advanced topics. For those who
misunderstand them, they are a constant source of confusion and are of no
apparent use. So, let's understand them.

The  conceptual  leap  from  the  complex  number     j  to  the  phasor     j(t+)

                                                   e                      e

comes in "Phasor Representation of Signals". Take as long as necessary to

understand every geometrical and algebraic nuance. Write the MATLAB

program in "Exercise 6" to fix the key ideas once and for all. Then use

phasors to study beating between tones, multiphase power, and Lissajous

figures in "Beating between Tones" through "Lissajous Figures". We

usually conduct a classroom demonstration of beating between tones using

two phase-locked sources, an oscilloscope, and a speaker. We also

demonstrate Lissajous figures with this hardware.

"Sinusoidal Steady State and the Series RLC Circuit" and Light Scattering
by a Slit" on sinusoidal steady state and light scattering are too demanding
for freshmen but are right on target for sophomores. These sections may be
covered in a sophomore course (or a supplement to a sophomore course) or
skipped in a freshman course without consequence.

In the numerical experiment in "Numerical Experiment (Interference
Patterns)", students compute and plot interference patterns for two sinusoids
that are out of phase.
Introduction

In engineering and applied science, three test signals form the basis for our
study of electrical and mechanical systems. The impulse is an idealized
signal that models very short excitations (like current pulses, hammer
blows, pile drives, and light flashes). The step is an idealized signal that
models excitations that are switched on and stay on (like current in a relay
that closes or a transistor that switches). The sinusoid is an idealized signal
that models excitations that oscillate with a regular frequency (like AC
power, AM radio, pure musical tones, and harmonic vibrations). All three
signals are used in the laboratory to design and analyze electrical and
mechanical circuits, control systems, radio antennas, and the like. The
sinusoidal signal is particularly important because it may be used to
determine the frequency selectivity of a circuit (like a superheterodyne
radio receiver) to excitations of different frequencies. For this reason, every
manufacturer of electronics test equipment builds sinusoidal oscillators that
may be swept through many octaves of Orequency. (Hewlett-Packard was
started in 1940 with the famous HP audio oscillator.)

In this chapter we use what we have learned about complex numbers and

the  function     j  to  develop  a  phasor  calculus  for  representing  and  ma-

               e

nipulating sinusoids. This calculus operates very much like the calculus we
developed in "Complex Numbers" and "The Functions ex and ej" for

manipulating complex numbers. We ap- ply our calculus to the study of

beating phenomena, multiphase power, series RLC circuits, and light

scattering by a slit.
Phasors: Phasor Representation of Signals

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

There are two key ideas behind the phasor representation of a signal:

   i. a real, time-varying signal may be represented by a complex, time-
      varying signal; and

  ii. a complex, time-varying signal may be represented as the product of a
      complex number that is independent of time and a complex signal that
      is dependent on time.

Let's be concrete. The signal
Equation:

                                                           x(t) = A cos (t + ),

illustrated in [link], is a cosinusoidal signal with amplitude A, frequency ,

and phase . The amplitude A characterizes the peak-to-peak swing of 2A,

                                                                                                                                2

the angular frequency  characterizes the period T = between

                                                                                                                                 

negative- to-positive zero crossings (or positive peaks or negative peaks),

and the phase  characterizes the time  =   -  when the signal reaches its

                                           

first peak. With  so defined, the signal x(t) may also be written as

Equation:

           x(t) = A cos (t -  ).
A Cosinusoidal Signal

When  is positive, then  is a "time delay" that describes the time (greater
than zero) when the first peak is achieved. When  is negative, then  is a
"time advance" that describes the time (less than zero) when the last peak

                                                                                                 2

was achieved. With the substitution  = we obtain a third way of

                                                                                                  T

writing x(t):

Equation:

x(t) = A cos  2

                     (t -  ).

              T

In this form the signal is easy to plot. Simply draw a cosinusoidal wave
with amplitude A and period T; then strike the origin (t = 0) so that the
signal reaches its peak at . In summary, the parameters that determine a
cosinusoidal signal have the following units:

A, arbitrary (e.g., volts or meters/sec, depending upon the application)
, in radians/sec (rad/sec)

T, in seconds (sec)

, in radians (rad)

, in seconds (sec)
Exercise:

   Problem:

                                                                   2

   Show that x (t) = A cos (t - ) is "periodic with period T ,"

                                                                    T

   meaning that x(t + mT ) = x(t) for all integer m.

Exercise:

   Problem:

   The inverse of the period T is called the "temporal frequency" of the

                                                                                                                                                            1

   cosinusoidal signal and is given the symbol f; the units of f = are

                                                                                                                                                           T

   (seconds)-1 or hertz (Hz). Write x(t) in terms of f. How is f related
   to ? Explain why f gives the number of cycles of x(t) per second.

Exercise:

   Problem:

                                                                                                                      

Sketch the function x (t) = 110 cos [2 (60)t - ] versus t. Repeat

                                             8

for x (t) = 5 cos [2 (16 × 10 )t + ] 6  and

                                      4

                     2        10  -3

x (t) = 2 cos [         (t -          )]. For each function, determine

                     10-3 8

A, , T , f, , and . Label your sketches carefully.

The signal x(t) = A cos (t + ) can be represented as the real part of a
complex number:
Equation:
                               x (t) = Re [Ae                                                                                  j(t+)

                                                                                                                                      ]

                                                                              j jt

                                        = Re[Ae e ].

We  call            j jt  the  complex  representation                                                                         of  x(t)  and  write

          Ae e

Equation:

                                                                             j jt

                                     x (t)  Ae e ,

meaning that the signal x(t) may be reconstructed by taking the real part of
. Aejejt In this representation, we call Aej the phasor or complex
amplitude representation of x(t) and write
Equation:

                                                                                                                                             j

                                                                       x (t)  Ae ,

meaning   that  the  signal    x(t)  may  be  reconstructed                                                                           from            j  by

                                                                                                                                            Ae

multiplying with ejt and taking the real part. In communication theory, we

call Aej the baseband representation of the signal x(t).

Exercise:

Problem:

For each of the signals in Problem 3.3, give the corresponding phasor
representation Aej.

Geometric Interpretation. Let's call
Equation:

                                                                                                                         j jt

                                                                              Ae e

the complex representation of the real signal A cos (t + ). At t = 0, the
complex representation produces the phasor
Equation:
                                                                                                                              j

                                                                                  Ae .

                                                                                                                                                               -

This phasor is illustrated in [link]. In the figure,  is approximately If

                                                                                                                                                                10

we let t increase to time t1, then the complex representation produces the
phasor

                             Rotating Phasor

We know from our study of complex numbers that ejt1 just rotates the

phasor Aej through an angle of t1 ! See [link]. Therefore, as we run t
from 0, indefinitely, we rotate the phasor Aej indefinitely, turning out the

circular trajectory of [link]. When t = 2 then ejt = ej2 = 1.

                                                                                             

                                              2

Therefore, every ( ) seconds, the phasor revisits any given position on

                                               

the  circle  of  radius  A.  We  sometimes  call            j jt  a  rotating  phasor          whose

                                                  Ae e

rotation rate is the frequency :

Equation:

                                  d
                                                  d
                                                       t = .

                                                 dt

This rotation rate is also the frequency of the cosinusoidal signal
A cos (t + ).

In summary, Aejejt is the complex, or rotating phasor, representation of

the signal A cos (t + ). In this representation, ejt rotates the phasor

          j  through  angles  t  at  the         rate  .  The  real         part  of  the  complex

Ae

representation is the desired signal Acos (t + ). This real part is read off

the rotating phasor diagram as illustrated in [link]. In the figure, the angle 

                         2

is about - . As we become more facile with phasor representations, we

                         10

will  write  x  (t)   =  Re                  jt  and   call             jt  the  complex   representation

                              [Xe ]                          Xe

and X the phasor representation. The phasor X is, of course, just the phasor

Ae j .
Reading a Real Signal from a Complex,
              Rotating Phasor

Exercise:
   Problem:

Sketch     the  imaginary  part  of                  j jt  to  show  that  this  is

                                           Ae e

A sin (t + ). What do we mean when we say that the real and

imaginary       parts  of            j jt  are  "90  out       of  phase"?

                           Ae e

Exercise:
Problem:

(MATLAB) Modify Demo 2.1 in "The Function ex and ej" so that
 = t, with  an input frequency variable and t a time variable that

                                 2                 2                                2
ranges from -2( )to + 2( ) in steps of 0.02 ( ). In your

                                                                                    

modified program, compute and plot ejt, Re [ejt], and Im[ejt] for

-2 ( )  t < 2 ( ) 2 2 in steps of 0.02 ( ) 2 . Plot ejt in a

                                                                         

two-dimensional               plot   to   get  a  picture  like  [link]  and  plot                   jt  and

                                                                                    Re[e ]

                  jt  versus  t  to  get  signals  like  those   of  [link].  You   should

Im[e ]

observe something like [link] using the subplot features discussed in
An Introduction to MATLAB. (In the figure, w represents Greek .)

          The Functions ejt, Re[e ] jt , and Im[e ] jt

Positive and Negative Frequencies. There is an alternative phasor
representation for the signal x(t) = A cos (t + ). We obtain it by using
the Euler formula of "The Function ex sj", namely, cos  = (e + e ) 1 j -j

                                                                                                                                              2

. When this formula is applied to x(t), we obtain the result

Equation:

          x (t) =             A  [e          j(t+)  +e  -j(t+)
                          =
                              2                                 ]

                              A j jt                A -j -jt
                                 ee          +e         e       .
                              2                     2

In this formula, the term  A                 is a rotating phasor that begins at the

                                       j jt

                                ee

                           2

phasor value Aej (for t = 0) and rotates counterclockwise with frequency

. The term e e A -j -jt is a rotating phasor that begins at the (complex

                               2

conjugate) phasor value e A -j (for t = 0) and rotates clockwise with

                                                           2

(negative) ffequency . The physically meaningful frequency for a cosine

is , a positive number like 2(60) for 60 Hz power. There is no such thing

as a negative frequency. The so-called negative frequency of the term

e e A -j -jt just indicates that the direction of rotation for the rotating

  2

phasor is clock-wise and not counterclockwise. The notion of a negative

frequency is just an artifact of the two-phasor representation of A

cos (t + ). In the one-phasor representation, when we take the "real

part," the artifact does not arise. In your study of circuits, systems theory,
electromagnetics, solid-state devices, signal processing, control, and
communications, you will encounter both the one- and two-phasor
representations. Become facile with them.
Exercise:

Problem:

Sketch the two-phasor representation of A cos (t + ). Show clearly
how this representation works by discussing the counterclockwise
rotation of the positive frequency part and the clockwise rotation of the
negative frequency part.
Adding Phasors. The sum of two signals with common frequencies but
different amplitudes and phases is
Equation:

                                         A1 cos (t + 1 ) + A2 cos (t + 2 ).

The rotating phasor representation for this sum is
Equation:

                  j1       j2  jt

           (A1 e      + A2 e )e .

The new phasor is A1ej1 + , A2ej2 and the corresponding real signal is
x (t) = Re[(A1ej1 + A2e ) j2 e ] jt . The new phasor is illustrated in
[link].

           Adding Phasors

Exercise:
Problem:

Write the phasor A1ej1 + A2ej2 as A3ej3 ; determine A3 and 3 in
terms of A1, A2, 1, and 2. What is the corresponding real signal?

Differentiating and Integrating Phasors. The derivative of the signal
A cos (t + ) is the signal
Equation:

              d                                                      -A sin (t + )

                    A cos (t + ) =                                                                          j jt

             dt                                                       - Im[Ae e ]

                                                                  =

                                               =                                  j jt
                                                                       Re[jAe e ]

                                               = Re[e                       j/2   j jt
                                                                                 Ae e ].

This finding is very important. It says that the derivative of A cos (t + )
has the phasor representation
Equation:

                               d                                                            j
                                                                     
                                   A cos (t + )                          jAe

                              dt

                                                                         e  j/2   j
                                                                                 Ae .

These two phasor representations are entirely equivalent. The first says that

the  phasor            j  is  complex  scaled  by  j                 to  produce  the          phasor             for

             Ae

  d

    A cos (t+), and the second says that it is scaled by  and phased by

 dt

+/2. The phasor representations of A cos (t + ) and

  d

    A cos (t + ) are illustrated in Figure 3.6. Note that the derivative

 dt

"leads by /2 radians (90)."
Differentiating and Integrating Phasors

The integral of A cos (t + ) is
Equation:

 A cos (t + )dt =                                          A
                                                     =
                                                     =           sin (t + )

                                                            
                                                                            A j jt

                                                           Im[ e e ]

                                                                            
                                                                                A j jt

                                                        Re[-j e e ]

                                                                                

                                                          A j jt
                                 =                      Re[ e e ]
                                                          j

                                                        1 -j/2  j jt
                                 = Re[ e                        Ae e ].
                                                        

This finding shows that the integral of A cos (t + ) has the phasor
representation
Equation:
                   A cos (t + )dt                                               1  Ae  j
                                                                         
                                                                                j

                                                                           1 -j/2         j
                                                                             e     Ae .
                                                                           

The phasor Aej is complex scaled by 1 or scaled by 1 and phased by

                                           j                                              

    -j/2  to  produce  the  phasor  for    A cos (t + )dt. This is illustrated

e

in [link]. Note that the integral "lags by /2 radians (90). Keep these
geometrical pictures of leading and lagging by /2 in your mind at all
times as you continue your more advanced study of engineering.

An Aside: The Harmonic Oscillator. The signal A cos (t + ) stands
on its own as an interesting signal. But the fact that it reproduces itself (with
scaling and phasing) under differentiation means that it obeys the second-
order differential equation of the simple harmonic oscillator.[footnote] That
is, the differential equation
This means, also, that we have an easy way to synthesize cosines with
circuits that obey the equation of a simple harmonic oscillator!
Equation:

                            d2 x (t)                     2
                                dt 2
                                           +  x (t) = 0

has the solution
Equation:

                            x(t) = A cos (t + ).

Try it:
Equation:

           d2                d

                   x (t) =                                                                                                        2
          dt 2
                                  [-A sin (t + )] = - A cos (t + ).
                            dt
The constants A and  are determined from the initial conditions
Equation:

                      2           2          2
x (0) = A cos         x (0) + x (       )=A
                                     2

                    

                            x(/2)

x(  2  ) = -A sin        -           =tan .

                            x(0)

Exercise:
   Problem:

   Show how to compute A and  in the equation
   x(t) = A cos (t + ) from the initial conditions x(O) and

        d

       x (t)|t=0.

       dt
Phasors: Beating between Tones

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Perhaps you have heard two slightly mistuned musical instruments play
pure tones whose frequencies are close but not equal. If so, you have sensed
a beating phenomenon wherein a pure tone seems to wax and wane. This
waxing and waning tone is, in fact, a tone whose frequency is the average
of the two mismatched frequencies, amplitude modulated by a tone whose
"beat" frequency is half the difference between the two mismatched
frequencies. The effect is illustrated in [link]. Let's see if we can derive a
mathematical model for the beating of tones.

We begin with two pure tones whose frequencies are 0 +  and 0 - 
(for example, 0 = 2 × 103rad/ sec and  = 2 rad / sec). The
average frequency is 0, and the difference frequency is 2. What you hear
is the sum of the two tones:
Equation:

              x (t) = A1 cos [(0 + )t + 1 ] + A2 cos [(0 - )t + 2 ].

The first tone has amplitude A1 and phase 1 ; the second has amplitude
A2 and phase 2. We will assume that the two amplitudes are equal to A.
Furthermore, whatever the phases, we may write them as
Equation:

      1 =  +                    and         2 =  - 
                                and
                   1                                    1

 = 2 (1 + 2 )                         = 2 (1 - 2 ).
Beating between Tones

Recall our trick for representing x(t) as a complex phasor:
Equation:

x (t) = A Re ej[(0+)t++] , +, ej[(0-)t+-]
                = A Re ej(0t+) , ej(t+) + e-j(t+)
                = 2A Re ej(0t+) , cos, (t + )

=  2A cos (0 t + ) cos (t + ).

This is an amplitude modulated wave, wherein a low frequency signal with
beat frequency  rad/sec modulates a high frequency signal with carrier
frequency 0 rad/sec. Over short periods of time, the modulating term
cos (t+) remains essentially constant while the carrier term

cos (0t + ) turns out many cycles of its tone. For example, if t runs
from 0 to  2   (about 0.1 seconds in our example), then the modulating

           10

wave turns out just 1/10 cycle while the carrier turns out 10 cycles

(about 100 in our example). Every time t changes by 2 radians, then the

modulating term goes from a maximum (a wax) through a minimum (a

wane) and back to a maximum. This cycle takes

Equation:

               t = 2  t =  2
                                  seconds,

                            

which is 1 second in our example. In this 1 second the carrier turns out
1000 cycles.
Exercise:

   Problem:

   Find out the frequency of A above middle C on a piano. Assume two
   pianos are mistuned by ±1Hz(±2rad/sec). Find their beat
   frequency  and their carrier frequency 0.
Exercise:

   Problem: (MATLAB) Write a MATLAB program to compute and plot

   A cos [(0 + )t + 1], A cos [(0 - )t + 2], and their sum. Then
   compute and plot 2A cos (0t + ) cos (t + ).

   Verify that the sum equals this latter signal.
Phasors: Multiphase Power

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The electrical service to your home is a two-phase service.[footnote] This
means that two 110 volt, 60 Hz lines, plus neutral, terminate in the panel.
The lines are  radians (180) out of phase, so we can write them as
It really is, although it is said to be "single phase" because of the way it is
picked off a single phase of a primary source. You will hear more about this
in circuits and power courses.
Equation:

x1 (t) = 110 cos [2 (60)t + ] = Re {110e                                j[2(60)t+]  }

           =  Re{X1 e      j2(60)t  }

                                                                  j

                           X1 = 110e

x2 (t)  = 110 cos [2 (60)t +  + ] =                                     Re {110ej[2(60)t++] }

        =     Re{X2 e      j2(60)t  }

                           X2 = 110e   j(+)                          .

These two voltages are illustrated as the phasors X1 and X2 in [link].
                    Phasors in Two-Phase Power

You may use x1 (t) to drive your clock radio or your toaster and the
difference between x1 (t) and x2 (t) to drive your range or dryer:
Equation:

                                      x1 (t) - x2 (t) = 220 cos [2(60)t + ].

The phasor representation of this difference is
Equation:

                                                                                                                                                       j

                                                                X1 - X2 = 220e .

The breakers in a breaker box span the x1-to-neutral bus for 110 volts and
the x1-to-x2 buses for 220 volts.
Exercise:

   Problem: Sketch the phasor X1 - X2 on [link].
   Most industrial installations use a three-phase service consisting of the
   signals x1 (t), x2 (t), and x3 (t):
   Equation:
                    j[0 t+n(2/3)]                jn(2/3)

xn (t) = 110 Re {e                 }  Xn = 110e           , n = 1, 2, 3.

   The phasors for three-phase power are illustrated in [link].

Exercise:

   Problem:

   Sketch the phasor X2 - X1 corresponding to x2 (t) - x1 (t) on
   [link]. Compute the voltage you can get with x2 (t) - x1 (t). This
   answer explains why you do not get 220 volts in three-phase circuits.
   What do you get?

Three-Phase Power

Constant Power. Two- and three-phase power generalizes in an obvious
way to N-phase power. In such a scheme, the N signals xn(n =
0, 1, ..., N - 1) are
Equation:

                                   (             )
     xn (t) =                                          A cos (t +               2
                                                                                       n)

                                                                                N

                                                       j2n/N jt                                           j2n/N
                  = Re [Ae                                      e ]  Xn = Ae                                     .

The  phasors  Xn  are     . j2(n/N )                   The      sum   of  all   N  signals                is  zero:

                       Ae

Equation:

                  N -1                                                    N -1 j2n/N jt

              n=0 xn (t) = Re {A n=0 e                                                                e}

                        =                                                                  1-e j2  ejt }

                                                                Re{A

                                                                                        1-e j2/N

                        =                                                    0.

But what about the sum of the instantaneous powers? Define the
instantaneous power of the nth signal to be
Equation:

                                               2                   2      2                        2  n)
                                                                A cos (t +
           pn (t) = x (t) =
                                                                                                   N
                                               n
                                                       A2             A2                                  2
                                                    =
                                                    =           +     2   cos (2t + 2 n)
                                                       2                                                  N

                                                             2            A  2

                                                       A                        e  j(2/N )2n j2t
                                                        2       + Re {                                e       }.
                                                                          2

The sum of all instantaneous powers is (see [link])
Equation:

                        N -1                                                 A2

                        P =  pn (t) = N                                            ,

                                                                2

                        n=0

and this is independent of time!
Exercise:
Problem:

Carry out the computations of Equation 3.33 to prove that
instantaneous power P is constant in the N-phase power scheme.
Phasors: Lissajous Figures

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Lissajous figures are figures that are turned out on the face of an
oscilloscope when sinusoidal signals with different amplitudes and different
phases are applied to the time base (real axis) and deflection plate
(imaginary axis) of the scope. The electron beam that strikes the
phosphorous face then had position
Equation:

                              z (t) = Ax cos (t + x ) + jAy cos (t + y ).

In this representation, Ax cos (t + x) is the "x-coordinate of the point,"
and Ay cos (t + ) is the "y-coordinate of the point." As time runs from
0 to infinity, the point z(t) turns out a trajectory like that of [link]. The

                                                                                                                                                     2

figure keeps overwriting itself because z(t) repeats itself every

                                                                                                                                                       

seconds. Do you see why?
         Lissajous Figure on Oscilloscope Screen

Exercise:
   Problem:

   Find the intercepts that the Lissajous figure makes with the real and
   imaginary axes in [link]. At what values of time are these intercepts
   made?
Exercise:
   Problem:

   Show that the Lissajous figure z (t) = Ax cos (t + x)+
   jAy cos (t + y) is just the rotating phasor Aej(t+) when

                                                                                                       

   Ax = Ay = A, x = , and y =  + .

                                                                                                       2

Two-Phasor Representation. We gain insight into the shape of the
Lissajous figure if we use Euler's formulas to write z(t) as follows:
Equation:
z (t) =           Ax   ej(t+x) + e-j(t+x)                        Ay   ej(t+y) + e-j(t+y)
               =    2
                                                    +j

                                                                   2

                       Ax ejx +jAy ejy          jt     A e-jx +jA e-jy         -jt
                                          2            x                 y

                                             e      +                 2     e       .

This representation is illustrated in [link]. It consists of two rotating
phasors, with respective phasors B1 and B2 :
Equation:

                       z (t) = B1 e             jt  + B2e  -jt

                       B1 =                  Ax ejx +jAy ejy
                                                                2

                       B2 =  Ax e-jx +jAy e-jy
                                                    2

Two-Phasor Representation of a Lissajous Figure
As t increases, the phasors rotate past each other where they constructively
add to produce large excursions of z(t) from the origin, and then they rotate
to antipodal positions where they destructively add to produce near
approaches of z(t) to the origin.

In electromagnetics and optics, the representations of z(t) given in [link]
and [link] are called, respectively, linear and circular representations of
elliptical polarization. In the linear representation, the x- and y-components
of z vary along the horizontal and vertical lines. In the circular
representation, two phasors rotate in opposite directions to turn out circular
trajectories whose sum produces the same effect.
Exercise:

   Problem:

   (MATLAB) Write a MATLAB program to compute and plot the
   Lissajous figure z(t) when Ax = 1/2, Ay = 1, x = 0, and
   y = /6. Discretize t appropriately and choose an appropriate range
   of values for t.
Phasors: Sinusoidal Steady State and the Series RLC Circuit

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Phasors may be used to analyze the behavior of electrical and mechanical
systems that have reached a kind of equilibrium called sinusoidal steady
state. In the sinusoidal steady state, every voltage and current (or force and
velocity) in a system is sinusoidal with angular frequency . However, the
amplitudes and phases of these sinusoidal voltages and currents are all
different. For example, the voltage across a resistor might lead the voltage
across a capacitor by 90 (  radians) and lag the voltage across an

                                                                 2

inductor by 90 (  radians)  .

                                          2

In order to make our application of phasors to electrical systems concrete,
we consider the series RLC circuit illustrated in [link]. The arrow labeled
i(t) denotes a current that flows in response to the voltage applied,and the +
and - on the voltage source indicate that the polarity of the applied voltage
is positive on the top and negative on the bottom. Our convention is that
current flows from positive to negative, in this case clockwise in the circuit.
                      Series RLC Circuit

We will assume that the voltage source is an audio oscillator that pro- duces
the voltage
Equation:

                                                           V (t) = A cos (t + ).

We represent this voltage as the complex signal
Equation:

                                                                                                                                        j jt

                                                                   V (t)  Ae e

and give it the phasor representation
Equation:

                                                                                                                                                           j

                                                             V (t)  V ; V = Ae .

We then describe the voltage source by the phasor V and remember that we
can always compute the actual voltage by multiplying by ejt and taking
the real part:
Equation:                                                                       jt
Exercise:
                        V (t) = Re {V e }.

Problem: Show that Re [V e ] jt = A cos (t + ) when V = Aej.

Circuit Laws. In your circuits classes you will study the Kirchhoff laws
that govern the low frequency behavior of circuits built from resistors (R),
inductors (L), and capacitors (C). In your study you will learn that the
voltage dropped across a resistor is related to the current that flows through
it by the equation
Equation:

                                                                     VR (t) = Ri (t).

You will learn that the voltage dropped across an inductor is proportional to
the derivative of the current that flows through it, and the voltage dropped
across a capacitor is proportional to the integral of the current that flows
through it:
Equation:

                                     di

                        VL (t) = L       (t)

                                     dt

                        VC (t) =  1   i (t)dt.

                                  C

Phasors and Complex Impedance. Now suppose that the current in the
preceding equations is sinusoidal, of the form
Equation:

                                                            i(t) = B cos (t + ).

We may rewrite i(t) as
Equation:

                                                             jt

           i (t) = Re {I e }

where I is the phasor representation of i(t).
Exercise:

Problem: Find the phasor I in terms of B and  in [link].

The voltage dropped across the resistor is
Equation:

           VR (t) =        Ri (t)

                           = R Re{I ejt }

                           = Re{RI ejt }.

Thus the phasor representation for VR (t) is
Equation:

                                                           VR (t)  VR ; VR = RI .

We call R the impedance of the resistor because R is the scale constant that
relates the "phasor voltage VR' to the "phasor current I."

The voltage dropped across the inductor is
Equation:

                       di                   d                                      jt

           VL (t) = L      (t) = L              Re {I e }.

                       dt                   dt

The derivative may be moved through the Re[ ] operator (see [link]) to
produce the result
Equation:
                                                                                  jt

VL (t) = L Re {jI e }

                                                                                jt

                   = Re{jLI e }.

Thus the phasor representation of VL(t)
Equation:

                                                        VL (t)  VL ; VL = jLI .

We call jL the impedance of the inductor because jL is the complex
scale constant that relates "phasor voltage VL' to "phasor current I."
Exercise:

                                                                                    d

Problem: Prove that the operators and Re[] commute:

                                                                                   dt

Equation:

d                 jt                         d   jt

          Re {e } = Re {                         e }.

dt                                           dt

The voltage dropped across the capacitor is
Equation:

VC (t) =  1       i (t)dt =  1                                            jt
                                   
                                                 Re {I e }dt.
          C                  C

The integral may be moved through the Re[ ] operator to produce the result
Equation:

                      1                      I   jt
VC (t) =                 Re { e }

                      C                      j

                  = Re{      I                   jt
                                                e }.

                             jC
Thus the phasor representation of VC(t) is
Equation:

                        VC (t)  VC ; VC =      I
                                            jC

We call  1   the impedance of the capacitor because  1   is the complex

         jC                                          jC

scale constant that relates "phasor voltage VC" to "phasor current I."

Kirchhoff's Voltage Law. Kirchhoff's voltage law says that the voltage
dropped in the series combination of R, L, and C illustrated in [link] equals
the voltage generated by the source (this is one of two fundamental
conservation laws in circuit theory, the other being a conservation law for
current):
Equation:

             V (t) = VR (t) + VL (t) + VC (t).

If we replace all of these voltages by their complex representations, we
have
Equation:

                        jt                           jt

             Re{V e } = Re{(VR + VL + VC )e }.

An obvious solution is
Equation:

                        V=  VR + VL + VC

                            = (R + jL +     1   )I

                                            jC

where I is the phasor representation for the current that flows in the circuit.
This solution is illustrated in [link], where the phasor voltages RI, jLI,
and  1     I are forced to add up to the phasor voltage V .

     jC

     Phasor Addition to Satisfy Kirchhoff's Law

Exercise:

Problem: Redraw [link] for R = L =  1   = 1.

                                    C

Impedance. We call the complex number R + jL +               1  the complex

                                                 jC

impedance for the series RLC network because it is the complex number

that relates the phasor voltage V to the phasor current I:

Equation:

           V = ZI

                                    1

           Z = R + jL +             jC  .
The complex number Z depends on the numerical values of resistance (R),
inductance (L), and capacitance (C), but it also depends on the angular
frequency () used for the sinusoidal source. This impedance may be
manipulated as follows to put it into an illuminating form:
Equation:

                                                                          R + j(L -            1

                  Z=                                                                              )

                                                                                               C

                                                                          L                             1
                   = R + j (LC -                                                                            ).

                                                                          C                       LC

The parameter 0 = 1                                                       is a parameter that you will learn to call an
                                                                        
                        LC

"undamped natural frequency" in your more advanced circuits courses.

With it, we may write the impedance as

Equation:

                                                                                               0

                   Z = R + j0 L (                                                           -           ).

                                                                                         0     

The frequency      is a normalized frequency that we denote by . Then the
               
                0

impedence, as a function of normalized frequency, is

Equation:

                   Z () = R + j0 L ( -                                                            1
                                                                                                      ).

                                                                                                  

When the normalized frequency equals one ( = 1), then the impedance is
entirely real and Z = R. The circuit looks like it is a single resistor.
Equation:

                                                                          = R[1 + (  0L  2        1 2 1/2
                  Z ()                                                                   ) ( - ) ] .
                                                                                     R            

                                                                         -1             0L              1
                                                                                                   ( -      ).
                   arg Z () =tan
                                                                                          R             
The impedance obeys the following symmetries around  = 1:
Equation:

                                          *   1
                           Z () = Z ( )
                                              

                                                                          1

                           Z() = Z( )

                                                                          

                    arg Z () =                                             1

                                       -arg Z ( ).

                                                                           

In the next paragraph we show how this impedance function influences the
current that flows in the circuit.

Resonance. The phasor representation for the current that flows the current
that flows in the series RLC circuit is
Equation:

                    I=                    V
                           =           Z ( )

                              1        e  -jargZ ( )                         V

                              |Z ( )|

The function H() =      1  displays a "resonance phenomenon." that is,
                    Z ( )

|H()| peaks at  = 1 and decreases to zero and  = 0 and  = :

Equation:

                    |H ()| =     0,  = 0

                                   1

                                             =1

                                   R

                                 0,  = .

When |H()| = 0, no current flows.

                                                                                                                                                                    

The function |H()| is plotted against the normalized frequency  = in

                                                                                                                                                                  0
                                                                                                                                                              1

Figure 3.14. The resonance peak occurs at  = 1, where |H()| =

                                                                                                                                                             R
meaning that the circuit looks purely resistive. Resonance phenomena
underlie the frequency selectivity of all electrical and mechanical networks.

Resonance in a Series RLC Circuit

Exercise:

   Problem:

   (MATLAB) Write a MATLAB program to compute and plot |H()|
   and arg H() versus  for  ranging from 0.1 to 10 in steps of 0.1.

                                                                                          L

   Carry out your computations for 0 = 10, 1, 0. 1, and 0.01, and

                                                                                          R

   overplot your results.

Circle Criterion and Power Factor. Our study of the impedance Z() and

the function H () =  1      brings insight into the resonance of an RLC

                     Z ( )

circuit and illustrates the ffequency selectivity of the circuit. But there is
more that we can do to illuminate the behavior of the circuit.
Equation:

                                     1

                     V = RI + j(L -     )I .

                                     C

This equation shows how voltage is divided between resistor voltage RI and
inductor-capacitor voltage j(L - C )I. 1
Equation:

                                                    0

           V = RI + j0 L (                -              )I

                                       0            

or
Equation:

                                 j0 L            1

           V = RI +                    ( - )RI .

                                 R               

In order to simplify our notation, we can write this equation as
Equation:

                                                                V = VR + jk ()VR

where VR is the phasor voltage RI and k() is the real variable
Equation:

                          k() =  0L              1
                                            ( -      ).

                                   R             

[link] brings very important geometrical insights. First, even though the

phasor voltage VR in the RLC circuit is complex, the terms VR and

                                                                      

jk ()VR are out of phase by radians. This means that, for every

                                                                      2

allowable value of VR, the corresponding jk ()VR must add in a right

triangle to produce the source voltage V . This is illustrated in [link]. As the

frequency  changes, then k() changes, producing other values of VR and

jk ()VR that sum to V . Several such solutions for VR and jk ()VR are

illustrated in Figure 3.15(b). From the figure we gain the clear impression

                                                         V                        V
that the phasor voltage V>R lies on a circle of radius centered at

                                                         2                        2

Let's try this solution,
Equation:

                                 V     V j
                  VR =                 +e
                              =     2  2

                                 V        j
                                    (1 + e ),
                                 2

and explore its consequences. When this solution is substituted into [link],
the result is
Equation:

               V  j                       V             j

           V=     (1 + e ) + jk () (1 + e )

               2                          2

or
Equation:

                                                     j

               2 = (1 + e ) [1 + jk ()].

   The Components of V ; (a) Addition of VR and jk ()VR
   to Produce V, and (b) Several Values of VR and jk ()VR

                            that Produce V

If we multiply the left-hand side by its complex conjugate and the right-
hand side by its complex conjugate, we obtain the identity
Equation:
                                                                                              2

           4 = 2 (1+ cos )[1 + k ()].

This equation tells us how the angle  depends on k() and, conversely,
how k() depends on :
Equation:

           cos  =  1 - k2 ()
                   1 + k2 ()

Equation:

               2   1- cos 
                   1+ cos 
           k () =

The number cos  lies between -1 and +1, so a circular solution does
indeed work.
Exercise:

   Problem:

   Check -1 cos   1 for - < k <  and - < k <  for
   -    . Sketch k versus  and  versus k.

The equation VR = (1 + e ) V j is illustrated in [link]. The angle that VR

                                                 2

makes with V is determined from the equation
Equation:

                                                                                                                      
                                                      2 +  -  =    =

                                                                                                                      2
The Voltages V and VR, and the Power Factor

                                              cos 

In the study of power systems, cos  is a "power factor" that determines
how much power is delivered to the resistor. We may denote the power
factor as
Equation:

 =cos  =cos                 
                                 .

                            2

But cos  may be written as
Equation:

                                                                                                          
                                                                   =cos  =cos

                                                                                                           2

But cos  may be written as
Equation:
           cos  =cos ( + ) =     cos2  - - sin 2 

                                   2             2
                 = cos  - (1- cos )

                 = 2 cos2  - 1
                 = 22 - 1.

Therefore the square of the power factor  is
Equation:

           2  cos  + 1                        1

           =                  =

              2 1 + k2 ()

The power factor is a maximum of 1 for k() = 0, corresponding to  = 1
( = 0). It is a minimum of 0 for k() = ±, corresponding to
 = 0, ( = 0, ).
Exercise:

   Problem:

With k defined as k () = ( - ) 0L 1 , plot k2 (), cos , and 2

              R                  

versus .

Exercise:

Problem: Find the value of  that makes the power factor  = 0. 707.
Phasors: Light Scattering by a Slit

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

One of the most spectacular successes for phasor analysis arises in the study
of light diffraction by a narrow slit. The experiment is to shine laser light
through a slit in an otherwise opaque sheet and observe the pattern of light
that falls on a distant screen. When the slit is very narrow compared with
the wavelength of the light, then the light that falls on the screen is nearly
uniform in intensity. However, when the width of the slit is comparable to
the wavelength of the light, the pattern of light that falls on the screen is
scalloped in intensity, showing alternating light and dark bands. The
experiment, and the observed results, are illustrated in [link].
                       Light Diffraction by a Slit

Why should this experiment produce this result? Phasor analysis illuminates
the question and produces an elegant mathematical description of a
profoundly important optical experiment.

Huygens's Principle. We will assume, as Christiaan Huygens did, that the

light incident on the slit sets up a light field in the slit that may be modeled

by N discrete sources, each of which radiates a "spherical wave of light."

This model is illustrated in [link]. The distance between sources is d, and

Nd = L is the width of the slit. Each source is indexed by n, and n runs

from  0  to  N  -  1.  The      th  source  is  located  at  the  origin  of  our  coordinate

                            0

system.

The spherical wave radiated by the nth source is described by the equation
Equation:

                                                A     j[t-(2/)rn ]

                       E (rn , t) = Re {           e                }.

                                                N

The function E(rn, t) describes the "electric field" at time t and distance rn
from the nth source. The field is constant as long as the variable
t - (2/)rn is constant. Therefore, if we freeze time at t = t0, the field
will be constant on a sphere of radius rn. This is illustrated in [link].
          Huygens's Model for Light Diffraction

Exercise:
   Problem:

   Fix rn in E(rn, t) and show that E(rn, t) varies cosinusoidally with
   time t. Sketch the function and interpret it. What is its period?
Exercise:
   Problem:

   Fix t in E(rn, t) and show that E(rn, t) varies cosinusoidally with
   radius rn. Sketch the function and interpret it. Call the "period in rn"
   the "wavelength." Show that the wavelength is .
Exercise:
   Problem:

   The "crest of the wave E(rn, t)" occurs when t - (2/)rn = 0.
   Show that the crest moves through space at velocity v = /2.

Geometry. If we now pick a point P on a distant screen, that point will be
at distance r0 from source 0, ..., rn from source n, ..., and so on. If we
isolate the sources 0 and n, then we have the geometric picture of [link].
The angle  is the angle that point P makes with the horizontal axis. The
Pythagorean theorem says that the connection between distances r0 and rn
is
Equation:

                           2                        2  2

(rn - nd sin ) + (nd cos ) = r0 .

Geometry of the Experiment

Let's try the solution
Equation:

                        rn = r0 + nd sin .

This solution produces the approximate identity
Equation:

                        2     2                  2

                        r0 + (nd cos )  r0
Equation:

                             2                2          2

                             r + (nd cos )  r            0
                             0

                                                    2

                                     nd

                             1+ (    r0  cos )          1.

                                                    nd

This will be close for << 1. We will assume that the slit width L is

                                                     r0

small compared to the distance to any point on the screen. Then

Nd    L
      = << 1, in which case the approximate solution for rn is valid

r0    r0

for all n. This means that, for any point P on the distant screen, the light

contributed by the nth source is approximately
Equation:

            En (, t) =            A Re j[t-(2/)(r { e 0+ndsin)] }

                                                    N

                          =  A Re -j(2/)r { e 0 e-j(2/)ndsin ejt }.

                                              N

The phasor representation for this function is just
Equation:

                     En () =      A  e  -j(2/)r0 -j(2/)ndsin
                                  N           e                     .

Note  that  E0  (),  the  phasor  associated  with  the      th  source,  is

                                                         0

e A -j(2/)r0 . Therefore we may write the phasor representation for the

 N

light contributed by the nth source to be

Equation:

                          En () = E0 ()e      -j(2/)ndsin        .
This result is very important because it shows the light arriving at point P
from different sources to be "out of phase" by an amount that depends on

                      nd sin 

the ratio

                              

Phasors and Interference. The phasor representation for the field observed
at point P on the screen is the sum of the phasors contributed by each
source:
Equation:

N -1  N -1

                          -j(2/)ndsin

E () =  En () = E0 ()  e                                                                                                                                          .

n=0   n=0

This is a sum of the form
Equation:

                                                                                                                                            N -1
                                                                                                                                                              jn

                                                          E () = E0 ()  e

                                                                                                                                             n=0

where the angle  is (2/)d sin . This sum is illustrated in [link] for
several representative values of . Note that for small , meaning small ,
the sum has large magnitude, whereas for  on the order of 2/N, the sum
is small. This simple geometric interpretation shows that for some values of
, corresponding to some points P on the screen, there will be constructive
interference between the phasors, while for other values of  there will be
destructive interference. Constructive interference produces bright light,
and destructive interference produces darkness.
        Phasor Sums for Diffraction

The geometry of [link] is illuminating. However, we already know from our
study of complex numbers and geometric sums that the phasor sum of
Equation 3.85 may be written as
Equation:

                      1 - e-j(2/)N dsin

        E () = E0 ()                                .

                      1 - e-j(2/)dsin

This result may be manipulated to produce the form
Equation:

                                                       d
        A -j(2/)r0 -j(/)(N -1)dsin sin (N                 sin )

E () =  e  e

        N sin ( d sin )

                                                                                                                                             

The magnitude is the intensity of the light at angle  from horizontal:
Equation:

                                                                                                                                                    d
                                      A                                 d
           |E ()| =|
                                         sin (N  sin )
                                      N
                                                                        

                                                                                     |.

                                                                    d

                                           sin ( sin )

                                                                    

Exercise:

Problem: Derive [link] from [link].

Limiting Form. Huygens's model is exact when d shrinks to 0 and N
increases to infinity in such a way that Nd  L, the slit width. Then
Equation:

                     A sin (             L  sin )

                                         

           |E ()| |                                       |.

                                         L

                                                 sin 

                                          

                                                                                                                      L

This function is plotted in [link] for two values of the width of the slit

                                                                                                                       

                     L                                 
measured in wavelengths. When << 1 (i.e., >> 1), then the light is

                                                       L

uniformly distributed on the screen. However, when        L                                       < 1),

                                                                                         > 1(

                                                                                               L

then the function has many zeros for | sin | < 1, as illustrated in the

figure. These zeros correspond to dark spots on the screen where the fields

radiated from the infinity of points within the slit interfere destructively.
           Interference Pattern for a Slit

Exercise:

   Problem: Derive [link] from [link].
Exercise:

Problem: (MATLAB) Plot the discrete approximation
Equation:

                   A                    d
                       sin (N  sin )
                   N                    

                                              d

                       sin ( sin )

                                              

           L       Nd  = 10 and N = 2, 4, 8, 16, 32. Compare
versus sin  for =

                   

with the continuous, limiting form

Equation:
L
   A sin ( sin )
                                     

                          L

              sin 

                          
Phasors: Numerical Experiment (Interference Patterns)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Let's add two sinusoids whose amplitudes and frequencies are identical and
whose phases are different:
Equation:

                               x(t) = A cos (t + ) + A cos (t +  + ).

Show analytically that this sum has the phasor representation
Equation:

             j[+(/2)]

X = 2A cos  ( )e       .

            2

Interpret this finding. Then write a MATLAB program that computes and
plots complex X on the complex plane as  varies from 0 to 2 and that
plots magnitude, |X|, and phase, arg X, versus the phase angle . (You

                                                               2

will have to choose  = n , n = 0, 1, ..., N - 1, for a suitable N .)

                                                                N

When do you get constructive interfelence and when do you get destructive
interference? Now compute and plot x(t) versus t (you will need to
discretize t) for several interesting values of . Explain your interference
results in terms of the amplitude and phase of x(t) and the magnitude and
phase of X. Use the subplots discussed in "An Introduction to MATLAB"
to plot all of your results together.
Linear Algebra: Introduction

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

We use this chapter to introduce students to the algebraic structure of
vectors and matrices and to introduce them to matrix computations. These
matrix computations are used in the chapters "Vector Graphics", "Filtering",
and "Binary Codes" to solve problems in vector graphics, filtering, and
binary coding.

Vectors are introduced in the section "Vectors", along with algebraic and
geometric interpretations of some fundamental vector operations and
properties. The section "Inner Product and Euclidean Norm", the section
"Direction Cosines", and the section "Projections" introduce inner products
and their applications, including norm, direction cosines, orthogonality, and
projections. Some important alternatives to the Euclidean norm are
introduced in the section "Other Norms". Matrices are motivated and
introduced in this section. The notation in these sections can be daunting to
the beginner, so we proceed very carefully, using example after example. In
the section "Solving Linear Systems of Equations" we codify the
elimination procedures that students have used in high school to solve linear
systems of equations. The MATLAB demonstration in Demo 2 shows how
to use MATLAB to solve linear equations. The section "Circuit Analysis"
shows how linear algebra and MATLAB can be used to analyze dc circuits.
The numerical experiment "Circuit Design" gives students practice in
building function files in MATLAB and shows how to solve a sequence of
linear equations in order to design a circuit with desired properties.

Occasionally we have placed important results in the problems. We feel that
students should not miss the material in Exercise 3 in "Vectors", Exercise 3
in "Inner Product and Euclidean Norm", Exercise 3 in "Projections",
Exercise 1 in "Matrices", and Exercise 4 in "Matrices".

Introduction

Linear algebra is a branch of mathematics that is used by engineers and
applied scientists to design and analyze complex systems. Civil engineers
use linear algebra to design and analyze load-bearing structures such as
bridges. Mechanical engineers use linear algebra to design and analyze
suspension systems, and electrical engineers use it to design and analyze
electrical circuits. Electrical, biomedical, and aerospace engineers use linear
algebra to enhance X rays, tomographs, and images from space. In this
chapter and the next we study two common problems from electrical
engineering and use linear algebra to solve them. The two problems are (i)
electrical circuit analysis and (ii) coordinate transformations for computer
graphics. The first of these applications requires us to understand the
solution of linear systems of equations, and the second requires us to
understand the representation of mathematical operators with matrices.

Much of linear algebra is concerned with systematic techniques for
organizing and solving simultaneous linear equations by elimination and
substitution. The following example illustrates the basic ideas that we
intend to develop.

Example:
A woman steps onto a moving sidewalk at a large airport and stands while
the moving sidewalk moves her forward at 1.2 meters/seconds. At the
same time, a man begins walking against the motion of the sidewalk from
the opposite end at 1.5 meters/second (relative to the sidewalk). If the
moving sidewalk is 85 meters long, how far does each person travel
(relative to the ground) before they pass each other?
To solve this problem, we first assign a variable to each unknown quantity.
Let x1 be the distance traveled by the woman, and let x2 be the distance
traveled by the man. The sum of the two distances is 85 meters, giving us
one equation:
Equation:

                             x1 + x2 = 85.

Our second equation is based on the time required before they pass. Time
equals distance divided by rate, and the time is the same for both people:
Equation:

           x1       x2

                 =                0. 3x1 - 1. 2x2 = 0.

           1. 2     1. 5 - 1. 2

                                                                                                                                  1. 2

We may substitute [link] into [link] to obtain the result x2 + x2 = 85,

                                                                                                                                  0. 3

or

Equation:

                                                            5x2 = 85  x2 = 17.

Combining the result from [link] with that of [link], we find that
Equation:

                                                                             x1 = 68.

So the man travels 17 meters, and the woman travels 68 meters.
[link] and [link] are the key equations of [link]. They may be organized
into the "matrix equation"
Equation:

                       1     1   x1         85
                    [
                                 ][ ] = [ ].
                       0. 3
                             -1. 2 x2       0

The rules for matrix-vector multiplication are evidently
Equation:

                    (1) x1 + (1)x2 = 85

Equation:

                    (0. 3)x1 + (-1. 2)x2 = 0.
[link] and [link] may be organized into the matrix equation
Equation:

   0     5  x1     85
[
            ][ ] = [ ].
   0. 3
         -1. 2 x2  0

This equation represents one partially solved form of [link], wherein we
have used the so-called Gauss elimination procedure to introduce a zero
into the matrix equation in order to isolate one variable. The MATLAB
software contains built-in procedures to implement Gauss elimination on
much larger matrices. Thus MATLAB may be used to solve large systems
of linear equations.
Before we can apply linear algebra to more interesting physical problems,
we need to introduce the mathematical tools we will use.
Linear Algebra: Vectors

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

For our purposes, a vector is a collection of real numbers in a one-
dimensional array.[footnote] We usually think of the array as being
arranged in a column and write
In a formal development of linear algebra, the abstract concept of a vector
space plays a fundamental role. We will leave such concepts to a complete
course in linear algebra and introduce only the functional techniques
necessary to solve the problems at hand.

               x1
               x2

x = x3 .

               |
               xn

Notice that we indicate a vector with boldface and the constituent elements
with subscripts. A real number by itself is called a scalar, in distinction
from a vector or a matrix. We say that x is an n-vector, meaning that x has
n elements. To indicate that x1 is a real number, we write
Equation:

                         x1   ,

meaning that x1 is contained in , the set of real numbers. To indicate that
x is a vector of n real numbers, we write
Equation:

              n

           x  ,

meaning that x is contained in Rn, the set of real n-tuples. Geometrically,
Rnis n-dimensional space, and the notation x  n means that x is a point
in that space, specified by the n coordinates x1, x2, ..., xn. [link] shows a
vector in R3, drawn as an arrow from the origin to the point x. Our
geometric intuition begins to fail above three dimensions, but the linear
algebra is completely general.

                         A Vector in R3

We sometimes find it useful to sketch vectors with more than three
dimensions in the same way as the three-dimensional vector of [link]. We
then consider each axis to represent more than one dimension, a hyperplane,
in our n-dimensional space. We cannot show all the details of what is
happening in n-space on a three-dimensional figure, but we can often show
important features and gain geometrical insight.
Vector Addition. Vectors with the same number of elements can be added
and subtracted in a very natural way:
Equation:

             x1 + y1     x1-                 y1

             x2 + y2     x2 - y2

          x + y = x3 + y3 ; x - y = x3 - y3      .

             |           |

             xn + yn     xn - yn

Example:

                      1                             0

The difference between the vector x = 1 and the vector y = 0 is the

                      1                             1

          1

vector z = x - y = 1 . These vectors are illustrated in [link]. You can

                                                    0

see that this result is consistent with the definition of vector subtraction in
[link]. You can also picture the subtraction in [link] by mentally reversing
the direction of vector y to get -y and then adding it to x by sliding it to
the position where its tail coincides with the head of vector x. (The head is
the end with the arrow.) When you slide a vector to a new position for
adding to another vector, you must not change its length or direction.
           Subtraction of Vectors

Exercise:
   Problem:
   Compute and plot x + y and x - y for each of the following cases:

        1         1

a. x =  3 , y= 2 ;
b. x =
c. x =  2         3

        -1           1

        3   , y= 2 ;

        -2           3
        1            1
        -3 , y =
                     3.

        2            2
Scalar Product. Several different kinds of vector multiplication are
defined.[footnote] We begin with the scalar product. Scalar multiplication
is defined for scalar a and vector x as
The division of two vectors is undefined, although three different
,Äúdivisions,Äù are defined in MATLAB.
Equation:

           ax =  ax1
                 ax2
                 ax3 .
                 |
                 axn

If |a| < 1, then the vector ax is "shorter" than the vector x; if |a| > 1, then
the vector ax is ,"longer" than x. This is illustrated for a 2-vector in [link].

           The Scalar Product ax

Exercise:
   Problem:

                                                                                                                                 1

   Compute and plot the scalar product ax when x = 1/2 for each of

                                                                                                                                 l/4

   the following scalars:

      a. a = 1;
      b. a = -1;
      c. a = -1/4;
      d. a = 2.

Exercise:
   Problem:

   Given vectors , ,  n and the scalar a  , prove the following
   identities:

      a. x + y = y + x. Is vector addition commutative?
      b. (x + y) + z = x + (y + z). Is vector addition associative?
      c. a(x + y) = ax + ay. Is scalar multiplication distributive over

         vector addition?
Linear Algebra: Inner Product and Euclidean Norm

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The inner product (x, y) between vectors x and y is a scalar consisting of
the following sum of products:
Equation:

                                  (x, y) = x1 y1 + x2 y2 + x3 y3 +  + xn yn .

This definition seems so arbitrary that we wonder what uses it could
possibly have. We will show that the inner product has three main uses:

   i. computing length or "norm",
  ii. finding angles between vectors and checking for "orthogonality", and
  iii. computing the "component of one vector along another" (projection).

Since the inner product is so useful, we need to know what algebraic
operations are permitted when we are working with inner products. The
following are some properties of the inner product. Given x, y, z  R n and
a  R,

   i. (x, y) = (y, x);
  ii. (ax, y) = a(x, y) = (x, ay); and
  iii. (x, y + z) = (x, y) + (x, z).

Exercise:
Problem:

Prove the three preceding properties by using the definition of inner
product. Is the equation x(y, z) = (x, y)z also a true property? Prove
or give a counterexample.

Euclidean Norm. Sometimes we want to measure the length of a vector,
namely, the distance from the origin to the point specified by the vector's
coordinates. A vector's length is called the norm of the vector. Recall from
Euclidean geometry that the distance between two points is the square root
of the sum of the squares of the distances in each dimension. Since we are
measuring from the origin, this implies that the norm of the vector x is
Equation:

            x = x2 + x2 + +x2 .
                                  1  2  n

Notice the use of the double vertical bars to indicate the norm. An
equivalent definition of the norm, and of the norm squared, can be given in
terms of the inner product:
Equation:

                                                                      x = (x, x)

or
Equation:

                             2

            x  = (x, x).

Example:
The Euclidean norm of the vector
Equation:
x=  1

    3
               ,

    5

    -2

is  x = 12 + 32 + 52 + (-2) = 39. 2 

An important property of the norm and scalar product is that, for any
x  R n and a  R,
Equation:

                                                                     ||ax|| = |a|||x||.

So we can take a scalar multiplier outside of the norm if we take its absolute
value.
Exercise:

   Problem: Prove [link].

Cauchy-Schwarz Inequality. Inequalities can be useful engineering tools.
They can often be used to find the best possible performance of a system,
thereby telling you when to quit trying to make improvements (or proving
to your boss that it can't be done any better). The most fundamental
inequality in linear algebra is the Cauchy-Schwarz inequality. This
inequality says that the inner product between two vectors x and y is less
than or equal (in absolute value) to the norm of x times the norm of y, with
equality if and only if y = x:
Equation:

                                                                 |(x, y)|  ||x||||y||.
To prove this theorem, we construct a third vector z = x - y and measure
its norm squared:
Equation:

2                                                  2  2                                  2

||x - y|| = (x - y, x - y) =  ||x|| - 2 (x, y) + ||y||  0.

So we have a polynomial in  that is always greater than or equal to 0
(because every norm squared is greater than or equal to 0). Let's assume
that x and y are given and minimize this norm squared with respect to . To
do this, we take the derivative with respect to  and equate it to 0:
Equation:

                          2                              (x, y)

   2||x|| - 2 (x, y) = 0   =                                            2

                                                         ||x||

When this solution is substituted into the formula for the norm squared in
[link], we obtain
Equation:

   (x, y)                      2                   2(x, y) 2
                                                                     (x, y) + ||y||  0,
                  2                             2
                                                                    2
   ||x||                         ||x|| -
                                                     ||x||

which simplifies to
Equation:

                            2  2                      2  2                 2

      (x, y)                   + ||y||  0  (x, y)  ||x|| ||y|| .

-

                         2

       ||x||

The proof of the Cauchy-Schwarz inequality is completed by taking the
positive square root on both sides of [link]. When y = x, then
Equation:
2                2        2                                      22

(x, y) = (x, x)     = [|| (x, x)] = (||||x|| )

                       2                             2        2

                    =  (|| ||x|| )||x||

                                                           2

                    =  (x, x)||x||

                                                        2

                    =  (y, y)||x||

                             2                          2

                    =  ||y|| ||x|| ,

which shows that equality holds in [link] when y is a scalar multiple of x.
Exercise:

   Problem:

   Use the Cauchy-Schwarz inequality to prove the triangle inequality,
   which states
   Equation:

                                                            ||x + y||  ||x|| + ||y||.

Explain why this is called the triangle inequality.
Linear Algebra: Direction Cosines

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Unit Vectors. Corresponding to every vector x is a unit vector ux pointing
in the same direction as x. The term unit vector means that the norm of the
vector is 1:
Equation:

                                                                           ||ux || = 1.

The question is, given x, how can we find ux? The first part of the answer
is that ux will have to be a positive scalar multiple of x in order to point in
the same direction as x, as shown in [link]. Thus
Equation:

                                                                             ux = x.

                  The Unit Vector ux
But what is ? We need to choose  so that the norm of ux will be 1:
Equation:

           ||ux || = 1

Equation:

           |x|| = 1

Equation:

           ||||x|| = 1

Equation:

           =        1
                 ||x||

We have dropped the absolute value bars on  because ||x|| is positive. The
 that does the job is 1 over the norm of x. Now we can write formulas for
ux in terms of x and x in terms of ux :
Equation:

           ux =     1
                            x,

                 ||x||

Equation:

           x = ||x||ux .

So the vector x is its direction vector ux, scaled by its Euclidean norm.

Unit Coordinate Vectors. There is a special set of unit vectors called the
unit coordinate vectors. The unit coordinate vectorei is a unit vector in n
that  points  in  the  positive  direction  of  the     th  coordinate  axis.  [link]  shows

                                                     i

the three unit coordinate vectors in 3.

      Unit Coordinate Vectors in R3

For three-dimensional space,R3, the unit coordinate vectors are
Equation:

                       e1 =      1              0           0
                                 0 , e2 =       1 , e3 =    0.
                                 0              0           1

More generally, in n-dimensional space, there are n unit coordinate vectors
given by
You should satisfy yourself that this definition results in vectors with a
norm of l.
Exercise:

   Problem: Find the norm of the vector au where u is a unit vector.
Exercise:

Problem: Find the unit vector ux in the direction of

                    3

a. x = [ ] ;

                    4
                     3

b. x = 6 ;

                     -2
                     1

c. x =  -1
                   .

        1

        -1
Direction Cosines. We often say that vectors "have magnitude and
direction." This is more or less obvious from "Linear Algebra: Vectors",

where  the  three-dimensional       vector    x  has  length  x2              +   x2      +  x2      and

                                                                           1           2          3

points in a direction defined by the components x1, x2, and x3. It is
perfectly obvious from [link] where x is written as x = ||x||ux. But perhaps

there is another representation for a vector that places the notion of

magnitude and direction in even clearer evidence.

[link] shows an arbitrary vector x  R 3 and the three-dimensional unit

coordinate vectorse1, e2, e3. The inner product between the vector x and

the  unit  vector  ek  just  reads  out  the      th  component  of           x:

                                              k

Equation:

                             (x, ek ) = (ek , x) = xk .

Since this is true even in Rn, any vector x  R n has the following
representation in terms of unit vectors:
Equation:

                                   x = (x, e1 )e1 + (x, e2 )e2 +  + (x, en )en .

     The Three-Dimensional Unit Vectors
Let  us  now  generalize  our  notion  of  an  angle    between  two  vectors  to        n

                                                                                   R

as follows:

Equation:

                               cos  =         (x, y)
                                           ||x||||y||

The celebrated Cauchy-Schwarz inequality establishes that -1-  cos
  1. With this definition of angle, we may define the angle k that a
vector makes with the unit vector ek to be
Equation:

                               cos k =        (x, ek )
                                           ||x||||ek ||

But the norm of ek is 1, so
Equation:

                                       (x, ek )         xk

                          cos k =                 =

                                           ||x||        ||x||

When this result is substituted into the representation of x in [link], we
obtain the formula
Equation:

     x = ||x|| cos 1 e1 + ||x|| cos 2 e2 +  + ||x|| cos n en

         =    ||x||(cos 1 e1 + cos 2 e2 +  + cos n en ).

This formula really shows that the vector x has "magnitude" ||x|| and
direction (1, 2, ..., n) and that the magnitude and direction are sufficient
to determine x. We call ( cos 1, cos 2, ..., cos n) the direction cosines for
the vector x. In the three-dimensional case, they are illustrated in [link].
Exercise:
   Problem:

   Show that [link] agrees with the usual definition of an angle in two
   dimensions.
Exercise:

Problem: Find the cosine of the angle between x and y where

a. x =  1         2
        0 , y=
        0         2;
        1
                  2
                      -1

b. x =  -1        0       ;

            , y=

        1         1

        -1        0

        2         4

c. x = 1 , y = 2

        -2        -4

If we compare [link] and [link] we see that the direction vector ux is
composed of direction cosines:
Equation:

ux =cos 1 e1 + cos 2 e2 +  + cos n en =                cos1
                                                       cos2

                                                                         .
                                                       

                                                       cosn

With this definition we can write [link] compactly as
Here x is written as the product of its magnitude ||x|| and its direction
vector ux. Now we can give an easy procedure to find a vector's direction
angles:

(i) find ||x||;

(ii) calculate ux =  x      ; and

                     ||x||

(iii) take the arc cosines of the elements of ux.

Step (iii) is often unnecessary; we are usually more interested in the
direction vector (unit vector) ux. Direction vectors are used in materials
science in order to study the orientation of crystal lattices and in
electromagnetic field theory to characterize the direction of propagation for
radar and microwaves. You will find them of inestimable value in your
courses on electromagnetic fields and antenna design.
Exercise:

   Problem:

   Sketch an arbitrary unit vector u  R 3. Label the direction cosines
   and the components of u. S

Exercise:

   Problem:

                                                                                                                                                              4

   Compute the norm and the direction cosines for the vector x = 2 .

                                                                                                                                                              6

Exercise:
   Problem:

Prove that the direction cosines for any vector satisfy the equality
Equation:

                     2             2  2
                 cos 1 + cos 2 +  + cos n = 1.
   What does this imply about the number of scalars needed to determine
   a vector x  R n ?

Exercise:

   Problem:

   Astronomers use right ascension, declination, and distance to locate

                                                                                                             

   stars. On [link] these are, respectively, -, - 3, and ||x||.

                                                                                                             2

   Represent x = (x1, x2, x3) in terms of , 3, and ||x|| only. (That is,
   find equations that give , 3, and ||x|| in terms of x1, x2, and x3, and
   find equations that give x1, x2, and x3 in terms of , 3, and ||x||. )

Exercise:

   Problem:

   (MATLAB) Write a MATLAB function that accepts any vector
   x  R n and computes its norm and direction cosines. Make x an input
   variable, and make ||x|| and ux output variables.

Exercise:

   Problem:

Let  x  and  y  denote  two    vectors       in        n  with  respective  direction  cosines

                                                 R

( cos 1, cos 2, ..., cos n) and ( cos 1, cos 2, ..., cos n). Prove

that , the angle between x and y, is

Equation:

cos  =cos 1 cos 1 + cos 2 cos 2 +  + cos n cos n .

Specialize   this  result  to        2  for  insight.

                               R

Exercise:
Problem:

          2  2

Compute the angle between the vectors x = 3 and 3 . Sketch the

          0  1

result.
Linear Algebra: Projections

Note:This module is part of the collection, A First Course in Electrical and
Computer Engineering. The LaTeX source files for this collection were
created using an optical character recognition technology, and because of
this process there may be more errors than usual. Please contact us if you
discover any errors.

Orthogonality. When the angle between two vectors is /2(90 ) 0 , we say
that the vectors are orthogonal. A quick look at the definition of angle
(Equation 12 from "Linear Algebra: Direction Cosines") leads to this
equivalent definition for orthogonality:
Equation:

                                        (x, y) = 0  x and y are orthogonal.

                                                 3  -2
For example, in Figure 1(a), the vectors x = [ ] and y = [ ] are clearly

                                                 1  6

orthogonal, and their inner product is zero:

Equation:

           (x, y) = 3(-2) + 1(6) = 0.

                             3                -2    0

In Figure 1(b), the vectors x = 1 , y = 6 , and z = 0 are

                             0                0     4

mutually orthogonal, and the inner product between each pair is zero:

Equation:

           (x, y) = 3(-2) + 1(6) + 0(0) = 0

Equation:
Equation:        (x, z) = 3(0) + 1(0) + 0(4) = 0
              (y, z) = -2(0) + 6(0) + 0(4) = 0.

              Orthogonality of Vectors

Exercise:

Problem: Which of the following pairs of vectors is orthogonal:

           1            0

a. x = 0 , y = 1 ;

           1            0

           1            1

b. x = 1 , y = 1 ;

           0            1

c. x = e1, y = e3 ;

           a         -b
d. x = [ ] , y = [ ]?

           b         a

We can use the inner product to find the projection of one vector onto
another as illustrated in Figure 2. Geometrically we find the projection of x
onto y by dropping a perpendicular from the head of x onto the line
containing y. The perpendicular is the dashed line in the figure. The point
where the perpendicular intersects y (or an extension of y) is the projection
of x onto y, or the component of x along y. Let's call it z.

Component of One Vector along
              Another

Exercise:
   Problem:
   Draw a figure like Figure 2 showing the projection of y onto x.

The vector z lies along y, so we may write it as the product of its norm ||z||
and its direction vector uy :
Equation:

                               y

z = ||z||uy = ||z||                   .

                               ||y||

But what is norm ||z||? From Figure 2 we see that the vector x is just z, plus
a vector v that is orthogonal to y:
Equation:

                                                             x = z + v, (v, y) = 0.

Therefore we may write the inner product between x and y as
Equation:
           (x, y) = (z + v, y) = (z, y) + (v, y) = (z, y).

But because z and y both lie along y, we may write the inner product (x, y)
as
Equation:

(x, y) = (z, y) = (||z||uy , ||y||uy ) = ||z||||y|| (uy , uy )

                                                      2

           =                        ||z||||y||||uy|| = ||z||||y||.

From this equation we may solve for ||z|| =           (x, y)             and substitute ||z|| into

                                                                  ||y||

Equation 6 to write z as

Equation:

                          z=                                  y
                                 =
                                            ||z||

                                                           ||y||

                                    (x,y)      y   =  (x,y)
                                     ||y||  ||y||
                                                                y.

                                                      (y,y)

Equation 10 is what we wanted-an expression for the projection of x onto y
in terms of x and y.
Exercise:

   Problem:

   Show that ||z|| and z may be written in terms of cos  for  as
   illustrated in Figure 2:
   Equation:

                          ||z|| = ||x|| cos 

Equation:

                          z=        ||x|| cos 
                                                             y.

                                           ||y||
Orthogonal Decomposition. You already know how to decompose a vector
in terms of the unit coordinate vectors,
Equation:

                                    x = (x, e1 )e1 + (x, e2 )e2 +  + (x, en )en .

In this equation, (x, ek)ek is the component of x along ek, or the projection
of x onto ek, but the set of unit coordinate vectors is not the only possible
basis for decomposing a vector. Let's consider an arbitrary pair of orthogonal
vectors x and y:
Equation:

                                                                            (x, y) = 0.

The sum of x and y produces a new vector w, illustrated in Figure 3, where
we have used a two-dimensional drawing to represent n dimensions. The
norm squared of w is

       2

||w||     = (w, w) = [(x + y), (x + y)] = (x, x) + (x, y) + (y, x) + (y, y)

                                  2  2

          =                       ||x|| + ||y|| .

This is the Pythagorean theorem in n dimensions! The length squared of w
is just the sum of the squares of the lengths of its two orthogonal
components.

       Sum of Orthogonal Vectors
The projection of w onto x is x, and the projection of w onto y is y:
Equation:

                                                                    w = (1)x + (1)y.

If we scale w by a to produce the vector z = aw, the orthogonal
decomposition of z is
Equation:

                                                             z = aw = (a)x + (a)y.

Let's turn this argument around. Instead of building w from orthogonal
vectors x and y, let's begin with arbitrary w and x and see whether we can
compute an orthogonal decomposition. The projection of w onto x is found
from Equation 10:
Equation:

wx =  (w, x)
                      x.

      (x, x)

But there must be another component of w such that w is equal to the sum of
the components. Let's call the unknown component wy. Then
Equation:

                                                                       w = wx + wy.

Now, since we know w and wx already, we find wy to be
Equation:

wy = w - wx = w -  (w, x)
                                   x.

                   (x, x)
Interestingly, the way we have decomposed w will always produce wx and
w>y orthogonal to each other. Let's check this:
Equation:

(wx , wy ) =                 (w,x)                  w-  (w,x)
                          =
                          =             x,                         x
                          =
                             (x,x)                      (x,x)

                             (w,x)                                          2

                                        (x, w) -        (w,x)

                             (x,x)                               2 (x, x)

                                                        (x,x)

                                                 2  -                       2

                             (w,x)                      (w,x)

                              (x,x)                      (x,x)

                                                    0.

To summarize, we have taken two arbitrary vectors, w and x, and
decomposed w into a component in the direction of x and a component
orthogonal to x.
Linear Algebra: Other Norms

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Sometimes we find it useful to use a different definition of distance,
corresponding to an alternate norm for vectors. For example, consider the l-
norm defined as
Equation:

                                               ||x||1 = (|x1 |+|x2 |+  +|xn |),

where |xi| is the magnitude of component xi. There is also the sup-norm,
the "supremum" or maximum of the components x1, ..., xn :
Equation:

                                             ||x||sup =max (|x1 |, |x2 |, ..., |xn |).

The following examples illustrate what the Euclidean norm, the l-norm, and
the sup-norm look like for typical vectors.

Example:                 -3
Consider the vector x =
                         l . Then

                         2
                                                                      1/2

i. ||x|| = [(-3) + (1) + (2) ] 2 2 2                                       = (14)1/2 ;

ii.  ||x||            =  (|  -  3|  +  |1|  +                |2|)  =  6;  and

                   1

iii. ||x||sup =max (| - 3|, |1|, |2|) = 3.

Example:

                                                                                                                                        x1

Figure 1 shows the locus of two-component vectors x = [ ] with the

                                                                                                                                        x2

property  that           ||x||  =   1, ||x||                 =  1,  or  ||x||              =  1.

                                                          1                           sup

       Locus of Two-Dimensional Vectors Whose
                     Various Norms Are 1

The next example shows how the l-norm is an important part of city life.
Example:
The city of Metroville was laid out by mathematicians as shown in Figure
2. A person at the intersection of Avenue 0 and Street -2 (point A) is
clearly two blocks from the center of town (point C). This is consistent
with both the Euclidean norm
Equation:

                                               ||A|| = 02 2 + (-2) = 4 = 2

and the l-norm
Equation:

                                                      ||A|| = (|0| + | - 2|) = 2.

                                                                                             1

But how far from the center of town is point B at the intersection of
Avenue-2 and Street 1? According to the Euclidean norm, the distance is
Equation:

                                                 ||B|| = (-2) + (1) = 2 2 5.
                      Metroville, U.S.A.

While it is true that point B is 5 blocks from C, it is also clear that the
trip would be three blocks by any of the three shortest routes on roads. The
appropriate norm is the l-norm:
Equation:

                                                                                  B

                                                       1 || = (| - 2| + |1|) = 3.

                                                                                            1

Even more generally, we can define a norm for each value of p from 1 to
infinity. The so-called p-norm is
Equation:

             p  p  p 1/p

             |Ix||p = (|x1 +|x2 +  +|xn | ) .

Exercise:
   Problem:

Show that the Euclidean norm is the same as the p-norm with p = 2
and that the 1-norm is the p-norm with p = 1. (It can also be shown
that the sup-norm is like a p-norm with p = .)

DEMO 4.1 (MATLAB). From the command level of MATLAB, type the
following lines:

>> x = [1;3;-2;4]
>> y = [0;1;2;-0.5]
>> x - y

Check to see whether the answer agrees with the definition of vector
subtraction. Now type
>> a = -1.5
>> a * x

Check the answer to see whether it agrees with the definition of scalar
multiplication. Now type

>> x' * y

This is how MATLAB does the inner product. Check the result. Type

>> norm(y)
>> sqrt(y' * y)

>> norm(y,1)
>> norm(y' * y)

Now type your own MATLAB expression to find the cosine of the angle
between vectors x and y. Put the result in variable t. Then find the angle 
by typing

>> theta = acos(t)

The angle  is in radians. You may convert it to degrees if you wish by
multiplying it by 180/:

>> theta = theta * (180/pi)
Linear Algebra: Matrices

Note:This module is part of the collection, A First Course in Electrical and Computer Engineering. The LaTeX
source files for this collection were created using an optical character recognition technology, and because of this
process there may be more errors than usual. Please contact us if you discover any errors.

The word matrix dates at least to the thirteenth century, when it was used to describe the rectangular copper tray, or
matrix, that held individual leaden letters that were packed into the matrix to form a page of composed text. Each
letter in the matrix, call it aij, occupied a unique position (ij) in the matrix. In modern day mathematical parlance,
a matrix is a collection of numbers arranged in a two-dimensional array (a rectangle). We indicate a matrix with a
boldfaced capital letter and the constituent elements with double subscripts for the row and column:

                             Matrix

In this equation A is an m x n matrix, meaning that A has m horizontal rows and n vertical columns. As an

extension of the previously used notation, we write A  R mxn to show that A is a matrix of size m x n with

a ij     R.  The  scalar  element  a ij  is  located  in  the  matrix  at    the      th  row  and  the     th  column.                                                                        For  example,  a 23  is

                                                                                   i                     j

located in the second row and the third column as illustrated in [link].

The main diagonal of any matrix consists of the elements aii. (The two subscripts are equal.) The main diagonal
runs southeast from the top left corner of the matrix, but it does not end in the lower right corner unless the matrix
is square ( R m×m).

The transpose of a matrix A  R m×n is another matrix B whose element in row j and column i is bji = aij for

1     i      m  and  1    j    n.  We    write  B  =        T  to  indicate  that  B      is  the  transpose    of  A.  In                                                                     MATLAB,  transpose       is

                                                      A

denoted by A'. A more intuitive way of describing the transpose operation is to say that it flips the matrix about its

main diagonal so that rows become columns and columns become rows.

Exercise:

                                                                                                                                                                                           21

   Problem: If A  R m×n, then AT ?. Find the transpose of the matrix A = 5 4 .

                                                                                         -
                                                                                                                                                                                           79

Matrix Addition and Scalar Multiplication. Two matrices of the same size (in both dimensions) may be added
or subtracted in the same way as vectors, by adding or subtracting the corresponding elements. The equation
C = A ± B means that for each i and j, cij = aij ± bij. Scalar multiplication of a matrix multiplies each element
of the matrix by the scalar:
Equation:
                                              aX =           ax 11      ax 12     ax 13   ... ax1n
                                                             ax 21      ax 22     ax 23   ... ax2n
                                                             ax 31      ax 32     ax 33   ... ax3n .

                                                                                               

                                                             ax ml      ax m2     ax m3   ... axmn

Matrix Multiplication. A vector can be considered a matrix with only one column. Thus we intentionally blur the
distinction between R n×1 and Rn. Also a matrix can be viewed as a collection of vectors, each column of the

matrix being a vector:

Equation:

                                                                                    a 11       a l2         a 1n

                                                  |       |          |

                                                                                    a 21       a 22         a 2n

                                      A = al a2 ... an =                                                          .

                                                                                    |          |            |

                                                  |       |          |

                                                                                    a m1       a m2         a mn

In the transpose operation, columns become rows and vice versa. The transpose of an n × 1 matrix, a column
vector, is a 1 ×n matrix, a row vector:
Equation:

                                                                     x1

                                                             x=      x2           T
                                                                     |
                                                                          ; x = [x1 x2 xn ].

                                                                     xn

Now we can define matrix-matrix multiplication in terms of inner products of vectors. Let's begin with matrices
A  R m×n and B  R n×p. To find the product AB, first divide each matrix into column vectors and row vectors
as follows:

Thus   ai  is  the  i th  column  of  A  and  T       is  the  j th  row  of  A.  For    matrix   multiplication  to  be  defined,  the   width  of  the

                                                   j

first  matrix  must       match  the  length  of  the     second     one  so  that  all  rows       T  and  columns  bi  have  the  same  number     of

                                                                                               

                                                                                                    i

elements n. The matrix product, C = AB, is an m × p matrix defined by its elements as cij = (i, bj). In words,

each element of the product matrix, cij, is the inner product of the ith row of the first matrix and the jth column of

the second matrix.
For n-vectors x and y, the matrix product xT y takes on a special significance. The product is, of course, a 1 × 1
matrix (a scalar). The special significance is that xT y is the inner product of x and y:

Thus  the  notation               T  y  is  often  used  in     place   of  (x,  y).  Recall  from  Demo   1   from   "Linear  Algebra:  Other  Norms"

                              x

that MATLAB uses x'*y to denote inner product.

Another special case of matrix multiplication is the outer product. Like the inner product, it involves two vectors,
but this time the result is a matrix:

In the outer product, the inner products that define its elements are between one-dimensional row vectors of x and

one-dimensional               column        vectors  of      T  ,  meaning  the  (i,  j)  element   of  A  is  xiyj.

                                                         y

Exercise:

Problem: Find C = AB where A and B are given by

                                                     0 -2               1 -3
                                                     42
                           1  -1        2      B=    2 -2               20       ;
                              0            ],
      a. A = [
                                        5
                           3

                                                                        31

      b. A = [10                               1234                ] ;

                              ], B = [

           01                                  5678

                1 -1 -1                                  036

      c. A = 1 -1 1 , B = 1 4 7 .

                11                      1                258

There are several other equivalent ways to define matrix multiplication, and a careful study of the following
discussion should improve your understanding of matrix multiplication. Consider A  R m×n, B  R n×p, and
C = AB so that C  R m×p. In pictures, we have
Equation:

                                                                                                                   p np
                                                                                                         m [C] = m [A][ ]n.

                                                                                                                                                      B

In our definition, we represent C on an entry-by-entry basis as
Equation:

                                                                                                                                                                                                              n

                                                                                                     cij = (i , bj ) =  aik bkj .

                                                                                                                                                                                                          k=1
In pictures,

You will prove in Exercise 3 that we can also represent C on a column basis:
Equation:

                                                                                                                                                                                           n

                                                                                                                    cj =  ak bkj .

                                                                                                                                                                                       k=1

Finally, C can be represented as a sum of matrices, each matrix being an outer product:
Equation:

                                                                                                                                                                                            n
                                                                                                                                                                                                               T

                                                                                                                      C =  aii

                                                                                                                                                                                         i=1

A numerical example should help clarify these three methods.

Example:
Let
Equation:

           A=  1213                                           121
               2 1 2 4 , B=
               3321                                           221
                                                                                    .

                                                              132

                                                              211

Using the first method of matrix multiplication, on an entry-by-entry basis, we have
Equation:

                                       4

               cij =  aik bkj

                                   k=1

or
Equation:
C=         (1  1 + 2  2 + 1  1 + 3  2) (1  2 + 2  2 + 1  3 + 3  1) (1  1 + 2  1 + 1  2 + 3  1)
           (2  1 + 1  2 + 2  1 + 4  2) (2  2 + 1  2 + 2  3 + 4  1) (2  1 + 1  1 + 2  2 + 4. 1)
           (3  1 + 3  2 + 2  1 + 1  2) (3  2 + 3  2 + 2  3 + 1  1) (3  1 + 3  1 + 2  2 + 1  1)

or
Equation:

                                                           C=  12 12 8
                                                               14 16 11 .
                                                               13 l9 l1

On a column basis,
Equation:

                                                                                 4

                                                           cj =  ak bkj

                                                                             k=1

1          2          1             3                      1     2                                   1                            3          1                         2     1
                                                           2 2+  1 2+                                2 3+                         4 1; c3 =  2 1+                      1 1+  2 2+
c1 = 2 1 + 1 2 + 2 1 + 4 2; c2 =                           3     3                                   2                            1          3                         3     2

3          3          2             1

Collecting terms together, we have

Equation:

C=                                                                                            C = [c1 c2 c3 ]
           (1  1 + 2  2 + 1  1 + 3  2) (1  2 + 2  2 + 1  3 + 3  1) (1  1 + 2  1 + 1  2 + 3  1)
           (2  1 + 1  2 + 2  1 + 4  2) (2  2 + 1  2 + 2  3 + 4  1) (2  1 + 1  1 + 2  2 + 4. 1)
           (3  1 + 3  2 + 2  1 + 1  2) (3  2 + 3  2 + 2  3 + 1  1) (3  1 + 3  1 + 2  2 + 1  1)

On a matrix-by-matrix basis,
Equation:

                                                                                4

                                                                                                  T

                                                           C =  aii

                                                                            i=1

Equation:

                   1                                    2                                                                      1                                    3  111
   C= 2               121 + 1                              221 + 132 + 2                                                          132 + 4

                   3                                    3                                                                      2                                    1

Equation:

           11 12 11                    22 22 21                  11 13 12                                                         32 31 31

   = 21 22 21 + 12 12 11 + 21 23 22 + 42 41 41

           31 32 31                    32 32 31                  21 23 22                                                         12 11 11

Equation:

C=         (1  1 + 2  2 + 1  1 + 3  2) (1  2 + 2  2 + 1  3 + 3  1) (1  1 + 2  1 + 1  2 + 3  1)
           (2  1 + 1  2 + 2  1 + 4  2) (2  2 + 1  2 + 2  3 + 4  1) (2  1 + 1  1 + 2  2 + 4. 1)
           (3  1 + 3  2 + 2  1 + 1  2) (3  2 + 3  2 + 2  3 + 1  1) (3  1 + 3  1 + 2  2 + 1  1)
as we had in each of the other cases. Thus we see that the methods are equivalent-simply different ways of
organizing the same computation!

Exercise:
   Problem:

   Prove that Equations 9, 11, and 13 are equivalent definitions of matrix multiplication. That is, if C = AB
   where A  R m×n and B  R n×p, show that the matrix-matrix product can also be defined by
   Equation:

                                                                                                                                                                                          n

                                                                                                                  cij =  aik bkj ,

                                                                                                                                                                                      k=1

and,  if  ck  is  the      th    column    of  C  and  ak   is  the      th  column       of  A,   then

                       k                                             k

Equation:

                                                                                           n

                                                                     cj =  ak bkj .

                                                                                        k=1

Show that the matrix C may also be written as the , "sum of outer products"
Equation:

                                                                                                                                                                                  n
                                                                                                                                                                                                        T

                                                                                                              C =  akk .

                                                                                                                                                                              k=1

Write  out    the  elements         in  a  typical  outer   product                 T  .

                                                                       ak

                                                                                    k

Exercise:

Problem:

Given     A       R  m×n         B    R    p×q ,  and  C    R   r×s ,  for   each         of  the  following  postulates,                                                                                  either  prove  that  it  is  true

                              ,

or give a counterexample showing that it is false:

a. (A ) T = A T .
b. AB = BA when n = p and m = q. Is matrix multiplication commutative?
c. A(B + C) = AB + AC when n = p = r and q = s. Is matrix multiplication distributive over

  addition?
d. (AB ) = B A T T T when n = p.
e. (AB)C = A(BC) when n = p and q = r. Is matrix multiplication associative?

Example:
Rotation
We know from the chapter on complex numbers that a complex number z1 = x1 + jy1 may be rotated by angle 
in the complex plane by forming the product
Equation:

                                                                                                                                                                                                j

                                                                                                                       z2 = e z1.
When written out, the real and imaginary parts of z2 are
Equation:

           z2 =                                                                        (cos  + j sin ) (x1 + jy1 )

                             = (cos )x1 - (sin )y1 + j [(sin )x1 + (cos )y1 ].

If the real and imaginary parts of z1 and z2 are organized into vectors z1 and z2 as in the chapter on complex
numbers, then rotation may be carried out with the matrix-vector multiply
Equation:

                                                                                       x2     cos  -sin                 x1
                                                                                                                  ]  [ ].
                             z2 = [ ] = [
                                                                                                   cos                  y1
                                                                                       y2     sin

We call the matrix R () = [cos -sin                                                    ] a rotation matrix.

           sin cos

Exercise:

Problem: Let R() denote a 2 × 2 rotation matrix. Prove and interpret the following two properties:

a. RT () = R (-);                                                                      0
                                                                                          ].
                                                                                    1
                                                                                       1
b. RT ()R () = R ()RT () = [

                                                                                    0
Linear Algebra: Solving Linear Systems of Equations

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

We are now equipped to set up systems of linear equations as matrix- vector
equations so that they can be solved in a standard way on a computer.
Suppose we want to solve the equations from Example 1 from "Linear
Algebra: Introduction" for x1 and x2 using a computer. Recall that
Equations 1 and 2 from Linear Algebra: Introduction are
Equation:

x1 + x2 = 85

x1   =         x2
1.2     1.5-1.2

The first step is to arrange each equation with all references to x1 in the
first column, all references to x2 in the second column, etc., and all
constants on the right-hand side:
Equation:

                                                                        x1 + x2 = 85

                                                              0. 3x1 - 1. 2x2 = 0.

Then the equations can be converted to a single matrix-vector equation. The
coefficients form a matrix, keeping their same relative positions, and the
variables and constants each form a vector:
Equation:
                                 1        1      x1                                        85
                              [
                                                 ][ ] = [ ].
                                 0. 3
                                          -1. 2 x2                                         0

Exercise:
   Problem:

Verify by the rules of matrix multiplication that the system of
equations in 2 in equivalent to the matrix equation in 3.

Equation 3 is of the general form
Equation:

                                                                               Ax = b

where in this case
Equation:

                                1      1                                               xl                85
                 A=[                                                                       b = [ ].
                                              ], x = [ ],
                                0. 3                                                                     0
                                       -1. 2                                           x2

Given  any  A            n×n  and     b    R n,  MATLAB                                    can  solve  Equation  4  for  x

                 R

(as long as a solution exists). Key ideas in the solution process are the

identity matrix and the inverse of a matrix.

When the matrix A is the 1 × 1 matrix a, the vector x is the l-vector x, and
the vector b is the l-vector b, then the matrix equation Ax = b becomes the
scalar equation
Equation:

                                             ax = b.

The scalar a-1 is the inverse of the scalar a, so we may multiply on both
sides of Equation 6 to obtain the result
Equation:
                                  a-1 (ax) = a-1 b
                                        1x = a-1 b.

We would like to generalize this simple idea to the matrix equation Ax = b
so that we can find an inverse of the matrix A, called A-1, and write
Equation:

                                                                 A-1 (Ax) = A-1 b

                                                                                                                                   -1

                                                                         I x = A b.

In this equation the matrix I is the identity matrix
Equation:

                                  1 0 0 ... 0

                                  0 1 0 ... 0

                              I=  0 0 1 ... 0         .

                                     
                                  0 0 0 ... 1

It is clear that the identity matrix I and the inverse of a matrix, A-1, play a
key role in the solution of linear equations. Let's study them in more detail.

The Matrix Identity. When we multiply a scalar by 1, we get back that

same scalar. For this reason, the number 1 is called the

multiplicativeidentity element. This may seem trivial, but the generalization

to matrices is more interesting. The question is, is there a matrix that, when

it multiplies another matrix, does not change the other matrix? The answer

is yes. The matrix is called the identity matrix and is denoted by I. The

identity matrix is always square, with whatever size is appropriate for the

matrix multiplication. The identity matrix has l's on its main diagonal and

      everywhere  else.  For  example,

0s

Equation:
I5 =  10000
      01000
      0 0 1 0 0.
      00010
      00001

The subscript 5 indicates the size. In terms of the unit coordinate vectors ei,
we can also write the n × n identity matrix as
Equation:

      |  |  |

In = e1 e2 ... en .

      |  |  |

For any matrix A  R n×p, we have
Equation:

                                                                            A = In A.

For p = 1, we obtain the following special form for any vector x  R n :
Equation:

                                                                              x = In x.

This last equation can be written as the sum
Equation:

                                                                                                                          n

                                                                        x =  xiei.

                                                                                                                       i=1

This is a special case of one of the results you proved in Exercise 3 from
"Linear Algebra: Matrices". Figure 1 illustrates Equation 14 and shows how
the vector x can be broken into component vectors xiei, each of which lies

in  the  direction  of  one  coordinate  axis.  The  values  of  the         are  the

                                                                      xis

coordinates of x, and their magnitudes are also the lengths of the

component vectors.

        Breaking a Vector into Components

Exercise:
   Problem:

   Use Equation 13 and the rules for matrix multiplication to show that
   x  R n may also be written as
   Equation:

                                                                                                                  n

                                                                  x =  (x, ei )ei .

                                                                                                               i=1

This verifies Equation 11 from "Linear Algebra: Direction Cosines".

When the product of two numbers is 1 (the identity element), we say that
they are inverses of each other, like 2 and 0.5. Likewise, we say that two
square matrices are inverses of each other if their product is the identity
matrix:
Equation:

                                                                                           -1

                           AB = I  B = A .

An interesting and useful result is implied by this definition. Take the first
form of Equation 16 and multiply by B from the left:
Equation:

                                       AB = I

                                B(AB) = BI

                                (BA)B = B

                                       BA = I.

We emphasize that the inference made in the last step here is only valid
when B and A are square matrices. The result means that, even though
matrix multiplication is not commutative in general, we have a special case
where it is commutative. If A and B are inverses of each other, then
Equation:

                               AB = BA = I.

Exercise:
   Problem:

Prove  that  the  inverse  of  the  2  ×2  rotation  matrix                                    R()  is        T  ().

                                                                                                        R

Matrices that are not square do not have inverses. In fact, not all square
matrices have inverses. So it becomes an important issue to determine
which matrices do have inverses. If a matrix has an inverse, the inverse is
unique. If a square matrix has no inverse, it is called a singular matrix. The
determinant of a square matrix is a scalar computed from the numbers in
the matrix. It tells us whether a matrix will have an inverse or not. A matrix
is singular if and only if its determinant is zero.[footnote] In MATLAB, the
notation det(A) is used to compute the determinant. Whenever the matrix
A in Equation 4 is singular, it means one of two things about the system of
equations represented: either the equations are inconsistent and there is no
solution, or the equations are dependent and there are infinitely many
solutions.
It is not important now to understand how the determinant is defined and
computed from the elements of a matrix. In your more advanced courses
you will study the determinant in some detail.

Solving Ax = b. Let's now study ways to solve the matrix equation
Ax = b. We will assume that a unique solution for x exists. Thus a unique
matrix A-1 exists with the property A-1A = I. The trick is to find it. Here
is one procedure.

For convenience, rewrite the matrix equation Ax = b as
Equation:

                                          x

                     [Ab][                        ] = 0.

                                          -1

The  matrix  [Ab]            nx(n+1)  is  called  the  augmented  matrix  for  the  system

                     R

of equations. The augmented matrix may be viewed as a systematic way of

writing all the information necessary to solve the equations.

The advantage of Equation 19 is that we may premultiply both sides by any
matrix C1 (of compatible size), and the right-hand side remains zero
(although this is equivalent to multiplying on both sides of Equation 4,
which some may prefer). We can repeat this operation as often as we like
with matrices C2, C3, etc. The general result is
Equation:

                                                          x

             [Cm  C2 C1 ACm  C2 C1 b][                        ] = 0.

                                                          -1

Now suppose that we have found a sequence of matrices C1, ... , Cm that
transforms the matrix A to the identity matrix:

Cm  C2C1A = I. The augmented matrix equation in 20 simplifies to
Equation:

                                                      x

                       [I Cm  C2 C1 b][                                             ] = 0,

                                                      -1

which can be multiplied out to reveal that the solution for x is
Equation:

                                                                x = Cm  C2 C1 b.

The method may be summarized as follows:

 i. form the augmented matrix [Ab] for the system;
ii. premultiply [Ab] by a sequence of selected matrices Ci, designed to

    take A to I; and
iii. when A is transformed to I, b will be transformed to x, so the solution

    will appear as the last column of the transformed augmented matrix.

We may also conclude that the product of the matrices Ci must be the

inverse  of  A  since        -1  is  the  unique  matrix                            for  which        -1  =  I.  In

                       A                                                                        AA

solving for x by this method, we have found A-1 implicitly as the product

Cm  C2C1.

Example:
Consider the equation
Equation:

                                        3  1      x1                                6
                                     [        ]
                                                 [ ]=[ ]
                                        2  4
                                                  x2                                5

Equation:

                                                                          A x = b.

The augmented matrix for this equation is
Equation:

                                      316

                 [A b] = [                    ].

                                      245

Now if we could add -2/3 times the first row to the second row, we
would get 0 in the lower left corner. This is the first step in transforming A
to the identity I. We can accomplish this row operation with the matrix
Equation:

                                   1     0
                 C1 = [                     ]

                                   -2/3  1

Equation:

           C1    [A b]           3      1                6
                        =[              10/3                ].

                                 0                       1

Now adding -3/10 times the new second row to the first row will
introduce 0 in the (1, 2) position, bringing us closer still to the identity.
Thus
Equation:

                                   1  -3/10
                                                      ]
                 C2 = [
                                   0  1

Equation:

           C2C1  [A b]           3      0                57/10
                        =[              10/3                            ].

                                 0                       1

We now complete the transformation to identity by normalizing each row
to get the needed l's:
Equation:

                                   1/3  0
                                                    ]
                 C3 = [
                                   0    3/10
Equation:

                                                 1 0 19/10

                    C3 C2 C1 [A b] = [                                 ].

                                                 0 1 3/10

According to the last column, the solution is
Equation:

                                             19/10

                                  x=[                  ].

                                             3/10

We note in passing that the inverse of A is the product of the Cs, so

                                     1/3     0         1     -3/10 1                  0
                                  [                                                      ]
A   -1    = C3C2C1 =                                     ][            ][
                                     0       3/10 0                                   1
                                                             1              -2/3

                             1/3 -1/10           1                 0        2/5   -1/10

                     =[                          ][                   ]=[                   ]

                             0         3/l0      -2/3 1                     -1/5 3/10

The method we have just used, combined with a particular way of choosing

the Ci matrices, is called Gauss elimination. Gauss elimination requires less

computation than finding the inverse of A because only the effect of A-1

on the specific vector b is computed. MATLAB can solve for x by either

method, as shown in Demo 4.2. For hand computations, we suggest

choosing the Ci matrices so that C1 produces Os everywhere below the

diagonal in the first column, C2 produces Os below the diagonal in the

second column, and so on up to Cn-1. Then Cn produces Os above the

diagonal in the nth column, Cn+1 produces Os above the diagonal in

column n - 1, etc. The last one, , C2n-1 normalizes the diagonal elements

to  l's.  We  have  assumed  for  simplicity     that  no          on  the  diagonal  will  be

                                                           Os

encountered in hand computations.

Exercise:

    Problem:  Check  that          -1  =  I  in  Example     1

                             AA

Exercise:
   Problem:

   Augment Equation 3 as in Equation 19 and use the technique of Gauss
   elimination to solve for x.

Demo 1 (MATLAB). From the command level of MATLAB, solve the
matrix equation of Example 1 from "Linear Algebra: Introduction" by
typing

>> A = [1 1;0.3 -1.2]
>> b = [85;0]

You have entered the matrices A and b, which describe the problem. You
can now solve for x by finding the inverse of A and multiplying b:

>> x = inv(A) * b

In this example the inverse is computed quickly because A is a small
matrix. For a large (say, 30 × 30) matrix, the answer would take longer to
compute, and the more efficient method of Gauss elimination would reduce
waiting time. You can use Gauss elimination in MATLAB by typing

>> x = A \ b

You should get the same answer. Now type the MATLAB code required to
compute Ax and to show Ax - b = 0.
Exercise:

   Problem:

   (MATLAB) Write the following system of equations as Ax = b and
   solve using MATLAB:
   Equation:

                                              3 (x1 - x3 ) + 2 (x2 - 1) - 6 = x3

   Equation:

                                                                      4x3 = 7x2 - 5
Equation:

           6 (x1 + x2 + 2) = x3 + 1.
Linear Algebra: Circuit Analysis

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In this section we use the linear algebra we have developed to find the
voltages and currents in a simple electrical circuit, such as the one shown in
Figure 1. There are many reasons why this might be necessary; in this
example we need to know the current flowing through the lamp to tell
whether or not it will glow. Too little current will have no visible effect; too
much current will cause the lamp to burn out. We will apply a few physical
laws relating the voltages and currents in a circuit, turn these laws into
systems of linear equations, and solve the equations for the voltages and
currents.

                 A Simple Electrical Circuit

Current, Voltage, and Resistance. We will use three physical quantities in
our analysis of electrical circuits: current, voltage, and resistance. Current is
the flow of electrical charge from one place to another. Electrons flowing
through a wire or through some other electronic device comprise a current.
Voltage is a difference in electric potential that makes electrons flow.
Voltage is sometimes called electromotive force because it is like a "force"
that moves electrons. Resistance is a property of the device through which
the electron current flows. The lower the resistance of a device, the more
easily current can flow through the device.

The analogy of water flowing through pipes can help you develop intuition
about electrical circuits. In this analogy, electrical current corresponds to the
flow rate of water. Voltage corresponds to the pressure that forces the water
to flow, and resistance is the friction of flow. A small pipe would impede
the flow of water more than would a large pipe, so the small pipe would
correspond to a higher resistance. While this analogy can be helpful, keep
in mind that electricity is not water. All analogies break down at some
point.

We measure electrical current in amperes. The standard symbol for current
is i, and the direction of positive flow is indicated by an arrow on the circuit
diagram. The arrow is for reference only; if the true current is in the
opposite direction, we get negative values for i. Because electrons are
negatively charged, current is defined as flowing in the opposite direction as
electron motion. But to reduce confusion, you should learn to think in terms
of current rather than electron motion.

A point in a circuit where several devices are connected together is called a
node. The conservation law for current says that "what flows in must flow
out of a node," a principle known as Kirchhoff's current law. Kirchhoff's
current law states that the sum of all currents leaving a node is zero. In this
law, a current entering the node is considered to be a negative current
leaving the node.

Voltage is measured in volts and is usually written as v (or e). Since voltage
is a difference in potential between two points (nodes), we can show it on a
circuit diagram with a +and a -sign to indicate which two nodes we are
comparing and which one of the nodes is considered negative. As with
current, the markings are for reference only and we may end up with a
negative value of v.

In an electrical circuit, one node is usually chosen as a reference node and is
considered to have a voltage of zero. Then the voltage at every other node is
measured with respect to the reference node. This saves us the trouble of
always specifying pairs of nodes for voltage measurements and marking +
and - signs for each voltage. Other names for the reference node are
common and ground.
A constant voltage source is a device that always forces the voltage
between its two terminals to be a constant value. In Figure 1 the circle at the
left represents a constant voltage source of 5 volts, so that the voltage at the
upper (+) end is always exactly 5 volts higher than the voltage at the lower
(-) end. A voltage source is something like a battery, but idealized. Real
batteries do not maintain a constant output voltage under all conditions.
Resistance is measured in ohms and is denoted by R. A resistor is shown as
a zig-zag line in circuit diagrams and labeled with the value of its resistance
in ohms. In this chapter we will consider only devices whose resistance is
positive and the same in both directions. Ohm's law, also called the resistor
law, relates the voltage and current in a resistor. For the resistor shown in
Figure 2, with reference directions assigned to v and i as shown, Ohm's law
is
Equation:

                                                                               v = iR.

Note that current flows from + to - through the resistor.

                       Ohm's Law
Example:
Ohm's law and Kirchhoff's current law are the only principles we need to
write equations that will allow us to find the voltages and currents in the
resistive circuit of Figure 1. We begin by choosing a reference node and
assigning variables to the voltages at every other node (with respect to the
reference node). These choices are shown in Figure 3.

Assigning Node Voltages

The constant voltage source forces v1 to be exactly 5 volts higher than the
reference node. Thus
Equation:

                                                                               v1 = 5.

Next we write equations by applying Kirchhoff's current law to each node
in the circuit (except the reference node and v1, whose voltages we already
know). At the node labeled v2 are three paths for leaving current. The
current leaving through the 50 ohm resistor can be found by Ohm's law,
where the voltage across that resistor is v2 - v1 :
Equation:

       v     (v2 - v1 )

i50 =     =

       R                 50

For current leaving through the 300 ohm resistor, the voltage is v2. Pay
careful attention to the sign; since we are interested in the current leaving
the node labeled v2, Figure 4.14 indicates that to apply Ohm's law we
should take the voltage as +v2- reference = v2 - 0 = v2. So
Equation:

               i300 =                    v2
                                        300

For the 100 ohm resistor, we can write
Equation:

               i100 =        (v2 - v3 )
                                   100

According to Kirchhoff's current law, the sum of these three leaving
currents is zero:
Equation:

             (v2 -v1 )  +     v2        +    (v2 -v3 )  =0
                    50       300                  100

             6 (v2 - v1 ) + v2 + 3 (v2 - v3 ) = 0

               -6v1 + 10v2 - 3v3 = 0.

Notice that when we wrote the equation for the node labeled v2, the
variable v2 had a + sign each time it occurred in the equation, while the
others had a -sign. This is always the case, and watching for it can help you
avoid sign errors. Now we apply Kirchhoff's current law at the node
labeled v3 to get the equation
Equation:

               (v3 -v2 )                   v3

                        100             +  2   =0

               (v3 - v2 ) + 50v3 = 0
             
               0v1 - 1v2 + 51v3 = 0.

Note that this time it is v3 that always shows up with a + sign.
Equations 2, 6, and 7 give us a system of three equations in the three
unknown variables v1, v2, and v3. We now write them in matrix form as
Equation:
             1      0      0  vl        5

             -6 10 -3         v2 = 0 

             0      -1 51     v3        0

Exercise:
   Problem:

(MATLAB) Use MATLAB to solve Equation 8. You should find
Equation:

                    v1 = 5. 0000 volts

Equation:

                    v2 = 3. 0178 volts

Equation:

                    v3 = 0. 0592 volt.

What is the determinant of the coefficient matrix A? Is the solution
unique?

We can determine the current flowing through the lamp from v3 to ground
in Example 1 by Ohm's law:
Equation:

                 v     v3

             i=     =      = 0. 0296 ampere.

                 R     2

The visible effect will, of course, depend on the lamp. Let us assume that
the specifications for our lamp indicate that 0.05 ampere or more is required
before it will glow, and more than 0.075 ampere will cause it to burn out. In
this case, our circuit would not make the lamp glow.
Exercise:

   Problem:
   (MATLAB) Write and solve equations for the circuit in Figure 4. What
   are the voltages at the nodes labeled v1 through v4? What is the
   current labeled i1 ? And i2?

                 A Resistive Network
Linear Algebra: Numerical Experiment (Circuit Design)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Our analysis in Example 1 from "Linear Algebra: Circuit Analysis" and
Problem 1 from "Linear Algebra: Circuit Analysis" indicates that not
enough current will flow through the lamp to make it glow. We now wish to
change the resistance of the 100 ohm resistor to a new value so that the
lamp will glow. We replace 100 in the equations with an unknown
resistance R. Equation 2 is unchanged, but Equation 6 becomes
Equation:

    (v2-v1)   +    v2                  +     (v2-v3)   =0
          50     300                                R

  6R (v2 - v1) + Rv2 + 300 (v2 - v3) = 0

  -6Rv1 + (7R + 300)v2 - 300v3 = 0.

Equation 7 from "Linear Algebra: Circuit Analysis" becomes
Equation:

    (v3-v2)                               v3

              R                        +  2   =0

    2 (v3 - v2) + Rv3 = 0
  
    0v1 - 2v2 + (R + 2)v3 = 0.

The matrix form of these equations is
Equation:
1  0   0          v1  5

-6R 7R +300 -300  v2 = 0 .

0  -2  R+2        v3  0

Write a MATLAB function file called builda to accept R as an input and
return the matrix A in Equation 3 as an output. The first line of your
function file should be

function A = builda(R);

Now choose several values for R. For each choice, use your function
builda and solve the resulting matrix equation Av = b for the voltages.
Each time you choose a different R to build a different matrix A, check the
determinant of A to be sure the equations have a unique solution:

>> det(A)

Make a table of R and the corresponding values of v3:

Now add a column to your table for the current through the lamp i = v3/2.
Add rows to your table until you have found a value of R for which the
lamp will glow. ( i needs to be between 0.05 and 0.075 ampere.)
Vector Graphics: Introduction

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Acknowledgements
Fundamentals of Interactive Computer Graphics by J. D. Foley and A. Van
Dam, ©1982 Addison-Wesley Publishing Company, Inc., Reading,
Massachusetts, was used extensively as a reference book during
development of this chapter. Star locations were obtained from the share-
ware program "Deep Space" by David Chandler, who obtained them from
the "Skymap" database of the National Space Science Data Center.

Notes to Teachers and Students:

In this chapter we introduce matrix data structures that may be used to
represent two- and three-dimensional images. The demonstration program
shows students how to create a function file for creating images from these
data structures. We then show how to use matrix transformations for
translating, scaling, and rotating images. Projections are used to project
three-dimensional images onto two-dimensional planes placed at arbitrary
locations. It is precisely such projections that we use to get perspective
drawings on a two-dimensional surface of three-dimensional objects. The
numerical experiment encourages students to manipulate a star field and
view it from several points in space.

Once again we consider certain problems essential to the chapter
development. For this chapter be sure not to miss the following exercises:
Exercise 2 in "Two-Dimensional Image Transformations", Exercise 1 in
"Homogeneous Coordinates", Exercise 2 in "Homogeneous Coordinates",
Exercise 5 in "Three-Dimensional Homogeneous Coordinates", and
Exercise 2 in "Projections".

Introduction

Pictures play a vital role in human communication, in robotic
manufacturing, and in digital imaging. In a typical application of digital
imaging, a CCD camera records a digital picture frame that is read into the
memory of a digital computer. The digital computer then manipulates this
frame (or array) of data in order to crop, enlarge or reduce, enhance or
smooth, translateor rotate the original picture. These procedures are called
digital picture processing or computer graphics. When a sequence of
picture frames is processed and displayed at video frame rates (30 frames
per second), then we have an animated picture.

In this chapter we use the linear algebra we developed in The chapter on
Linear Algebra to develop a rudimentary set of tools for doing computer
graphics on line drawings. We begin with an example: the rotation of a
single point in the (x, y) plane.

Example:
Point P has coordinates (3, 1) in the (x, y) plane as shown in Figure 1.

                                                                                                                               

Find the coordinates of the point P , which is rotated radians from P .

                                                                                                                               6
Rotating a Single Point in the (x, y) Plane

To solve this problem, we can begin by converting the point P from
rectangular coordinates to polar coordinates. We have
Equation:

  r = x2 + y2 = 10

         -1     y

   =tan      ( )  0. 3217 radian.

                x

                                                                                                                                                     

The rotated point P  has the same radius r, and its angle is  + . We

                                                                                                                                                     6

now convert back to rectangular coordinates to find x and y for point P :

Equation:

         
x = r cos ( + )  10 cos (0. 8453)  2. 10
         6

             
y = r sin ( + )  10 sin (0. 8453)  2. 37.
             6

So the rotated point P  has coordinates (2.10, 2.37).
Now imagine trying to rotate the graphical image of some complex object
like an airplane. You could try to rotate all 10,000 (or so) points in the same
way as the single point was just rotated. However, a much easier way to
rotate all the points together is provided by linear algebra. In fact, with a
single linear algebraic operation we can rotate and scale an entire object and
project it from three dimensions to two for display on a flat screen or sheet
of paper.

In this chapter we study vector graphics, a linear algebraic method of
storing and manipulating computer images. Vector graphics is especially
suited to moving, rotating, and scaling (enlarging and reducing) images and
objects within images. Cropping is often necessary too, although it is a little
more difficult with vector graphics. Vector graphics also allows us to store
objects in three dimensions and then view the objects from various
locations in space by using projections.

In vector graphics, pictures are drawn from straight lines.[footnote] A curve
can be approximated as closely as desired by a series of short, straight lines.
Clearly some pictures are better suited to representation by straight lines
than are others. For example, we can achieve a fairly good representation of
a building or an airplane in vector graphics, while a photograph of a forest
would be extremely difficult to convert to straight lines. Many computer-
aided design (CAD) programs use vector graphics to manipulate
mechanical drawings.
It is possible to extend these techniques to deal with some types of curves,
but we will consider only straight lines for the sake of simplicity.

When the time comes to actually display a vector graphics image, it may be
necessary to alter the representation to match the display device. Personal
computer display screens are divided into thousands of tiny rectangles
called picture elements, or pixels. Each pixel is either off (black) or on
(perhaps with variable intensity and/or color). With a CRT display, the
electron beam scans the rows of pixels in a raster pattern. To draw a line on
a pixel display device, we must first convert the line into a list of pixels to
be illuminated. Dot matrix and laser printers are also pixel display devices,
while pen plotters and a few specialized CRT devices can display vector
graphics directly. We will let MATLAB do the conversion to pixels and
automatically handle cropping when necessary.

We begin our study of vector graphics by representing each point in an
image by a vector. These vectors are arranged side-by-side into a matrix G
containing all the points in the image. Other matrices will be used as
operators to perform the desired transformations on the image points. For
example, we will find a matrix R, which functions as a rotation: the matrix
product RG represents a rotated version of the original image G.
Vector Graphics: Two-Dimensional Image Representation

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Point Matrix. To represent a straight-line image in computer memory, we
must store a list of all the endpoints of the line segments that comprise the
image. If the point Pi = (xi, yi) is such an endpoint, we write it as the
column vector
Equation:

                                                                                            xi
                                                                            pi = [ ]

                                                                                            yi

Suppose there are n such endpoints in the entire image. Each point is
included only once, even if several lines end at the same point. We can
arrange the vectors Pi into a point matrix:
Equation:

                             G=         [p1p2p3. . . pn]

                                        x1 x2 x3 xn

                             =[                               ].

                                        y1 y2 y3 yn

We  then  store  the  point  matrix  G            2xn  as  a  two-dimensional  array  in

                                          R

computer memory.

Example:
Consider the list of points
Equation:

                                 P1 = (0, 0)
                             P2 = (-1. 5, 5)

                               P3 = (4, 2. 3)
                               P4 = (4, -1).

The corresponding point matrix is
Equation:

                0            -1. 5  4          4
G=[                          5      2. 3              ]

                0                              -1

Line Matrix. The next thing we need to know is which pairs of points to
connect with lines. To store this information for m lines, we will use a line
matrix, H  R2×m. The line matrix does not store line locations directly.
Rather, it contains references to the points stored in G. To indicate a line
between points pi and pj, we store the indices i and j as a pair. For the kth
line in the image, we have the pair
Equation:

                                                                                            ik
                                                                           hk = [ ].

                                                                                            jk

The order of i and j does not really matter since a line from pi to pj is the
same as a line from pj to pi. Next we collect all the lines hk into a line
matrix H:
Equation:

                             i1 i2 i3 ... im

H=[                                            ].

                             j1 j2 j3 ... jm
All the numbers in the line matrix H will be positive integers since they
point to columns of G. To find the actual endpoints of a line, we look at
columns i and j of the point matrix G.

Example:
To specify line segments connecting the four points of Example 1 into a
quadrilateral, we use the line matrix
Equation:

1234

H1 = [             ].

2341

Alternatively, we can specify line segments to form a triangle from the first
three points plus a line from P3 to P4 :
Equation:

1233

H2 = [             ].

2314

Figure 1 shows the points G connected first by H1 and then by H2.

Two Sets of Lines
Demo 1 (MATLAB). Use your editor to enter the following MATLAB
function file. Save it as vgraphl.m.

function vgraphl (points, lines);

% vgraphl (points, lines) plots the points as *'s

and

% connects the points with specified lines. The po

ints

% matrix should be 2xN, and the lines matrix shoul

d be 2xM.

% The field of view is preset to (-50,50) on both

axes.

%

% Written by Richard T. Behrens, October 1989

%

m=length(lines);                   % find the num

ber of

                                   % lines.

axis([-50 50 -50 50])              % set the axis

scales

axis('square')

plot(points(1,:),points(2,:),'*') % plot the poi

nts as *

hold on                            % keep the poi

nts...

for i=i:m                          % while plotti

ng the

                                   % lines

     plot([points(1,lines(1,i)) points(1,lines(2,i)

)],..

          [points(2,lines(2,lines(1,i)) points(2,lin

es(2,i))],'-')

     end

     hold off
After you have saved the function file, run MATLAB and type the
following to enter the point and line matrices. (We begin with the
transposes of the matrices to make them easier to enter.)

>> G = [       -0.4728;
       0.6052   3.5555;
                7.9629;
     -0.4366
     -2.6644   10.7547;
     -7.2541   11.5633;
   -12.5091    15.1372;
   -12.5895    13.7536;
     -6.5602   -7.7994;
   -31.2815    -9.9874;
   -38.8314    -1.1537;
   -44.0593
   -38.8314     2.5453;
   -39.4017     9.4594;
   -39.3192    15.0932;
   -45.9561    23.4158]

>> G = G'

>> H = [
     1 2;
     2 3;
     3 4;
     4 5;
     4 7;
     5 6;
     8 9;
     9 10;
     10 11;
     11 12;
     12 13;
     12 14]

>> H = H'
At this point you should use MATLAB's "save" command to save these
matrices to a disk file. Type

>> save dippers

After you have saved the matrices, use the function VGRAPH1 to draw the
image by typing

 vgraph1(G,H)

The advantage of storing points and lines separately is that an object can be
moved and scaled by operating only on the point matrix G. The line
information in H remains the same since the same pairs of points are
connected no matter where we put the points themselves.

Surfaces and Objects. To describe a surface in three dimensions is a fairly
complex task, especially if the surface is curved. For this reason, we will be
satisfied with points and lines, sometimes visualizing flat surfaces based on
the lines. On the other hand, it is a fairly simple matter to group the points
and lines into distinct objects. We can define an object matrix K with one
column for each object giving the ranges of points and lines associated with
that object. Each column is defined as
Equation:

      f irst point

ki =  last    point
      f irst                   .

                line

      last    line

As with the line matrix H, the elements of K are integers.

Example:
Consider again Demo 1. We could group the points in G and the lines in H
into two objects with the matrix
Equation:

           K=  18

               7 l4
                                 .

               17

               6 12

The first column of K specifies that the first object (Ursa Minor) is made
up of points 1 through 7 and lines 1 through 6, and the second column of
K defines the second object (Ursa Major) as points 8 through 14 and lines
7 through 12.
Vector Graphics: Two-Dimensional Image Transformations

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

We now turn our attention to operating on the point matrix G to produce the
desired transformations. We will consider rotation scaling and translation
(moving) of objects. Rotation and scaling are done by matrix multiplication
with a square transformation matrix A. If we call the transformed point
matrix Gnew, we have
Equation:

                                                                   [Gnew ] = [A] [G].

We call A a matrix operator because it "operates" on G through matrix
multiplication. In contrast, translation must be done by matrix addition.

In a later section you will see that it is advantageous to perform all
operations by matrix operators and that we can modify our image
representation to allow translation to be done with a matrix operator like
rotation and scaling. We will call the modified representation homogeneous
coordinates.

Rotation. We saw in the chapter on linear algebra that the matrix that
rotates points by an angle  is
Equation:

                                    cos  -sin
A = R () = [                                            ].

                                    sin  cos
When applied to the point matrix G, this matrix operator rotates each point
by the angle , regardless of the number of points.

Example:
We can use the rotation matrix to do the single point rotation of the
example from "Vector Graphics: Introduction". We have a point matrix
consisting of only the point (3, 1):
Equation:

                                                                                            3
                                                                            G = [ ].

                                                                                            1

                                                                                                                                  

The necessary transformation matrix is R() with  = Then the rotated

                                                                                                                                  6

point is given by
Equation:

                                                                                3  2. 10

Gnew = R ( )G =                   cos                 -sin                      [ ][      ]
                               6
                                                   6                         6  1  2. 37
                                                                       

                                  sin                 cos

                                                  6                    6

Scaling. An object can be enlarged or reduced in each dimension inde-
pendently. The matrix operator that scales an image by a factor of sx along
the x-axis and sy along the y-axis is
Equation:

                                              sx      0
A = S (sx , sy ) = [                                       ].

                                              0       sy

Most often we take sx = sy to scale an image by the same amount in both
dimensions.
Exercise:
Problem:

Write out the following matrices. Simplify and give numerical answers
to two decimal places:

                     

   a. R( );

                     2

   b. S(3, 2);

                         

   c. R(- );

                         4

   d. S(-1, 1).

Exercise:
Reflections

   Problem: What does S(-1, 1) do? S(1, -1)?S(-1, -1)? S(1, 1)?
Exercise:

   Problem:

                               0  -1. 5  4     4           
                                  5      2. 3      ] and  = find Gnew =R()G.
Given G = [
                                               -1          3
                               0

Give numerical answers to two decimal places.

Exercise:

Problem:

Apply each of the transformations in Exercise 1 and 2 to the image
Equation:

                                  1122             1234

             G=[                                  ] ; H=[     ].

                                  1221             2341

Sketch the original image and each transformation of it.
Translation. An object can be moved by adding a constant vector b to

                                                                                                          20

every point in the object. For example, b = [ ] will move an object 20

                                                                                                          -5

units to the right and 5 units down. We can write this in terms of the point
matrix as
Equation:

                                                                                                                                                       T

                                                                   Gnew = G + b1

where 1 (read "the one-vector") is a vector of n l's:
Equation:

1=  1

    1
           .

    

    1

In MATLAB, 1 may be obtained by ones(n,1). The outer product of b
with 1 in Equation 7 simply serves to make n copies of b so that one copy
can be added to each point in G.
Vector Graphics: Composition of Transformations

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Often we will want to perform several operations on an object before we

                                                                                                                                                 

display the result. For example, suppose we want to rotate by and reduce

                                                                                                                                                 3

       1

to size in each dimension:

       2

Equation:

                                           

                  G1 = R ( )G
                                           3

                                        1  1

                  Gnew = S ( 2 , 2 )G1 .

If there are n points in the matrix G, it will require 4n multiplications to
perform each of these operations, for a total of 8n multiplications.
However, we can save some multiplications by noting that
Equation:

                                  1  1        
                  = S( ,
           G new                        ) [R ( )G] = AG
                                  2
                                     2        3

where
Equation:
                    1     1        
                 S ( , )R ( )
A=                  2     2        3

              1                 1        
                 cos ( ) - sin( )

              2  3              2        3

          =[                                ].

              1              l        
                 sin ( )
                                cos ( )
              2  3           2        3

In other words, we take advantage of the fact that matrix multiplication is
associative to combine S and R into a single operation A, which requires
only 8 multiplications. Then we operate on G with A, which requires 4n
multiplications. By "composing" the two operations, we have reduced the
total from 8n to 4n + 8 multiplications. Furthermore, we can now build
operators with complex actions by combining simple actions.

Example:
We can build an operator that stretches objects along a diagonal line by
composing scaling and rotation. We must

   i. rotate the diagonal line to the x-axis with R(-);
  ii. scale with S(s, 1); and
  iii. rotate back to the original orientation with R().

Figure 1 shows a square being stretched along a 45o line. The composite
operator that performs this directional stretching is
Equation:

A(, s) =         R()S(s, 1)R(-)

          cos -sin           s0          cos    sin

=[                     ][          ][                ]

          sin cos            01          -sin cos

          scos2  + sin2  (s - 1)sincos

=         [                                     ].

          (s - 1)sincos cos2  + ssin2 

Note that the rightmost operator in a product of operators is applied first.
                 Rotating and Scaling for Directional Stretching
Vector Graphics: Homogeneous Coordinates

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In the previous section we were able to combine rotation and scaling into a
single composite operation by matrix multiplication. Unfortunately,
translation cannot yet be included in the composite operator since we do it
by addition rather than by multiplication.

Example:

                                                                                                     

Suppose we wish to rotate the image G by about the point (-10, 10).

                                                                                                     3

Our rotation matrix R() always rotates about the origin, so we must
combine three transformations to accomplish this:

   i. translate the point (-10, 10) to the origin;

                           

  ii. rotate radians about the origin; and

                           3

  iii. translate the origin back to (-10, 10).

                                                                  l0

For step (i), we have b0 = [ ] and

                                                                  -10

Equation:

                                                                    T

                G1 = G + b01 .

For step (ii),
Equation:
           G2 =                     

                       R ( 3 )G1

                                                                                    T

                   = R ( 3 ) [G + b0 1 ]

                                                                                       T

                   = R ( 3 )G + R ( 3 )b0 1 .

For step (iii), we can use - b0 from step (i):
Equation:

           Gnew =                                         T

                         G2 - b01

                                                                                    T     T
           = R ( 3 )G + R ( 3 )b0 1 - b0 1

                                                                                          T
           = R ( 3 )G + [(R ( 3 ) - I)b0 ]1 .

In this example we were unable to find a single matrix operator A to do the
entire job. The total transformation took the form

Equation:

                                                                                 T

                   Gnew = AG + b1 .

This is called an affine transformation because it involves both
multiplication by A and addition of a constant matrix. This is in contrast to
the more desirable linear transformation, which involves only
multiplication by A.

We will now move toward a modified representation of the image and the
operators by rewriting the last equation as
Equation:

                                                                                                     G
                                                                  Gnew = [Ab][ ]

                                                                                                                                                    T

                                                                                                     1

                                                                                          
where in the example we had A = R( ) and b = (R ( ) - I)b0.

                         3                                                                3

Exercise:
Problem: Show that, for any matrices A, B, C, D of compatible sizes,
Equation:

AB + CD =                                                    B
                                         [A C] [ ].

                                                             D

                              G

The matrix [ T ] looks like

                              1

Equation:

                                 x1  x2                xn
                                 y1  y2                yn ,
                                 1   1                 1

and the points (xi, yi, 1) are called homogeneous coordinates. We can
modify Equation 5 so that the new point matrix is also in homogeneous
coordinates:
Equation:

G new                                A                 b        G
                                                          ]
[                                ]=[                         [ ].
   1T                                          OT      1        1T

In the new representation, each point in the image has a third coordinate,
which is always a 1. The homogeneous transformation is a 3 × 3 matrix,
Equation:

                                                   A   b
                                 Ah = [                   ],

                                                   0T  1

which is capable of translation, rotation, and scaling all by matrix multi-
plication. Thus, using homogeneous coordinates, we can build composite
transformations that include translation.

In homogeneous coordinates, we have
Equation:

            cos -sin 0

    R () = sin cos                               0

            0                              0     1

                    sx 0                         0

    S (sx , sy ) = 0                          sy 0

                    0                         0  1

    T (tx , ty ) =                         1 0 tx
                                           0 1 ty .
                                           001

Example:
The composite transformation to triple the size of an image and then move
it 2 units to the left is
Equation:

    1 0 -2  300                                     3 0 -2
    010
A=  00l     030 = 030                                       .

            001                                     001

On the other hand, the composite transformation to move an image 2 units
to the left and then triple its size is
Equation:

    300     1 0 -2                                  3 0 -6
    030
B=  001     010                                  = 030      .

            001                                     001
In the latter case, the distance of the translation is also tripled.

Exercise:
   Problem:
   Find a single composite transformation in homogeneous coordinates
   that rotates an image by angle  about point (xi, yi) as in Example 1.
Vector Graphics: Three-Dimensional Homogeneous Coordinates

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

We now consider the storage and manipulation of three-dimensional
objects. We will continue to use homogeneous coordinates so that
translation can be included in composite operators. Homogeneous
coordinates in three dimensions will also allow us to do perspective
projections so that we can view a three-dimensional object from any point
in space.

Image Representation. The three-dimensional form of the point matrix in
homogeneous coordinates is
Equation:

    x1 x2 x3 ... xn

    yl  y2 y3 ... yn     4×n

G=                    R       .

    z1 z2 z3 ... zn

    1   1  1  ... 1

The line matrix H is exactly as before, pointing to pairs of columns in G to
connect with lines. Any other grouping matrices for objects, etc., are also
unchanged.

Image manipulations are done by a 4 × 4 matrix A. To ensure that the
fourth coordinate remains a 1, the operator A must have the structure
Equation:
                          A=          a 11   a 12   a 13  a 14
                                      a 21   a 22   a 23
                                      a 31   a 32   a 33  a 24
                                      0      0      0                 .

                                                          a 34

                                                          1

The new image has point matrix
Equation:

                                      Gnew = AG.

Exercise:
   Problem:

If  the  coordinates  of  the     th  point  in  G  are   (xi ,  yi,  zi,  1),   what   are  the

                               i

coordinates  of  the     th  point    in  G new  =  AG    when   A       is  as  given  in

                      i

Equation 2?

Exercise:

Problem:

Write down the point matrix G for the unit cube (the cube with sides
of length 1, with one corner at the origin and extending in the positive
direction along each axis). Draw a sketch of the cube, numbering the
vertices according to their order in your point matrix. Now write down
the line matrix H to complete the representation of the cube.

Left- and Right-Handed Coordinate Systems. In this book we work
exclusively with right-handed coordinate systems. However, it is worth
pointing out that there are two ways to arrange the axes in three dimensions.
Figure 1(a) shows the usual right-handed coordinates, and the left-handed
variation is shown in Figure 1(b). All possible choices of labels x, y, and z
for the three coordinate axes can be rotated to fit one of these two figures,
but no rotation will go from one to the other.
Three-Dimensional Coordinate Systems; (a)
     Right-handed, and (b) Left-handed

Be careful to sketch a right-handed coordinate system when you are solving
problems in this chapter. Some answers will not be the same for a left-
handed system.

Image Transformation. Three-dimensional operations are a little more
complicated than their two-dimensional counterparts. For scaling and
translation we now have three independent directions, so we generalize the
operators of Equation 10 from "Vector Graphics: Homogeneous
Coordinates" as
Equation:

                                sx 0       0  0

                                0  sy 0       0

           S (sx , sy , sz ) =  0  0       sz 0
           T (tx , ty , tz ) =
                                0  0       01

                                1 0 0 tx

                                0 1 0 ty
                                                                .

                                0 0 1 tz

                                0001

Exercise:
Problem:

Show that T(-tx, -ty, -tz) is the inverse of T (tx, ty, tz). T-1
undoes the work of T .

Rotation may be done about any arbitrary line in three dimensions. We will
build up to the general case by first presenting the operators that rotate
about the three coordinate axes. Rx () rotates by angle  about the x-axis,
with positive  going from the y-axis to the z-axis, as shown in Figure 2. In
a similar fashion, positive rotation about the y-axis using Ry () goes from
z to x, and positive rotation about the z-axis goes from x to y, just as in two
dimensions. We have the fundamental rotations
Equation:

         10      0   0

         0 cos -sin 0

Rx () =

         0 sin cos   0

         00      0   1

         cos     0 sin 0

         0       10  0

Ry () =

         -sin 0 cos 0

         0       00  1

         cos -sin 0 0

         sin cos     00
                                     .
Rz () =
                     10
         0    0

         0    0      01

A more general rotation about any line through the origin can be
constructed by composition of the three fundamental rotations. Finally, by
composing translation with the fundamental rotations, we can build an
operator that rotates about any arbitrary line in space.
                      Directions of Positive Rotation

Example:
To rotate by angle  about the line L , which lies in the x - y plane in
Figure 3, we would

   i. rotate L to the x-axis with Rz (-);
  ii. rotate by  about the x-axis with Rx (); and
  iii. rotate back to L with Rz ().
The composite operation would be
Equation:

                                              A (, ) = Rz ()Rx ()Rz (-).
Composition of Rotations

Direction Cosines. As discussed in the chapter on Linear Algebra, a vector
v may be specified by its coordinates (x, y, z) or by its length and direction.
The length of v is ||v||, and the direction can be specified in terms of the
three direction cosines ( cos x, cos y, cos z). The angle x is measured
between the vector v and the x-axis or, equivalently, between the vector v
and the vector ex =[100]T . We have
Equation:

         (v, ex )            x

cos x =                   =

         ||v||||ex ||        ||v||

Likewise, y is measured between v and ey = [010]T , and z is measured
between v and ez = [001]T . Thus
Equation:
            cos y =      y
                      ||v||

            cos  z =     z
                      ||v||

The vector
Equation:

            u=   cos x
                 cos y
                 cos z

is a unit vector in the direction of v, so we have
Equation:

                                                                                                     cos x
                                                     v = ||v||u = ||v|| cos y .

                                                                                                     cos z

Exercise:

   Problem: Show that u is a unit vector (i.e. 1 u|| = 1).

The direction cosines are useful for specifying a line in space. Instead of
giving two points P1 and P2 on the line, we can give one point P1 plus the
direction cosines of any vector that points along the line. One such vector is
the vector from P1 to P2.

                                                                                             x

Arc tangents. Consider a vector v = { } in two dimensions. We know

                                                                                             y

that
Equation:

                                                                                                  y
                                                                           tan  =

                                                                                                 x
for the angle  shown in Figure 4. If we know x and y, we can find  using
the arc tangent function
Equation:

                               -1 y

                         =tan  ( ).

                               x

Tangent and Arc Tangent

In MATLAB,

theta = atan(y/x)

                                     -                                    
Unfortunately, the arc tangent always gives answers between and

                                     2                                    2

corresponding to points v in quadrants I and IV. The problem is that the

                   -y

ratio -x is the same as the ratio - - -xA so quadrant III cannot be

                                                                                                                                             y

distinguished from quadrant I by the ratio x Likewise, quadrants II and IV

are indistinguishable.

The solution is the two-argument arc tangent function. In MATLAB,

theta = atan2(y,x)
will give the true angle  - and  in any of the four quadrants.

Example:                           cosx
Consider the direction vector u =
                                   cosy , as shown in Figure 5. What

                                                                                      cosz

is the angle y between the projection of u into the x - y plane and the y-
axis? This is important because it is Rz (y) that will put u in the y - z
plane, and we need to know the angle y in order to carry out this rotation.
First note that it is not the same as y. From the geometry of the figure, we
can write
Equation:

tan y =                            cos x
                                   cos y

This gives us a formula for y in terms of the direction cosines of u. With
the two-argument arc tangent, we can write
Equation:

        -1

y =tan                             (cos x , cos y ).
            Angles in Three Dimensions

Exercise:

   Problem:

      a. Suppose point p is in the y - z plane in three dimensions,
         p = (0, y, , 1). Find  so that Rx () will rotate p to the
         positive z-axis. (Hint: Use the two-argument arc tangent.  will be
         a function of y and z.)

      b. Let p be any point in three-dimensional space, p = (x, y, z, 1).
         Find  so that Rz () rotates p into the y - z plane. (Hint: Sketch
         the situation in three-dimensions, then sketch a two-dimensional
         view looking down at the x - y plane from the positive z-axis.
         Compare with Example 2.) Your answers to parts (a) and (b) can
         be composed into an operator Z(p) that rotates a given point p to
         the positive z-axis, Z (p) = Rx ()Rz ().

      c. Let L be a line in three-dimensional space specified by a point 1
         =(x, y, z, 1) and the direction cosines ( cos x, cos y, cos z).
         Use the following procedure to derive a composite operator
         R(, L ) that rotates by angle  about the line L :

            i. translate 1 to the origin;
            ii. let u =( cos x, cos y, cos z, 1) and use Z(u) to align L

               with the z-axis;
iii. rotate by  about the z-axis;
iv. undo step (ii); and
 v. undo step (i).
Vector Graphics: Projections

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Computer screens and printers are two-dimensional display devices. We
must somehow convert three-dimensional images to two dimensions in
order to display them. This task is done by another kind of matrix operator
called a projection.

To build a projection, we first choose a projection plane in the three-
dimensional space of the object we wish to view. All points of the object are
then projected onto the plane. There are many different kinds of projections,
corresponding to various geometric rules for mapping points in space onto a
plane. We begin with the parallel projection illustrated in Figure 1, wherein
the dotted lines between the points and their projections in the plane are all
parallel to one another. These dotted lines are called projectors.

Range. The projection plane is called the range of the projection. We will
assume for now that the projection plane passes through the origin. If it
does not, we may later compose the necessary translations with our
projection. Three points, not all in a line, are required to determine a plane.
We will take the origin as one of the points and suppose that the other two
points are the vectors r1 and r2. From these vectors, we form the matrix
Equation:

                                                                           R = [r1 r2 ],

which determines the range of the projection.
                     Oblique Parallel Projection

Null-Space. To complete the specification of the parallel projection, we
must specify the direction of the projectors. The line through the origin in
this direction is called the null-space of the projection. Note that any line in
the three-dimensional object that is parallel to the null-space will disappear
to a point when projected. The null-space may be specified by a vector n
pointing in the direction of the projectors.

Orthogonal Projection. If the null-space is perpendicular to the range, we
say that the projection is an orthogonal projection. The matrix operator for
orthogonal projection is a function of the range. If we assume that R is
specified in three-dimensional coordinates (not homogeneous!), we have
the following definition for the orthogonal projection onto the range of R:
Equation:

                                              T -1 T                  3×3
           P (R) = R(R R) R  R                                             .

In homogeneous coordinates, we embed this 3 × 3 projection matrix in the
general 4 × 4 transformation:
Equation:

                                                      P(R)  0
                          Ph (R) = [                           ].

                                                      0T    1

Example:
Suppose we choose the x - y plane as our projection plane. Vectors r1 and
r2 can be any two points in the plane (besides the origin), so let's take
Equation:

                                           1                       1
                          r1 = 0              , r2 = 1

                                           0                       0

Then the range matrix is
Equation:

                          R=                  11
                                              0 1.
                                              00

The orthogonal projection looking down on the x - y plane from the z-
axis is
Equation:
                                                                 -1

                11               100     11                          100
                01                       01
P (R) =         00           [        ]  00                          [    ]

                                 110                                 110

                                 100

             =                   0 1 0.

                                 000

In homogeneous coordinates,
Equation:

                Ph (R) =         1000

                                 0100
                                                               

                                 0000

                                 0001

Exercise:
   Problem:

                2                0

Let the vectors r1 = 0 and r2 = 3 specify the range of an

                0                0

orthogonal projection. Find P(R) and Ph (R). Compare with Example

1 and explain any similarities.

Example:
In the chapter on linear algebra you learned that the projection of w onto x
is given by
Equation:
               z=  (x, w)x
                     (x, x)

This is an orthogonal projection of w onto a line, but it is closely related to
the projection into the plane just described. To see the similarity, let's work
on the expression for z a little:
Equation:

           z=      x(x,w)
                     (x,x)

                                                   -1

           = x(x, x) (x, w)

                                     T -1 T

           = x(x x) (x w)

                                          T -1 T

           = [x(x x) x ]w

           =       P(x)w.

So we see that it can be written in the same way as the projection onto the
plane. The only difference is that the range is now one-dimensional and
specified by x in place of R.

Oblique Projection. More generally, we may have a null-space n that is
not perpendicular to the range R. The projection shown in Figure 1 is an
oblique projection. Once again we start with nonhomogeneous coordinates
for n and R and write the 3 × 3 oblique projection as
Equation:

           T                 -1 T
E (R, n) = R{R [I - -P (n)]R} R [I - -P (n)]

where
Equation:

                                                      T -l T   nn T

           P (n) = n(n n) n =                                               2

                                                              ||n||
As with the orthogonal projection, we can return to homogeneous
coordinates by
Equation:

                                          E(R n) 0

                        Eh (R, n) = [                                        ].
                                                          OT              1

Exercise:
   Problem:

Prove and interpret the following properties of paralle1 projections
(both orthogonal and oblique):

a. P2 = P; E2 = E.

b. P R = R; ER = R.

c.  En  =    0;  Pn  =  0.  (First  show  that                      T  n  =  0   when  n  is

                                                              R

    orthogonal to R.)

Display from Projections. Even after we have used a projection, the image
points are in three-dimensional homogeneous coordinates. How then do we
display them on a two-dimensional display? If we had chosen the x - y
plane as the range of our projection, we could let the output device
represent the x - y plane and ignore the z-coordinate of each point. The z-
coordinates of the projected image would all be 0 anyway since the
projected points would lie in the x - y plane. The fourth coordinate of 1
may also be ignored for display. But even if the projection plane is not the
x - y plane, we may perform a rotation to align the two planes and again
let the output device represent the x - y plane.

Perspective Projections. To obtain a perspective projection, we first
choose a projection plane as we did for parallel projections. Instead of
choosing a null-space parallel to all projectors, we now choose a viewpoint.
The projectors all pass through the viewpoint in a perspective projection, as
shown in Figure 2. For a viewpoint at z = d on the z-axis and a projection
plane coinciding with the x - y plane, the three-dimensional homogeneous
operator for perspective projection is
Equation:

                    100      0

                    010      0
                                    .
           M (d) =
                             0
                    000
                             1
                    00  -1
                          d

The first thing you should notice about the perspective projection M(d) is
that it violates the structure given in Equation 2 from "Vector Graphics:
Three-Dimensional Homogeneous Coordinates" by having the 4,3 position

                          1

equal to - rather than to 0. This means that the fourth coordinates will

                          d

not remain 1 in the new point matrix
Equation:

                                                                    Gnew = M (d)G.
A Perspective Projection

This situation is interpreted to mean that the new point (x, y, z, w) must be

x yz
renormalized to ( ,        1) before the operation is considered complete.

w ww

Renormalization adds another computational step to the image

transformation process. This is undesirable, but we are stuck with it if we

wish to include perspective projections in our repertoire of transformations.

Note that renormalization is a point-by-point process since w may be

different for each point.
How does renormalization affect composition of operators? We might
expect that, each time we perform an operation requiring renormalization,
we will be forced to stop and do the renormalization before going on with
other operations. In this respect we are fortunate: we may put off the
renormalization until all transformations are complete and renormalize once
just before displaying the image. Thus we are able to compose perspective
projections at will with other transformations.
Exercise:

   Problem:

   What is the perspective projection matrix for a viewpoint at infinity,
   M()? Interpret the result.

Generalization of Projections. "Projection" is a technical term in linear

algebra. A square matrix of any size is considered a projection if it obeys

the  property  of  Exercise    2(a),        2  =  P.  All  of  our  geometric          projection

                                      P

matrices have this property. We have considered only three-dimensional

spaces with a two-dimensional range and a one-dimensional null-space. In

general, the dimensionality of the space may be split in any way between

range and null-space. If we reinterpret homogeneous coordinates as four-

dimensional space, we have projections with three-dimensional range and

one-dimensional null-space, but the perspective projection is actually not

quite  a  projection  in  the  technical       sense  even     though          2  (d)  =  M  (d)

                                                                       M

because perspective projection also includes renormalization.
Vector Graphics: Numerical Experiment (Star Field)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

With Earth at the origin, we may specify the star positions for the Big and
Little Dippers in three-dimensional homogeneous coordinates. With light
years as our units, we have GT =

1.5441    -1.2064  153.0875                         1.0000
-1.0386   8.4588   142.7458                         1.0000
-8.7955   26.2870  198.0698                         1.0000
-12.8807  19.0964  106.5383                         1.0000
-18.8926  17.461   90.6185                          1.0000
-45.1364  54.2706  215.1148                         1.0000
-9.6222   20.1734  88.0062                          1.0000
-33.7097  -8.4048  64.6574                          1.0000
-33.7144  -8.7191  52.3806                          1.0000
-43.8531  -1.1483  59.7193                          1.0000
-36.1086  2.3667   55.7927                          1.0000
-34.2309  8.2181   52.1260                          1.0000
-30.7876  11.8182  46.9810                          1.0000
-61.8581  31.5183  80.7615                          1.0000

To make use of this data, we need a function to display it. Enter and save
the following generalization of the function from Demo 1 in "Vector
Graphics: Two Dimensional Image Representation". Call it vhgraph.m.

function vhgraph (P,L,A,ps,ls);
% vhgraph(P,L,A,PS,LS) graphs images whose points
are
% stored in P and whose lines are stored in L. The
 points

% in P must be in homogeneous coordinates in eithe
r 2 or 3
% dimensions, with each column of P representing a

 point.
% The lines are coded in L, with each column of L
containing
% 2 integers pointing to a pair of points in P to
be
% connected by a line segment. If A is present, th
e points
% in P are transformed to A*P beforre graphing. Fo
r 3D data
% points, only the first two coordinates are graph
ed, so A
% should include the desired projection from 3D to

 2D. The
% point symbol may be specified in PS and the line

 type in
% LS, if desired
%
% Richard T. Behrens, October 1989.
%
% The first dection of the program determines the
sizes of
% all the input matrices and chacks that they make

 sense.
[mp,np] = size(P);
if (nargin > 1)

     [ml,nl] = size(L);
else

       ml = 2; nl = 0;
end
if (nargin <=2)

       A = eye(mp);
end
[mA,nA] = size(A);
if ((mp~= nA) | (ml~=2))

       error('Incompatible sizes of input matrices.")
end
if (nargin <= 3);

       ps = '*';
end

P = A*P;  % Performs the transformation A on the
 points   % (effect is only local to this functi

on).

% The next section contains a loop that renormaliz
es the
% homogeneous coordinates of the points if necessa
ry.
renorm = find((P(mA,:)~= 1));
if~isempty(renorm)

       for i = 1:length(renorm)
              P(:,renorm(i)) = P(:,renorm(i))/P(mA,renor

m(i));
       end

end

% The next program line sets a fixed scale output
window
% from -50 to 50 in both x and y directions on the

 screen.
% For automatic scaling to include all points of t
he
% image, we could use instead the line q = min(min
(P));
% r = max(max(P));
q = -50; r = 50;
axis([q r q r])
axis('square')
plot(P(1,:),P(2,:),ps) % Plots the points with sy

mbol ps.

hold on       % Saves the points while w

e plot

for i = 1:nl  % lines with line type LS.

plot([P(1,L(1,i))P(1,L(2,i))],..

     [P(2,L(1,i))P(2,L(2,i))],ls)

end

hold off

Enter the point matrix given at rhe beginning of this section (and take its
transpose to put it in the usual form). Also enter the line matrix from Demo
1 in "Vector Graphics: Two Dimensional Image Representation". Save these
two matrices and try looking at the image

 save dip3d
 vhgraph(G,H)

No dippers in sight, right? Without specifying a transformation matrix A,
we have defaulted to looking down on the x - y plane from z =  (a
parallel projection). This is how the constellations would look from a
distant galaxy (say, a billion light years north of here) through an enormous
telescope. We need a perspective view from the origin (Earth), but first we
need a set of functions to give us the fundamental operators with which we
can build the desired projection.

Take Ry () as an example. The function to build it looks like

       function Ry = vhry (theta) ;
% Rotation matrix about y-axis for 3-D homogeneous
% coordinates.

       Ry = eye(4);
       Ry(1,1) = cos(theta);
       Ry(3,3) = cos(theta);
       Ry(3,1) = -sin(theta);
       Ry(1,3) = sin(theta);

Enter and save hry.m as given. Then write functions for
Equation:

               Rx () vhrx. m
                Rz () vhrz. m
           S(sx, sy, sz) vhs. m
           T(tx, ty, tz) vht. m
                 M(d) vhm. m

Useful MATLAB functions for this task include zeros, eye, and diag.

Now build and use a perspective projection with viewpoint Earth and
projection plane at z = 1000 behind the dippers:

   1. translate Earth to z = -1000 so that the projection plane coincides
      with the x - y plane: T(O, 0, -1000);

   2. use the fundamental perspective projection: M(-1000); and
   3. translate back: T(O, 0, 1000).

 A = vht(0,0,1000) * vhm(-1000) * vht(0,0,-1000)
 vhgraph(G,H,A)

Oops! Now the image is too big; it's mostly off the screen. Scale it down
and have another look:

 A = vhs(.06,.06,.06) * A
 vhgraph(G,H,A)

Now the view should look familiar. Leave A as it is now:

 save dip3d

Experiment with scale and rotation about the z-axis. For example, try

 vhgraph(G,H,vhrz(pi/2) * A)
The two-dimensional star positions given in Demo 1 in "Vector Graphics:
Two Dimensional Image Representation" were obtained from the three-
dimensional positions with the composite operator A you are now using. To
compare the two, type

 Gnew = A * G

 for i = 1:14
Gnew(;,i) = Gnew(:,i)/Gnew(4,i);
end

 Gnew

and compare the x and y coordinates with those of Demo 1 in "Vector
Graphics: Two Dimensional Image Representation".

Astronomers give star positions in equatorial coordinates using right
ascension, declination, and distance. The following function converts
equatorial coordinates, which are spherical, to Cartesian coordinates with
the z-axis pointing north, the x-axis pointing at the vernal (Spring) equinox
in the constellation Pisces, and the y-axis pointing toward the Winter
solstice in the constellation Opheuchus.

function v = starxyz(rah,ram,decd,decm,dist)

% starxyz is the cartesian coordinates of a star w

hose

% spherical coordinates ( e.g. from a star catalog

) are

%

%         rah  right ascension hours

%         ram  right ascension minutes

%         decd declination degrees

%         decm declination minutes (should be

negative

%              if decd is negative)

%         dist distance (light years)

%
phi = (pi/180) * (decd + decm/60);
theta = (pi/12) * (rah + ram/60);
r = dist;
v = [r * cos(phi) * cos(theta); -
r * cos(phi) * sin(theta);

       r * sin(phi)];

Have you ever wondered what the constellations would look like from other
places in the galaxy? We will soon see the answer. First we will view the
dippers from Alpha Centauri, the nearest star, whose coordinates are

-1.5680   1.3157                  -3.6675.

We will look toward the centroid of the fourteen stars in the dippers, located
at

-26.3632  12.8709                 100.4714.

To get the desired view, we must

1. translate the viewpoint to the origin;
2. rotate the centroid (direction to look) to the z-axis-note that the

  centroid will have new coordinates after step (1); and
3. apply the composite

  A=S(.06,.06,.06)*T(0,0,1000)*M(-1000)*T(0,0,-10
  00) (as used to view from Earth).

Write a function vhz.m based on Exercise 5 from "Vector Graphics: Three-
Dimensional Homogeneous Coordinates" to accomplish step (2). Test it on
several random points to make sure it works right. Now write a general
perspective projection function called vhview.m. The function vhview
should accept as inputs two vectors, the first specifying the viewpoint and
the second the point to look toward. Its output should be a composite
operator that performs all three of the preceding steps.

Now we want to look toward the centroid of the dippers from Alpha
Centauri. To do so, enter the vectors for the two points of interest and
construct the view like this:
 acentauri = [-1.5680; 1.3157; -3.6675]
 centroid = [-26.3632; 12.8709; 100.4714]
 A = vhview(acentauri,centroid)
 vhgraph(G,H,A)
 title('From Alpha Centauri')

The farther we move from Earth, the more distorted the dippers will look in
general. It should be easy now to view them from any desired location. Just
choose a viewpoint, recalculate the composite operator for that viewpoint
using vhview, and use vhgraph. Follow this procedure to view the
dippers from each of the stars in the following list. You will need to use
starxyz first to convert their coordinates.

            Right                Distance

Star        Ascension  Declination (ly)

Alpha       14h 40m    -60° 50'  4.2
Centauri

Sirius      6h 45m     -16°43'   9.5

Arcturus    14h 16m    19°11'    16.6

Pollux      7h 45m     28°02'    35.9

Betelgeuse  5h 55m     7°24'     313.5

Table 1 is a six-row and four-column table with the first row as a header,
the first column describing different stars, and the values in the second
through fourth columns describing the corresponding right ascension,
declination, and distance for each star.
Of course, star viewing is not the only application of vector graphics. Do
some experiments with the unit cube (see Exercise 2 from "Vector
Graphics: Three-Dimensional Homogeneous Coordinates"). View the cube
from location (4,3,2) looking toward the origin using the procedure just
outlined for stars. You may need to adjust the scaling to get a meaningful
view.
Filtering: Introduction

Note:This module is part of the collection, A First Course in Electrical and Computer Engineering.
The LaTeX source files for this collection were created using an optical character recognition
technology, and because of this process there may be more errors than usual. Please contact us if you
discover any errors.

Notes to Teachers and Students:

Filtering is one of the most important things that electrical and computer engineers do. In this chapter
we extend everyday understanding of filters to numerical filters. We then study weighted moving
averages and exponential averages. We define the important test signals for electrical and computer
engineering and show how filters respond to them. The idea that filters are characterized by their
response to simple test signals is fundamental. In the numerical experiment, students explore the
frequency response of a simple filter, a concept that forms the basis of circuit theory, electronics, optics
and lasers, solid-state devices, communications, and control.

Introduction

A filter is any device that passes material, light, sound, current, velocity, or information according to
some rule of selectivity. Material (or mechanical) filters are commonplace in your everyday life:

   i. coffee filters pass flavored water while filtering out coffee grounds;
  ii. Goretex fibers pass small, warm perspiration droplets while filtering out large, cool droplets of

      rain or snow;
  iii. fiberglass strands in a furnace filter pass warm air while filtering out particles of dirt and dust;
  iv. a centrifuge retains material of low density while spinning out (or filtering out) material of high

      density; and
   v. an electrostatic precipitator filters out dust and other effluents by attaching charge to them and

      using an electric field to move the charged particles to a high potential drain.

The first three of these examples selectively pass material according to size; the last two selectively
pass material according to its mass density.

Typical filters for light are

   i. UV filters on camera lenses and eyeglasses that pass light in the range of visible wavelengths
      while blocking light in the invisible (but damaging) ultraviolet range;

  ii. polaroid lenses that pass light that is randomly polarized while blocking out glare that is linearly
      polarized;

  iii. green fabrics that reflect green light and absorb other colors;
  iv. red taillights that pass light in the long wavelength red range and reflect light in the short

      wavelength violet range (look at the inside of your taillights to see violet); and
   v. glacial ice that absorbs all but the blue wavelengths so that it appears blue.

Exercise:
Problem: List as many examples of natural and man-made sound filters as you can.

Satellite Television. Among current filters, the tuner in a super-heterodyne receiver is, perhaps, the

first example that comes to mind. But satellite TV filters are another fascinating example. A typical C-

band satellite has twelve transponders (or repeaters), each of which transmits microwave radiation in a

personalized  36  MHz     band.  (The   abbreviation           MHz   stands   for  megahertz,         or          6  Hz,    or               6  cycles     per

                                                                                                          10                         10

second.    Other  common  abbreviations            are  Hz  for  1  Hz,  kHz  for          3  Hz,  and   GHz         for          9  Hz.)       Each

                                                                                   10                                     10

transponder actually transmits two channels of information, one vertically polarized and one

horizontally polarized. There is an 8 MHz guard band between each band, and the vertical and

horizontal channels are offset by 20 MHz. The transmission scheme for the 24 channels is illustrated in

Figure  1.  The   entire  transmission  band       extends     over  540  MHz,     from       3.   7  ×          9  Hz  to  4.       24  ×              9  Hz.

                                                                                                         10                                     10

The satellite receiver has two different microwave detectors, one for vertical and one for horizontal

polarization, and a microwave tuner to tune into the microwave band of interest.

Exercise:

   Problem: Check that the transmission scheme of Figure 1 consumes 540 MHz of bandwidth.
Exercise:

   Problem:

   List as many examples of natural and man-made devices for velocity filtering as you can.

     Satellite TV- Vi, Vertically Polarized Channel i; Hj,
                Horizontally Polarized Channel j

An Aside on Hertz and Seconds. The abbreviation Hz stands for hertz, or cycles/second. It is used to

describe the frequency of a sinusoidal signal. For example, house current is 60 Hz, meaning that it has

60 cycles each second. The inverse of Hz is seconds or, more precisely, seconds/cycle, the period of 1

cycle. For example, the period of 1 cycle for house current is 1/60 second. When we are dealing with

sound, electricity, and electromagnetic radiation, we need a concise language for dealing with signals

and  waves  whose  frequencies     range  from          0  Hz  (called   DC  or  direct       current)   to          18   Hz  (visible          light).

                                                                                                             10

Table 1 summarizes the terms and symbols used to describe the frequency and period of signals that

range  in  frequency  from  0  Hz  to          12  Hz.

                                       10
Frequency                           Period

Hz  Term   Units Seconds Term                            Units         Example

Hz  hertz  1 Hz                     sec     second       1 sec         battery current:
                                                                       0 Hz
                                                                       house current:
                                                                       60 Hz

kHz kilohertz 103                   msec    millisecond 10-3           midfrequency
                                Hz                                sec  sound

MHz megahertz 106 µsec                      microsecond  10-6sec       clock
                                Hz                                     frequencies in
                                                                       microcomputers

GHz gigahertz 109 nsec                      nanosecond   10-9sec       microwave
                                Hz                                     radiation for
                                                                       satellite
                                                                       communication

THz terahertz 1012 psec                     picosecond   10-12         infrared
                                Hz                       sec           radiation

Terms and symbols for Sinusoidal Signals

Numerical Filters. Rather amazingly, these ideas extend to the domain of numerical filters, the topic of
this chapter. Numerical filters are just schemes for weighting and summing strings of numbers. Stock
prices are typically averaged with numerical filters. The curves in Figure 2 illustrate the daily closing
average for Kellogg's common stock and two moving averages. The 50-day moving average is obtained
by passing the daily closing average through a numerical filter that averages the most current 50 days'
worth of closing averages. The 200-day moving average for the stock price is obtained by passing the
daily closing prices through a numerical filter that averages the most current 200 days' worth of daily
closing averages. The daily closing averages show fine-grained variation but tend to conceal trends.
The 50-day and 200-day averages show less fine-grained variation but give a clearer picture of trends.
In fact, this is one of the key ideas in numerical filtering: by selecting our method of averaging, we can
filter out fine-grained variations and pass long-term trends (or vice versa), or we can filter out periodic
variations and pass nonperiodic variations (or vice versa). Figure 2 illustrates that moving averages
typically lag increasing sequences of numbers and lead decreasing sequences. Can you explain why?

We will call any algorithm or procedure for transforming one set of numbers into another set of
numbers a numerical filter or digital filter. Digital filters, consisting of memories and arithmetic logic
units (ALUs), are implemented in VLSI circuits and used for communication, control, and
instrumentation. They are also implemented in random-or semicustom-logic circuits and in
programmable microcomputer systems. The inputs to a digital filter are typically electronic
measurements that are produced by A/D (analog-to-digital) conversion of the output of an electrical or
mechanical sensor. The outputs of the filter are "processed," "filtered," or "smoothed" versions of the
measurements. In your more advanced courses in electrical and computer engineering you will study
signal processing and system theory, assembly language programming, microprocessor system
development, and computer design. In these courses you will study the design and programming of
hardware that may be used for digital filtering.

      Dow-Jones Averages (Adapted from the New York Stock Exchange, Daily Graphs,
                       William O'Neil and Co., Inc., Los Angeles, California)
Filtering: Simple Averages

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The simplest numerical filter is the simple averaging filter. This filter is
defined by the equation
Equation:

                                            N

                                1

                            x=      un.

                                N

                                   n=1

The filter output x is the average of the N filter inputs u1, u2, ... , uN. These
inputs may be real or complex numbers, and x may be real or complex. This

simple averaging filter is illustrated in Figure 1.

                     A Simple Averaging Filter
Example:
If the averaging filter is excited by the constant sequence
u1 = u2 =  = uN = u, then the output is
Equation:

                                        N

                            1

                        x=   u = u.

                            N

                                       n=1

The output is, truly, the average of the inputs. Now suppose the filter is
excited by the linearly increasing sequence
Equation:

                                                         un = n, n = 1, 2, ..., N .

This sequence is plotted in Figure 2. How do we sum such a sequence in
order to produce the average x? For N even, the average may be written as
Equation:

x=   1                   1                         1

          (x1 + xN ) +        (x2 + xN -1 ) +  +        (xN /2 + x(N /2)+1 ).
    N                   N                         N

                                                                                                                                         N

Each pair-sum in parentheses equals N + 1, and there are such pair-

                                                                                                                                          2

sums, so the average is

Equation:

                        1N                  N +1

    x=                      (N + 1) =             .

                        N2                  2

This is certainly a reasonable answer for the average of a linearly
increasing sequence. See Figure 2.
                   Linearly Increasing Sequence

Exercise:
   Problem:

                                                             N

                                  1

   Write x =  n as a sum of pair-sums for N odd. What does x

                                 N

                                                          n=1

   equal?

General Sum Formula. Suppose the input to the simple averaging filter is
the polynomial sequence
Equation:

                                                                                                           k

                                                         un = n , n = 1, 2, ..., N
where k is a non-negative integer such as k = 0, 1, 2, .... The output of the
filter is
Equation:

                                                                   N

                                            (k)            1             k

                                       x         =             n .

                                            N          N

                                                               n=1

We   rewrite       as      (k)   to remind ourselves that we are averaging N numbers,

              x          x

                              N

each of which is nk. For example, when N = 8 and k = 2,

Equation:

                      (2)                    8         1
                                                           (1 + 4 + 9 +  + 64).
                   x  8    =     12
                                      n =              8

                                 8

                                         n=1

Rather  than  study        the   average       (k)  ,  we      will   study      the  sum   (k)           and divide

                                            x                                              Nx

                                                 N                                                     N

by N at the very end:

Equation:

                                                                      N

                                       (k)             (k)                    k

                                    S  N    = Nx       N       = n .

                                                                      n=1

The   sum     (k)  may be rewritten as the sum

           S

                N

Equation:

                                    (k)                    N -1 k                k

                                 S  N       =              n=1     n +N

                                                              (k)             k

                                            =          S   N -1       +N .

This  result  is   very    important      because          it  tells  us    that  the  sum  (k)           , viewed as

                                                                                            S

                                                                                                 N

a  function   of      ,  obeys   a  recursion          in  which         (k)     is just the sum using one

                   N                                                  S

                                                                           N
less input, namely, SN-1 (k) , plus N k. Now, since polynomials are the most

general      functions     that  obey      such    recursions,   we   know  that   (k)   must be a

                                                                                  s

                                                                                      N

polynomial of order k + 1 in the variable N:

Equation:

                      (k)                                     2             k+1

                   sN = a0 + a1 N + a2 N +  + ak+1 N .

Let's check to see that this polynomial really can obey the required

recursion.   First    note   that        (k)     is  the   following  polynomial:

                                      S

                                           N -1

Equation:

                 (k)                                                               k+1

             sN -1 = a0 + a1 (N - 1) +  + ak+1 (N - 1) .

The term (N - 1)k+1 produces (0 )N (-1) + (1 )N (-1) +  k+1 k+1 0 k+1 k 1

. (Remember the binomial expansion?) Therefore the difference between

(k)          (k)
        and S is
S            N -1

     N

Equation:

                           (k)           (k)                                k

                        SN - SN -1 = c0 + c1 N +  + ck N .

This recursion is general enough to produce the difference Nk provided we

can solve for a0, a1, ... , ak+1 to make c0 = c1 =  = ck-1 = 0 and

        1.   We  know      that       (k)  = 0 for N = 0, so we know that a0 = 0,

ck  =                            S

                                      N

meaning      that  the  polynomial            for    (k)   can really be written as

                                                   S

                                                        N

Equation:

                           (k)                             2                k+1

                        SN = a1 N + a2 N +  + ak+1 N .

In order to solve for the coefficients of this polynomial, we propose to write

out     our  equation   for      (k)  as follows:

                             s

                                 N

Equation:

                                      ()
                                   (k)

            (N = 1)             S  1         =                 a1 +  + ak+1
            (N = 2)
            (N = 3)                (k)                                            k+1

                                S  2         =            2a1 +  + 2                   a k+1

                                   (k)                                            k+1

                                s  3         =            3a1 +  + 3                   a k+1

                                                                            
           (N = k)
      (N = k + 1)                  (k)                                            k+1

                                S  k         =            ka1 +  + k                   a k+1

                                   (k)                                                 k+1

                                Sk+1 = (k + 1)a1 +  + (k + 1)                                 ak+1 .

Using the linear algebra we learned earlier, we may write these equations as
the matrix equation
Equation:

                                                                                          (k)

            l              1                 ... 1             a1                      s  1       
                                             ... 2k+1                  a2
            2              4                                                                 (k)

                                                                                       S

                                                                                            2

                                                                         = .

            k k2 ... kk+1

         2 k+1 (k + 1) (k + 1) ... (k + 1) a  k+1                                         (k)

                                                                                       S          

                                                                                          k+1

The terms on the right-hand side of the equal sign are "initial conditions"

that  tell  us  how  the   sum          (k)  begins for N = 1, 2, ..., k + 1. These initial

                                   S

                                        N

conditions must be computed directly. (For example, S2 = 1 + 2 . (k) k k )
Then the linear system of (k + 1) equations in (k + 1) unknowns may be

solved  for     a1 , a2 , ..., ak+1 .   The     solution  for        k  is  then  complete,       and  we

                                                               S

                                                                    N

may   use   it  to  solve  for  Sk      for  arbitrary  N.

                                     N

Example:
When k = 2, we have the following equation for the coefficients a1, a2,
and a3 in the polynomial SN = a1N + a2N + a3N (2) 2 3 :
Equation:    1 1 1 a1                                    12            1
                                                         12 + 22    

                 248                 a2 =                           =5 

                                           12 +22 + 32              
                 3 9 27              a3                                14

Exercise:
   Problem:

Solve for a1, a2, a3 in the linear equation of Example 2. Show that

SN = a1N + a2N + a3N (2) 2 3 obeys the recursion

   . (2) (2) 2
S  N  -S   N -1  =N

Exercise:

Problem:

(MATLAB) Write a MATLAB program to determine the coefficients

                        for     the  polynomial  (k)     . Generate a table of formulas

a1,   a2,  ...,  a k+1                           S

                                                      N

for   the  averages     (k)     for k = 1, 2, ..., 5. Evaluate these formulas for

                        x

                             N

N = 2, 4, 8, and 16.

Exponential Sums. When the input to an averaging filter is the sequence
Equation:

                                                                                              n

                                                un = a , n = 0, 1, 2, ..., N - 1,

we say that the input is exponential (or geometric). Typical sequences are
illustrated in Figure 6.5 for a = 0. 9, a = 1, and a = 1. 1. Don't let it throw
you that we have changed the index to run from 0 to N - 1 rather than
from 1 to N. This change is not fundamentally important, but it simplifies
our study. The sum of the inputs is
Equation:
                               N -1
                                                   n

         SN =  a .

                                n=0

Exponential Sequences

How do we evaluate this sum? Well, we note that the sum aSN is
Equation:

            N -1 n+1                                     N       k

aS N  =     n=0  a                       =               k=1  a

            N -1                                      N

      = k=0 ak + a - 1

                                         N
      =     SN + a - 1.

Therefore, provided a  1, the sum SN is
Equation:

      SN =                     N         a  1.

            1-a
                               ,

              1-a
This  formula,  discovered     already     in                                                      the    chapter         covering  the  functions      x

                                                                                                                                                    e

and ej, works for a  1. When a = 1, then SN = N :

Equation:

                               SN                      1-a N                                                         a1
                                                                                                                     a = 1.
                                                              ,
                                      = { 1-a

                                                 N,

When  |a|  <  1,  then      N      0  for  N                                                              ,          and  we  have  the  asymptotic

                        a

formula

Equation:

                         lim SN =                                                                       1            |a| < 1.
                                                                                                                  ,
                        N 
                                                                                                   1-a

Exercise:
   Problem:

                   N -1

Evaluate SN =  an and XN = SN 1 for a = 0. 9, 1, and 1.1 and

                     n=0                                                                                  N

for N = 1, 2, 4, 8, 16, and 32.

Exercise:

                                      N -1

Problem:      Prove  that      SN  =                                                                   n  obeys      the   recursion

                                                                                                   a

                                                                                              n=0

Equation:

                                                                                                                     N -1

                                   SN = SN -1 + a                                                                          .

Prove that SN = N obeys this recursion for a = 1 and that

           1 - aN  obeys it for a  1.

SN =

           1-a
Recursive Computation. Every sum of the form
Equation:

                                                                                                                             N -1

                                                                        SN =  un

                                                                                                                              n=0

obeys the recursion
Equation:

                     SN = SN -1 + uN -1 .

This means that when summing numbers you may "use them and discard
them." That is, you do not need to read them, store them, and sum them.

You may read u0 to form S1 and discard u0; add u1 to S1 and discard u1 ;
add u2 to S2 ; and continue.

The Recursion Sn+1 = Sn + un
This is very important for hardware and software implementations of
running sums. You need only store the current sum, not the measurements
that produced it. Two illustrations of the recursion Sn+1 = Sn + un are
provided in Figure 4. The diagram on the left is self-explanatory. The
diagram on the right says that the sum Sn is stored in a memory location, to
be added to un to produce Sn+1, which is then stored back in the memory
location to be added to un+1, and so on.
Filtering: Weighted Averages

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Weighted, tapered, or windowed averages are straightforward
generalizations of simple averages. They take the form
Equation:

                                                                                                                        N

                                                                       x =  wnun

                                                                                                                     n=1

with the constraint that the "weights in the window," wn, sum to 1:
Equation:

                                                                                                            N

                                                                          wn = 1.

                                                                                                         n=1

                                 1

When wn = then x is the simple average studied in the section on

                                N

"Simple Averages".

Example:
There are many windows that are commonly used in engineering practice.
For N odd, the standard triangular window is
Equation:
           wn=2                                           2        N +1
                                                                         2
                 (1-                                                        - n |).

           N +1                                           N +1

This window, illustrated in Figure 1, weights the input u(N+1)/2 by

                                                                   2

2     and the inputs u1 and uN by (                             2  ) The most general

N +1                                                         N +1

triangular window takes the form
Equation:

              N +1

           wn = (1 - |                                    - n |); ,  > 0, N odd.
                                                       2

           Triangular Window

Exercise:
Problem:

Determine the constraints on  and  to make the general triangular

                                                                                                      N

window a valid window (i.e.,  wn = 1). Show that

              n=1

           2  =  is a valid solution. Propose another solution that you

=

       N +1

like.

Exercise:

Problem:

You are taking three 3-credit courses, one 5-credit course, and one 2-
credit course. Write down the weighted average for computing your
GPA in a system that awards 4.0 points for an A, 3. 0 points for a B, ...
, and (horrors!) 0 points for an F .
Filtering: Moving Averages

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Moving averages are generalizations of weighted averages. They are
designed to "run along an input sequence, computing weighted averages as
they go." A typical moving average over N inputs takes the form
Equation:

xn =                                 N -1

                            k=0 wk un-k

= w0 un + w1 un-1 +  + wN -1 un-(N -1) .

The most current input, un, is weighted by w0; the next most current input,
un-1, is weighted by w1 ; and so on. This weighting is illustrated in Figure
1. The sequence of weights, w0 through wN-1, is called a "window," a
"weighting sequence," or a "filter." In the example illustrated in Figure 6.8,
the current value un is weighted more heavily than the least current value.
This is typical (but not essential) because we usually want xn to reflect
more of the recent past than the distant past.
             Moving Average

Example:

                                                                                                                            1

When the weights w0, w1, ..., wN-1 are all equal to , then the moving

                                                                                                                           N

average xn is a "simple moving average":
Equation:

             xn =   1

                         [un + un-1 +  + uN -1 ].
                   N

This is the same as the simple average, but now the simple average moves
along the sequence of inputs, averaging the N most current values.

Exercise:
   Problem:

                                  N -1

Evaluate the moving average xn =        1

                                          un-k for the inputs

                                        N

                                  k=0
a. un =          0, n < 0
b. un =          u, n  0;
                 0, n  0
                 n, n > 0.

   Interpret your findings.
Exercise:

   Problem:

                                                               N -1

Evaluate the simple moving average xn =                                1

                                                                         un-k when un is

                                                                             N

                                                                   k=0

the sequence

Equation:

                             un =                   0,      n<0
                                                            n  0.
                                                        n

                                                    a,

Interpret your result.

Example:

When  the  weights  wn      equal                n  for  n  =  0,  1,  ...,  N  -  1,  then  the

                                   w0a

moving average xn takes the form

           N -1

xn = w0          ak un-k .

                                 k=0

When a < 1, then un is weighted more heavily than un-(N-1); when a > 1
, un-(N-1) is weighted more heavily than un ; when a = 1, un is weighted
the same as un-(N-1).

Exercise:
Problem:

Evaluate w0 so that the exponential weighting sequence wn =

                                                                                                                                                                            N -1

w0an (n = 0, 1, ..., N - 1) is a valid window (i.e.,       wn = 1).

                                                      n=0

Exercise:

Problem:

                                                                                                                        N -1

Compute the moving average xn = w0akun-k when the input

                                                                                                                         k=0

sequence un is
Equation:

                    n

                 b , n0

           un =

                 0,  n < 0.

What happens when b = a? Can you explain this?
Filtering: Exponential Averages and Recursive Filters

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Suppose we try to extend our method for computing finite moving averages
to infinite moving averages of the form
Equation:

xn =           

      k=0 wk un-k

= w0 un + w1 un-1 +  + w1000 un-1000 + 

In general, this moving average would require infinite memory for the
weighting coefficients w0, w1, ... and for the inputs un, un-1, ....
Furthermore, the hardware for multiplying wkun-k would have to be
infinitely fast to compute the infinite moving average in finite time. All of
this is clearly fanciful and implausible (not to mention impossible). But
what if the weights take the exponential form
Equation:

                         0,                        k<0
      wk = {                                       k  0?

                                                k

                         w0a ,

Does any simplification result? There is hope because the weighting
sequence obeys the recursion
Equation:
            0,      k<0

      wk =  w0,     k=0
            aw k-1  k  1.

This recursion may be rewritten as follows, for k  1:
Equation:

                                                         wk - awk-1 = 0, k  1.

Let's now manipulate the infinite moving average and use the recursion for
the weights to see what happens. You must follow every step:
Equation:

xn =                 

            k=0 wk un-k

                                 

= k=1 wk un-k + w0 un

                           

= k=1 awk-1 un-k + w0 un

                             

= a m=0 wm un-1-m + w0 un

=           axn-1 + w0 un .

This result is fundamentally important because it says that the output of the
infinite exponential moving average may be computed by scaling the
previous output xn-1 by the constant a, scaling the new input un by w0,
and adding. Only three memory locations must be allocated: one for w0,
one for a, and one for xn-1. Only two multiplies must be implemented: one
for axn-1 and one for w0un. A diagram of the recursion is given in Figure
1. In this recursion, the old value of the exponential moving average, xn-1,
is scaled by a and added to w0un to produce the new exponential moving
average xn. This new value is stored in memory, where it becomes xn-1 in
the next step of the recursion, and so on.
Recursive Implementation of an Exponential Moving
                           Average

Exercise:
   Problem:

Try to extend the recursion of the previous paragraphs to the weighted
average
Equation:

                   N -1

             xn =                       k

                                    a un-k .

                   k=0

   What goes wrong?
Exercise:

   Problem:

   Compute the output of the exponential moving average xn =
   axn-1 + w0un when the input is
   Equation:

                                0,  n<0
                                    n  0.
             un = {
                                u,
   Plot your result versus n.
Exercise:

Problem: Compute w0 in the exponential weighting sequence
Equation:

                    0,         n<0
wn = { n                       n0

                    a w0,

to make the weighting sequence a valid window. (This is a special case
of Exercise 3 from Filtering: Moving Averages.) Assume -1 < a < 1
Filtering: Test Sequences

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

When we design a filter, we design it for a purpose. For example, a moving
average filter is often designed to pass relatively constant data while
averaging out relatively variable data. In an effort to clarify the behavior of
a filter, we typically analyze its response to a standard set of test signals.
We will call the impulse, the step, and the complex exponential the standard
test signals.

Unit Pulse Sequence. The unit pulse sequence is the sequence
Equation:

                                                           1,  n=0
                                                               n  0.
                           un = n = {
                                                           0,

This sequence, illustrated in Figure 1, consists of all zeros except for a
single one at n = 0. If the unit pulse sequence is passed through a moving
average filter (whether finite or not), then the output is called the unit pulse
response:
Equation:

                                                                  

                           hn = k=0 wk n-k

                           =  wn.
                         Unit Pulse Sequence

(Note that n-k = 0 unless n = k.) So the unit pulse sequence may be used
to read out the weights of a moving average filter. It is common practice to
use wk (the kth weight) and hk (the kth impulse response) interchangeably.
Exercise:

   Problem:

   Find the unit pulse response for the finite moving average

                            N -1

   xn =  wkun-k. Caution: You must consider

                              k=0

   n < 0, 0  n  N - 1, and n  N .
Exercise:

   Problem:

   Find the unit pulse response for the recursive filter
   xn = axn-1 + w0 un .

Unit Step Sequence. The unit step sequence is the sequence
Equation:
                                           1,  n0
           un = n = {                          n < 0.

                                           0,

This sequence is illustrated in Figure 2. When this sequence is applied to a
moving average filter, the result is the unit step response
Equation:

                                                                                                                                     n

                                                                  gn = k=0 wk

                                                                                                                                     n

                                                                             = k=0 hk .

The unit step response is just the sequence of partial sums of the unit pulse
response.

           Unit Step Sequence

Exercise:
Problem:

Find the unit step response for the finite moving average filter

                    N -1

xn =  wkun-k. Specialize your general result to the special case

k=0

where wk =  1  for k = 0, 1, ..., N - 1.

            N

Exercise:

Problem:

Find the unit step response for the recursive filter
xn = axn-1 + w0 un .

Complex Exponential Sequence. The complex exponential sequence is the
sequence
Equation:

                                                                                                   jk

                                                     uk = e , k = 0, ±1, ±2, ...

This sequence, illustrated in Figure 3, is a "discrete-time phasor" that
"ratchets" counterclockwise (CCW) as k moves to k + 1 and clockwise
(CW) as k moves to k - 1. Each time the phasor ratchets, it turns out an
angle of . Why should such a sequence be a useful test sequence? There
are two reasons.
                         Discrete-Time Phasor

(i)      jk  represents  (or  codes)  cos  k.  The  real    part  of  the  sequence         jk  is

     e                                                                                  e

the cosinusoidal sequence cos k:

Equation:

                                                  jk

                                 Re[e ] =cos k.

Therefore    the  discrete-time  phasor        jk  represents  (or    codes)   cos  k   in  the

                                           e

same  way    that  the  continuous-time    phasor       jt  codes   cos    t.  If  the  moving

                                                    e

average filter

Equation:

                                                        

                                 xn =  hk un-k

                                                      k=0
has real coefficients, we can get the response to a cosinusoidal sequence by
taking the real part of the following sum:
Equation:

                             xn =           

                                   k=0 hk cos (n - k)

                                                                     j(n-k)

                             = Re[k=0 hk e ]

                                      jn                                -jk

                             = Re[e k=0 hk e ].

In this formula, the sum
Equation:

                                         
                                                                -jk

                                       hke

                                      k=0

is called the complex frequency response of the filter and is given the
symbol
Equation:

                                          

                                   j                                 -jk

                             H (e ) =  hk e                               .

                                          k=0

This complex frequency response is just a complex number, with a

magnitude                 j  and a phase arg H(e ) j . Therefore the output of the

           H (e )

moving average filter is

Equation:

           xn =                           jn                         j
                      =               Re [e H (e )]
                      =
                             Re[e     jn       j jargH (ej )
                                          H (e ) e
                                                                             ]

                                   j                                         j
                             H (e )| cos [n+ arg H (e )].
 Thisremarkableresultsaysthattheoutputisalsocosinusoidal,butitsamplitude isjratherthan1,anditsphaseis j  rather                 than

               H (e )                                                     argH (e )

0. In the examples to follow, we will show that the complex "gain" H(ej)

can be highly selective in , meaning that cosines of some angular
frequencies are passed with little attenuation while cosines of other
frequencies are dramatically attenuated. By choosing the filter coefficients,
we can design the frequency selectivity we would like to have.

(ii) ejk is a sampled data version of ejt. The discrete-time phasor ejk

can  be  produced  physically    by      sampling         the  continuous-time  phasor                                              jt  at

                                                                                                                                e

the periodic sampling instants tk = kT :

Equation:

                                 ejk = ejt                 = ejkT

                                                     t=kT

                                                  = T .

The dimensions of  are radians, the dimensions of  are radians/second,

and the dimensions of T are seconds. We call T the sampling interval and

1

   the sampling rate or sampling frequency. If the original angular

T

frequency of the phasor ejt is increased to  + m( ) 2 , then the

                                                                                                                             T

discrete-time  phasor  remains               jk  :

                                         e

Equation:

                   j[+m(2/T )]t                         j(kT +km2)        jk

               e                                    =e                    =e .

                                         t=kT

This means that all continuous-time phasors of the form ej[+m(2/T )]t "hide
under the same alias" when viewed through the sampling operation. That is,
the sampled-data phasor cannot distinguish the frequency  from the

                                          2

frequency  + m . In your subsequent courses you will study aliasing in

                                           T

more detail and study the Nyquist rule for sampling:
Equation:
                          2     1           

T                            ;     

                                T           2

                                                                                                                                 1

This rule says that you must sample signals at a rate ( ) that exceeds the

                                                                                                                                T

                            

bandwidth of the signal.

                           2

Example:
Let's pass the cosinusoidal sequence uk = cos k through the finite
moving average filter
Equation:

                             N -1

xn = k=0 hk un-k

                       1  k = 0, 1, ..., N - 1.

hk =

                      N

We know from our previous result that the output is
Equation:

j                                                    j
xn = H (e ) cos [n+ arg H (e )].

The complex frequency response for this example is
Equation:

H (ej )                   =           N -1   1 -jk
                          =
                                                 e

                                      k=0   N

                                 1 1-e-jN 
                                N 1-e-j

(Do you see your old friend, the finite sum formula, at work?) Let's try to
manipulate the result into a more elegant form:
Equation:
                              j             1         e-j(N /2) [ej(N /2) -e-j(N /2) ]
                                           N               e-j(/2) [ej(/2) -e-j(/2) ]
                              H (e ) =
                                                     =            N
                                               1 -j[(N -1)/2] sin( 2 )
                                                      e           1.

                                               N                  sin( )

                                                                  2

The magnitude of the function H(ej) is
Equation:

                                                   j   1                         N
                                                            ,
                                |H (e )|=                      sin ( )
                                                      N
                                                                                  2

                                                                                          .

                                                                                  1

                                                               sin ( )

                                                                                  2

At  = 0, corresponding to a "DC phasor," H(e ) j equals 1; at  = 2

                                                                                                           N

               j  =  0  .  The  magnitude  of  the       complex  frequency                  response  is

H (e )

plotted in Figure 4.

        Frequency Selectivity of a Moving Average Filter

This result shows that the moving average filter is frequency selective,
passing low frequencies with gain near 1 and high frequencies with gain
near 0.

Exercise:
   Problem: Compute the phase of the complex frequency response
   Equation:
                                                                       N
                                                          sin ( )
                                    1
                              j             -j[(N -1)/2]               2

             H (e ) =                    e                                                                      .

                                    N                                  1

                                                          sin ( )
                                                                       2

Exercise:
   Problem:

                                                                                                                   1

   Choose the filter length N for the filter hk = , k = 0, 1, ..., N - 1,

                                                                                                                  N
                                                                                                           1

   so that a 60 Hz cosine, sampled at the rate = 180, is perfectly

                                                                                                          T

   zeroed out as it comes through the filter.

Exercise:

   Problem:

(MATLAB) Write a MATLAB program to compute and plot the

magnitude                   j  and  the  phase  arg                 j  versus                                   -  <    <  

             H (e )                                  H (e )

when

Equation:

                                                                       N

                              j     1 -j[(N -1)/2] sin ( 2 )                                                    .
                                         e
             H (e ) =

                                    N sin ( 1 )

                                                                                                             2

   Choose suitable increments for .
Exercise:

   Problem:

   Compute the complex frequency response H(ej) for the recursive
   filter xn = axn-1 + w0un.
Filtering: Numerical Experiment (Frequency Response of First-Order
Filter)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Consider the exponential moving average filter
Equation:

xn =                                       a = 0. 98.
                                        k

                                a un-k;

                         k=0

1. Write out a few terms of the sum to show how the filter works.

2. Write xn as a recursion and discuss the computer memory required to

implement the filter.

3. Compute the complex frequency response H         j  for the filter.

                                                e

4. Write a MATLAB program to plot the magnitude and phase of the

complex frequency response H      j        versus  for  = -to +  in

                              e

                          2

  steps of Do this for two values of a, namely, a = 0. 98 and

                          64

  a = -0. 98. Explain your findings.
5. Write a MATLAB program to pass the following signals through the

  filter when a = 0. 98:

a. un = n      2
b. un = n             n

c. un = n cos  64
d. un = n cos             2
e. un = n cos                    n
f. un = n cos
g. un = n cos             32
h. un = n cos
                          2
                                 n

                          16
                          2

                                 n
                           8

                          2
                                 n

                           4
                          2

                              n.

                           2

Plot the outputs for each case and interpret your findings in terms of the

complex frequency response H            j  . Repeat step 5 for a = -0. 98.

                                    e

Interpret your findings.
Binary Codes: Introduction

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Acknowledgment: Richard Hamming's book, Information Theory
andCoding, Prentice-Hall, New York (1985) and C. T. Mullis's unpublished
notes have influenced our treatment of binary codes. The numerical
experiment was developed by Mullis.

We use this chapter to introduce students to the communication paradigm
and to show how arbitrary symbols may be represented by binary codes.
These symbols and their corresponding binary codes may be computer
instructions, integer data, approximations to real data, and so on.

We develop some ad hoc tree codes for representing information and then
develop Huffman codes for optimizing the use of bits. Hamming codes add
check bits to a binary word so that errors may be detected and corrected.
The numerical experiment has the students design a Huffman code for
coding Lincoln's Gettysburg Address.

Introduction

It would be stretching our imagination to suggest that Sir Francis had digital
audio on his minde (sic) when he wrote the prophetic words

"Sir Francis Bacon, 1623 ...a man may express and signifie the intentions of
his minde, at any distance... by... objects... capable of a twofold difference
onely. "
Nonetheless, this basic idea forms the basis of everything we do in digital
computing, digital communications, and digital audio/video. In 1832,
Samuel F. B. Morse used the very same idea to propose that telegram words
be coded into binary addresses or binary codes that could be transmitted
over telegraph lines and decoded at the receiving end to unravel the
telegram. Morse abandoned his scheme, illustrated in Figure 1, as too
complicated and, in 1838, proposed his fabled Morse code for coding letters
(instead of words) into objects (dots, dashes, spaces) capable of a threefold
difference onely (sic).

                    Generalized Coder-Decoder

The basic idea of Figure 1 is used today in cryptographic systems, where
the "address ai" is an encyphered version of a message wi ; in vector
quantizers, where the "address ai" is the address of a close approximation to
data wi ; in coded satellite transmissions, where the "address ai" is a data
word wi plus parity check bits for detecting and correcting errors; in digital
audio systems, where the "address ai" is a stretch of digitized and coded
music; and in computer memories, where ai is an address (a coded version
of a word of memory) and wi is a word in memory.
In this chapter we study three fundamental questions in the construction of
binary addresses or binary codes. First, what are plausible schemes for
mapping symbols (such as words, letters, computer instructions, voltages,
pressures, etc.) into binary codes? Second, what are plausible schemes for
coding likely symbols with short binary words and unlikely symbols with
long words in order to minimize the number of binary digits (bits) required
to represent a message? Third, what are plausible schemes for "coding"
binary words into longer binary words that contain "redundant bits" that
may be used to detect and correct errors? These are not new questions.
They have occupied the minds of many great thinkers. Sir Francis
recognized that arbitrary messages had binary representations. Alan Turing,
Alonzo Church, and Kurt Goedel studied binary codes for computations in
their study of computable numbers and algorithms. Claude Shannon, R. C.
Bose, Irving Reed, Richard Hamming, and many others have studied error
control codes. Shan- non, David Huffman, and many others have studied
the problem of efficiently coding information.

In this chapter we outline the main ideas in binary coding and illustrate the
role that binary coding plays in digital communications. In your subsequent
courses in electrical and computer engineering you will study integrated
circuits for building coders and decoders and mathematical models for
designing good codes.
Binary Codes: The Communication Paradigm

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

A paradigm is a pattern of ideas that form the foundation for a body of

knowledge. A paradigm for (tele-) communication theory is a pattern of

basic building blocks that may be applied to the dual problems of (i)

reliably transmitting information from source to receiver at high speed or

(ii) reliably storing information from source to memory at high density.

High-speed communication permits us to accommodate many low-rate

sources (such as audio) or one high-rate source (such as video). High-

density storage permits us to store a large amount of information in a small

space.  For  example,  a  typical  1.2  Mbyte  floppy    disc  stores     9.     6  ×          6  bits  of

                                                                                       10

information,  whereas     a  typical  CD  stores  about  2  ×          9  bits,  enough  for

                                                               10

one hour's worth of high-quality sound.

Basic Building Blocks in a (Tele-) Communication
                          System
Figure 1 illustrates the basic building blocks that apply to any problem in

the theory of (tele-) communication. The source is an arbitrary source of

information. It can be the time-varying voltage at the output of a vibration

sensor (such as an integrating accelerometer for measuring motion or a

microphone for measuring sound pressure); it can be the charges stored in

the CCD array of a solid-state camera; it can be the addresses generated

from a sequence of keystrokes at a computer terminal; it can be a sequence

of instructions in a computer program. The source coder is a device for

turning primitive source outputs into more efficient representations. For

example, in a recording studio, the source coder would convert analog

voltages into digital approximations using an A/D converter; a fancy

source coder would use a fancy A/D converter that finely quantized likely

analog values and crudely quantized unlikely values. If the source is a

source of discrete symbols like letters and numbers, then a fancy source

code would assign short binary sequences to likely symbols (such as e) and

long binary sequences to unlikely symbols (such as z). The channel coder

adds "redundant bits" to the binary output of the source coder so that errors

of transmission or storage may be detected and corrected. In the simplest

example, a binary string of the form 01001001 would have an extra bit of 1

added to give even parity (an even number of l's) to the string; the string

10110111 would have an extra bit of 0 added to preserve the even parity. If

one bit error is introduced in the channel, then the parity is odd and the

receiver knows that an error has occurred. The modulator takes outputs of

the channel coder, a stream of binary digits, and constructs an analog

waveform that represents a block of bits. For example, in a 9600 baud

Modem,  five  bits  are  used  to  determine  one  of      5  =  32  phases  that  are  used

                                                       2

to modulate the signal A cos (t + ). Each possible string of five bits has

its own personalized phase, , and this phase can be determined at the

receiver. The signal A cos (t + ) is an analog signal that may be

transmitted over a channel (such as a telephone line, a microwave link, or a

fiber-optic cable). The channel has a finite bandwidth, meaning that it

distorts signals, and it is subject to noise or interference from other

electromagnetic radiation. Therefore transmitted information arrives at the

demodulator in imperfect form. The demodulator uses filters matched to the

modulated signals to demodulate the phase and look up the corresponding

bit stream. The channel decoder converts the coded bit stream into the
information bit stream, and the source decoder looks up the corresponding
symbol. This sequence of steps is illustrated symbolically in Figure 7.3.

          Symbolic Representation of Communication

In your subsequent courses on communication theory you will study each
block of Figure 1 in detail. You will find that every source of information
has a characteristic complexity, called entropy, that determines the
minimum rate at which bits must be generated in order to represent the
source. You will also find that every communication channel has a
characteristic tolerance for bits, called channel capacity. This capacity
depends on signal-to-noise ratio and bandwidth. When the channel capacity
exceeds the source entropy, then you can transmit information reliably; if it
does not, then you cannot.
Binary Codes: From Symbols to Binary Codes

Note:This module is part of the collection, A First Course in Electrical and
Computer Engineering. The LaTeX source files for this collection were
created using an optical character recognition technology, and because of this
process there may be more errors than usual. Please contact us if you
discover any errors.

Perhaps the most fundamental idea in communication theory is that arbitrary
symbols may be represented by strings of binary digits. These strings are
called binary words, binary addresses, or binary codes. In the simplest of
cases, a finite alphabet consisting of the letters or symbols s0, s1, ..., sM-1 is
represented by binary codes. The obvious way to implement the
representation is to let the ith binary code be the binary representation for the
subscript i:
Equation:

                                                                    s0  000 = a0

                                                                    s1  001 = a1

                                                                               

                                                                    s6  110 = a6

                                                                    s7  111 = a7 .

The number of bits required for the binary code is N where
Equation:

   N -1  N
2        <M 2 .

We say, roughly, that N =log2 M.

Octal Codes. When the number of symbols is large and the corresponding
binary codes contain many bits, then we typically group the bits into groups
of three and replace the binary code by its corresponding octal code. For
example, a seven-bit binary code maps into a three-digit octal code as
follows:
Equation:

        0000000    000
        0000001    001

                   046
        0100110 

                
        101111  137

                 
        1111111  177.

The octal ASCII codes for representing letters, numbers, and special
characters are tabulated in Table 1.
Exercise:

   Problem: Write out the seven-bit ASCII codes for A, q, 7, and{.

'0  '1  '2  '3     '4   '5  '6                                        '7

'00x        

'01x        

'02x        

'03x        
'04x  !            "  #  $  %  &  '

'05x (          )  *  +  ,  -  .  /

'06x 0          1  2  3  4  5  6  7

'07x 8          9  :  ;  <  =  >  ?

'10x         @  A  B  C  D  E  F  G

'11x         H  I  J  K  L  M  N  O

'12x P          Q  R  S  T  U  V  W

'13x X          Y  Z  [  \  ]  ^  _

'14x `          a  b  c  d  e  f  g

'15x h          i  j  k  l  m  n  o

'16x p          q  r  s  t  u  v  w

'17x x          y  z  {  |  }  ~  

Octal ASCII Codes (from Donald E. Knuth, The TEXbook, ©1986 by the
American Mathematical Society, Providence, Rhode Island p. 367, published
by Addison-Wesley Publishing Co.)

Exercise:
   Problem:

Add a 1 or a 0 to the most significant (left-most) position of the seven-bit
ASCII code to produce an eight-bit code that has even parity (even
number of 1's). Give the resulting eight-bit ASCII codes and the
corresponding three-digit octal codes for %, u, f, 8, and +.
Quantizers and A/D Converters. What if the source alphabet is infinite?

Our only hope is to approximate it with a finite collection of finite binary

words. For example, suppose the output of the source is an analog voltage

that lies between -V0 and +V0. We might break this peak-to-peak range up

                                                                       2V

into little voltage cells of size A and approximate the voltage in each cell

                                                                        M

by its midpoint. This scheme is illustrated in Figure 1. In the figure, the cell

Ci is defined to be the set of voltages that fall between i - 2 -V pV and
                                                                                                                                                                                         MM

2V             VA
i- M  +         M:

Equation:

                                   2V 0         V0               2V 0            V0
                                    M    -              i
                Ci = {V   : i.                      <V                   +           }.
                                                M                  M
                                                                                 M

The mapping from continuous values of V to a finite set of approximations is
Equation:

                                         2V 0

                          Q (V ) = i                ,  if V  Ci .

                                         M

That is, V  is  replaced  by  the  quantized  approximation                 2V0  whenever V                                                                                                  lies in
                                                                            -

                                                                         i

                                                                            M

cell  Ci.  We  may  represent  the  quantized          values     2V  0  with    binary  codes                                                                                               by

                                                               i-

                                                                  M

simply representing the subscript of the cell by a binary word. In a subsequent

course on digital electronics and microprocessors you will study A/D

(analog-to-digital) converters for quantizing variables.
                             A Quantizer

Example:
If M = 8, corresponding to a three-bit quantizer, we may associate quantizer
cells and quantized levels with binary codes as follows:
Equation:
                 V  C-3                                                             2V 0   111
                 V  C-2  
                 V  C-1                 V-3 = (-3) 8
                         
                  V  C0                                                             2V 0   110
                  V  C1  
                  V  C2                 V-2 = (-2) 8
                  V  C3
                                                                                    2V 0   101

                                        V-1 = (-1) 8

                                             V0 = 0  000

                                                                        2V 0   001

                                        V1 = (1) 8

                                                                        2V 0   010

                                        V2 = (2) 8

                                                                        2V 0   011.

                                        V3 = (3) 8

This particular code is called a sign-magnitude code, wherein the most

significant bit is a sign bit and the remaining bits are magnitude bits (e.g.,

110  -2 and 010  2). One of the defects of the sign-magnitude code is

that it wastes one code by using 000 for 0 and 100 for-O. An alternative code

that  has  many  other  advantages  is  the  2's  complement                              code.  The      

                                                                                                      2s

complement codes for positive numbers are the same as the sign-magnitude

codes, but the codes for negative numbers are generated by complementing

all bits for the corresponding positive number and adding 1:

Equation:

                         -4  100             (100 + 1)
                         -3  101             (101 + 1)
                        -2  110              (110 + 1)
                         -1  111

                           0  000
                           1  001
                           2  010
                          3  011.

Exercise:
   Problem:

   Generate the four-bit sign-magnitude and four-bit 2's complement binary
   codes for the numbers -8, -7, ..., -1, 0, 1, 2, ..., 7.
Exercise:
   Problem:

   Prove that, in the 2s complement representation, the binary codes for
   -nand + n sum to zero. For example,
   Equation:

                                                                     101 + 011 = 000
                                                                        (-3) (3) (0).

In your courses on computer arithmetic you will learn how to do arithmetic in
various binary-coded systems. The following problem illustrates how easy
arithmetic is in 2's complement.
Exercise:

   Problem:

   Generate a table of sums for all 2s complement numbers between -4
   and +3. Show that the sums are correct. Use
   0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, and 1 + 1 = 0 with a carry into the
   next bit. For example, 001 + 001 = 010.

Binary Trees and Variable-Length Codes. The codes we have constructed

so far are constant-length codes for finite alphabets that contain exactly

M  =      N  symbols.  In  the  case  where  M  =  8  and  N  =  3,  then  the  eight

      2

possible three-bit codes may be represented as leaves on the branching tree

illustrated in Figure 2(a). The tree grows a left branch for a 0 and a right

branch for a 1, until it terminates after three branchings. The three-bit codes

we have studied so far reside at the terminating leaves of the binary tree. But

what if our source alphabet contains just five symbols or letters? We can

represent these five symbols as the three-bit symbols 000 through 100 on the

binary tree. This generates a constant-length code with three unused, or
illegal, symbols 101 through 111. These are marked with an "x" in Figure
2(a). These unused leaves and the branches leading to them may be pruned to
produce the binary tree of Figure 2(b).
If we admit variable-length codes, then we have several other options for
using a binary tree to construct binary codes. Two of these codes and their
corresponding binary trees are illustrated in Figure 3. If we disabuse ourselves
of the notion that each code word must contain three or fewer bits, then we
may construct binary trees like those of Figure 4 and generate their
corresponding binary codes. In Figure 4(a), we grow a right branch after each
left branch and label each leaf with a code word. In Figure 4(b), we prune off
the last right branch and associatea code word with the leaf on the last left
branch.

       Binary Trees and Constant-Length Codes; (a) Binary Tree, and (b)
                                   Pruned Binary Tree

All of the codes we have generated so far are organized in Table 2. For each
code, the average number of bits/symbol is tabulated. This average ranges
from 2.4 to 3.0. If all symbols are equally likely to appear, then the best
variable-length code would be code 2.

    Binary Trees and Variable-Length Codes; (a) Binary Tree for Variable-
      length Code, and (b) Another Binary Tree for Variable-length Code
All of the codes we have constructed have a common characteristic: each
code word is a terminating leaf on a binary tree, meaning that no code word
lies along a limb of branches to another code word. We say that no code word
is a prefix to another code word. This property makes each of the codes
instantaneously decodable, meaning that each bit in a string of bits may be
processed instantaneously (or independently) without dependence on
subsequent bits.
Exercise:

   Problem: Decode the following sequence of bits using code 2:
   Equation:

                                                    0111001111000000101100111.

    Left-Handed Binary Trees for Variable-Length Codes; (a) Left-handed
                      Binary Tree, and (b) Pruned Binary Tree
Code                                 Average
                                     Bits/Symbol
#     S0  S1  S2       S3     S4

1     000 001 010 011         100    15/5 = 3.0

2     000 001 01       10     11     12/5 = 2.4

3     000 001 010 011         1      13/5 = 2.6

4     1   01  001      0001   00001  15/5 = 3.0

5     1   01  001 0001 0000          14/5 = 2.8

Variable Length Codes

Exercise:
   Problem:

   Illustrate the following codes on a binary tree. Which of them are
   instantaneously decodable? Which can be pruned and remain
   instantaneously decodable?
   Equation:

          S0  S1   S2  S3      S4
                   00  11     101
          011 100

          011 100 00       0  01

          010 000 100 101 111.

Code #2 generated in Table 2 seems like a better code than code #5 because
its average number of bits/symbol (2.4) is smaller. But what if symbol S0 is a
very likely symbol and symbol S4 is a very unlikely one? Then it may well
turn out that the average number of bits used by code #5 is less than the
average number used by code #2. So what is the best code? The answer
depends on the relative frequency of use for each symbol. We explore this
question in the next section.
Binary Codes: Huffman Codes for Source Coding

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In 1838, Samuel Morse was struggling with the problem of designing an

efficient code for transmitting information over telegraph lines. He reasoned

that an efficient code would use short code words for common letters and

long code words for uncommon letters. (Can you see the profit motive at

work?) In order to turn this reasoned principle into workable practice,

Morse rummaged around in the composition trays for typeface in a

printshop.  He  discovered  that  typesetters  use  many  more        than  s's.  He

                                                                es

then formed a table that showed the relative frequency with which each

letter was used. His ingenious, variable-length Morse code assigned short

codes to likely letters (like "dot" for e) and long codes to unlikely letters

(like "dash dash dot dot" for z). We now know that Morse came within

about 15% of the theoretical minimum for the average code word length for

English language text.

A Variation on Morse's Experiment. In order to set the stage for our study
of efficient source codes, let's run a variation on Morse's experiment to see
if we can independently arrive at a way of designing codes. Instead of
giving ourselves a composition tray, let's start with a communication source
that generates five symbols or letters S0, S1, S2, S3, S4. We run the source
for 100 transmissions and observe the following numbers of transmissions
for each symbol:
Equation:

                                  
                                                    

                                  50 S s

                                                   0
                                                    

                                  20 S s

                                                   1
                                                  

                                   20S s

                                                 2
                                                  

                                   5S s

                                                 3
                                                

                                  5 S s.

                                                4

We will assume that these "source statistics" are typical, meaning that 1000

transmissions  would  yield  500          and  so     on.

                                  S0s

The most primitive binary code we could build for our source would use
three bits for each symbol:
Equation:

                                  S0  000
                                  S1  001
                                  S2  010
                                  S3  011
                                  S4  100
                                   x  101
                                   x  110
                                  x  111.

This code is inefficient in two ways. First, it leaves three illegal code words
that correspond to no source symbol. Second, it uses the same code word
length for an unlikely symbol (like S4) that it uses for a likely symbol (like
S0). The first defect we can correct by concatenating consecutive symbols
into symbol blocks, or composite symbols. If we form a composite symbol
consisting of M source symbols, then a typical composite symbol is
. S1S0S1S4S2S3S1S2S0 The number of such composite symbols that can
be generated is 5M . The binary code for these 5M composite symbols must
contain N binary digits where
Equation:
         N -1  M   N

      2        < 5 < 2 (N  M log2 5).

The number of bits per source symbol is
Equation:

                                                                N
                                                                         log2 5 = 2. 32.

                                                                M

This scheme improves on the best variable length code of Table 2 from
"Binary Codes: From Symbols to Binary Codes" by 0.08 bits/symbol.
Exercise:

   Problem:

   Suppose your source of information generates the 26 lowercase roman
   letters used in English language text. These letters are to be
   concatenated into blocks of length M. Complete the following table of
   N (number of bits) versus M (number of letters in a block) and show

                 N

   that approaches log2 26.

                 M

         M

         1     2      3                                                                   4  5  6

N        5     10

N /M     5     5
Now let's reason, as Morse did, that an efficient code would use short codes
for likely symbols and long codes for unlikely symbols. Let's pick code #5
from Table 2 from "Binary Codes: From Symbols to Binary Codes" for this
purpose:
Equation:

S0  S1   S2      S3     S4
 1  01  001    0001  0000.

This is a variable-length code. If we use this code on the 100 symbols that
generated our source statistic, the average number of bits/symbol is
Equation:

          1
                 [50 (1) + 20 (2) + 20 (3) + 5 (4) + 5 (4)] = 1. 90bits/symbol.

       100

Exercise:
   Problem:

   Use the source statistics of Equation 1 to determine the average
   number of bits/symbol for each code in Table 2 from "Binary Codes:
   From Symbols to Binary Codes".

Entropy. So far, each ad hoc scheme we have tried has produced an
improvement in the average number of bits/symbol. How far can this go?
The answer is given by Shannon's source coding theorem, which says that
the minimum number of bits/symbol is
Equation:

          M

    N  -       pi log2 pi
    M

          i=1

where pi is the probability that symbol Si is generated and - pi log2 pi
is a fundamental property of the source called entropy. For our five-symbol
example, the table of pi and - log pi is given in Table 2. The entropy is
1.861, and the bound on bits/symbol is
Equation:

                                                                         N
                                                                                   1. 861.

                                                                         M

Code #5 comes within 0.039 of this lower bound. As we will see in the
next paragraphs, this is as close as we can come without coding composite
symbols.

Symbol     Probability                    ~ Log Probability
                                          1
S0         0.5                            2.32
                                          2.32
S1         0.2                            4.32
                                          4.32
S2         02

S3         0.05

S4         0.05

Source statistics for Five-Symbol Source

Exercise:
Problem:

Select an arbitrary page of English text. Build a table of source
statistics containing pi (relative frequencies) and-log pi for a through z
. (Ignore distinction between upper and lower case and ignore
punctuation and other special symbols.) Compute the entropy

   26

-       pi log2 pi .

   i=1

Huffman Codes. In the late 1950s, David Huffman discovered an
algorithm for designing variable-length codes that minimize the average
number of bits/symbol. Huffman's algorithm uses a principle of optimality
that says, "the optimal code for M letters has imbedded in it the optimal
code for the M - 1 letters that result from aggregating the two least likely
symbols." When this principle is iterated, then we have an algorithm for
generating the binary tree for a Huffman code:

   i. label all symbols as "children";
  ii. "twin" the two least probable children and give the twin the sum of the

      probabilities:

  iii. (regard the twin as a child; and
  iv. repeat steps (ii) and (iii) until all children are accounted for.

This tree is now labeled with 1's and 0's to obtain the Huffman code. The
labeling procedure is to label each right branch with a 1 and each left
branch with a 0. The procedure for laying out symbols and constructing
Huffman trees and codes is illustrated in the following examples.
Example:
Consider the source statistics
Equation:

     Symbol                     S0   S1     S2     S3    S4
Probability                     0.5  0.2    0.2  0.05  0.05

for which the Huffman algorithm produces the following binary tree and its
corresponding code:

Example:
The Huffman code for the source statistics
Equation:

     Symbol    S0                       S1     S2    S3    S4
Probability  0.75                    0.075  0.075  0.05  0.05
is illustrated next:

Exercise:
   Problem:

   Generate binary trees and Huffman codes for the following source
   statistics:
   Equation:

      Symbol            S0    S1    S2    S3  S4   S5     S6           S7
Probability1          0.20  0.20  0.15  0.15  0.1  0.1  0.05         0.05

Probability2 0.3 0.25 0.1               0.1 0.075 0.075 0.05 0.05.

Coding a FAX Machine. Symbols can arise in unusual ways and be
defined quite arbitrarily. To illustrate this point, we consider the design of a
hypothetical FAX machine. For our design we will assume that a laser
scanner reads a page of black and white text or pictures, producing a high
voltage for a black spot and a low voltage for a white spot. We will also
assume that the laser scanner resolves the page at 1024 lines, with 1024
spots/line. This means that each page is represented by a two-dimensional
array, or matrix, of pixels (picture elements), each pixel being 1 or 0. If we
simply transmitted these l's and Os, then we would need
1024 × 1024 = 1, 059, 576 bits. If these were transmitted over a 9600
baud phone line, then it would take almost 2 minutes to transmit the FAX.
This is a long time.

Let's think about a typical scan line for a printed page. It will contain long
runs of 0's, corresponding to long runs of white, interrupted by short bursts
of l's, corresponding to short runs of black where the scanner encounters a
line or a part of a letter. So why not try to define a symbol to be "a run of k
0's" and code these runs? The resulting code is called a "run length code."
Let's define eight symbols, corresponding to run lengths from 0 to 7 (a run
length of 0 is a 1):
Equation:

S0 = run length of 0 zeros (a 1)

S1 =  run length of 1 zero

      run legnth of 7 zeros.
S7 =

If we simply used a simple three-bit binary code for these eight symbols,
then for each scan line we would generate anywhere from 3 × 1024 bits
(for a scan line consisting of all 1's) to 3 × 1024/7 400 bits (for a scan
line consisting of all 0's). But what if we ran an experiment to determine the
relative frequency of the run lengths S0 through S7 and used a Huffman
code to "run length encode" the run lengths? The following problem
explores this possibility and produces an efficient FAX code.
Exercise:
Problem:

An experiment conducted on FAXed documents produces the
following statistics for run lengths of white ranging from 0 to 7:
Equation:

     Symbol    S0    S1  S2   S3   S4     S5    S6  S7
Probability  0.01  0.06  0.1  0.1  0.2  0.15  0.15  0.2

These statistics indicate that only 1% of a typical page is black.
Construct the Huffman code for this source. Use your Huffman code to
code and decode these scan lines:
Binary Codes: Hamming Codes for Channel Coding

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The idea behind Hamming codes is to intersperse, or append, extra binary
digits to a binary code so that errors in transmission of the code over a
channel may be detected and corrected. For example, suppose we transmit
the code 01101001, and it is received as 01001001. In this transmission, the
third most significant bit is received erroneously. Let's define the following
"modulo-2 addition" of binary numbers:
Equation:

                                                                           00 = 0

                                                                            01 = 1

                                                                            10 = 1

                                                                           1  1 = 0.

Multiplication in modulo-2 arithmetic is simply 0  0 = 0  1 = 1  0 = 0
and 1 1 = 1. Then we can say that the error sequence 00100000 is "added"
to the transmission 01101001 to produce the erroneous reception:
Equation:

01101001 transmitted

 00100000  error

01001001   received.
Hamming error correcting codes will permit us to receive the erroneous
transmission and to detect and correct the error. This is obviously of great
value in transmitting and storing information. (Imagine how upset you
would be to have the binary code for your checking account confused with
that of Mrs. Joan Kroc.)

Choosing the Number of Check Bits. Let's suppose we have N bits of

information that we wish to transmit and that we wish to intersperse "check

bits" that will enable us to detect and correct any single bit error in the

transmission. If we use N information bits and n check bits, then we will

transmit  a  code  word  containing  N  +  n  bits.  The  n  check  bits  can  code      n

                                                                                     2

events, and we want these events to indicate whether or not any errors

occurred and, if so, where they occurred. Therefore we require

where (N + n) is the number of single error events that can occur and +1 is
the number of no-error events. For example, when N = 4, we require
n = 3 so that 23  (4 + 3) + 1.

How many check bits do you require to code seven bits of information for
single error correction?

Code Construction. Let's suppose we have constructed an (N, n)
Hamming code consisting of N information bits and n check bits (or parity
bits). We denote the information bits by x1, x2, ..., xN and the check bits by
c1, c2, ..., cn. These bits may be interspersed. When N = 4 and n = 3, then
a typical array of bits within a code word would be one of the following:
Equation:

                         c1             or    x1
                         c2                   x2
                         x1                   x3
                         c3                   x4 .
                         x2                   c1
                         x3                   c2
                         x4                   c3
The first ordering is "natural" (as we will see), and the second is

"systematic" (a term that is used to describe any code whose head is

information and whose tail is check). If a single error occurs in an (N, n)

code, then the received code word will be the modulo-2 sum of the code

word  and  the  error  word         that  contains  a  1  in  its    th  position:

                                                                   i

Equation:

                                               c1         0

                                               c2         0

                                               xl         0

                                               c3  l .

                                               x2         0

                                               x3         0

                                               x4         0

We would like to operate on this received code word in such a way that the
location of the error bit can be determined. If there were no code word, then
an obvious solution would be to premultiply the error word by the parity
check matrix
Equation:

                                          1010101

                         T                0110011
                                                                                                               .
                   A=
                                          0001111

                                [(1) (2) (3) (4) (5) (6) (7)]

The    th  column  of        T  is  just  the  binary  code   for  i.    When        T                            premultiplies

     i                 A                                                       A

an error word, the error bit picks out the column that codes the error

position:
If the error word contains no error bits, then the product is 0, indicating no
errors.

This seems like a good idea, but what about the effect of the code word? In
Exercise 1, you are asked to show that the effect of the parity check matrix
AT applied to the modulo-2 sum of a code word x and an error word e is
Equation:

                                  T               T        T
                          A (x  e) = A x  A e.

In this equation all sums and products obey the rules of modulo-2
arithmetic.
Exercise:

   Problem:

Let y = x  e denote the modulo-2 sum of a code word x and an error

word  e;        T  is  a  parity  check  matrix.  Show  that

          A

Equation:

                                     T   T              T
                                  A y = A x  A e.

We have designed the parity check matrix AT so that the syndromeATe
produces a binary code for the error location. (The location of the error is
the syndrome for the error word.) The product ATx will interfere with this

syndrome  unless        T  =  0.  Therefore  we  will  require  that  the  code  word  x

                  Ax

satisfy the constraint

Equation:

                                        T

                                  A x = 0.

This constraint actually defines the Hamming code. Let's illustrate this point
by applying the constraint to a code word in its "natural format" xT =
. (c1c2x1c3x2x3x4)

Natural Codes. When the information bits and the check bits are coded in
their natural order , (c1c2x1c3x2x3x4) then we may determine the check bits
by writing ATx as follows:
Equation:

                                                 c1

                                                 c2

                  1010101                        x1             0
                  0110011
                  0001111                        c3    =0

                                                 x2             0

                                                 x3

                                                 x4

We use the rules of modulo-2 arithmetic to write these constraints as
Equation:

                                                             c1  x1  x2  x4 = 0
                                                             c2  x1  x3  x4 = 0
                                                            c3  x2  x3  x4 = 0.

Therefore the check bits c1, c2, and c3 are simply the following modulo-2
sums
Equation:

              c1 = x1  x2  x4
              c2 = x1  x3  x4
              c3 = x2  x3  x4.

This finding may be organized into the matrix equation
Equation:

              c1  1101

              c2  1011

              xl  1000      x1

              c3 = 0111     x2
                                      .
              x2  0100
                            x3

                            x4

              x3  0010

              x4  0001

This equation shows how the code word x is built from the information bits
(x1, x2, x3, x4). We call the matrix that defines the construction a coder
matrix and write it as H:
Equation:

                  x = H

           T             T
           x = (c1c2x1c3x2x3x4)  = (x1x2x3x4)

Equation:
                           H=                1101
                                             1011
                                             1000
                                             0111
                                             0100
                                             0010
                                             0001

This summarizes the construction of a Hamming code x.
Exercise:

   Problem:

Check  to  see  that  the  product  of  the  parity  check  matrix        T  and  the

                                                                    A

coder matrix H is ATH = 0. Interpret this result.

Exercise:

Problem:

Fill in the following table to show what the Hamming (4, 3) code is:
Equation:
                x1 x2 x3 x4 c1 c2 x1 c3 x2 x3 x4
                 0 0 0 0 00 0 0 0 0 0
                 0 0 0 1 11 0 1 0 0 1
                 0010
                 0011
                 0100
                 0101
                 0110
                 0111
                 1000
                 1001
                 1010
                 1011
                 1100
                 1101
                 1110
                 1111

Exercise:
   Problem:

   Design a Hamming (11, n) code for coding eleven information bits
   against single errors. Show your equations for c1, c2, ..., cn and write
   out the coder matrix H for x = H.

Decoding. To decode a Hamming code, we form the syndrome ATy for the

received  (and  possibly  erroneous)  code  word  y  =  x    e.  Because        T  =  0,

                                                                          Ax

the syndrome is

Equation:

                                               T

                          s = A e.
Convert this binary number into its corresponding integer location and
change the bit of y in that location. If the location is zero, do nothing. Now
strip off the information bits. This is the decoding algorithm.
Exercise:

   Problem:

   Use the table of Hamming (4, 3) codes from Exercise 3 to construct a
   table of received codes that contain either no bit errors or exactly one
   bit error. Apply the decoding algorithm to construct (x1, x2, x3, x4)
   and show that all received code words with one or fewer errors are
   correctly decoded.

Digital Hardware. The tables you have constructed in Exercise 3 and 5 for
coding and decoding Hamming (4, 3) codes may be stored in digital logic
chips. Their functionality is illustrated in Figure 1. The coder chip accepts
(x1x2x3x4) as its address and generates a coded word. The decoder chip
accepts (c1c2x1c3x2x3x4) as its address and generates a decoded word. In
your courses on digital logic you will study circuits for implementing
coders and decoders.

                 Digital Logic for Hamming Code

Exercise:
   Problem:

   Discuss the possibility of detecting a received (4, 3) code word that is
   neither a valid code word nor a code word with a single error. How
   would you use such a detector?
Exercise:
   Problem:

   What fraction of received seven-bit words can be correctly decoded as
   Hamming (4, 3) codes?

Systematic Codes. Systematic Hamming codes are codes whose
information bits lead and whose check bits trail. The format for a (4, 3)
code is then . (x1x2x3x4c1c2c3) The construction of a (4, 3) code word from
the information bits may be written as
Equation:

x1       1                       0    0    0

x2       0                       1    0    0

x3       0                       0    1    0  x1
                                              x2
x4 =     0                       0    0    1  x3
                                              x4
c1       c11 c12 c13 c14

c2       c21 c22 c23 c24

c3       c31 c32 c33 c34

The coder matrix takes the form
Equation:

    1    0                       0    0

    0    1                       0    0

    0    0                       1    0                    I
                                           = _____ .
H=  0    0                       0    1
                                                          C
    c11  c12                     c13  c14
    c21  c22                     c23  c24
    c31  c32                     c33  c34
The problem is to find the matrix C that defines the construction of check

bits. The constraint ATx = 0 produces the constraint ATH = 0 so that

      T  =  0.  The  constraints        T  =  0  may  be   written  out  as

A H                               AH

Equation:

                                           1     0    0    0

                                           0     1    0    0

1010101                                    0     0    1    0                  0000
0110011                                                             = 0 0 0 0.
0001111                           =        0     0    0    1
                                                                              0000
                                     c11      c12     c13  c14
                                     c21      c22     c23  c24
                                     c31      c32     c33  c34

These constraints produce all the equations we need (twelve equations in
twelve unknowns) to determine the cij.
Exercise:

   Problem:

   Solve Equation 19 for the cij. Show that the coder matrix for a
   systematic Hamming (4, 3) code is
   Equation:

                     H=                    1000
                                           0100
                                           0010
                                           0 0 0 1.
                                           0111
                                           1011
                                           1101

Exercise:
   Problem:

   Show that the coder matrix of Exercise 7 is a permutation of the coder
   matrix in Equation 14. (That is, the rows are reordered.)
Exercise:
   Problem:

   (MATLAB) Write a MATLAB program that builds Hamming (4, 3)
   codes from information bits (x1x2x3x4) and decodes Hamming (4, 3)
   codes (c1c2x1c3x2x3x4) to obtain information bits (x1x2x3x4).
   Synthesize all seven-bit binary codes and show that your decoder
   correctly decodes correct codes and one-bit error codes.
Binary Codes: Numerical Experiment (Huffman Codes)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The paragraph below contains Lincoln's Gettysburg Address. Ignore special
symbols like periods and ignore the distinction between lowercase and
uppercase letters. Compute the relative frequency of occurrence for each of
the 26 letters of the alphabet. Write a MATLAB program to generate a
binary tree for the Huffman code of the Gettysburg Address. When you
have generated the code, compute the average code word length
Equation:

                                                                 26  ni
                                                                           li
                                             L=
                                                                     N
                                                               i=1

where  ni  is the relative frequency for symbol i and li is the code word
       N

length for symbol i. Compare L with the entropy

Equation:

                                         26  log2  ni                            26  ni  log2  N
                                                   N                                 N         ni
                                         ni                          =
           H = -
                                                                               i=1
                                         N

                                       i=1

and compare L to log2 26. Interpret your findings.
Gettysburg Address
Fourscore and seven years ago, our fathers brought
forth upon this
continent a new nation, conceived in liberty and
dedicated to the proposition
that all men are created equal. Now we are engaged
in a great civil war,
testing whether that nation or any nation so
conceived and so dedicated can
long endure. We are met on a great battlefield of
that war. We have come
to dedicate a portion of that field as a final
resting-place for those who have
given their lives that that nation might live. It
is altogether fitting and proper
that we should do this. But in a larger sense, we
cannot dedicate, we cannot
consecrate, we cannot hallow this ground. The
brave men, living and dead,
who struggled here have consecrated it far above
our power to add or detract.
The world will little note nor long remember what
we say here, but it can
never forget what they did here. It is for us the
living rather to be dedicated
here to the unfinished work which they who fought
here have thus far so nobly
advanced. It is rather for us to be here dedicated
to the great task remaining
before us-that from these honored dead we take
increased devotion to that
cause for which they gave the last full measure of
devotion-that we here
highly resolve that these dead should not have
died in vain, that this nation
under God shall have a new birth of freedom, and
that government of the
people, by the people, for the people shall not
perish from the Earth.

                         -Abraham Lincoln, November 19, 1863
An Introduction to MATLAB: Introduction

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Acknowledgment: This appendix, written with assistance from Cédric J.
Demeure and Peter Massey, was inspired by the MATLAB user's manual
from The MATHWORKS, Inc. The MA TLAB Primer, available through
the MATLAB User's Group, is a useful learning aid for teachers and
students. To join the MATLAB User's Group, send your request via E-mail
to matlab-users request@mcs.anl.gov.

Introduction

MATLAB stands for "Matrix Laboratory." It is a computing environment
specifically designed for matrix computations. The program is ideally
suited to circuit analysis, signal processing, filter design, control system
analysis, and much more. Beyond that, its versatility with complex numbers
and graphics makes it an attractive choice for many other programming
tasks. MATLAB can be thought of as a programming language like
PASCAL, FORTRAN, C, or BASIC. Like most versions of BASIC,
MATLAB can be used in an interactive mode wherein statements are
executed immediately as they are typed. Alternatively, a program can be
written in advance and saved to a disc file using an editor and then executed
in MATLAB. You will find both modes of operation useful.
An Introduction to MATLAB: Running MATLAB (Macintosh)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In order to run MATLAB on a Macintosh SE or PLUS computer, you need
the program called EDU-MATLAB. The program requires at least 1 Mbyte
of memory, System 3.0 or above, Finder version 3.0 or above, and an 800K
drive. A hard disc drive is highly recommended. In order to run MATLAB
on a Macintosh II, IIx, IIcx, or SE/30, you need the program called MacII-
MATLAB, and the same system requirements apply.

To start MATLAB, you may need to open the folder containing the
MATLAB program. Then just "double-click" the program icon or the
program name (for example, EDU-MATLAB). Figure A.1 shows a typical
organization of the folder containing Mac II-MATLAB. It contains the main
program, the settings file, the demonstrations folder, and any toolbox
folders. The double-click on Mac II-MATLAB produces the Command
window as shown in Figure A.2. You will also see a Graph window
partially hidden behind it. (The fact that the window is not in ffont means
that it is opened but not currently active.) If you do not know what
"clicking," "dragging," "pop-up menu," and "trash" mean, you should stop
reading now and familiarize yourself with the Macintosh.
      The MATLAB Folder
    (©Apple Computer, Inc.,
      used with permission.)

In the command window, you should see the prompt . The program
interpreter is waiting for you to enter instructions. At this point it is a good
idea to run the demonstration programs that are available in the "About
MATLAB" menu under the Apple menu. Just click on the "demos" button
and select a demo. During pauses, strike any key to continue. Whenever
you have a MATLAB file in any folder, then you may double-click the file
to launch the program. This allows you to have your own folder containing
your own MATLAB files, separated from the MATLAB folder.

     The Command Window
     (©Apple Computer, Inc.,
      used with permission.)

MATLAB has four types of windows:
   i. Command for computing, programming, and designing input/output
      displays;
  ii. Graph for displaying plots and graphs;

  iii. Edit for creating and modifying your own files; and
  iv. Help for getting on-line help and for running demos.
All windows follow the traditional behavior of Macintosh windows. You
can resize them (actually the help window has a fixed size) or move them.
For more details on menus and windows, see the Macintosh and MATLAB
manuals.
An Introduction to MATLAB: Running MATLAB (PC)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In order to run MATLAB (Version 3.5) on an IBM or compatible personal
computer, you must have a floating point math coprocessor
installed and at least 512 kbytes of memory. The program is called PCMAT-
LAB.EXE, but it is usually invoked via the batch file MATLAB.BAT in the
MATLAB subdirectory. If you are using a menu system and MATLAB is
one of your choices, just choose it. Otherwise, go to the MATLAB
suiUirectory and type MATLAB.

You may be able to usea more powerful implementation of MATLAB if you
have an 80286 or 80386 machine. AT-MATLAB runs on an 80286 with at
least 1 Mbyte of extended memory. AT-MATLAB is distributed with PC-
MATLAB. 386-MATLAB, a special version for 80386 or 80486 machines
with virtual memory support and no limits on variable size, is sold
separately.

When you run MATLAB, you should see the prompt . The program
interpreter is waiting for you to enter instructions. Some MATLAB
instructions, such as plot, are graphics-type instructions which plot results
and data. Execution of one of these graphics instructions puts the PC screen
into the graphics mode, which displays the resulting plot. No instructions
can be executed in the graphics mode other than a screen-dump function.
Striking any other key will return the PC to the command mode, but the
graphics are temporarily stored (like variables) and can be recalled by the
shg (show graphics) instruction. If you wish, you may run some of the
demonstration programs now by entering demo and following the on-screen
instructions.
An Introduction to MATLAB: Interactive Mode

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In command mode, MATLAB displays a prompt and waits for your
input. You may type any legal mathematical expression for immediate
evaluation. Try the following three examples (press "enter" or "return" at
the end of each line):
 2+2
 5^2
 2*sin(pi/4)

The variable pi = 3.14 is built into MATLAB, as are the sin function
and hundreds of other functions. When you entered each of the preceding
lines, MATLAB stored the results in a variable called ans for answer. The
value of ans was then displayed. The last line should have produced the
square root of 2. We can manipulate ans to find out

 ans^2

The new answer is very close to 2, as expected. Let's see what the roundoff
error is:

 ans-2
An Introduction to MATLAB: Variables

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

Any result you wish to keep for a while may be assigned to a variable other
than ans:

 x = pi/7
 cos(x)
 y = sin(x)^2+cos(x)^2;
 y

A semicolon (;) at the end of the line suppresses printing of the result, as
when we calculated y in the next-to-last line just shown. This feature is
especially useful when writing MATLAB programs where intermediate
results are not of interest and when working with large matrices.

MATLAB supports the dynamic creation of variables. You can create your
own variables by just assigning a value to a variable. For example, type x
= 3.5+4.2. Then the real variable x contains the value 7.7. Variable
names must start with an alphabetical character and be less than nineteen
characters long. If you type x = -3*4.0, the content 7.7 is replaced by
the value -12. Some commands allow you to keep track of all the variables
that you have already created in your session. Type who or whos to get the
list and names of the variables currently in memory (whos gives more
information than who). To clear all the variables, type in clear. To clear a
single variable (or several) from the list, follow the command clear by
the name of the variable you want to delete or by a list of variable names
separated by spaces. Try it now.
MATLAB is case sensitive. In other words, x and X are two different
variables. You can control the case sensitivity of MATLAB by entering the
command casesen, which toggles the sensitivity. The command
casesen on enforces case sensitivity, and casesen off cancels it.

If one line is not enough to enter your command, then finish the first line
with two dots (. . ) and continue on the next line. You can enter more than
one command per line by separating them with commas if you want the
result displayed or with semicolons if you do not want the result displayed.
For example, type

 theta = pi/7; x = cos(theta); y = sin(theta);
 x,y

to first compute theta,cos(theta), and sin(theta) and then to
print x and y.
An Introduction to MATLAB: Complex Variables

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

The number -1 is predefined in MATLAB and stored in the two variable
locations denoted by i and j. This double definition comes from the
preference of mathematicians for using i and the preference of engineers for
using j (with i denoting electrical current). i and j are variables, and their
contents may be changed. If you type j = 5, then this is the value for j
and j no longer contains -1. Type in j = sqrt(-1) to restore the
original value. Note the way a complex variable is displayed. If you type i,
you should get the answer

i =
       0+1.0000i.

The same value will be displayed for j. Try it. Using j, you can now enter
complex variables. For example, enter z1 = 1+2*j and z2 =
2+1.5*j. As j is a variable, you have to use the multiplication sign *.
Otherwise, you will get an error message. MATLAB does not differentiate
(except in storage) between a real and a complex variable. Therefore
variables may be added, subtracted, multiplied, or even divided. For
example, type in x = 2, z = 4.5*j, and z/x. The real and
imaginary parts of z are both divided by x. MATLAB just treats the real
variable x as a complex variable with a zero imaginary part. A complex
variable that happens to have a zero imaginary part is treated like a real
variable. Subtract 2*j from z1 and display the result.
MATLAB contains several built-in functions to manipulate complex
numbers. For example, real (z) extracts the real part of the complex
number z. Type

 z = 2+1.5*j, real(z)

to get the result

z =
     2.000+1.500i

ans =
     2

Similarly, imag(z) extracts the imaginary part of the complex number z.
The functions abs(z) and angle(z) compute the absolute value
(magnitude) of the complex number z and its angle (in radians). For
example, type

 z = 2+2*j;
 r = abs(z)
 theta = angle(z)
 z = r*exp(j*theta)

The last command shows how to get back the original complex number
from its magnitude and angle. This is clarified in Chapter 1: Complex
Numbers.

Another useful function, conj (z), returns the complex conjugate of the
complex number z. If z = x+j*y where x and y are real, then conj
(z) is equal to x-j*y. Verify this for several complex numbers by using
the function conj (z).
An Introduction to MATLAB: Vectors and Matrices

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

As its name indicates, MATLAB is especially designed to handle matrices.
The simplest way to enter a matrix is to use an explicit list. In the list, the
elements are separated by blanks or commas, and the semicolon (;) is used
to indicate the end of a row. The list is surrounded by square brackets [ ].
For example, the statement

 A = [1 2 3;4 5 6;7 8 9]

results in the output

A =
     1 2 3
     4 5 6
     7 8 9

The variable A is a matrix of size 3 × 3. Matrix elements can be any
MATLAB expression. For example, the command

 x = [-1.3 sqrt(3) (1+2+3)*4/5]

results in the matrix

x =
     -1.3000 1.7321 4.8000
We call a matrix with just one row or one column a vector, and a 1 × 1
matrix is a scalar. Individual matrix elements can be referenced with indices
that are placed inside parentheses. Type x(5) = abs(x(1)) to produce
the new vector

x =
     -1.3000 1.7321 4.8000 0.000 1.3000

Note that the size of x has been automatically adjusted to accommodate the
new element and that elements not referenced are set equal to 0 (here x(4)).
New rows or columns can be added very easily. Try typing r = [10 11
12],A = [A;r]. Dimensions in the command must coincide. Try r =
[13 14],A = [A;r].

The command size(A) gives the number of rows and the number of
columns of A. The output from size(A) is itself a matrix of size 1 × 2.
These numbers can be stored if necessary by the command [m n] =
size(A). In our previous example, A = [A;r] is a 4 × 3 matrix, so the
variable m will contain the number 4 and n will contain the number 3. A
vector is a matrix for which either m or n is equal to 1. If m is equal to 1, the
matrix is a row vector; if n is equal to 1, the matrix is a column vector.
Matrices and vectors may contain complex numbers. For example, the
statement

 A = [1 2;3 4]+j*[5 6;7 8]

and the statement

 A = [1+5*j 2+6*j;3+7*j 4+8*j]

are equivalent, and they both produce the matrix

A =                  2.0000+6.0000i
     1.0000+5.0000i  4.0000+8.0000i
     3.0000+7.0000i

Note that blanks must be avoided in the second expression for A. Try typing
A = [1 + 5*j 2 + 6*j 2 + 6*j;3 +7*j 4 + 8*j]

What is the size of A now?

MATLAB has several built-in functions to manipulate matrices. The special
character, ', for prime denotes the transpose of a matrix. The statement A =
[ 1 2 3;4 5 6;7 8 9]' produces the matrix

A =
     1 4 7
     2 5 8
     3 6 9

The rows of A' are the column of A, and vice versa. If A is a complex
matrix, then A is its complex conjugate transpose or hermitian transpose.
For an "unconjugate" transpose, use the two-character operator dot-prime (.
'). Matrix and vector variables can be added, subtracted, and multiplied as
regular variables if the sizes match. Only matrices of the same size can be
added or subtracted. There is, however, an easy way to add or subtract a
common scalar from each element of a matrix. For example, x = [1 2 3
4],x = x-1 produces the output

x =
     1 2 3 4

x =
     0 1 2 3

As discussed in the chapter on linear algebra, multiplication of two matrices

is only valid if the inner sizes of the matrices are equal. In other words, A*B

is valid if the second size of A (number of columns) is the same as the first

size  of  B  (number     of  rows).  Let  a i,j  represent     the        element  of  A  in  the     th

                                                                                                   i

row   and    the     th  column.  Then  the  matrix          A*B  consists  of     elements

                  j

Equation:

                                                          n

                                  (AB) =                       ai,k bk,j

                                                     i,j

                                                          k=1
where n is the number of columns of A and the number of rows of B. Try
typing A = [1 2 3;4 5 6];B = [7;8;9]; A*B. You should get
the result

ans =
       50
       112

The inner product between two column vectors x and y is the scalar defined
as the product x'*y or equivalently as y'*x For example, x =
[1;2],y = [3;4],x'*y, leads to the result

ans =
       11

Similarly, for row vectors the inner product is defined as x*y'. The
Euclidean norm of a vector is defined as the square root of the inner product
between a vector and itself. Try to compute the norm of the vector [1 2 3
4]. You should get 5.4772. The outer product of two column (row)
vectors is the matrix x*y' (x'*y).

Any scalar can multiply or be multiplied by a matrix. The multiplication is
then performed element by element. Try A = [1 2 3;4 5 6;7 8
9];A*2. You should get

ans =
       2 4 6
       8 10 12

     14 26 28

Verify that 2*A gives the same result.

The inverse of a matrix is computed by using the function inv(A) and is
only valid if A is square. If the matrix is singular, meaning that it has no
inverse, a message will appear. Try typing inv(A). You should get
Warning: Matrix is close to singular or badly scal
ed.

     Results may be inaccurate. RCOND=2.937385e-18

ans =                     0.3152
         1.0e+16*        -0.6304
         0.3152 -0.6304
                          0.3152
       -0.6304 1.2609
         0.3152 -0.6304

The inverse of a matrix may be used to solve a linear system of equations.
For example, to solve the system

you could type A = [1 2 3;1 -2 4;0 -2 1]; b = [2;7;3];
inv(A)*b and get

ans =
       1

     -1
       1

Equation:

           12            3  x1    2

           1 -2 4           x2 = 7 ,

           0 -2 1           x3    3

Check to see that this is the correct answer by typing A*[1;-1;1]. What
do you see?

MATLAB offers another way to solve linear systems, based on Gauss
elimination, that is faster than computing the inverse. The syntax is A\b
and is valid whenever A has the same number of rows as b. Try it.

The "Dot" Operator. Sometimes you may want to perform an operation
element by element. In MATLAB, these element-by-element operations are
called array operations. Of course, matrix addition and subtraction are
already element-by-element operations. The operation A. *B denotes the
multiplication, element by element, of the matrices A and B. Make two 3
×3 matrices, A and B, and try

 A*B
 A.*B

Suppose we want to find the square of each number in A. The proper way to
specify this calculation is

 A_squared=A.^2

where the period (dot) indicates an "array operation" to be performed on
each element of A. Without the dot, A is multiplied by A according to the
rules of matrix multiplication described in Chapter 4, giving a totally
different result:

 A^2

Subtleties. Because MATLAB can do so many different mathematical
functions with just a few keystrokes, there are times when a very slight
change in what you type will lead to a different result. Using the matrix A
entered earlier, type the following two lines:

 2.^A            %with a space after
 2 .^A

the 2.

In the first case, the dot is "absorbed" by the 2 as a decimal point and the ^
is taken as a matrix exponential. But, when the dot is separated from the 2
by a space, it becomes part of the operator (. ^) and specifies that 2 should
be raised to the power of each element in A. The point is, you should be
very careful to type what you mean in an unambiguous way until you are
familiar enough with MATLAB to know how the subtle situations wiIl be
interpreted. An unambiguous way of typing the preceding lines is
 (2.)^A       %for matrix
              %for array
exponential
 (2).^A

exponential.
An Introduction to MATLAB: The Colon

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

You can use the colon several ways in MATLAB (see help :). Its basic
meaning is a vector of sequential values. For example, type
 x = 3:9

to get

x =
     3 4 5 6 7 8 9

For increments other than 1, use statements like
 x = 1:0.5:4
 x = 6:-1:0

Most MATLAB functions will accept vector inputs and produce vector out-
puts. The statement
 y = sqrt(1:10)

builds a vector of integers from 1 to 10 and takes the square root of each of
those numbers. Try it.

Now for another subtlety-what is the effect of each of the following
statements and why?
 1+1:5
 1+(1:5)

Appending to a Matrix or Vector. A matrix or vector can be enlarged in
size by appending new values to the old values. Let x=[1 3 5]:
Equation:

x = [x6810]  x =       [1356810]

                  1 3 5 6 8 10

y = [x; 1 : 6]  y = [             ].

                  123456
An Introduction to MATLAB: Graphics

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

In "Complex Numbers", you learn that complex variables can be
represented as points in the plane. MATLAB makes it easy for you to plot
complex variables in a graph. Type z1 = 1+.5*j;plot(z1,'o').
The graph window should be activated and the point z1 displayed by a 'o'.
You must specify the symbol for display, and the authorized symbols for
point display are '.', 'o', '+', and '*'. When you are displaying a
curve (to come later), no type is necessary. MATLAB automatically adjusts
the scale on a graph to accommodate the value of the point being plotted. In
this case, the range is [0, 2] for the real part and [0, 1] for the imaginary
part.

Let's now plot a second complex number by typing z2 = 2+1.5*j;
plot(za,'o'). Note that the second plot command erases the first
plot and changes the scaling to [0, 4] and [0, 3]. Sometimes you may want
to have the points plotted on the same graph. To achieve this, you have to
use the command hold on after the first plot. Try the following:

 plot(z2,'o')
 hold on
 plot(z1,'o')
 hold off

The advantage in using the hold command is that there is no limit to the
number of plot commands you can type before the hold is turned off, and
these plots may involve the same variable plotted over a range of values.
You can also use different point displays. A disadvantage of the hold
command is that the scaling is enforced by the first plot and is not adjusted
for subsequent plots. This is why we plot the point z2 first. Try reversing
the order of the plots and see what happens. This means that points outside
the scaling will not be displayed. The command hold off permits
erasing the current graph for the next plot command.

You can freeze the scaling of the graph by using the command axis.
MATLAB gives you the message

Axis scales frozen
ans =

     0 4 0 3

This freezes the current axis scaling for subsequent plots. Similarly, if you
type axis a second time, MATLAB resumes the automatic scaling feature
and prints the message

Axis scales auto-ranged
ans =

     0 4 0 3

The axis scaling can also be manually enforced by using the command

 axis([xmin xmax ymin ymax])

where (xmin, ymin) is the lower left corner and (xmax, ymax) is
the upper right corner of the graph. This scaling remains in effect until the
next axis command is entered (with or without arguments).

Another way to plot several complex numbers on the same graph is to
display them as a curve. For this purpose, you have to store the numbers in
a vector. For example, type z1 = z1,z(2) = z2,plot(z). Note that
the two points are at the two extremes of the line plotted on the graph. If
you specify a symbol, then no line is drawn, just the extreme points. Try
plot(z,'o') .
If you examine your current graph carefully, you will notice that the unit
lengths on the x and y axes are not quite the same. In fact, MATLAB adjusts
the length of an axis to conform to the overall size of the graph window.
What this means is that a 45o line will actually be displayed at an angle
depending on the overall aspect ratio of the graph window. To ensure that
the aspect ratio is equal to 1, you may enter the command
axis('square'). MATLAB will then enforce an aspect ratio equal to 1,
regardless of the aspect ratio for the outside graph window. This ensures
that circles appear as circles and not as ellipses. MATLAB will make the
square graph as large as possible to fit within the graph window. To go back
to the default ratio, just type in axis('normal').

To add labels to your graph, the functions xlabel('text'),
ylabel('text'), and title('text') are useful and self-
explanatory. The argument text contains a string of characters. Add the
label Real on the horizontal axis and the label Imaginary on the vertical
axis of your graph. The command grid draws a grid on your graph. The
grid does not remain in effect for the next plots. Try it.

The plot Instruction. The plot instruction in MATLAB is very versatile. It
can be used to plot several different types of data. Its syntax is
plot(x,y,' symbol and/or color') or plot(y,'symbol
and/or color'). The instruction will plot a vector of data versus
another vector of data. The first vector is referenced to the horizontal axis
and the second to the vertical axis. If only one vector is used, then it is
plotted with reference to the vertical axis while the horizontal axis is
automatically forced to be the index of the vector for the corresponding data
point. The notation inside the apostrophes is optionally used to designate
whether each element of the vector is to be plotted as a single point with a
certain symbol or as a curve with a straight line drawn between each data
value. The colors can also be specified. Possible symbols are (*,o,+,.),
and colors are (r,g,b,w) (red, green, blue, and white). Complex valued
vectors are plotted by making the horizontal axis the real part of the vector
and the vertical axis the imaginary part. Warning: A complex valued vector
will automatically be plotted correctly on the complex plane (instead of real
versus imaginary) only if every element of the vector is complex valued.
Try plot (x,y,'*') , plot (x,'*'), plot (y,'*'), plot
(y,x,'*') and plot (z,'*'), plot (Real (z), Imag
(z),'*') to clarify your understanding of plot. Use
x = [1357], y = [2468], z =[1 + j, 2 + 2j, 3 + 3j].

We may summarize as follows:

plot(x,'*r')    (red star--points with the
plot(y)         values of
plot(x,y,'og')
                x

                on vertical and indicies
                on horizontal)

                (line--connected curve
                of the value of

                y

                on vertical and the value
                of

                x

                on horizontal)

                (line--connected curve
                of the value of

                y

                on vertical and the value
                of
plot(x,y,'og')              x
plot(real(z),imag(z))       on horizontal)
plot(real(z),imag(z),'+b')
                            (circle--points of the
                            value of
                            y
                            on vertical and the value
                            of
                            x
                            on horizontal)

                            (line--connectedplot of
                            z
                            on the complex plane)

                            (blue plus--points of
                            z
                            on the complex plane).
Subplots. It is possible to split the graphics screen up into several separate
smaller graphs rather than just one large graph. As many as four subplots
can be created. The MATLAB instruction subplot (mnp) signifies
which of the smaller graphs is to be accessed with the next plot statement.
The mnp argument consists of three digits. The m and n are the numbers of
rows (m) and columns (n) into which the screen should be divided. The p
designates which of the matrix elements is to be used. For example,

Help and Demos. MATLAB has on-line help and a collection of
demonstrations. For a list of available functions, type

 help

For help on a specific function, sin for example, type

 help sin

To learn how to use colon (;, a very important and versatile character) in
MATLAB, type

 help :

The demos will also help you become more familiar with MATLAB and its
capabilities. To run them, type

 demo
An Introduction to MATLAB: Editing Files and Creating Functions
(Macintosh)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

If you quit MATLAB now, all the commands you have typed will be lost.
This is where the Edit window is useful. If you choose new from the File
menu, a new window appears with the title Edit 1: Untitled. In this window,
you should type in all the commands you would like MATLAB to execute
at once. When you are finished typing, you may save the file by choosing
save or save as in the file menu and by entering a name for the file. If the
edit window is active (that is, if it appears in front), then choose save and
go from the file menu to save the file and execute it. If the command
window is active, then you can execute the file by entering its name.

Editing Files. To test your understanding of file editing, enter the following
commands in a file named myfile:

clear, clg                      %Clear variables a
nd graphics
j=sqrt(-1);                     %To be sure
z1=1+.5*j,z2=2+1.5*j            %Enter variables
z3=z1+z2,z4=z1*z2               %Compute sum and p
roduct
axis([0 4 0 4]),                %First plot

   axis('square'),plot(z1,'o')  %Allow overplot
hold on                         %Other plots
plot(z2,'o'),plot(z3,'+'),
       plot(z4,'*')
hold off

You do not have to type the % sign and the text that follows it. These are
simply comments in a file. They are ignored by the MATLAB interpreter.
You should, however, make a habit of adding comments (preceded by %) to
your file if you want to be able to understand programs that have been
written long ago.

Do not forget to save your file. Such a file is called a script file. It contains
MATLAB commands that could have been entered one by one in the
command window. You have three ways to execute a script file:

   i. with the edit window active, choose save and go from the file menu;
  ii. with the command window active, enter the file name; or
  iii. with the command window active, choose run script... from the M-file

      menu. In this case, a menu pops up to ask you which file you want to
      execute.

Try each of these three methods in order to get used to their differences.
Figure 1 shows the plot that you should get.

Creating Functions. MATLAB puts many commands at your disposal, and
you just have to enter their names (with or without arguments) to execute
them. Some commands are built in to MATLAB, and others are contained
in files to which you have access (not to modify them, but to see how things
are done). You can try to display the contents of a command file in the
command window by entering the command type filename. Enter type plot.
You should get the message

??? Built-in function.
     A Typical Graph (©Apple
     Computer, Inc., used with

             permission.)

This means that the command plot is a build-in function and thus cannot
be typed by the user (it is compiled with the program). Similarly, try to type
the function file containing the command sinh by entering the command
type sinh. You should get

function y=sinh(x)
%SINH SINH(X) is the hyperbolic sine of the elemen
ts of X.
y=(exp(x)-exp(-x))/2;

This is a typical example of a function file. It differs from a script file by the
fact that the first line contains the word function. What it does is make
the command y = sinh(x) equivalent to the command y=(exp(x)-
exp(-x))/2 . The variable x is the input argument (there could be more
than one), and y is the output argument (there also could be more than one).
The second line contains comments about the function and its arguments.
They can spread to several lines. Display them by typing the command
help sinh. The third line contains the actual function commands (there
could also be several lines).

As an exercise, enter the function perp(x):
function y=perp(x)
%PERP PERP(X) is a complex value perpendicular to
X.
j=sqrt(-1);
y=j*real(x)-imag(x);

Evaluate perp on various complex numbers. Replace the last line by y =
x*j;. Do you get the same result? Why?

Note that local variables are just that-local. Only the input and out- put
arguments are kept in memory after the function is called and executed. For
more on functions and multiple arguments, see the MATLAB manual. In
the previous example, the variable j is local. If, before using the function
perp, you use the same variable j, its contents will not be affected by the
command perp(z). Verify this.

Normally, while a file (script or function) is executed, the commands are
not displayed on the command window. Just the results are displayed. The
command echo allows you to view all the instructions. This is useful for
debugging and demonstrations. It is turned off by typing echo off.
An Introduction to MATLAB: Editing Files and Creating Functions (PC)

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

You should write a MATLAB program whenever you anticipate exe- cuting
some sequence of statements several times or again in a later session. On an
IBM PC, you may use any text editor to write a program, as long as the file
can be saved in ASCII format without the control codes used by most word
processors. Applicable text editors include Edix, Wordstar, XTree Pro, and
Turbo Pascal's editor.

Editing Files. If you have enough memory, you can run your editor without
leaving MATLAB by using the exclamation point (!), like this:

 !EDIX

The exclamation point may be used to execute any DOS command or
program from MATLAB. When the command or program finishes, your
MATLAB variables are just as you left them. Use your editor to write
program lines just as you would type them in MATLAB's command mode.
Then save the file with extension .m in the directory where you will run
MATLAB. Such MATLAB programs are called m-files. You may run your
m-file by typing the file name (without the .m extension) at the MATLAB
command prompt ().

Script Files. There are two kinds of m-files, called script files and
functions. Running a script file is exactly like typing the commands it
contains at the  prompt. Your m-file will automatically be a script file
unless you specify otherwise, as described later. Practice by entering,
saving, and running plotsin.m as listed next:
t = -6:.2:6;
y = sin(t);
plot(t,y)
title('SINE')
pause
grid
xlabel('t')
ylabel('sin(t)')

When the pause is executed, you will need to press a key to go on. If you
type whos after running plotsin, you will see that the variables t and y
remain in memory. Comments are important to a script file. They are
marked with the symbol %. Anything following this symbol on a line is
assumed to be a comment and is ignored by the MATLAB program
interpreter.

Functions. Functions differ from script files in that they have designated
input and output variables. Any other variables used within a function are
local variables, which do not remain after the function terminates and which
have no effect on variables outside the function. Many of the functions
supplied with MATLAB are actually m-files. A good example is triu.m:

 type triu

The word function at the beginning of the file makes it a function rather
than a script file. The function name in this line must match the file name.
The input variables of triu are x and k, meaning that the first input
argument will be referred to as x and the second as k within the function.
Likewise, the function line designates y as the output. There is nothing
special about the variable names x,k, and y when the function is used. It is
only that whatever inputs and output you use will be referred to as x,k, and
y inside the function. The variables m,n,j, and i are created temporarily
when triu runs and disappear when it terminates. They are local variables
and have no effect on variables with the same names outside the function.
In contrast, a script file has no local variables and does no substitution of
input and output variable names.
As an exercise, enter and save the function perp.m:

          function y=perp(x)
          % PERP(x) is a complex number perpendicular
to x.
          j = sqrt(-1);
          y = j*real(x)-imag(x);

Evaluate perp on various complex numbers. Replace the last line by y =
x*j;. Do you get the same result? Why?

Printing Files and Graphics. To display an m-file on the screen, use the
instruction  type filename. To make a copy at a printer, use the
DOS command  !print filename.m. Graphics hardcopy is
available through the commands meta and gpp. See the MATLAB manual
for more information.
An Introduction to MATLAB: Loops and Control

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

MATLAB has control statements like those in most computer languages.
We will only study the for loop here. See the MATLAB manual for details
on if and while statements.

What for loops do is allow a statement or a group of statements to be
repeated. For example,

for i = 1:n,x(i) = 0,end

assigns the value 0 to the first n elements of the array x. If n is less than 1,
the instruction is still valid but nothing will be done. If n is not defined,
then the following message will appear:

??? Undefined function or variable.
Symbol in question==>n

If n contains a real value, the integer part of n is used. If n is a complex
number, the integer part of the real part is taken. (This should, however, be
avoided.) If x is not declared earlier or is of smaller dimension than n, then
extra memory is allocated.

The command end must follow the command for. If it is not present,
MATLAB will wait for remaining statements until you type the command
end, and nothing will be executed in the meantime.
More than one statement may be included in the loop. The statement 1:n is
the way to specify all the integer values between 1 and n. A step different
than 1 may be specified. For example, the statement for
i=1:2:5,x(i)=1,end is equivalent to x(1)=1,x(5)=1. Negative
steps are also allowed, as in i=n:-1:1.

We may use a for loop to draw a circle of radius 1. Type

 j=sqrt(-1);
 n=360;
 for i=1:n,circle(1)=exp(2*j*i*pi/n);end;
plot(circle)

Note how easy it is to plot a curve. But also note how slowly the for loop is
executed. MATLAB is not very good at executing things one by one. It
prefers, by far, a vector-oriented statement. Using the range specification as
in the for loop, it is possible to speed up the process by replacing the
explicit for loop by an implicit for loop using the colon, like this:

 circle = exp((2*j*pi/n)*[1:n]);

Note how much faster this command is executed. In general, for loops
should be avoided as much as possible. For example, the first for loop you
typed could have been replaced by the command x=zeros(1,n);, which
is much more efficient. The function zeros fills the variable with 0's to the
specified size. Similarly, the function ones fills the variable with 1's. The
size can also be determined by the size of the argument. If A is a matrix of
size m,n, then the command B=ones(a) fills the matrix B with 1's and
forces the matrix B to have exactly the same size as the matrix A.

Avoiding for Loops. Since for loops are very inefficient in MATLAB
(they are computed sequentially, adding several more computations for
every loop), it is preferable to use the matrix capabilities of MATLAB to
replace for loops and speed up processing time.

   i. Replace the for loop
       for i = 1:10,  x(i) = i;  end;
    with
     x = 1:10

    to get

    x = [1 2 3 4 5 6 7 8 9 10]

ii. Replace the for loop
     z = something;  for i = 1:10,  x(i) =
    z*i;  end;

    with
     z = something  x = z*(1:10);

    to get

    x = [z 2*z 3*z ... 10*z]

iii. Replace the for loop
     z = something;  x(1) = z;  for i = 2:10.
     x(i) = z*x(i-1);  end;

    with
     z = something;  x = z.^(1:10);

    to get

    x = [z z**2 z**3 ... z**10]

iv. Replace the for loop
     for i = 0:2:100,  x(i) =
    1.0*exp(j*2*pi*i/100);  end;

    with
     x = 1.0*exp(j*2*pi*(0:2:100)/100);

    to get

    x = [exp(0) exp(j*4*pi/100) ...

    exp(j*200*pi/100)]
The Edix Editor

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

On a PC, creating and editing m-files is done outside of MATLAB. The
Edix editor is one of the visual types of editors. It can be accessed either
from DOS by using > edix filename.m or from MATLAB by using
 !edix filename.m. The latter will return you back to MATLAB
after you quit the editor. MATLAB script files must end with a .m
extension. They are also called m-files. Once in the Edix editor, a help list
of the editor's commands can be displayed on the screen by typing "Alt-h."
(Note: The "Alt" key must be held down while the "h" key is depressed.)
Pressing the "space" key will get you out of the help system.

A new file is created by calling the Edix editor with a file name that has not
been previously used. If the file name already exists on disc, then that file is
retrieved and displayed on the screen and is ready to be edited. Since Edix
is a visual editor, changes are made by moving the cursor to wherever
something needs to be typed in or deleted. Once changes have been made to
a file, then that file needs to be saved (written to disc) by typing "Alt-w."
When all editing is finished, you may exit from the Edix editor by typing
"Alt-x." Following are some useful Edix editor commands:

Alt-   help-list of all the Edix commands;
h(F7)
Alt-   saves (writes) the file to disc;
w
Alt-x  exits the Edix editor;
Alt-d
       deletes the current line;
Alt-
m      the first time used, marks the beginning of a block of lines
(F8)   to be edited; the second time, marks the end of a block of
       lines to be edited and highlights this block in white; the
Alt-c  third time, "un-marks" the highlighted block;

Alt-   makes a copy of the highlighted block at the current cursor
m      location (can be repeated);
(F5)
(F6)   (moves the highlighted block to the current cursor location
       (can be repeated);

       put the cursor at the beginning of the line; and

       puts the cursor at the end of the line.
Useful Mathematical Identities

Note:This module is part of the collection, A First Course in Electrical
and Computer Engineering. The LaTeX source files for this collection
were created using an optical character recognition technology, and
because of this process there may be more errors than usual. Please contact
us if you discover any errors.

ej, cos , and sin 

j                                             n                                  1       n

n e =limn (1 + j ) = n=0 n! (j) =cos  + j sin 

                                                                  n                                           n

                                              (-1)                   2n                                 (-1)       2n+1

   cos  =                                     (2n)!                   ; sin  =         n=0  (2n+1)!              

                                         n=0

                                  n                                                                  n

cos  =                            (-1)                                              (-1)                    2n+1

                             n=0                              2n                                        

                                               ; sin  =

                                  (2n)!                                     n=0     (2n + 1)!

Trigonometric Identities

Equation:

                                                                         2          2

                                                                     sin + cos  = 1

Equation:

                                  sin ( + ) =sin  cos + cos  sin 

Equation:

                                  cos ( + ) =cos  cos - sin  sin 

Equation:

                                  sin ( - ) =sin  cos - cos  sin 
Equation:

           cos ( - ) =cos  cos + sin  sin 

Euler's Equations                                     j

Equation:                                         e =cos  + j sin 
Equation:
                                                  sin  =  ej - e-j
Equation:                                                          2j

                                                  cos  =  ej + e-j
                                                                    2

De Moivre's Identity

Equation:

                                                                     n

           (cos  + j sin ) =cos n + j sin n

Binomial Expansion

Equation:

                                               N  N  n N -n     N         N!

                          N                          xy      ;         =

(x + y) =

                               n                                n         (N - n)!n!

                   n=0
Equation:

                                          N

                                             N

                     N

                 2=

                                             n

                                       n=0

Geometric Sums

Equation:

                                                   a    |z| < 1
                                      k       1-z

                          az =

                 k=0

Equation:

                 N -1                                                 N  z1
                                        k
                                           a(1 - z )
                           az =                  1-z

                  k=0

Taylor's Series                                                          k

Equation:                                     (k)       (x - a)

Equation:        f (x) =                   f       (a)

                                                               k!

                          k=0

                 (Maclaurin's Series if a = 0)
