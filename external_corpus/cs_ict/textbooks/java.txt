Java with BlueJ

      Ron McFadyen
     Jeanette Bautista
   September 3, 2019
©2019 Ron McFadyen, Jeanette Bautista
Department of Applied Computer Science
University of Winnipeg
515 Portage Avenue
Winnipeg, Manitoba, Canada
R3B 2E9

je.bautista@uwinnipeg.ca
r.mcfadyen@uwinnipeg.ca

This work is licensed under Creative Commons Attribution NonCommercial
ShareAlike 4.0 International Public License. To view a copy of this license visit

http://creativecommons.org/licenses/by-nc-sa/4.0/

This work can be distributed in unmodified form for non-commercial purposes.
Modified versions can be made and distributed for non-commercial purposes
provided they are distributed under the same license as the original. Other uses
require permission of the author.
The website for this book is

www.acs.uwinnipeg.ca/rmcfadyen/CreativeCommons/

                                             2
To Callum
To Linden & Bryn

                                                       3
Contents

1. Introduction............................................................................................................................................ 9
   1.1 Java, the beginning ..................................................................................................................... 9
   1.2 The Java Compiler and the Java Virtual Machine ........................................................10
   1.3 BlueJ ...............................................................................................................................................11
   1.4 A First Program .........................................................................................................................12
   1.5 Using BlueJ to Run HelloWorld ............................................................................................13

2 Basics.......................................................................................................................................................17
   2.1 Literals ..........................................................................................................................................17
   2.2 Variables.......................................................................................................................................17
   2.3 Primitive Data Types...............................................................................................................22
      2.3.1 Numeric Data Types: byte, short, int, long .............................................................22
      2.3.2 Integer Arithmetic ..........................................................................................................22
      2.3.3 Numeric Data Types: float, double ...........................................................................26
      2.3.4 Numeric Expressions.....................................................................................................29
      2.3.5 boolean Data Type ..........................................................................................................36
      2.3.6 char Data Type..................................................................................................................41
   2.4 Conditional Operator ?:........................................................................................................44
   2.5 Operator Priorities...................................................................................................................45
   2.6 The String Class..........................................................................................................................48
   2.7 Implied declarations using var ...........................................................................................58
   2.8 Output............................................................................................................................................59
      2.8.1 System.out..........................................................................................................................59
      2.8.2 JOptionPane.......................................................................................................................63
   2.9 Input...............................................................................................................................................65
      2.9.1 The Scanner Class ...........................................................................................................65
      2.9.2 The JOptionPane Class ..................................................................................................68

3 Control Structures..............................................................................................................................71
   3.1 Compound Statements ...........................................................................................................71
   3.2 if .......................................................................................................................................................72
                                                       4
3.3 while ...............................................................................................................................................85

3.4 for ....................................................................................................................................................93

3.5 switch ......................................................................................................................................... 107

3.6 do ...while ................................................................................................................................... 112

4 Introduction to Methods .............................................................................................................. 117

4.1 Void Methods........................................................................................................................... 118

4.2 Value-returning Methods ................................................................................................... 120

4.3 Parameters ............................................................................................................................... 122

4.4 Summary ................................................................................................................................... 126

5 Classes in the Java Class Libraries ............................................................................................ 131

5.1 Random...................................................................................................................................... 131

5.2 Character................................................................................................................................... 135

5.3 Scanner ...................................................................................................................................... 143

5.4 Math ............................................................................................................................................ 150

5.5 Integer ........................................................................................................................................ 154

6 ArrayLists ........................................................................................................................................... 159

6.1 Examples ................................................................................................................................... 161

6.2 Sieve of Eratosthenes........................................................................................................... 166

6.3 Parallel Lists ............................................................................................................................ 169

7 Designing Java Classes................................................................................................................... 173

7.1 Using Multiple Classes ......................................................................................................... 175

7.2 Fields........................................................................................................................................... 176

7.3 Methods ..................................................................................................................................... 180

7.4 Constructors ............................................................................................................................ 185

7.5 Visibility Specifications: Public, Private ....................................................................... 189

7.6 Constructors ............................................................................................................................ 190

7.7 Overloading.............................................................................................................................. 191

7.8 Associations ............................................................................................................................. 192

7.9 Reusing code............................................................................................................................ 196

7.10 Parameter lists and arguments........................................................................................ 198

7.10.1  Varargs: a variable number of arguments ......................................................... 201
                                             5
7.10.2 Code listings: Student, Subject................................................................................ 203
                                                 6
Preface

This book is Part I of a two-part set that introduces the Java programming
language. The text assumes the student will be using the BlueJ development
environment and provides some introductory BlueJ material. Our experience
has been that BlueJ is easy to learn and provides a good programming
environment for the beginner programmer.

The material in chapters 1 through 7 are required topics.
    · Chapter 1: This is a high-level introduction to Java. We discuss the
       HelloWorld program, and how to run HelloWorld in BlueJ.

    · Chapter 2: Basic concepts having to do with constants, variables, data
       types, expressions and input/output are covered.

    · Chapter 3: This chapter covers the major control structures a
       programmer uses.

    · Chapter 4: Methods are indispensable for organizing your code into
       modular components. Some programs present a solution to a complex
       problem. To help manage that complexity we can use methods where
       each method handles one small part of the overall solution..

    · Chapter 5: Java provides a great deal of functionality in its class
       libraries. We introduce several classes such as Random ...Random gives
       the programmer the ability to simulate throwing dice or tossing coins.
       As well, useful functionality in utility classes such as Math, Integer, and
       Character are covered.

    · Chapter 6: Many applications require a program to work with
       collections of data. For example, the set of courses at a university is a
       collection. Java programs must be able to manage such a set and the
       ArrayList data structure is well-suited to the task.

    · Chapter 7: The program code in a Java system is managed in structures
       where the basic component is the class. A Java class contains data and
       executable code. This chapter covers concepts that must be understood
       if one is to design and implement a Java-based system.

                                                       7
The examples in the text, and solutions to many exercises, are available on
the website for this text.

                                                  8
1 Introduction

This book is about programming in Java. We begin with short descriptions of Java and
BlueJ. We feel that BlueJ is one of the simplest development environments for the
beginning programmer to use. All examples in this text have been tested using BlueJ.
Sample solutions for odd-numbered exercises are available on the website for this text.

     Java, the beginning

James Gosling is referred to as the father of the Java programming language. He
graduated with a BSc (1977) from the University of Calgary and a PhD (1983) from
Carnegie Mellon University. Later, in 1994 at Sun Microsystems he created the Java
language while leading a team that was purposed with developing a handheld home-
entertainment controller targeted at the digital cable television industry. That project
did not produce the expected outcome, but in 1995, the team announced that the
Netscape Navigator Internet browser would incorporate Java technology, and from there
its adoption for implementing systems began. James Gosling has received several
awards, including:

     2007 - appointed an Officer of the Order of Canada.[1]

     2013 - named an Association of Computing Machinery Fellow for "Java, NeWS,
         Emacs, NetBeans, and other contributions to programming languages, tools, and
         environments".[2]

     2015 - awarded the IEEE John von Neumann Medal for "the Java programming
         language, Java Virtual Machine, and other contributions to programming
         languages and environments".[3]

In 2010 Oracle acquired Sun Microsystems and took over the development of the
language. The language has gone through a number of updates, and at the time of writing
the current release is referred to as Java 12. All programs in this text have been tested
using BlueJ running with Java 11.

This text is about programming Java applications. The student may be interested in other
Java technologies such as Java Card, Java TV, applets, etc.; for these we refer you to
Oracle documentation
(https://www.oracle.com/technetwork/java/javase/tech/index.html).

                                                       9
10

     The Java Compiler and the Java Virtual Machine

When someone develops a Java program they must first enter the Java code in a text file.
Such files have names that end with ".java" and are known as source code files. In order
to execute a Java program the program must first be translated into Java bytecode. We
say source code files are human-readable but bytecode files are just 0's and 1's and are
not human-readable.

A program that performs this transation is called a compiler, and we say that the source
code is compiled into bytecode. The compiler made available by Oracle is called javac.
Bytecode files always have a name that ends with ".class".

The bytecode is not directly executable on a computer - bytecode is not machine code,
but it is close to that. Bytecode is "executed" by a special program call the Java Virtual
Machine, or JVM. Java programs are portable in the sense that you can write a program
and deploy it anywhere - as long as there is a JVM for that platform.

The process of developing, compiling, and running a Java program is shown below.
                                                                                                             11

     BlueJ

BlueJ is an integrated development environment that provides a programmer with a
framework that includes an editor, a compiler, and a runtime environment. It is our
experience that BlueJ is very suitable for the beginning Java programmer.

BlueJ is available as a free download from http:www.bluej.org. The BlueJ website is a
resource for those who want to learn more.

We expect that if you are reading this text then BlueJ is already installed on available
student workstations. If not please consult your technical services staff. If you need BlueJ
on your own computer then please visit http://www.bluej.org and follow their
download and installation instructions.

Below is a picture showing HelloWorld in a BlueJ project. Note the button available to
compile the source code. This program is discussed in the next section.
12

       A First Program

Shown in Listing 1.1 is the traditional first program, HelloWorld, that appears in many
Java texts. When executed, this program does one simple thing: it displays the message
"Hello World".

                        Listing 1.1 HelloWorld.java

    1 public class HelloWorld

    2 {

    3    public static void main(String[] args)

    4    {

    5       String message = "Hello World";

    6       System.out.println(message);

    7    }

    8 }

The purpose of the HelloWorld program is to display one line on the standard output
device (the Terminal Window in BlueJ). When you inspect this program one thing that is
immediately obvious is that there is a lot of overhead to do just one thing. Each line of
the program is explained below:

Line 1 gives a name to the program: HelloWorld.

The program is actually a Java class and the lines making up the class are delimited by
the left brace { in line 2 and the right brace } in line 8.

Line 3 begins the definition of a method named main. In general, a method can take
arguments and the text String[] args() is the way those are indicated for a main
method - much more on this in later chapters.

The lines that comprise the main method begin with the left brace { in line 4 and end
with the right brace } in line 7.

Line 5 is an example of a Java assignment statement that, when executed, causes the value
Hello World to be stored in the memory locations reserved for the variable message.
                                                                                                             13

Line 6 is an example of how a program creates output. When this line executes the
contents of message are transferred to the standard output device (BlueJ's Terminal
Window) for the user to see.

     Using BlueJ to Run HelloWorld

Very little instruction is required to learn how to use BlueJ. This text assumes that BlueJ
is demonstrated in lectures and/or a laboratory setting. More information is available
at the BlueJ web site; for instance, there is a tutorial at
http://www.bluej.org/tutorial/tutorial-201.pdf.

In this section we discuss typical steps one can follow to run HelloWorld in the BlueJ
environment.

1. Download the sample programs from the text's web pages.

2. Unzip the sample programs storing them in a folder on your computer. Open the
   folder and locate the file HelloWorld.java.

3. Start BlueJ and then create a new project:

    An empty project actually contains one item

         ...a file named ReadMe.txt that will be discussed later on in the text.

4.       Now, to get a copy of HelloWorld ...Click the HelloWorld.java file, hold the mouse

button down, drag the file to your new BlueJ project window, and then release the mouse

button:
14

This action copies the file and now you have HelloWorld in your project.
   5. Double-click the image in the project representing HelloWorld ...the BlueJ editor
       opens showing you the contents. You should see the 8 lines shown in Listing 1.1.
       You should see the editor open as shown below:

   6. The next step is to compile the program. There are two ways to do this ...use the
       compile button on the editor window, or use the compile button on the project
       window with HelloWorld selected. If you click the compile button on the editor
       window the response will be that the code compiled with no errors:
                                                                                                         15

7. Finally, to run the program you must close the editor by clicking the close button.
   You are now back at the BlueJ project where you must right-click the HelloWorld
   icon and select, from the options shown, to execute the main method:

8. As a result of the above, BlueJ is ready to run the main method and prompts you
   for any argument values for main. Since there are none (arguments are discussed
   much later in the text), click the OK button:
16

   9. The program runs and you see the output in a window (named the Terminal
       Window) that pops up:

Exercises
      1. Run the Hello World program.
      2. Modify the Hello World program so it displays your name instead of "Hello
           World". To do this you must use the BlueJ editor and alter line 5. Then you must
           recompile the program and run the new version.
                                                                                                             17

  2 Basics

This chapter covers material that gives you the necessary information to run basic
programs that use constants and variables, perform calculations, obtain input from a
user, and generate output. The topics covered are literals, variables, primitive data types,
the String class, input, and output. Java is an object-oriented language and with the last
three topics you will begin to get an understanding of what object-oriented means.
Literals, variables, and the primitive data types are concepts you will find in most (if not
all) programming languages you encounter.

     Literals

It is common for programs to include constants; in Java these are referred to as literals.
Examples include: 123, 123.45, 'a', "Gosling", true. Most of the time a programmer codes
numeric literals and boolean literals in the same way we would normally write them
down (e.g. 123, 123.45, true, false). With practice you will get used to using single quotes
to specify a single character (e.g. 'a'), or double quotes to specify a text string (e.g.
"Gosling").

     Variables

The variable is a fundamental concept in programming. In general terms we say a
variable is a named location in a computer's memory, and the value stored in that
location is controlled during the execution of programs. A variable is a name associated
with a piece of computer memory - a piece of memory that holds a value that a program
can use and change as it executes.

The Java programming language requires us to declare the type of data to be primitive
types associated with a variable. Java makes a distinction between primitive data types
and other data types defined via classes. In the Java class libraries there are many pre-
defined classes, for example: String and System. The Java language contains eight
primitive data types: byte, short, int, long, float, double, char and boolean:

        · byte, short, int, and long are used for cases where the data is to be treated as
            whole numbers (numbers without a fractional component). For example, 33,
            498, -100 are whole numbers. These data types differ with regards to the
            magnitude of number they can represent.
18

        · float and double are used for cases where the data is numeric and where one
            expects values to have a fractional component such as: 101.5, 26.334, -55.5.
            When written we show them with a decimal point. Again, these two types differ
            with regards to size in terms of the number of significant digits and in the
            magnitude of the number they can represent.

        · char is used when there are individual characters to be handled. Examples of
            individual characters are 'a', 'b', 'q', '$'. Values are enclosed in single quotes.

        · boolean is used when the situation requires one to work with logical values of
            true and false. In a Java program these values are written just as we do in
            English: true, false.

A Java programmer declares a variable in a declaration statement, and then uses the
variable name later in a program to assign a value, to alter the current value, and to
reference the value currently stored. Two example programs follow; in Listing 2.1 the
program defines and uses a variable, and in Listing 2.2 the program alters the value
stored in a variable.

In Listing 2.1 note the following:

     In line 10 an int variable named i is declared,

     In line 11 the value 14 is assigned to i (that is, the value 14 is stored in the
         memory location reserved for i),

     Line 12 displays the value of i

           Listing 2.1: Using a variable

9   /**

10     * This Java class declares

11     * an int variable named i,

12     * assigns the value 14 to i,

13     * and displays i.

14     */

15  public class Variable

16  {

17         public static void main(String[] args){

18         int i;
                                                                                           19

19            i = 14;

20            System.out.println(i);

21         }

Listing 2.2 starts off like Listing 2.1 but modifies the value of i to 30 in line 13 just
before it is displayed for the second time. This program changes the value associated
with the variable.

    Listing 2.2: Changing the value stored in a variable

1   /**

2      * This Java class declares

3      * an int variable named i,

4      * assigns it a value and then

5      * changes its value.

6      */

7   public class VariableChanged

8   {

9          public static void main(String[] args){

10            int i;

11            i = 14;

12            System.out.println(i);

13            i = 30;

14            System.out.println(i);

15         }

16  }

Naming Variables

A convention used by many Java programmers is to choose names that are concise yet
meaningful. A name you choose should indicate the intent of its use. In situations where
the intent of use involves more than one word a common naming scheme is camel case.
For instance, suppose you need a variable to keep track of net pay. In order to have a
proper name a programmer could choose the name netPay for the variable. Two words
are involved: net and pay. the first word is in lower case and other word is catenated to
it, and only the first letter of the second word is capitalized.

Camel case is a style where words are catenated together forming a variable name - the
first word is all lower case, the second and subsequent words have only the first letter
capitalized.
20

Some examples of variables named according to camel case:

    netPay     grossPay         monthOfYear billingAddress
    dayOfWeek  shippingAddress  studentNumber lastName

Camel case is a good convention to follow when declaring variables. However, Java will
accept any variable name as long as the name starts with a letter and contains any
mixture of letters, digits, and the underscore character (' '). Some valid variable names
include: a123, net pay, gross pay.

Java variable names are case-sensitive. This means that variable names such as NetPay
and netPay are different variables.

Keywords

Java reserves the use of certain names referred to as keywords. Keywords are reserved
for special purposes and cannot be used as variable names. For example, int is reserved
for situations where one declares a variable to be of type int; you cannot declare a
variable with the name int.

In the sample programs shown so far we have seen a few of these reserved words: public,
class, void, static. In subsequent chapters we will see other keywords introduced such as
while, do, if, else.
                                                                                                             21
Exercises

    1. Java requires that all variables be declared. What type of message does the Java
         compiler report if a variable is not declared before it is used?

    Consider Listing 2.1. Change line 11 to read

          abc = 14;

         instead of

          i = 14;

    Compile the program. What is the response you get from the compiler?

    2. Java does not permit reserved words to be used as variable names.
    Consider Listing 2.1 again. Change all references to the variable i to public, as shown
    here:

                            int public;
                            public = 14;
                            System.out.println(public);

    Compile the program. What is the response you get from the compiler?
    3. Java variable names are case sensitive so two variables named Message and

         message do not refer to the same thing. Modify line 6 in the HelloWorld to be:

                           System.out.println(Message);

         What is the response you get from the Java compiler?
22

     Primitive Data Types

2.3.1 Numeric Data Types: byte, short, int, long

Numeric data types are used for numer values where there is no fractional component -
all values are whole integers. The byte, short, int, and long types differ in the amount of
memory used (and therefore minimum and maximum values):

data   memory minimum value               maximum value
type
byte   1 byte   -128                      127
short  2 bytes  -32768                    32767
int    4 bytes  -2147483648               2147483647
long   8 bytes  -9223372036854775807      9223372036854775808

Calculations can involve any of addition, subtraction, multiplication, division, and
modulo. The operations are represented by +, -, *, /, and % respectively. Some examples
follow:

                operator  example of use  example's result

                     +          7+11              18
                     -          12-5               7
                     *           3*4              12
                     /          13/5               2
                     %          13%5               3

2.3.2 Integer Arithmetic

If the operands of an arithmetic operation are both integers, the result is an integer.
Consider division - there is no remainder ...13/5 evaluates to 2 and not 2.6.

Modulo gives the remainder when the first operand is divided by the second operand.
The result of 13%5 is 3.
                                                                                                             23
Example: Division and Modulo

The following example program uses division and modulo to obtain the last two digits of
an integer. The output follows the listing.

    Listing 2.3: Obtain the last two digits of an integer

1   public class IntegerArithmetic

2   {

3      public static void main(String[] args)

4      {

5         // Use integer arithmetic

6         // Division: no remainder

7         // Modulo: yields the remainder

8         int number, digit;

9         number = 1297;

10        // Get right-most digit

11        digit = number % 10;

12        System.out.println(digit);

13        // Decrease number by a factor of 10

14        // and get next digit

15        number = number / 10;

16        digit = number % 10;

17        System.out.println(digit);

18     }

19  }

          Figure 2.1: Last two digits
24

Default Integer Data Type

If a numeric literal has no decimal point (such as 10025) then the data type used is int.
If a programmer wanted to use the long data type the value would have a suffix of L or l;
for example, 10025L.

L is recommended since the lowercase l appears too much like digit 1. We say int is the
default integer data type.
                                                                                                             25
Exercises

      4. We have seen some simple expressions in Java. Modify the program in Listing
           2.2 to use a simple expression. Alter the statement

            i = 30;

    to the following (so the value in i is multiplied by 3):

            i = i*3;

    This statement causes i to be multiplied by 3 and the result is stored back in i.

      5. Modify the program in Listing 2.3 so that each of the four digits are displayed
           on separate lines.

      6. Write a program to determine what happens when:
         (a) 1 is added to the largest int value,
         (b) 1 is subtracted from the smallest int value,
         (c) an integer is divided by zero.

      7. What values are produced by the following expressions:
         99 / 10
         99 / 10 * 10
         99 % 10
         99 - 99 % 10
         99 - 99 / 10
         99 10 * 10 + 99 % 10
26
2.3.3 Numeric Data Types: float, double

These data types are used to represent values that have decimal places. For example, the
numbers 11.5, 12.25, -300.123, and 0.0 are written with decimal places. Even zero
written as 0.0 is a double.

The float and double types differ with respect to the number of significant digits they
store (approximately 7 for float and 16 for double) and the overall magnitude of a value
that can be represented. The table below shows the amount of memory used and the
maximum value per type:

   data type  memory              maximum
      float   4 bytes        3.4028235 × 1038
              8 bytes  1.7976931348623157 ×
    double             10308

Of course a programmer can perform calculations on doubles and floats. The operators
we will discuss at this time include +, -, *, and / as shown in the following table.

   operator   example of                 example's
              use                        result
       +      7.1 + 1.1                  8.2
        -     12.1 - 5.0                 7.1
        *     2.2 * 2.2                  4.84
        /     10.0 / 4.0                 2.5

Listing 2.4 illustrates some simple double calculations in order to compute and display
fuel consumption as litres per 100 kilometres travelled.

   Listing 2.4: Perform simple double calculations

1  public class FuelConsumption

2  {

3     public static void main(String[] args)

4     {

5             // Calculate fuel consumption as

6             // litres per 100 kilometres travelled.
                                                27

7         // All calculations involve doubles.

8         double litres, km, km100;

9         litres = 60.6;

10        km = 500.25;

11        km100 = km/100.0;

12        // calculate litres per 100km

13        double consumption = litres/km100;

14        System.out.println(consumption);

15     }

16  }

Doubles as approximations

Not every number can be represented exactly as a double or float. You know that some
fractions cannot be written, using decimals, exactly or completely. Most people use the
decimal number system where we can write out the fraction 1/4 exactly as 0.25.
However, the fraction 1/3 is a repeating decimal. If we write it out as a decimal number
we either stop at some number of digits, or, we write it as 0.33333 ..., to indicate the
number has an infinite representation.

A similar case arises with computers - there are fractions that cannot be represented
exactly in a computer. With limited space we are often storing just an approximation.

One must be aware that round-off can occur when calculations are done with float and
double. Hence they are not appropriate for certain situations: for example if your
program needs to represent monetary values. A highly recommended book on Java is
Effective Java[4]. This is a great reference for the experienced programmer ...for
monetary calculations the BigDecimal class is recommended.

The following program demonstrates a calculation: one value subtracted from another.
If you performed the calculation yourself, you would say the answer is 0.05. However
this program prints a different answer. We have included this example to illustrate how
some values are just approximate values.

       Listing 2.5: Approximations.java

1   public class Approximations

2   {

3      public static void main(String[] args)

4      {
28

    5                          // the following result should be

    6                          // 0.05 but the value printed is

    7                          // 0.04999999999999716

    8                          System.out.println(100.25-100.20);

    9      }

    10  }

The output from the above is:

Default Decimal Data Type

When a numeric literal (such as 100.25) appears in a program with a decimal point, the
data type used is double; we say double is the default data type for values with a decimal
point. If the programmer wanted to use a float value then the suffix f would be used, as
in 100.25f.

To a non-programmer literals such as 100.0 and 100 may seem the same, but a Java
programmer knows the first is represented internally as a double and the second is
represented as an int.

We say that double and int are the default numeric data types.

We focus on these numeric data types for the rest of this text.
                                                                                                             29
Exercises

      8. Modify the program in Listing 2.4 to calculate and display fuel consumption as
           the number of kilometres travelled per litre of fuel.

      9. Write a program that converts a value in centimetres to an equivalent value in
           inches. Use the conversion: one inch equals 2.54 centimetres. Use variables of
           type double.

      10. Write a program that converts a value in dollars to an equivalent value in euros.
           Use the conversion: one euro equals 1.5 dollars. Use variables of type double.

      11. Modify Listing 2.5 to run some different calculations, such as:
                   System.out.println(100.5-100.00);
                   System.out.println(100.33-100.00);

2.3.4 Numeric Expressions

Calculations arise in almost every computerized application. For instance,

          calculating gross pay
          calculating tax payable
          resizing of text on a computer monitor
          direction of a ball when it strikes a border

Calculations are defined using Java expressions which comprise operators and operands:

          operators we consider are addition, subtraction, multiplication, division, and
              modulo represented by +, -, *, /, and % respectively. All of these operators are
              binary operators, meaning that they have two operands. Expressions
              involving these are written in an infix manner where one operand is on the
              left of the operator and the other operand in on the right of the operator.

          operands are either literals, variables, or sub-expressions.

          Sub-expressions are expressions enclosed in parentheses, ( and ).

Some examples of expressions, going from simple to more complex are:
30

                                           Some Java Expressions
                                  1 32.0
                                  2 9.0/5.0
                                  3 105%10
                                  4 9.0/5.0*c
                                  5 9.0/5.0*c+32.0
                                  6 5.0*(f-32.0)/9.0

Expressions numbered 3, 4 and 5 above are complex, and to fully understand how Java
evaluates these requires knowledge of operator priorities and associativity.

Operator Priorities

Java gives each operator a priority and then uses those priorities to control the order of
evaluation for an expression. Higher priority operators are executed before lower
priority operators. Sometimes a programmer may need to override these priorities and
would use a sub-expression for that purpose; a sub-expression is always evaluated
before the expression in which it is contained is evaluated. Consider the following table
of operator priorities:

                                     Operator Priorities
                                      Highest to lowest

                                             * /%

                                    + -

Multiplication is given the same priority as division and modulo, and addition is given
the same priority as subtraction. However, the priority of multiplication, division, and
modulo is higher than that of addition and subtraction. The following table shows
expressions, the order of evaluation shown with equivalent sub-expressions, and the
final result.
                                                                       31

           Java expressions involving priorities

expression        equivalent                                   final
                  evaluation                                   result

9.0 / 5.0 + 32.0  (9.0 / 5.0) + 32.0                           33.8

105 - 105 % 10 105 - (105 % 10)                                100

1 + 3 * 2         1 + (3 * 2)                                  7

The next two examples show situations where operator priorities must be overridden in
order to have correct calculations:

Example: Calculate Net Pay

Suppose we must calculate an employee's net pay. Suppose for the employee we have
their gross pay, deductions from gross, and their tax rate in variables named grossPay,
deductions, and taxRate respectively. Suppose net pay is calculated by subtracting
deductions from gross pay and then multiplying by the tax rate. If we code this as
grossPay - deductions * taxRate we will get the wrong result since * has
higher priority than -. We need use a sub-expression as:

(grossPay - deductions)* taxRate

Example: Calculate Area of Trapezoid
Consider the formula for calculating the area of a trapezoid:
32

If we were to code the formula as a + b / 2 * h

the area would be calculated incorrectly due to division and multiplication having higher
priority than addition. To force the correct evaluation we can use a sub-expression and
override operator priorities: the formula must be written as:

(a + b)/ 2.0 * h

Sub-expressions are used to change the order of evaluation ...in this case we make a +
b a sub-expression, and hence evaluated before the division and multiplication.

Operator Associativity

When an expression involves more than one operator of the same priority it is necessary
to understand the order in which they are evaluated. If more than one multiplication or
division appears in an expression, they are evaluated from left to right; similarly for
addition and subtraction. In programming terms we say these operators are left
associative.

Suppose if we want to convert a temperature in Celsius to an equivalent Fahrenheit
temperature using the formula

A programmer can code this as 9.0 / 5.0 * c + 32.0. This would be correct as the expression
is evaluated by Java as required: the division, 9.0 / 5.0, is performed, then the
multiplication, and then the addition. If division and multiplication were right-to-left
associative the result of the above would be incorrect.

Mixed Mode Expressions

Expressions could contain a mixture of types. Java permits conversions between integer
and floating-point types.

There are two types of conversions: widening and narrowing.

By widening we mean that the type being converted to contains all values of the other
type. For example, any value of the short type (a 2-byte integer) can be represented as
an int type (a 4-byte integer). In the following program (see line 12) the value of s, a 2-
byte integer, will be converted to an int value, a 4-byte integer.
                                                          33

              Listing 2.6: Example of widening

1   /**

2      * This Java class declares a short variable,

3      * assigns it a value, and then assigns the

4      * value to a variable of type int

5      */

6   public class ShortToInt

7   {

8          public static void main(String[] args){

9             short s;

10            int t;

11            s = 100;

12            t = s;

13            System.out.println ("s is: "+s);

14            System.out.println ("t is: "+t);

15         }

16  }

Java allows these widening conversions automatically:

    · from byte to short, int, or long, float, or double
    · from short to int, long, float, or double
    · from int to long, float, or double
    · from long to float or double
    · from float to double
    · from char to int, long, float, or double

Example 1
 Consider the expression

          (100 - 10)* 0.10

 The sub-expression involves integers and the result is an integer producing a value of
 90. Next in the evaluation will be the multiplication involving 90 and 0.10; note these
 are different types: int and double. Java automatically converts the 90 to 90.0 before the
 multiply is performed.

Example 2

Consider the expression
34

(9/5)* 1 + 32.0

The sub-expression, 9/5, involves integers and the result is an integer yielding a value of
1. Next in the evaluation will be the multiplication involving 1 and 1, which yields the int
value of 1. Now we have 1 plus 32.0. For this to be performed the 1 is converted to 1.0
and the final result is 33.0. Note that this would be considered inaccurate (wrong) for the
conversion of 1 degree Celsius to Fahrenheit. To obtain a more accurate result 9.0/5.0
should be used instead of 9/5.

Narrowing conversions are cases where there could be a loss of precision narrowing
going from one type to another. For example converting from a double to an int is not
allowed unless the programmer directly indicates that casting is to be performed. We will
leave casting until a later chapter.

Unary Minus

There are several unary operators where the operator takes one operand. The unary
minus is one most people would be familiar with. A unary minus, -, can be placed
immediately in front of an expression to negate the value of the expression. For instance
the value of -(50-75) is 25. The unary minus precedes its operand as shown above. Its
priority is higher than multiplication, division, and modulo.

Exercises

    12. Write a program to calculate an employee's gross pay where variables
        hoursWorked and rateOfPay hold the employees hours worked and rate of
        pay respectively. Gross pay is calculated as hours worked times rate of pay. Test
        your program with hoursWorked = 40 and rateOfPay = $7.50 per hour.

    13. Write a program to calculate the provincial sales tax and the general sales tax
        payable for an item where the variables pstPayable, gstPayable,

    price represent the provincial sales tax payable, the general sales tax payable,
    and an item's price. Use the formulas:

                 pstPayable = price  0.05  gstPayable = price  0.08

    Test your program with price = $50.00.

    14. Suppose a customer is charged an amount and the customer gives the clerk an
        amount that is larger. An amount equal to the difference between the amount
        given and the amount charged must be returned to the customer. Write a
        program that calculates this amount to be returned to the customer. Use
                                                                                                      35
    variables amountCharged, amountGiven, amountReturned to represent the
    different amounts. Test your program with amountCharged = $75.50 and
    amountGiven = $100.00.
15. Write a program that uses the formula

   where c represents degrees Celsius to calculate the equivalent Fahrenheit value.
   Test your program using c = 22.0.
16. Write a program that uses the formula

   where f represents degrees Fahrenheit to calculate the equivalent Celsius value.
   Test your program using f = 22.0.
17. Write a program that uses the formula

   to calculate the area of a triangle. Run your program for h=25.
36

2.3.5 boolean Data Type

The boolean type has two values: true and false. We will see that the boolean type can be
useful when we discuss control structures in the next chapter. There are three operators
defined for booleans: and, or and not represented in Java as &&, ||, and ! respectively.

&& and || are binary operators where the operator appears between the two operands;

! is a unary operator that precedes its operand.

   operator in Java                 Boolean operators

   AND  &&                meaning
                          Evaluates to true if and only if both operands are true;
   OR   ||                evaluates to false otherwise.
                          Evaluates to true if at least one operand is true;
   NOT  !                 evaluates to false if both operands are false.
                          NOT: negates the operand.

Three truth tables below show the results for Boolean operators for all possible values
of their operands.

Boolean operation of AND  Boolean operation of OR          Boolean operation of NOT

a  b a &&b                       a                b a ||b  a  ! a

true true true            true      true true              true false

false true false          false     true true              false true

true false false          true      false true

false false false         false     false false
                                                                                                             37

The following table gives some example boolean expressions. The last 3 examples are
complex expressions. To understand those evaluations we need to know Java rules for
evaluating these expressions (discussed in the notes below).

         boolean x, y, z;
x=false; y=true; z=true;

     example     result
1 y              true
2 y && z         true
3 x || y         true
4 !x             true
5 x && y || ! z  false
6 ! x || y       true
7 ! (x || y)     false

A Boolean expression may have multiple operators. Consider example 5 from above,
x && y || ! z
Java assigns priorities to Boolean operators:
! is highest, followed by &&, followed by ||.

Higher priority operators are evaluated before lower priority operators. So, for the
above expression
!z is evaluated first yielding false.
So now the expression effectively becomes: x && y || false
As && has higher priority than || it is evaluated next yielding false.
So now the expression effectively becomes: false || false which evaluates to false.
38
sub-expressions
Sub-expressions are enclosed in parentheses. A sub-expression is evaluated before the
expression of which it is a part, and that value is substituted in its place. Consider
examples 6 and 7 from above. They are the same except for the use of parentheses.
In example 6:
! x || y
the ! is evaluated first, and the expression effectively becomes:
true || y
which evaluates to true.

In example 7:
! (x || y)
the sub-expression (x || y) is evaluated first, and then ! is evaluated. Since x||y evaluates
to true, the result for the expression is false.
Some further points about the Boolean operators (not very important to us yet):

      When && is being evaluated and if the first operand is false, then the result must
          be false and so the second operand is not evaluated.

      When || is being evaluated and if the first operand is true, then the result must
          be true and so the second operand is not evaluated.

other operators
· There are other operators (&, |, and ^) that you may be interested in learning about
subsequent to this course. These, amongst other features, are discussed in Java in a
Nutshell [5].
                                                                                                             39
Relational Operators

There are a number of operators defined for comparing one value to another. These are
summarized in the table below (assume x and y are of type int). These operations
evaluate to a boolean (true or false):

Relational operators

operator     meaning                   example

<            less than                 x <y

>            greater than              x > 5

<=           less than or equal to     22 <= y

>=           greater than or equal to  x > y

==           equal to                  x == y

! =          not equal to              x ! = 0

Make special note that == is the operator used to test for equality, and != is used to test
two operands to determine if they are not equal. Listing 2.7 illustrates the use of
relational operators. Later in the chapter on control structures we will use relational
operators in many examples.

             Listing 2.7: Comparing char values

1    public class CompareNumber

2    {

3         public static void main(String[] args)

4         {

5            // i1 and i2 are two char variables
40

    6         int i1 = 111;

    7         int i2 = 555;

    8         // Display i1 and i2

    9         // Display true or false according

    10        // to whether they are equal or not

    11        System.out.println("The int values");

    12        System.out.println(i1);

    13        System.out.println(i2);

    14        System.out.println("Testing i1==i2");

    15        System.out.println(i1==i2);

    16        System.out.println("Testing i1<i2");

    17        System.out.println(i1<i2);

    18        System.out.println("Testing i1>i2");

    19        System.out.println(i1>i2);

    20     }

    21  }
                                                                                                             41
2.3.6 char Data Type

char is used when you need to handle characters individually. When you see a char value
in a program you see it enclosed in single quotes, as in:

'a', 'A', 'q', '%'.

Java organizes memory for char values so that each value is stored using two bytes of
memory. One byte of memory is eight bits. We can consider a bit as being either on or off,
or, 0 or 1. A byte of memory can be considered to be a sequence of eight 0's and 1's. Just
for interest, the bit sequences and corresponding integer value for a few characters is
listed below:

character       bit sequence  corresponding integer
                              value
   'a'     0000000001100001
   'b'     0000000001100010                 97
   'c'     0000000001100011                 98
   'A'     0000000001000001                 99
   'B'     0000000001000010                 65
   'C'     0000000001000011                 66
   '0'     0000000000110000                 67
   '1'     0000000000110001                 48
   '2'     0000000000110010                 49
   '$'     0000000000100100                 50
   '%'     0000000000100101                 36
   '&'     0000000000100110                 37
                                            38

Recall the relational operators compare one value to another, and so these operators
produce a boolean value of true or false. These are shown again in the table below;
assume x and y are of type char.
42

        operator    Relational operators    example
            <                               x < y
            >     meaning                   x > 'a'
            <=    less than                 'a' <= y
            >=    greater than              x > y
            ==    less than or equal to     x == y
            !=    greater than or equal to  x != '$'
                  equal to
                  not equal to

Recall that == is the operator used to test for equality, and != is used to test two values
to determine if they are not equal. Listing 2.8 illustrates their use in a program. Later on
in the section on the Character class you will see useful techniques for analyzing
individual characters in a string.

              Listing 2.8: Comparing char values

    1   public class CompareChar

    2   {

    3      public static void main(String[] args)

    4      {

    5             // c1 and c2 are two char variables

    6             char c1 = 'a';

    7             char c2 = 'z';

    8             // Display c1 and c2

    9             // Display true or false according

    10            // to whether they are equal or not

    11            System.out.println("The char values");

    12            System.out.println(c1);

    13            System.out.println(c2);

    14            System.out.println("Testing c1==c2");

    15            System.out.println(c1==c2);

    16            System.out.println("Testing c1<c2");

    17            System.out.println(c1<c2);

    18            System.out.println("Testing c1>c2");

    19            System.out.println(c1>c2);

    20     }

    21  }
                                                                                                             43

                                  Results of comparing char values
Exercises

      18. Write a program that will print the integer values for the characters '!',
           '@', '#', '$', '%', '^', '&', '*', '(', ')'. Note that Java
           allows a statement such as

            int value = 'a';

      19. Since Java uses two bytes of memory there are 16 bits used to represent char
           values. How many different char values can be represented?
44

     Conditional Operator ?:

The conditional operator is sometimes called the ternary operator as it has three

operands. Note the placement of ? and : in its syntax:

<logical expression> ? <true value> : <false value>

where

<logical expression> is some logical expression evaluating to true or false

<true value> is the result when the logical expression is true

<false value> is the result when the logical expression is false

The conditional operator yields a result that is either <true value> or <false value>.

Example 1

Suppose we want to assign the variable maxValue the maximum of two variables, x and
y. This is easily done with an assignment statement where the right hand side is coded
with the conditional operator, as in:

                      maxValue = (x>y) ? x : y ;

          This form is often used by programmers for simple cases like the above. In a later
          chapter we will see the if-else statement that can be used for exactly the above
          , but it is much more verbose.

Example 2

Suppose you need to display the larger of two values x and y. To do this we can use the
above expression inside a display statement., as in:

System.out.println("largest is "+ ((x>y) ? x : y ) );

Exercises
      20. Write a program that obtains a String (a password) from the user and displays
           the message "too short" if the length of the password is less than 8. Note
           that if passwd is of type String then passwd.length() is the number of
           characters (the length) of the value stored in passwd.
                                                                                                     45

Operator Priorities

We have seen arithmetic, relational, and boolean operators so far. The table below shows
these operators and several others: method invocation, postincrement, post-decrement,
and assignment.

              Priorities of Operators

priority  Java operator  meaning
16
          name of a method(...) method invocation
15
14        ++             post-increment
13
          -              post-decrement
12
          -              unary minus
10
          !              boolean not
9
5         new            object creation
4
3         /              division
2
          *              multiplication

          %              modulo

          +              addition

          -              minus

          +              string catenation

          <              less than

          <=             less than or equal to

          >              greater than

          >=             greater than or equal to

          ==             equals

          !=             not equals

          &&             boolean and

          ||             boolean or

          ? :            conditional operator

          =              assignment

          +=             assignment with operation

          -=             assignment with operation

          *=             assignment with operation

          /=             assignment with operation

          %=             assignment with operation

Previously we stated some operators had the same priority as others, and that some had
a lower/higher priority that some others. In the table above you see the actual operator
46

priorities. For example, both unary minus and boolean not have the same priority (15)
which is much higher than most others. Assignment has the lowest priority (2).

There are several operators we do not discuss in this text. There are operators for every
level from 1 to 16; we have not included any of the operators at levels 1, 6, 7, or 8. You
could consult a reference such as Java in a Nutshell [5] at some future date.

Complex Expressions

Expressions can be very complex ...each operand can itself be an expression that
evaluates to true or false. Consider the following complex expression where a, b, c,
d, x, z are numeric types:

boolean answer = a+b > c+d && x<z

The && operator has two operands:

a+b > c+d and x<z

and each will evaluate to either true or false. If you look at the priorities of operators you
will see the additions will be done first, followed by the relational operators, followed by
&&, and finally the assignment to the variable answer.

Some programmers prefer to include extra spaces and parentheses in expressions like
the above ...in order to make the expression more readable, as in:

boolean answer = ((a+b)> (c+d))&& (x<z)

In this example the parentheses do not change the order of operations; rather, they may
make it easier for someone to read.

The Assignment Operator

What is often referred to as the assignment statement is really a Java expression followed
by a semicolon. The assignment operator, having a priority of 2, is usually the last
operator to be evaluated. The assignment operator is right associative. That is, when
several assignment operators appear in an expression they are evaluated/performed
from right to left. So, if you have the statement:

           int q = (j=1)+1;
                                                                                                             47
then j will have the value 1 and q will have the value 2.

That statement above would be an odd statement to see in a program.
What is more likely is to have several variables all initialized to the same value, as in:

          int i = j = k = 1;
48

     The String Class

It is very common for a program to work with text strings and the Java String class is
provided to facilitate the many things that programmers need to do with text strings.
String literals are written as a sequence of characters that are delimited by double
quotes. For example:

"this is a line of text"

"my first name is Joe"

"Joe was born on May 1, 1999"

The assignment statement:

     String fullName = "Joe Smith";

declares fullName to be of type String. fullName is a variable and the Java compiler
allocates memory for fullName. The memory location for fullName will contain a
reference (an address) to the storage location where the text string "Joe Smith" is
actually stored. Memory for primitive types is handled differently. The memory location
associated with a primitive type contains the value (not an address) of the variable. For
example, an int variable will have a memory location reserved for it where the value of
the variable is stored.

There is a subtle difference that may be hard to appreciate at this time: a variable (of
type String) holds a reference to the value instead of holding the actual value. The
diagram below attempts to show the difference.

Object References
49
50

Since text strings are objects of type String another way to declare fullName and assign
it a value is to use the new operator:

     String fullName = new String ("Joe Smith");

In general, the new operator is used to instantiate (to create) an object. new operator
Because text strings are so common Java provides the short cut for allocating a string,
such as:

     String fullName = "Joe Smith";

The only way to work with objects is through the methods that are defined in the class
from which the object is instantiated. The String class provides many methods for
working with text strings such as:

               Useful String methods

method name    type            description

charAt(...)    char            returns the character at a

                               specified position (provided

                               as the argument) where

                               position is one of 0, 1, ..., up

                               to the length of the string.

equals(...)    boolean         used to determine if two
                               strings are identical

equalsIgnoreCase(...) boolean  used to determine if two
                               strings are identical
                               irrespective of case

indexOf(...)   int             returns the first position of a

                               character provided as an

                               argument, or -1 if it is not

                               present

length()       int             returns the length of a string

toLowerCase()  String          converts all characters to
                               lower case

toUpperCase()  String          converts all characters to
                               upper case
                                              51

trim()  String  removes leading spaces

                (blanks) and trailing spaces

                from a string

Table 2.1: Some of the useful String methods

At some time you should view the official documentation for the String class. Perhaps
you will do this when you are developing a program and you want to look up the String
methods. If you are using BlueJ it is very easy to see the documentation for a class. As
Figure 2.4 illustrates, you just need to click on Help and then click on Java Class Libraries.
Choosing this results in an internet browser opening to a page where, on the left pane,
you can find and click on the entry for String (or some other class) to view
documentation which includes information about methods.

                      Figure 2.4: Getting documentation on Java classes

Several example programs follow that demonstrate how to use the various methods of
the String class. To use a String method it is necessary that you reference the object
and the method. For example, to obtain the length of s use the expression s.length().
Note the variable name is followed by a period which is followed by the method name
and any arguments enclosed in parentheses. In object-oriented terminology we are
asking the object s to execute its length() method.

Example, obtaining the length of a string

In many applications it is necessary to examine a text string, characterby-character, to
ensure it conforms to certain rules. For instance, when a user resets a password there
may be restrictions that at least one character is in uppercase, that at least one character
is alphabetic, etc. To do this processing where we examine the string character-by-
character we need to know how long the string is. The String class has a method named
52

length which returns, to the point where it is called, an integer value that is the length of
the string. The following program shows the method being used; see line 9 in particular:

     int passwordLength = password.length();

When this line executes the method is invoked and returns a value to where it was
invoked. The value returned is assigned to passwordLength. Note the name of the method
is followed by parentheses even though no argument is passed ...this is necessary so the
Java compiler knows that the code specifies a method name.

                               Listing 2.9 Finding the length of a string

1   public class UsingStringLength

2   {

3      public static void main(String[] args)

4      {

5         // variable password is of type String

6         // variable passwordLength is of type int

7         String password = "my123Password";

8         // use the length() method

9         int passwordLength = password.length();

10        // Display the string and its length

11        System.out.println("password is");

12        System.out.println(password);

13        System.out.println("length is");

14        System.out.println(passwordLength);

15     }

16  }

       Figure 2.5: Showing the string and its length
                                                                             53

Example, getting the character at a specific position

In many applications where strings are being processed a specific character is expected
in a specific position. For instance, a social insurance number can be coded as 3 digits, a
hyphen, 3 digits, a hyphen followed by 3 more digits. The following program obtains the
character at position 3. The method charAt(...) returns the character at a specific position
to the point where the method is invoked. The method charAt(...) must always have an
argument value (the position) passed to it. For Java, positions within a string begin at 0
and so the first hyphen should be at position 3. Note in the program, at line 9, shown
here:

    char firstHyphen = sin.charAt(3);

how the method is invoked (a period separates the name of the string, sin, from the name
of the method) and how the value 3 is passed to the method (in parentheses as an
argument value).

Listing 2.10 Obtaining a character within the string at a specific position

1   public class UsingStringCharAt

2   {

3      public static void main(String[] args)

4      {

5         // variable password is of type String

6         // variable passwordLength is of type int

7         String sin = "123-987-555";

8         // use the charAt() method

9         char firstHyphen = sin.charAt(3);

10        // Display the string and

11        // the character in position 3

12        System.out.println("SIN is");

13        System.out.println(sin);

14        System.out.println("character at position 3 is");

15        System.out.println(firstHyphen);

16     }

17  }
54

    Figure 2.6: Showing the string and the character at position 3

Example: determining if one string equals another string

To determine if one object is equal to another object you must use a method which, by

convention, is named equals. The String class has a method equals and another method

named equalsIgnoreCase. Both of these methods require an argument to be passed. If we

want to compare two strings, say s1 and s2, to see if they are equal we can use either of

these two expressions: s1.equals(s2)  s2.equals(s1)

Both must return the same boolean value. The following program initializes two strings
and then displays the value when they are compared for equality. Note line 15, repeated
here:

    boolean equalsResult = s1.equals(s2);

On the right hand side of the assignment operator is the expression:

    s1.equals(s2)

We say, in object-oriented terms, that we are asking the object s1 to execute its equals()
method with the argument s2. When line 15 executes the method is invoked, a value is
returned to this point in the statement, and that result is assigned to the boolean variable
equalsResult.

          Listing 2.11: How to compare two strings

    1  public class UsingStringEquals

    2  {

    3     public static void main(String[] args)

    4     {
                                                     55

5         // variable password is of type String

6         // variable passwordLength is of type int

7         String s1 = "John A. Smith";

8         String s2 = "John A Smith";

9         // Display s1 and s2

10        // Display true or false according

11        // to whether they are equal or not

12        System.out.println("The strings");

13        System.out.println(s1);

14        System.out.println(s2);

15        boolean equalsResult = s1.equals(s2);

16        System.out.println(equalsResult);

17     }

18  }

        Showing the result of using equals()

Catenation operator +

We have seen the + operator before, but the operands were always numeric. The +
operator can also be used to add (i.e. catenate) strings. It is used frequently in statements
that generate output. If at least one operand is a string then a result is formed by joining
two strings. Joining two strings is called catenation.

When one operand is not a string then the equivalent string representing that non-
string's value is generated, and then the catenation of two strings is carried out forming
a new string as a result. For instance if you want to display a message "The value of
x is " followed by the value of x you just code:

     System.out.println("The value of x is "+x);
56

However, suppose you wanted to display a string and show the sum of two numbers.
Consider:

int x = 10; int y = 11;

System.out.println("the total is "+x+y);

Someone might expect the output from the above to be:

     The total is 21

but it is not, rather the output is:

     The total is 1011

The reason this happens is that the expression is evaluated from left to right. The first +
is adding a string and a number producing the string "The total is 10". Hence the
second + is adding a string and a number producing the string "The total is
1011".
                                                                                                             57

Exercises

      21. Evaluate the following Java expressions:
            "x = "+100
            "The remainder is "+ (21 % 10)
            (21 % 10)+ "is the remainder"
            "x = "+100+200
            100 +"is the value of x"
            100 + 200 +"is the value of x"
            "" + 100 + 5

      22. Write a program with 3 String variables: firstName, middleInitials,
           lastName. Assign values to these variables to represent your name. Print a line
           that shows your name displayed with the last name first, followed by a comma,
           followed by your first name, and then your middle initials. For example:
          Smith, John A
58

    Implied declarations using var

A recent (March 2018, Java 10) addition to Java is the ability to declare and initialize
variables using var; for example:

    var sum = 0.0;
    var count = 0;
    var name = "";

With the above statements the variables sum, count and name have been initialized, and
their types (determined by their initialized values) are double, int, and String
respectively.

Consider the listing below which is a rewrite of Listing 2.11 but all declarations use
var.

        Listing 2.12: Using var to declare/initialize variables

    1   public class UsingVar

    2   {

    3      public static void main(String[] args)

    4      {

    5               // variable password is of type String

    6               // variable passwordLength is of type int

    7               var s1 = "John A. Smith";

    8               var s2 = "John A Smith";

    9               // Display s1 and s2

    10              // Display true or false according

    11              // to whether they are equal or not

    12              System.out.println("The strings");

    13              System.out.println(s1);

    14              System.out.println(s2);

    15              var equalsResult = s1.equals(s2);

    16              System.out.println(equalsResult);

    17     }

    18  }

Java is a strongly typed language. When the compiler sees a statement such as
var s1 = "John A. Smith";
                                                                                                             59

it determines s1 is of type String and so we could not follow that with a statement
such as

          s1 = 100;

The int value 100 cannot be assigned to a String variable.

     Output

We discuss two different ways to generate output from a program: using System.out
and JOptionPane. We discuss the use of System.out in the next two sections; in the
second of these we discuss how you can redirect the output which normally appears in
the Terminal Window to a file.

In the third section we discuss the JOptionPane class and how that can be used to
present information and data in dialog boxes.

2.8.1 System.out

A simple way to generate output for the user is to use the println(...) and
print(...) methods that belong to the pre-defined Java class named System and an
object within System named out. The output generated is said to go to the standard
output device. When you use this type of output with BlueJ you will see a window pop
up named "Terminal Window" that contains the output produced by the program.

The following program listing illustrates ways of producing output. The println(...)
and print(...) methods take one argument which is a text string. Often that text
string is composed of multiple catenations. Notice the last println(...) introduces
special characters for new line (\n) and tab (\t). The special characters are not
displayed, they are used to control the appearance of the output.
60
                                     Listing 2.13 Using println()

1 public class UsingPrintln

2 {

3     public static void main ( String [] args )

4     {

5        double grossPay, taxesPaid, taxRate, netPay,

    deductions;

6        grossPay = 100.00;

7        deductions = 10.00;

8        taxRate = 0.10;

9        // Calculate taxes and net pay

10       taxesPaid = (grossPay - deductions) * taxRate ;

11       netPay = grossPay - taxesPaid;

12       //

13       // Each time println () executes the output will start

    on a new line

14       // Produce one line of output with one

15       double value;

16       System.out.println (grossPay);

17       // Often a good idea is to label the output so it is

    self - describing

18       // Produce one line of output with a label and a value

19       System.out.println ("Gross Pay is "+ grossPay);

20       // Several items can be catenated

21       // Note that one text string must appear on one line

22       // but a long one can be formed over multiple lines

23       System.out.println ("Gross Pay = "+ grossPay +"

    Deductions = "+ deductions);

24       // You can force output to go onto more than one line

25       // by embedding control characters in a string

26       // '\n' is the new line character

27       // '\t' is the tab character

28       System.out.println ("\tGross Pay = "+ grossPay

29               +"\n\tDeductions = "+ deductions

30               +"\n\tTaxes Paid = "+ taxesPaid

31               +"\n\tNet Pay = "+ netPay );

32    }

33 }
                                                                                                             61

Output from UsingPrintln
The println(...) method causes the display to advance to a new line and then
displays output. The print(...) method differs from println(...) in that it does
not automatically advance to a new line when it displays output; instead, output begins
at the point where the previous print(...) or println(...) left off. If we change
all the println(...) to print(...) expressions for the previous example the
output we get is:

Exercises
      23. Write a program to calculate the total of the provincial sales tax, the general
           sales tax, and the price of an item. Use the variables totalPayable, pstPayable,
           gstPayable, and price to represent the total payable, the provincial sales tax
           payable, the general sales tax payable, and the item's price. Use the formulas:
                         pstPayable = price  0.05
                         gstPayable = price  0.08
                         totalPayable = price + pstPayable + gstPayable
62

     Test your program with price = $50.00. Your program must display price, pstPayable,
     gstPayable, and totalPayable.

     Similar to lines 28-31 in Listing 2.12 create output that is nicely aligned with values
     on separate lines.
                                                            63

2.8.2 JOptionPane

In some situations a programmer may prefer to use JOptionPane message dialogs in
order to provide the user a more interactive experience. The following program shows
how to get data from the user. When getting data from the user, the program waits for
the user to respond with the click of a button. When a pop-up window appears, the
program is suspended until the user clicks the OK button. Note that line 1 is an import
statement that directs the compiler to the location where it finds details regarding the
JOptionPane class.

                   Listing 2.14: Using JOptionPane()

1 /**

2     * This Java class uses JOptionPane to obtain

3     * input from the user

4 */

5 import javax.swing.JOptionPane;

6 public class UsingJOptionPane

7 {

8      public static void main(String[] args){

9         String firstName = JOptionPane.showInputDialog("Enter

    first name");

10        String lastName = JOptionPane.showInputDialog("Enter

    last name");

11        System.out.println ("Your name is: "+firstName+"

    "+lastName);

12     }

13 }

When lines 9 and 10 execute a pop-up window becomes visible and the program
waits for the user to press the OK button:
64

Exercises
      24. Write a program that prompts the user for their first name, last name, and
           middle name. The program then displays the names in order of first name,
           middle name, last name.
     Input

We examine two ways a programmer can arrange to get input from the user by using
pre-defined Java classes: the Scanner class and the JOptionPane class.

2.9.1 The Scanner Class

A Scanner object can be used with the standard input stream which is named System.in.
The typical statement used is:

         Scanner keyboard = new Scanner(System.in);

System is a pre-defined Java class that has an object named in. Once a variable like
keyboard is defined the programmer can use methods defined for a scanner object to get
values (Java refers to these as tokens) the user has typed on the keyboard. Some of the
most useful methods are listed below.

               Useful Scanner methods

hasNext()      returns true if the scanner has more tokens
next()         returns the next token
nextLine()     returns the next line
nextInt()      returns the next int in the input stream
nextDouble()   returns the next double in the input stream
nextBoolean()  returns the next boolean in the input stream

The program below shows one how to use next(), nextDouble(), and nextInt()
to obtain a user's name, hours worked and rate of pay. Note that line 1 is an import
statement that directs the compiler to the location where it find details of the Scanner
class. The program uses pairs of statements; for example consider lines 12 and 13
repeated here:

     System.out.println("\n\nEnter your name and press
     enter");

     name = keyboard.next();
Line 12 prompts the user, and then in line 13 the user's input is obtained. The listing
is followed with the contents of the Terminal Window for a sample run. This shows
the output (prompts) from the program and the input provided by the user via the
keyboard.

               65
66                        Listing 2.15: Using Scanner for input

    1  import java.util.Scanner;
    2  public class UsingScannerForInput
    3  {
    4
    5         public static void main(String[] args)
    6         {
    7
    8                double rateOfPay;
    9                String name;
   10                int hoursWorked;
   11                // Declare a scanner object for the keyboard
   12                Scanner keyboard = new Scanner(System.in);
                     // Prompt the user for a name
   13                System.out.println("\n\nEnter your name (no spaces) and
   14  press enter");
   15                name = keyboard.next();
                     // Prompt the user for hours worked
   16                System.out.println("Enter the hours worked (no decimal
   17  places) and press enter");
   18                hoursWorked = keyboard.nextInt();
                     // Prompt the user for the rate of pay
   19                System.out.println("Enter your rate of pay and press
   20  enter");
   21                rateOfPay = keyboard.nextDouble();
   22
   23                // Calculate gross pay and display all the information
   24                double grossPay = hoursWorked * rateOfPay;
   25                System.out.println("\n Your name: "+name
   26
   27                       +"\n hours worked: "+hoursWorked
   28                       +"\n rate of pay: "+rateOfPay
                            +"\n gross pay : "+grossPay);
              }
       }
                                                                                                             67

                      Terminal Window showing interaction with user
Exercises

      25. Write a program that prompts the user for their birthday as the day (as an
           integer), followed by the month (as text), followed by the year (as an integer)
           with at least one space between the values. Use the Scanner methods next()
           and nextInt() to get these values. Then the program displays the birthday in
           the format month day, year. For example, if the user entered
                                 1 January 1990

    then the program would display January 1, 1990.
68

2.9.2 The JOptionPane Class

To provide a user with a more interactive experience the programmer can use
JOptionPane to prompt the user and to obtain text input from the user. One of the
methods defined in JOptionPane is showInputDialog(...). When this method executes the
user is prompted to enter text. The text the user enters becomes the value of the method.
Typically showInputDialog(...) is on the right-hand-side of an assignment statement; for
example:

           String name = JOptionPane.showInputDialog("Enter name");

When the above line executes the user sees the pop-up window:

The user then uses the keyboard to enter something in the white box in the pop-up, and
then clicks the OK button. The text the user entered is the value returned by the method.
The following program uses two pop-ups to obtain values from the user; comments
follow the listing.

              Listing 2.16: Using JOptionPane for input

1   /**

2      * This Java class uses JOptionPane to obtain

3      * input from the user

4      */

5   import javax.swing.JOptionPane;

6   public class UsingJOptionPaneForInput

7   {

8          public static void main(String[] args){

9             String firstName =

10            JOptionPane.showInputDialog("Enter first name");

11            String lastName =

12            JOptionPane.showInputDialog("Enter last name");

13            System.out.println ("Your name is:"+firstName+"

    "+lastName);

14         }

15  }
                                                                                                             69
          · Line 5 is required since we need to tell the Java compiler where it can find the

             JOptionPane class.
          · When line 9 executes it causes a dialog box to be displayed to the user:

             The user enters a value in the box and presses OK. Then control returns to the
             program and the value entered is assigned to firstName.
             A similar dialog box is displayed when line 10 executes.
          · In line 13 the values obtained from the dialog boxes is displayed in BlueJ's
             terminal window.

Exercises
      26. Write a program that uses a dialogue box to prompt the user for a temperature
           in Celsius. Then the program uses a dialogue box to display the equivalent
           temperature in Fahrenheit.
      27. Write a program that uses a dialogue box to prompt the user for a temperature
           in Fahrenheit. Then the program uses a dialogue box to display the equivalent
           temperature in Celsius.
70
3 Control Structures

Programmers need 3 basic control structures when coding programs. These three things
are: sequences, decisions, and loops. A sequence structure is one that comprises
instructions that are to be executed sequentially one after the other. A decision structure
allows for exactly one of a set of sequences to be executed. A loop structure comprises a
sequence that is to be executed iteratively. Java has one sequence structure, two (some
may say more) different decision structures, and several ways of coding loops.

     Compound Statements

Java statements delimited by curly braces form a compound statement. The opening
brace, "{", appears first followed by Java statements and then the closing brace, "}"
follows. Any time you include a "{" you must have a matching "}". Pairs like these must
be used properly - a pair cannot overlap with another pair, but as we will see one
compound statement can contain another compound statement (see sections on nesting
statements). An example is the following compound statement where the values of x and
y are interchanged:

          {
          temp = x;
          x = y;
          y = temp;
          }

                                                      71
72

     if

The structure of an if statement is shown below. The else and statement-2 are
optional; we say the if statement has an optional else clause. Statement-1 is
sometimes referred to as the then clause.

When the JVM executes an if statement, the JVM will first evaluate the logical
expression. If the expression is true then statement-1 is executed; if the expression is
false then statement-2 is executed. The if statement conditionally executes either
statement-1 or statement-2, and never both. The JVM process can be visualized as:
How the JVM executes an if
                                                                                                             73

Logical Expressions
A logical expression is an expression that evaluates to a boolean value, i.e. true or false.
Java has several operators which evaluate to true and false including the relational and
equality operators. Recall the relational operators are <, <=, >=, and >:

                    Relational operators

operator  meaning                   example

     <    less than                 count < 100
     >    greater than              netPay > 100
    <=    less than or equal to     netPay <= grossPay
    >=    greater than or equal to  number >= 0

Recall the equality operators are == and !=.
                                     Equality operators

          operator  meaning       example

              ==    equal to      netPay == grossPay
               !=   not equal to  netPay != grossPay

Recall the logical operators and, or, and not where operands are boolean values and the
result is a boolean:

Operator  In Java   Boolean operators
                                                 Meaning
   AND      &&
                        Evaluates to true if and only if both operands are
    OR      ||          true
   NOT      !           Evaluates to false otherwise
                        Evaluates to true if any operand is true
                        Evaluates to false otherwise
                        Negates the operand
74

Some sample boolean expressions follow where

        boolean found = false; int i = 5; int j = 100;

           Expression         Value

           j == 100           true

           j != 100           false

           found && i <100    false

           ! found && i<100   true

           ! found || i== -1  true

           I<100 && j<100     false

Example 1

Suppose one needs to display one of two possible messages. To do this we can use an if
with a then clause and an else clause. Consider the following program that displays one
of two messages depending on the value of the expression number > 0. In lines 9 and 10
the user is prompted for a number; in line 14 the if determines to print "positive"
or "not positive". Note that compound statements are used even though it was not
necessary. The output of a run where the user supplied the value 123 follows.

                              Listing 3.1 Using an if statement

    1      import java.util.Scanner;

    2      public class PositiveOrNot

    3      {

    4         public static void main(String[] args)

    5         {

    6                // Use a scanner object for keyboard input

    7                Scanner keyboard = new Scanner(System.in);

    8                // Prompt the user for a number

    9                System.out.println("Enter a number "

    10                  +"and then press Enter: ");

    11               int number = keyboard.nextInt();

    12               System.out.print("the number "+number+" is ");

    13               // Display a message if number is positive or not

    14               if (number > 0) {

    15                        System.out.println("positive");

    16               }

    17               else {

    18                        System.out.println("not positive");
             75

19        }

20     }

21  }
76

Exercises
   1. Write a program that obtains a number from the user and displays whether the
        number is an even number or an odd number. Note the expression number % 2
        is equal to 0 if number is even and 1 if number is odd. Use an if-else.

   2. Write a program that obtains two numbers from the user and displays the larger
        of the two numbers. Use if-else.

   3. Rewrite PostiveOrNot with one println statement using a conditional
        operator.
                                                                                                             77

Nesting statements

The syntax of the if statement provides for the conditional execution of any Java
statement, including other if statements, whiles, etc.

Example 2

Suppose we need to handle monetary transactions and the program operates in a
country where there are no pennies in circulation. In this case cash transactions will be
rounded to the nearest nickel; electronic transactions are for the exact amount but there
is a surcharge of 25 cents.

Consider the program in Listing 3.2 where the user is prompted to supply two things:
the nature of the transaction (cash vs debit card) and the amount of the transaction. In
the section on doubles we discussed the use of an integer data type for monetary
transactions, and so the amount of a transaction is in pennies. In line 12 int variables are
defined to hold the amount. In line 14 the user is prompted for the type and cost of a
purchase.

The structure of the code involves the use of nested if statements. The outer if (lines 19
to 26) determines if payment is by cash or debit card. The then clause (lines 20-24)
handles a cash payment and the else clause (lines 25-26) handles a debit card payment.
For the case of a cash payment there is an inner if (lines 20 to 23) nested inside the then
clause that rounds the cost up or down to the nearest nickel. The else clause of the outer
adds the additional charge for using a debit card.

Following the listing is sample output showing the result for a cash transaction for
$121.21.
78

                      Listing 3.2 Using nested ifs

1 import java.util.Scanner;

2 /**

3 * Determine value of payment to be received from customer

4 * based on whether or not it is cash payment.

5 * Cash payments are rounded off to the nearest nickel and

6 * debit card payments have a surcharge of 25 cents.

7 */

8 public class RoundCostUpDown

9 {

10     public static void main(String[] args)

11     {

12        int originalCost, actualCost;

13        String typePayment;

14        System.out.println("Enter type of payment and "

15              +"value of purchase in pennies: ");

16        Scanner kb = new Scanner(System.in);

17        typePayment = kb.next();

18        originalCost = kb.nextInt();

19        if (typePayment.equals("cash")) {

20              if (originalCost % 5 < 3)

21                    actualCost = originalCost - originalCost%5;

22              else

23                    actualCost = originalCost + (5 - originalCost%5);

24        }

25        else

26              actualCost = originalCost + 25;

27        System.out.println(originalCost+" "+actualCost);

28     }

29 }
                                                                                                             79

Example 3

Sometimes the information we need to implement in a Java program is given by a table
structure. For instance suppose we have the following table that is to be used to
determine the appropriate numeric grade to be given for a specific letter grade. Consider
the table:

letter  numeric
grade    grade
            4
  A         3
  B         2
  C         1
  D         0
  F

If a person is given a letter grade, its a simple matter for that person to find the grade in
the letter grade column and look across to determine the numeric grade. However, it
may not be obvious how to do this in a Java program. We will consider 3 different ways
this might be coded, the last of which we would say is the preferred approach.

A first approach is to code an if statement for each line of the table where the logical
expression relates to the letter grade value in the line. For instance the statement

if (letterGrade.equals("A")) numericGrade = 4.0;

will assign numericGrade the value 4.0 when the letter grade is "A". A program needs
similar statements for the other letter grades. For example at most one of the following
logical expressions will evaluate to true:

if (letterGrade.equals("A")) numericGrade = 4.0;
if (letterGrade.equals("B")) numericGrade = 3.0;
if (letterGrade.equals("C")) numericGrade = 2.0;

If you examine the program in Listing 3.3 you will see the variable numericGrade
initialized to 0.0 and so there are just 4 if statements to catch "A", "B", "C" and
"D"
80                   Listing 3.3 Using multiple ifs

      1  import java.util.Scanner;
      2
      3  /**
      4
      5  * Determine a numeric equivalent to a letter grade.
      6
      7  * Note the standard indentation of extra spaces.
      8
      9  */
     10
     11  public class LetterGradeToNumericGrade1
     12
     13  {
     14
     15       public static void main(String[] args)
     16
     17       {
     18
     19          String letterGrade;
     20
     21          // default value for numericGrade
     22
     23          //  corresponds to "F"
     24
     25          double numericGrade=0.0;

     26          System.out.println("Please enter letter grade:");
     27
                 Scanner kb = new Scanner(System.in);

                 letterGrade = kb.next();

                 if (letterGrade.equals("A"))

                     numericGrade = 4.0;

                 if (letterGrade.equals("B"))

                     numericGrade = 3.0;

                 if (letterGrade.equals("C"))

                     numericGrade = 2.0;

                 if (letterGrade.equals("D"))

                     numericGrade = 1.0;

                       System.out.println(letterGrade+" is equivalent to
         "+numericGrade);

                }

         }

When this first version executes every logical expression is evaluated. This can be
avoided to some degree if we use nested ifs - we can avoid some unnecessary
evaluations.

Consider the program in Listing 3.4. When you review this program note the nesting
of the ifs - each else clause contains an if. Only a minimum number of logical
expressions are evaluated. For instance if the letter grade is "B" only two logical
expressions are evaluated.
                                                             81

                Listing 3.4 Nested ifs with indentation

1 import java.util.Scanner;

2 /**

3 * Determine a numeric equivalent to a letter grade.

4 * Note the standard indentation of extra spaces

5 * for nested if statements.

6 */

7 public class LetterGradeToNumericGrade2

8 {

9      public static void main(String[] args)

10     {

11        String letterGrade;

12        double numericGrade;

13        System.out.println("Please enter letter grade:");

14        Scanner kb = new Scanner(System.in);

15        letterGrade = kb.next();

16        if (letterGrade.equals("A"))

17              numericGrade = 4.0;

18        else

19              if (letterGrade.equals("B"))

20                    numericGrade = 3.0;

21              else

22                    if (letterGrade.equals("C"))

23                          numericGrade = 2.0;

24                    else

25                          if (letterGrade.equals("D"))

26                                numericGrade = 1.0;

27                          else

28                                numericGrade = 0.0;

29        System.out.println(letterGrade+" is equivalent to

    "+numericGrade);

30     }

31 }

    The indentation you see in the above program is the standard way to show one
    control structure embedded in another control structure.

    However, when there are nested ifs and when the logical expressions differ only in
    the value being tested: "A", "B", ..., a Java programmer can change the indentation.
    Each of the cases being tested for are essentially the same and to stress that, a
82

    programmer would alter the indentation to that shown below in Listing 3.5. Then,
    the nested ifs are be referred to as an if-else-if structure.

                    Listing 3.5 Using an if statement

    1 import java.util.Scanner;

    2 /**

    3     * Determine a numeric equivalent to a letter grade.

    4     * Note the standard indentation of extra spaces

    5     * for nested if statements.

    6 */

    7 public class LetterGradeToNumericGrade3

    8 {

    9      public static void main(String[] args)

    10     {

    11        String letterGrade;

    12        double numericGrade;

    13        System.out.println("Please enter letter grade:");

    14        Scanner kb = new Scanner(System.in);

    15        letterGrade = kb.next();

    16        if (letterGrade.equals("A"))

    17                    numericGrade = 4.0;

    18        else if (letterGrade.equals("B"))

    19                    numericGrade = 3.0;

    20        else if (letterGrade.equals("C"))

    21                    numericGrade = 2.0;

    22        else if (letterGrade.equals("D"))

    23                    numericGrade = 1.0;

    24        else

    25                    numericGrade = 0.0;

    26        System.out.println(letterGrade+" is equivalent to

        "+numericGrade);

    27     }

    28 }

Later on in the section on the switch statement we will see yet another way to
determine the pertinent line of the grade table.
83
84

Exercises

    4. Consider how a numeric grade could be translated into a letter grade, as defined
        in this table:

           range   grade
           80-100  A
           70-79   B
           60-69   C
           50-59   D
           0-49    F

    Given a mark, it is a simple matter to figure out which range it falls into and
    determine the corresponding grade. Write a program which obtains a numeric value
    and translates that into a letter grade. Consider using statements of the form: if (

    mark > ... )

    5. Modify your program for the above question so that it validates the mark
        obtained from the user to ensure the value is in the range [0,100].

    6. Write a program that obtains 10 numbers from the user and then displays the
        largest of these numbers. Control the input using a while and nest an if inside
        the while.
                                                                                                             85

     while

The JVM executes the statements in a program sequentially, one statement after another.
However, the while statement can change this. A while statement contains a statement to
be executed repeatedly as long as some logical expression is true. The statement
executed repeatedly is often a compound statement. The general syntax is

            while ( logical expression ) statement
The order of execution of Java statements can be visualized using a flow diagram:

                    How the JVM executes a while

Example 1
The following program prints numbers from 0 to 9. It does so by executing a compound
statement repeatedly. The variable count is initialized in line 8 to the value 0 and as the
while loop executes count takes on the values 1, 2, 3, etc. A detailed explanation of the
program follows the program listing. As you examine the code note the use of
indentation - for readability purposes it is common practice to indent the lines
comprising a while loop.

                                 Listing 3.6 Displaying numbers
                    1 /**
                    2 * Display the numbers from 0 to 9.
                    3 */
                    4 public class Numbers0To9
                    5 {
86

     6               public static void main(String[] args)
     7               {
     8
     9                      int count = 0;
    10                      System.out.println("Numbers");
    11                      while ( count < 10 ){
    12
    13                             System.out.println(count);
    14                             count = count + 1;
    15                      }
    16 }                    System.out.println("*******");
                     }

     The JVM starts sequential execution with the statement in line 8 - the variable
        count is initialized to 0.

     The JVM then moves on to Line 9 which results in the printing of a heading for
        the output.

     Next, the JVM encounters the while loop in Line 10.

     Observe that lines 11 and 12 are part of a compound statement. This compound
        statement is executed for count equal to 0, 1, 2, and so on, up to count equal to
        9; when count has the value 9 the compound statement is executed and count is
        assigned the value 10 in line 12. That's the last time the compound statement is
        executed since the logical expression evaluates to false - the JVM will move on to
        the statement following the while statement (line 14) where normal sequential
        execution resumes.

The output follows:
                                                       87

Example 2

Consider another program which displays the digits of a positive number provided by
the user. The program includes a scanner object in line 7 that is used to get input from
the user via the keyboard. Lines 14 to 19 form a while loop where

         Line 15: the rightmost digit is obtained using the expression number % 10
         Line 16: the digit is displayed
         Line 17: the value of number is reduced by a factor of 10 using the expression

          number / 10

         Line 18: the number is displayed
         Eventually the value of number will be reduced to 0 and the loop terminates.

        Listing 3.7 Display digits

1 import java.util.Scanner;

2 public class DisplayDigits

3 {

4    public static void main(String[] args)

5    {

6       // Arrange to use a scanner object for keyboard input

7       Scanner keyboard = new Scanner(System.in);

8       // Prompt the user for a positive number

9       System.out.println("Enter a positive number "

10      +"and then press Enter: ");

11      int number = keyboard.nextInt();

12      System.out.println("The number is "+number);
88

13       System.out.println("\tdigit\tnumber");

14       while (number > 0){

15          int digit = number % 10;

16          System.out.print("\t"+digit);

17          number = number / 10;

18          System.out.println("\t"+number);

19       }

20       System.out.println("end of list");

21    }

22 }

An example of output follows where the user entered the value 3476:

Nesting statements
 The statement executed repeatedly can be any Java statement including another while
 (or any other statement discussed in this chapter).

Example 3
 The program in Listing 3.8 displays the product i*j for i and j where both i and j take
 on values 1 through 4. The outer while (lines 15-23) executes 4 times, the first time
 with i as 1 and the next time with i as 2, then 3, and then 4. The inner while (lines 18-
 21) is executed entirely for each value of i; that is, for each value of i, the variable j takes
 on the value 1, then 2, then 3, then 4. Note the indentation in the program: each line
 within the outer while is indented the same amount, and each line within the inner
 while is indented a further amount.

                     Listing 3.8 Nesting one while inside another while
                                                                 89

1 /**

2 * Program with one while inside another while.

3 * The program prints i, j, and i*j

4 * where i varies from 1 to 4 and

5 * where j varies from 1 to 4

6 */

7 public class NestedWhiles

8 {

9      public static void main(String[] args)

10     {

11        int i, j;

12        System.out.println("\ti\tj\ti*j");

13        // i takes on values 1,2,3,4

14        i = 1;

15        while (i < 5){

16           j = 1;

17           // j takes on values 1,2,3,4

18           while (j < 5){

19                System.out.println("\t"+i+"\t"+j+"\t"+(i*j));

20                j = j + 1;

21           }

22           i = i + 1;

23        }

24        System.out.println("program ended");

25     }

26 }
90

                             Output from NestedWhiles
Exercises

     7. What happens when a user enters the value 0 when DisplayDigits is executed?
     8. What happens when a user enters a negative value when DisplayDigits is
     executed?
     9. What happens when a user enters something that is not an integer when
     DisplayDigits is executed?
     10. Write a program that will sum the digits of a number. For example if the number
     is 124, then the sum of its digits is 7 = 1+2+4.
     11. Write a program that obtains integers from the user and displays their total. The
     program keeps getting integers until the user enters a value less than zero or greater
     than 100.
                                                                              91

12. Write a program that will sum the integers from -100 to 100. Note the answer
you expect is a sum equal to 0.

13. Write a program that converts from Celsius to Fahrenheit for Celsius values
starting at -40 and going up +40 in increments of 1.

14. Write a program that converts from Fahrenheit to Celsius for Fahrenheit values
starting at -40 and going up +40 in increments of 1.

15. Write a program to convert from Euro Dollars to US Dollars for Euros ranging
from 100 to 1,000 in steps of 100. Prompt the user for the exchange rate for
converting Euros to US dollars. At the time of writing the exchange rate was 1.12;
that is, 1 Euro was worth 1.12 US dollars.

16. Consider the calculation of n factorial defined as:

n! = 1 × 2 × 3 × ... × n  where n > 0

Use a while to calculate n! Prompt the user for the value of n.

17. How many times is the print statement in Listing 3.3 (line 19) executed?
18. Modify the program in Listing 3.3 so that i and j vary from 1 to 10.

Autoincrement
Because statements that increment a variable's value, such as

           i = i + 1;

are so common, Java has a special unary operator ++ for this. The statement

           i++;

has the same effect as the above assignment statement. ++ is a unary operator (takes one
operand). The operand can be before or after the ++. The difference relates to when the
increment occurs which is only relevant in more complex expressions.

Java has a similar operator, - -, which has the effect of decrementing the value of a
variable, and so the following two statements are equivalent:
92

           count = count - 1;
           count--;

Exercises
     19. Modify the program in Listing 3.3 to use the ++ operator.

     20. Use nested whiles to print a 4×4 times-table. The times-table should appear as
     follows

                                                12 3 4

                                        1 12 3 4
                                        2 24 6 8
                                        3 3 6 9 12
                                        4 4 8 12 16
                                                                                                             93

     for

The for statement is commonly used where there is a need for a statement to be
executed a specific number of times. This type of looping construct is sometimes called
a counted loop. The syntax of the for statement we consider here is

           for ( initialization; logical expression; increment ) statement

Contrasting the for syntax to the while syntax:

   1. The keyword beginning the statement is for

   2. Instead of a single logical expression inside parentheses there are three
       components separated by semi-colons.

            An initialization section
            A logical expression (just as the while has)
            An increment section

JVM and the for
The JVM executes a for as shown:
94

The for is heavily used in Java programming. We will use several examples to show its
application.

Example 1

Below we use a for to manage a loop that displays the numbers from 0 to 9. You should
compare this to Numbers0To9 in Section 3.2.

              Listing 3.9 Using for

    1 /**

    2     * Display numbers 0 to 9 using a for

    3 */

    4 public class Numbers0To9WithFor

    5 {

    6      public static void main(String[] args)

    7      {

    8         System.out.println("Numbers");

    9         for (int count=0; count < 10; count++ )

    10        System.out.println(count);

    11        System.out.println("*******");

    12     }

    13 }

Comparing the above program to Numbers0To9 in section 3.2 we note:

         1. The initialization component declares and initializes the variable count.
             Because it is declared inside the for, this variable count is known only here
             inside the for. This is known as its scope.

         2. The second component is the logical expression - the loop executes as long as
             this evaluates to true

         3. The update component is an autoincrement for count.

Notice how the lines that comprise the for statement are indented to enhance
readability. This program displays the values 0, 1, ...9 and so it should be evident that
count takes on values 0, 1, ...9, and that the for executes 9 times.

The for statement is the preferred programming idiom for a counted loop.
                                                                                                             95

Example 2

A common situation where a counted loop arises in the processing of strings. A string of
text comprises individual characters. The String method length() returns the length of a
string, and the charAt(...) is used to access individual characters. The argument provided
to charAt(...) is the index of a character within the string - the index of the first character
is 0, and the index of the last character is length()-1.

Consider the following program that displays the characters comprising a string one-by-
one. To do this, the program has a for loop (lines 14-17) that executes once for each
character in the string.

          Listing 3.10 Display characters in a string one-by-one.

1 /**

2 * Displays a text string character-by-character.

3 * Get individual characters using the charAt(...) method

4 */

5 public class GetIndividualCharacters

6 {

7      public static void main(String[] args){

8         // a string of characters

9         String text = "abc123";

10        // the length (number of characters) of the string

11        int textLength = text.length();

12        System.out.println("text string is: "+text);

13        System.out.println("now, each character one-by-one");

14        for (int i=0; i<textLength; i++){

15           char c = text.charAt(i);

16           System.out.println(c);

17        }

18     }

19 }

    The output from GetIndividualCharacters follows
96
                                                                   97

Nested statements

The for statement contains a statement to be repeated. This statement can be any Java
statement. Consider the following example where an if statement appears inside a for
statement.

Example 3

This program examines a line of text and counts the number of times 'a' appears. The
program uses the String method length() to obtain the length of a text string and the
method charAt(...) to obtain an individual character within a text string. The program has
a for loop (lines 17-20) that executes once for each character in the text string; the for
contains an if where the current character is compared to 'a'.

           Listing 3.11 Counting lower case alphabetic characters

1 import java.util.Scanner;

2 /**

3          * Count the number of lowercase 'a's

4          * in a line provided by the user.

5 */

6 public class CountLetters

7 {

8                  public static void main(String[] args)

9                  {

10                    String text;

11                    System.out.println("Enter text: ");

12                    Scanner kb = new Scanner(System.in);

13                    text = kb.nextLine();

14                    int count = 0;

15                    for (int i=0; i<text.length(); i++){

16                       if (text.charAt(i) == 'a')

17                       count++;

18                    }

19                    System.out.println("The line contains

           "+count+" a\'s");

20                 }

21 }
98

Example 4

The program in Listing 3.12 below displays the product i*j for i and j where both i
and j take on values 1 through 4. The output produced is the same as Example 3 in the
section on the while statement.

The outer for (lines 10-13) executes 4 times, the first time with i as 1 and the next time
with i as 2, then 3, and then 4. The inner for (lines 11-12) is executed entirely for each
value of i; that is, for each value of i, the variable j takes on the value 1, then 2, then 3,
then 4.

Note the indentation in the program: each line within the outer for is indented the same
amount, and each line within the inner for is indented a further amount.

                 Listing 3.12 Using nested for statements

1 /**

2     * Print values of i, j , and i*j where

3     * i varies from 1 to 4 in increments of 1, and

4     * where j varies from 1 to 4 in increments of 1.

5     */

6 public class NestedFor

7 {

8          public static void main(String[] args){

9             System.out.println("\ti\tj\ti*j");

10            for (int i=1; i<=4; i++){

11               for (int j=1; j<=4; j++)

12               System.out.println("\t"+i+"\t"+j+"\t"+(i*j));

13            }

14            System.out.println("program ended");

15         }

16 }
                                                                                                             99
Display i, j, and i*j
100

Example 5

In this example we create a 5 × 5 times table. This table comprises rows and columns
where the entry at the intersection the ith row and jth column is the product of i and j,
i j:

                                        12 3 4 5

                                1 12 3 4 5
                                2 2 4 6 8 10
                                3 3 6 9 12 15
                                4 4 8 12 16 20
                                5 5 10 15 20 25

We develop this example in two steps. In the first step we simply produce the values that
will appear as entries in the times table, and in the second step we will see it properly
formatted with column and row headings.

...Step 1, products for the times table

This version produces all the values for the first row, then for the second row, etc. This
will require an outer for controlling the row number and an inner for controlling the
column number:

          for (int i=1; i<=5; i++){
                for (int j=1; j<=5; j++){
                     System.out.print(i*j); ...

In the above the outer for uses the variable i to ensure the loop controlling rows executes
5 times, and the inner for uses the variable j to ensure this loop executes 5 times, once
for each column. As the inner loop is executed completely for each value of i, the print
statement in the inner loop executes a total of 5×5 = 25 times. Now, consider the
following program where nested for s are used to produce values for the times table.
                                                                   101

                Listing 3.13 Step 1 products for the times table.

1 /**

2     * Produce values for a 5x5 times table using nested for

    statements

3 */

4 public class TimesTableStep1

5 {

6      public static void main(String[] args)

7      {

8         // variable i represents row i

9         for (int i=1; i<=5; i++) {

10              // variable j represents row j

11              for (int j=1; j<=5; j++) {

12                 // multiply i and j

13                 // print(... ) keeps all values for i on same line

14                 System.out.print("\t"+i*j);

15              }

16              System.out.println();

17        }

18     }

19 }
102

...Step 2, formatting the times table

The completed program and its output are shown next. To reasonably format the times
table we have added a title for the output (line 10), column headings (lines 12-14). Then,
for each row of the table, a row heading is printed (line 19). Note the mixed use of the
print() and println() methods.

          Listing 3.14: Step 2 formatted times table.

1 /**

2     * 5x5 times table with column and row headings

3     * using nested for statements

4 */

5 public class TimesTableWithFors

6 {

7      public static void main(String[] args)

8      {

9         // heading and column headings

10        System.out.println("\n\t5x5 Times Table");

11        System.out.println();

12        for (int i=1; i<=5; i++)

13           System.out.print("\t"+i);

14        System.out.println();

15

16        // Compute and print rows of times table

17        for (int i=1; i<=5; i++){

18           // row heading and row contents

19           System.out.print(i);

20           for (int j=1; j<=5; j++)

21           System.out.print("\t"+i*j);

22           System.out.println();

23        }

24     }

25 }
                                                                     103
Formatting the times table
104

Exercises
      21. Modify the program in Example 1 to display the value of count in line 11 outside
           the scope of the for. Does your program compile? What message do you get from
           the compiler?
      22. Consider Example 1 again. The variable count is defined in the for statement and
           so the scope of count is the for statement. Modify the example properly in order
           to display the value of count in the print statement (line 11). To do this you must
           declare count before the for statement, as in:
               int count; for (count=0; count < 10; count++)
                      ...

      23. Write a program that prompts the user for 10 values, and then displays the sum,
           the average, the minimum, and the maximum of those 10 values.

      24. Write a program that converts from Celsius to Fahrenheit for Celsius values
           starting at -40 and going up +40 in increments of 1.

      25. Write a program that converts from Fahrenheit to Celsius for Fahrenheit values
           starting at -40 and going up +100 in increments of 1.

      26. Write a program to convert from Euro Dollars to US Dollars for Euros ranging
           from 100 to 1,000 in steps of 100. Prompt the user for the exchange rate for
           converting Euros to US dollars. At the time of writing the exchange rate was
           1.12; that is, 1 Euro was worth 1.12 US dollars.

      27. Write a program that will sum the digits of a number. For example if the number
           is 124, then the sum of its digits is 7 = 1+2+4

      28. Write a program that prompts the user for an identification number (e.g.
           student number, credit card number, etc.). The program must then display each
           digit of the number.
                                                                                                     105

29. Consider the calculation of n factorial defined as:
                             n! = 1 × 2 × 2 × ... × n where n > 0

    Write a program that will list in table form, the value of n and n! for n =
    1,2,3,4,5,6,7,8,9,10. Display n and n! The output will look similar to:

                                             n n!
                                             1 1
                                             2 2
                                             3 6
                                             4 24
                                             ...

30. The fibonacci sequence is the following integer                    sequence:
    0,1,1,2,3,5,8,13,21,34,...
    We can define them more generally as:

    Fn = Fn-1 + Fn-2 for n > 1 where F1 = 1 and F0 = 0

    Write a program that prompts the user for n and then displays Fn.

31. Consider the formula where the value of f depends on x:

    f(x) = 3 + 5x - 7x2 + 3x3 + 6x4

For computational purposes we can re-express the formula as:

f(x) = 3 + x(5 + x(-7 + x(3 + 6x)))

which reduces the total number of calculations.

Write a program to evaluate f(x) for x = 0,1,2,3,...10

32. Modify the Times Table example so that it produces an n × n times table. Prompt
    the user for the value of n.
106

     33. Write a program that reads an integer value and then displays that number of
         asterisks. For instance, if the value read is 11 then the output is:

         ***********

     34. Write a program that reads an integer value representing the number of
         students majoring in Mathematics and then another value representing the
         number of students majoring in Statistics. The program then displays two lines
         of asterisks to illustrate the number of students majoring in those subject areas.
         For example if the values were 11 and 15 the output would be:

     Mathematics ***********

     Statistics            ***************

     35. Modify the previous program so that it reads 5 pairs of values, where each pair
         comprises a major (a text string) and the number of students in that major (an
         integer). For example if the input was

     Mathematics 14

     Statistics            15

     English               25

     French                15

     Geology               10

     the output would be:

     Mathematics           **************
     Statistics            ***************
     English               *************************
     French                ***************
     Geology               **********
                                                                                                           107

     switch

The switch statement is a decision structure where one choice, of possibly many,
different choices are made. The general structure of the switch statement is

           switch ( expression ){
           case value1 : statement list1
           case value2 :statement list2
           case value3 :statement list3
           ...
           default: default statement list
           }

JVM and the switch
The JVM executes a switch as shown:

The switch statement contains a number of case groups where each group contains a
list of statements. The switch statement has an expression which is used to determine
where execution continues: If the value of the expression matches a value for a case
108

group, then execution continues with the case group's statement list. If the expression
does not match any of the specified values then the default statement list is executed, if
one exists.

Each statement list has a well-defined starting point. The statements of a statement list
are executed one-by-one until the JVM encounters a break statement. When a break is
executed, the execution of the switch terminates and the statement following the
switch is executed next (normal sequential execution of statements resumes). If a
statement list does not have a break statement then the the next statement list will
execute, and so on until either a break is encountered or the end of the switch is reached.

The default case group is optional: If the switch expression's value does not match a
case value and if there is no default case group then the switch statement terminates -
and the statement following the switch is executed next.

Normal usage of the switch is that each case group has a statement list and the last
statement of the group is a break. However, there are times when it is useful for a
statement group to be empty, and there are times when it is useful for a statement group
to not have a break statement.

Note that when all statement lists end with a break statement it is possible to replace a
switch statement with nested if statements where the logical expressions are of the
form expression.equals(value) for String expressions, and expression == value for other
types.

The expression and matching values can only be of certain data types that include: char,
byte, short, int, and the String type. Other included types are enumeration types and
the wrapper classes: Character, Byte, Short, Integer.
                                                                                                           109

Example 1

Previously we considered translating a letter grade to a numeric grade using an if. In
the program below each case group represents a line from the table:

            letter            grade
            grade             point

              A                 4
              B                 3
              C                 2
              D                 1
              F                 0

In this program a letter grade is obtained from the user. When the switch executes the
expression grade is evaluated and compared to each case value. If the value of grade
matches a value in some case, then the statement list for that case is executed. If the value
of grade is not an "A", "B", "C" or "D" the program assumes it must be "F" and so the
default case is executed and 0.0 is assigned to nGrade.

     Listing 3.15: Translate grade to its numeric value.

1 import java.util.Scanner;

2 /**

3    * Letter grade translated to a numeric grade.

4    */

5 public class LetterGradeToNumericGradeWithSwitch

6 {

7        public static void main(String[] args)

8        {

9           String grade;

10          double nGrade;

11          System.out.println("Enter letter grade:");

12          Scanner kb = new Scanner(System.in);

13          grade = kb.next();

14          switch (grade) {

15          case "A": nGrade = 4.0;

16          break;

17          case "B": nGrade = 3.0;

18          break;

19          case "C": nGrade = 2.0;
110

     20          break;

     21          case "D": nGrade = 1.0;

     22          break;

     23          default: nGrade = 0.0;

     24       }

     25       System.out.println(grade+" --> "+nGrade);

     26    }

     27 }

If this program did not have any break statements then every grade would be assigned
the same numeric value: 0.0. Consider this code:

          grade = kb.next();
          switch (grade) {
          case "A": nGrade = 4.0;
          case "B": nGrade = 3.0;
          case "C": nGrade = 2.0;
          case "D": nGrade = 1.0;
          default: nGrade = 0.0;
          }
          System.out.println(grade+" --> "+nGrade);

Now suppose grade has the value "A" then every assignment statement executes and
the last one executed is nGrade = 0.0 so the numeric grade assigned is 0.0.
                                                                                                           111

Exercises
      36. Write a program that prompts the user for a date in the yyyy mm dd format and
           then prints the date in the form month name dd, yyyy. For example, if the user
           provides 2000 01 01 then the program displays January 1, 2000.
      37. Write a program where the user provides the name of a month and the program
           displays the number of days in that month. We will ignore the fact that February
           sometimes has 29 days (in a leap year). In a sense Java lets you combine cases
           by allowing empty statement lists. For example, April, June, September, and
           November each have 30 days and so you can write code such as:
             case "April":
             case "June":
             case "September":
             case "November": numDays = 30;
             break;
         If the switch expression evaluates to any of

"April", "June", "September", "November" then numDays = 30 will be
executed.

      38. Suppose we need a program that accepts a month followed by a day and then
           reports the number of days left in the year. Again, we shall ignore the concept
           of leap year. For example, suppose the user entered: October 30
         As October has 31 days, November has 30 days, and December has 31 days, the
         number of days left is (31 - 30) + 30 + 31 = 62.

         Incorporate the following type of switch where each statement group simply
         increments a variable and where there are no break statements (so statement
         lists are executed from the selected case until the end of the switch). Note the
         use of the combined assignment operator +=.

          int numberOfDays = 0;
          switch (month) {
          case "January": numberOfDays += 31;
          case "February": numberOfDays += 28;
          case "March": numberOfDays += 31;
          ...
112

     do ...while

The do ...while statement is useful when it is known the loop body must execute at
least once. The syntax of the do ...while statement is
do statement while ( logical expression ) ;
JVM and the do ...while
The JVM executes a do ...while as shown:

In words we express the process followed by the JVM as:
   1. execute the statement
   2. evaluate the logical expression
   3. if the expression is true then go back to step 1, otherwise carry on with the
       statement following the do ...while

When one compares this control structure to other Java control structures (compound,
if, for, and switch statements) there is one difference that stands out: the semi-colon
at the end. This semi-colon is necessary - if you remove it the compiler will not recognize
your do ...while and the program will not be executable.
Example 1

Let us consider a simple program in Listing 3.16 below that displays the numbers from
0 to 9 using a do...while. Lines 11 and 12 form the compound statement that is
executed repeatedly. The process of executing the do ...while is straightforward:

        1 execute lines 11 and 12
        2 display a number
        3 increment the value of count
        4 evaluate count < 10 in line 14, and if the expression is true then repeat these

              steps starting at step 1.

Note the semi-colon at the end of line 14.

          Listing 3.16 Display numbers 0 ...9.

1 /**

2     * Display the numbers from 0 to 9.

3 */

4 public class Numbers0To9UsingDoWhile

5 {

6      public static void main(String[] args)

7      {

8         int count = 0;

9         System.out.println("Numbers");

10        do{

11             System.out.println(count);

12             count = count + 1;

13        }

14        while ( count < 10 ) ;

15        System.out.println("*******");

16     }

17 }

Example 2

Consider a program someone can use to develop their addition skills (Listing 3.17
below). The program should behave as follows:

   1. Give the user two numbers to add.

               113
114

   2. Evaluate the user's answer.

   3. Prompt the user whether or not to repeat.

   4. Go back to step 1 if the user wants to try another addition.

As well as including a do ...while this program makes use of three Java classes:
Random (Chapter 5.1), Scanner (Chapter 5.3), and String (Section 2.6). Consider these
points:

   1. (line 14) The variable generator references an instance created from the Random
       class. The Random class has many methods that can be used to generate random
       values; in lines 20 and 21 there is the expression generator.nextInt(10)+1 to
       obtain random values between 1 and 10.

   2. The variable kb defined in line 13 references an instance of the Scanner class and
       is used to manage input from the standard input device, the keyboard.

   3. The String variable response defined in line 15 is used to hold the user's response
       to the prompt "To try again enter Y". The program uses two methods
       from the String class: toLowerCase() and equals(...).

        (a) (line 31) toLowerCase() converts the user's response to all lower case
              characters

        (b) (line 33) equals("y") is used to compare the user's response in lower case to
              the lower case "y" and evaluates to true if the user's response had been "Y"
              or "y". If true then execution resumes at line 20, otherwise execution of the
              do ...while terminates and execution resumes at line 34.
                                                        115

              Listing 3.17 Developing addition skills.

1 import java.util.Scanner;

2 import java.util.Random;

3 /**

4     * Give the user two random integers to add.

5     * Inform user if their answer is correct.

6     * Prompt the user to try again.

7     * The user always attempts one addition.

8 */

9 public class Additions

10 {

11     public static void main(String[] args)

12     {

13        Scanner kb = new Scanner(System.in);

14        Random generator = new Random();

15        String response;

16        System.out.println("Welcome. "

17            +"Try some additions:");

18        do

19        {

20            int n1 = generator.nextInt(10)+1;

21            int n2 = generator.nextInt(10)+1;

22            System.out.println(n1+"+"+n2+"=?");

23            int answer = kb.nextInt();

24            if (answer == n1+n2) System.out.println("Correct!");

25            else System.out.println(

26            "Sorry that is not correct "

27            +"... the sum is "+(n1+n2));

28            System.out.println(

29            "To try again enter Y: ");

30            response = kb.next( );

31            response = response.toLowerCase();

32        }

33        while ( response.equals("y"));

34        System.out.println("Goodbye");

35     }

36 }
116

Exercises
      39. Modify Example 1 so the program will display the sum of the numbers from 0
           to 9.
      40. Modify Example 2 so the user gets a report when the program ends: the number
           of correct and the number of incorrect answers.
      41. Write a program that chooses a random number between 1 and 100, and then
           asks the user to guess what the number is. If a user guesses the number the
           program informs the user and stops, otherwise the program informs the user if
           they too high or too low, and the user is prompted to guess again. Use a do
           ...while to control the iteration.

      42. One can simulate the tossing (rolling) of a six-sided die through the use of the
           Random class. In many games two dice are thrown and the player's turn
           depends on the total value of the two dice. The following code instantiates two
           dice that can be used in a game:

           Random die1 = new Random();
           Random die2 = new Random();

       Now, if we want to roll the two dice and know the total thrown we could use:

           int toss1 = die1.nextInt(6)+1;
           int toss2 = die2.nextInt(6)+1;
           total = toss1 + toss2;

       In some games a player rolls the dice at least once. Suppose we want to simulate a
       player rolling the dice until "snake eyes" are thrown. Snake eyes is the term used
       to describe a throw where two one's appear. Write a program that uses a do
       ...while to simulate the rolling of two dice. The program must list the totals
       thrown until "snake-eyes" appear.
4 Introduction to Methods

Every Java application has at least one class that has a method named main. If you
execute a Java class the JVM automatically looks for a method named main and passes
control to its first statement.

In practice programmers develop programs comprising many methods. By using
methods you can

      write programs made up from component parts;
      write programs that are more understandable to other readers;
      write reusable code segments - code that can be called from more than one

         location in your program.

Methods begin with a header:

public static <return type> <name> ( <list of parameters>)

where <return type> can be one of void, int, double, char, or String;

where <name> is a valid Java name the programmer determines,

where <list of parameters> is a comma-separated list of parameter definitions. For some
methods this will be empty.

In this chapter we introduce methods to show you can organize your code to develop
more readable programs. In the following sections we discuss:

      Void methods: These methods do something such as displaying information but
          their logic does not need to return any value. These are useful structures to
          create modular code.

      Value-returning methods: These return a value to the point where called.
      Methods with parameters: These enable the reuse of methods with different

          supplied values.

There are other important aspects of methods discussed in later chapters.

                                                     117
118

     Void Methods

A void method is a named code segment that can be called to execute. When called, it
does something useful, and when complete control returns automatically to the point
following where it was called.

Example 1

Our first example is a rewrite of TimesTableWithFors from Chapter 3. That program
does two things:

     displays headings;

     displays the rows of the times table.

The main method in Listing 4.1 calls two methods, displayHeadings and
displayRows, that do just what their names suggest.

Examine lines 7 and 8 below and note how each method is called. Lines 11 and 20 are
the beginnings of the methods - note their headers: public static void ...

                                  Listing 4.1

1 /**

2          * 5x5 times table

3          */

4 public class TimesTable

5 {

6              public static void main(String[] args) {

7                 displayHeadings();

8                 displayRows();

9              }

10

11             public static void displayHeadings(){

12                // heading and column headings

13                System.out.println("\n\t5x5 Times Table");

14                System.out.println();

15                for (int i=1; i<=5; i++)

16                System.out.print("\t"+i);
                                                        119

17       System.out.println();

18    }

19

20    public static void displayRows(){

21       // Compute and print rows of times table

22       for (int i=1; i<=5; i++){

23          // row heading and row contents

24          System.out.print(i);

25          for (int j=1; j<=5; j++)

26          System.out.print("\t"+i*j);

27          System.out.println();

28       }

29    }

30 }

void methods are useful for decomposing a complex program into manageable
components. Overall, this type of program decomposition can lead to more readable
programs.

When the JVM executes a statement specifying the name of a void method (i.e. the
calling statement; e.g. lines 7 and 8 above) the following occurs:

    the JVM transfers control to the method (one exception - see section on
    parameters);

    the statements comprising the method are executed;

    after the method's last statement executes the JVM transfers control back to the
    statement following the calling statement.

When designing programs it is recommended to give methods obvious names; this
practice leads to programs that are readable, and where fewer comments are needed.
120

     Value-returning Methods

A value-returning method is designed to return a value to the point where it is called.
The return type for a method can be any of Java's primitive types (e.g. int, double,
char, boolean, etc.), String, or any other class defined in Java and its libraries, and
as we will see later on, class types that you create. For now we focus on methods that
return values of type int, double, char, boolean and String.

The last statement in a value-returning method is a return statement of the form:

          return <expression>

<expression> is a Java expression that yields a value corresponding to the method's type.

Example 2

Consider Question 10 from Chapter 3 where we are required to get a value for n from
the user and then calculate and display n! We have rewritten the provided solution
replacing the code that gets the value of n from the user with a method named
askUserForN. See Listing 4.2 for the revised code.

Line 10 is the assignment statement:
       int n = askUserForN();

Before n can be assigned a value, the method askUserForN must execute, the method
must create and return an int value.
At line 23 we see the beginning of method askUserForN and that it has a return type
of int. The last statement of a value-returning method must be a return statement;
the last statement in this method is

        return n;

and n is of course an int value.
                                                       121

                            Listing 4.2

1   import java.util.Scanner;

2   /**       Consider the calculation of n factorial defined as:

3      *         n! = 1 × 2 × 3 × ... × n where n > 0

4      *      Use a while to calculate n!

5      *      Prompt the user for the value of n

6      */

7   public class Ch3Q10

8   {

9          public static void main(String[] args){

10            int n = askUserForN();

11            int originalN = n;

12            int nFactorial = 1;

13            while (n > 0){

14               nFactorial = nFactorial * n;

15               n = n-1;

16            }

17            System.out.println("The value of "

18               +n

19               +"! is: "

20               +nFactorial);

21         }

22

23         public static int askUserForN(){

24            Scanner kb = new Scanner(System.in);

25            System.out.println("Please enter a value for n");

26            int n = kb.nextInt();

27            return n;

28         }
122

     Parameters

If you require a method that works with one set of values one time, and possibly
another set of values another time, you use a method with parameters. A calling
method can pass values to those parameters in the calling statement.

In general a method starts
          public static <return type> <name> ( <list of parameters>)

So far we have only used methods without parameters. For example,
        public static int askUserForN ( )

A method with parameters must define the type and name of each parameter.
<list of parameters> is a comma-separated list of variable declarations.

For example, a method FindMax with 3 parameters could start as:

           public static int findMax(int i1, int i2, int i3)

A calling statement must supply arguments matching each parameter, and the
arguments must be in the same order as the parameters. For example, consider:

           int max = findMax( 10, 4, 7 );

This statement would invoke findMax with the values 10, 4, 7 passed to
parameter variables i1, i2, and i3 respectively.

The mechanism Java uses, in computer science terms, for passing values to parameters
is call-by-value. With this technique, all values passed to a method are copied to
corresponding parameter variables. On exit from the method the opposite does not
occur. There is more to be said about this subject, but that is mentioned later on when
we discuss creating your own classes and objects.
Aside: some programming languages may use call-by-value and/or another technique
call-by-reference.
                                                                                                           123

Example 3

Consider the example LetterGradeToNumericGradeWithSwitch from Chapter
3, and review how the code converts a grade to its numeric value. In our rewrite of
LetterGradeToNumericGradeWithSwitch we have moved that code to a
method named convert.

Listing 4.3 is our rewrite that uses a method named convert that starts

           public static double convert(String s)

and has one parameter, a variable named s of type String. The main method has the
calling statement:

           nGrade = convert (grade);

When this statement executes three things happen:

   1 the value of grade in main is copied to the memory locations reserved for s in
         the method convert;

   2 the code comprising convert executes, and during its execution the variable
         num in convert will be assigned a value;

   3 lastly, the return statement in convert executes causing the value of num to
         be passed back to where convert was invoked (and so nGrade gets a value).

Note the variables in a method are independent of variables outside of it, and so the
variables in convert could just as easily have been named nGrade and grade
instead of num and s. We say the variables defined in a method are local to that
method. Local variables may have the same names as variables in other methods, and
there is no confusion as they belong to separate methods.

Depending on the value of the argument in the calling statement, different values can
be returned by convert:

        nGrade = convert ("A"); // nGrade becomes 4.0
        nGrade = convert ("C"); // nGrade becomes 2.0
124
                                                                                    125
                          Listing 4.3

1 import java.util.Scanner;

2 /**

3     * Letter grade translated to a numeric grade.

4 */

5 public class LetterGradeToNumericGrade

6 {

7      public static void main(String[] args)

8      {

9         String grade;

10        double nGrade;

11        System.out.println("Enter letter grade:");

12        Scanner kb = new Scanner(System.in);

13        grade = kb.next();

14        nGrade = convert (grade);

15        System.out.println(grade+" --> "+nGrade);

16     }

17     public static double convert(String s){

18        double num;

19        switch (s) {

20           case "A": num = 4.0;

21                      break;

22           case "B": num = 3.0;

23                      break;

24           case "C": num = 2.0;

25                      break;

26           case "D": num = 1.0;

27                      break;

28           default: num = 0.0;

29        }

30        return num;

31     }

32 }
126

     Summary

We have known since Chapter 1 that every Java application has a main method. Each
program you write is an algorithm that may be solving some scientific problem, or,
provide a process useful in some business application. Regardless, we need to make
our algorithms comprehensible to others.

A program implements an algorithm that you code in a language such as Java. Your
program's methods must reflect the overall structure of your algorithm. If some part is
complex then you can break it down into simpler components. In his book Clean Code,
Robert Martin recommends writing methods that "do one thing, and only one thing".

In general terms, when a method is called, the JVM:

      copies values supplied in a calling statement to the parameters of a method;

      then starts execution of the method;

      then,

          o if the method is value-returning and a return statement is executed, the
               value given in a return statement is passed back to the point where the
               method was called and the calling method resumes execution;

          o if the method is of type void, then when the end of the method is
               encountered control returns to the point following the method call and the
               calling method resumes execution.

With Java we need to be aware that:

     methods should be given names that suggest their purpose;
     to invoke a method, we use a call statement that names the method and

         supplies arguments corresponding to parameters;
     void methods do something, but do not return a value;
     value-returning methods compute and return a value;
     the declaration of a method specifies whether it is value-returning;
     when calling a method that has parameters the calling statement must provide

         a proper value for each parameter in the order of the method declaration.
127
128

Exercises

  1. Rewrite the program in Listing 4.2 so the main method becomes:

        public static void main(String[] args)
        {

                int n = askUserForN();
                int nFactorial = factorial(n);
                displayResults(n, nFactorial);
        }

  2. Rewrite the program in Listing 4.3 so the main method becomes:

        public static void main(String[] args)
        {

                String grade = askUserForLetterGrade();
                int nGrade = convert(grade);
                displayResults(grade, nGrade);
        }

3. Write a program that displays the French translation of an English word obtained
    from the user. Include a method named translate that returns a French word for a
    given English word. The method has one parameter, a word in English, and returns
    the French translation according to the table below. If a word passed
    to translate does not appear in the table, then the method must return "????".

English  French
season   saison
winter   hiver
rain     plouie
car      voiture

street   rue

4. We define a palindrome as a word that reads the same in either the forward or
    reverse direction.

Examples of palindromes
Ava
Radar
Pip
Otto
Mom
Noon
Layal
                                                                                                        129

  Write a program that obtains a word from the user and displays whether of not the
  word is a palindrome. Include a boolean method isPalindrome that determines
  whether or not a word is a palindrome.

5. Suppose we have a simple check digit scheme for a control number. To calculate
    the check digit we need to know the sum of the digits of the control number. The
    check digit is calculated as the remainder when the sum is divided by 10.

  For example if the control number is "2389" then the weighted sum is calculated as

        2 + 3 + 8 + 9 = 22

  The remainder when 22 is divided by 10 is 2.

  Therefore the check digit for "2389" is 2.

  Write a program that obtains a control numbers from the user and prints the control
  number followed by its check digit. Include a method checkDigit that returns the
  check digit of an integer.

  Test your program with the control number 543210.
130
5 Classes in the Java Class Libraries

     Random

The Random class provides a capability to generate pseudorandom values. The term
pseudorandom is used because the stream of values we can get are generated
algorithmically - if one knows the initial value used and the algorithm, we can predict the
sequence of random values. The interested reader who wants to learn more about
random number generation should consult the book The Art of Computer Programming
Volume 2 [6]. In what follows we will use the word random but do remember the values
obtained are pseudorandom.

The Random class provides methods the programmer can use to generate random values
that include boolean, integer, and double types. The Math class also has a method
random() that can be used to generate random double values between 0.0 (inclusive)
and 1.0.

In order to generate random values a program must instantiate an object from the
Random class. There are two constructors for this purpose: one that takes an argument
(a seed or initial value) and one that does not (the no-arg constructor). The advantage to
using a seed is that the stream of values is always the same and this can assist in
debugging code. One cannot predict the values to be obtained if the no-arg constructor
is used since it bases its' seed on the system time.

The table below shows some of the methods in the Random class.

Method              Description

nextBoolean()       Returns the next pseudorandom uniformly
                    distributed boolean value
nextInt()
                    Returns the next pseudorandom
nextInt(int limit)  uniformly distributed int value

                    Returns the next pseudorandom
                    uniformly distributed int value between
                    0 and limit-1

                    131
132

Example 1

We begin with a simple example to simulate rolling a six-sided die. Traditionally the
values of the sides are 1, 2, 3, 4, 5, 6. We use Random's nextInt(...) method to
obtain an int value between 0 and 5. So, if g is an instance of Random, and we want values
between 1 and 6, then we use: g.nextInt(6)+1. The following program simulates
tossing a die 10 times.

                  Listing 5.1: Roll Die 10 times.

1    import java.util.Random;

2    /**

3          * Display 10 rolls of a 6-sided die.

4          */

5    public class RollDie

6    {

7              public static void main(String[] args)

8              {

9                 System.out.print("\n\n10 rolls: ");

10                Random g = new Random();

11                for (int i=0; i<10; i++)

12                System.out.print(g.nextInt(6)+1+" ");

13             }

14   }

               Four sample runs of RollDie.java:
                                    RollDie run four times
                                                                 133

Example 2

Consider the tossing of a coin where one side of the coin is considered a head and the
other a tail. There are many approaches one could use, for example:

1. nextInt(2) generates 0 and 1

2. nextRandom() generates true and false

3. nextInt() generates integers - approximately half are negative, the other half
   positive (or half are even and half are odd).

The next program simulates tossing a coin 100 times and tabulating the number of
occurrences for the two outcomes. In the long run we expect the number of heads and
the number of tails to be equal, but that's not likely to occur on a single run.

              Listing 5.2: Toss a coin 100 times.

1          import java.util.Random;

2          /**

3             * Toss a coin 100 times and tabulate the

4             * number of heads and the number of tails.

5             */

6          public class TossCoin

7          {

8                 public static void main(String[] args)

9                 {

10                   int heads = 0;

11                   System.out.print("\n100 tosses: ");

12                   Random g = new Random();

13                   for (int i=0; i<100; i++)

14                      if(g.nextBoolean())heads++;

15                   System.out.println("\nHeads: "+heads

16                                   +"\nTails: "+(100-heads));

17                   }

18         }

                     A result from running TossCoin.java:
134

Exercises

      1. Modify Example 1 using a seed value when instantiating g. For example replace
           the line

             Random g = new Random()
             with
             Random g = new Random(101)

Run the program twice and notice the sequence of random numbers is the same both
times. Using a seed can be useful if you are having difficulty debugging your program.

     2. In the game of craps there are names given to various outcomes of rolling two
         dice. For example:

     snakes eyes  Names of rolls
       hard four                 two 1s
       yo-leven                  two 2s
        natural                 6 and 5

                  1 and 6, 2 and 5, 3 and 4

Write a program that will simulate throwing 2 dice until snake eyes occurs. The program
must list each throw including the snake eyes.

      3. In the standard game of Pig players take turns rolling a single die. In a turn a
           player repeatedly rolls a die according to:
                a. If a player rolls a 1, the player scores nothing for that turn and it
                     becomes the next player's turn.
                b. If a player rolls any other number, that number is added to the player's
                     turn total and the player's turn continues.
                c. If a player chooses to "hold", the player's turn total is added to the
                     player's total score, and it becomes the next player's turn.

Write a program to simulate the rolling of a single die until a 1 turns up. Your program
must list each roll.

      4. Consider the game of Pig again. Write a program to simulate a player's turn
           where the player's strategy is to continue rolling as long as the turn score is less
           than 25. That is, the player holds if the turn score is 25 or better. Of course, if a
           1 is rolled, the player gets a turn score of 0. Your program must list each roll and
           at the end of the turn display the turn total.
                                                                            135

     Character

The Character class has many static methods that can be used. Because the methods are
static the programmer does not instantiate an object. Instead, when using one of these
class methods it must be prefixed with Character., for example
Character.toLowerCase(ch). The following table lists some common static
methods of the Character class:

          Method                Description
          getNumericValue(...)
          isDigit(...)          Returns the int value that the specified
          isLetter(...)         character represents.
          isWhitespace(...)
          toLowerCase(...)      Determines if the specified character is a
          toUpperCase(...)      digit.
Three examples follow
                                Determines if the specified character is a
                                letter.

                                Determines if the specified character is
                                white space

                                Converts the character argument to
                                lowercase

                                Converts the character argument to
                                uppercase

1. Detecting the type of character

2. Getting the numerical value of a numeric character

3. Validating input
136

Example 1

If the data you have is a string then the String method charAt(...) can be used to access a
character at a specific index. When used in conjunction with a for statement the
characters of a string can be accessed one-by-one. In the following program we access
the characters of a string one-by-one and determine the type of each character using the
Character methods isDigit() and isLetter().

                     Listing 5.3: Types of characters.

     1  import java.util.Scanner;

     2  /**

     3     * A string provided by the user is examined

     4     * character by character to determine its type.

     5     */

     6  public class CharacterTypes

     7  {

     8         public static void main(String[] args)

     9         {

10                Scanner kb = new Scanner(System.in);

11                System.out.print("Enter a line: ");

12                String line = kb.nextLine();

13                // characters are examined one-by-one

14                for (int i = 0; i < line.length(); i++){

15                   char c = line.charAt(i);

16                   if(Character.isLetter(c))

17                   System.out.println(i+"\t"+ c+"\t\tletter");

18                   else if(Character.isDigit(c))

19                   System.out.println(i+"\t"+c+"\t\tdigit");

20                   else

21                   System.out.println(i+"\t"+c+"\t\tother");

22                }

23             }

24      }

     Below is the output from CharacterTypes.java for when the user provides the string
     "A$12"
137
138
Example 2
The Character method getNumericValue() can be used to obtain the decimal value of a
character. Consider the program in Listing 5.4. The main method in lines 7-13:

      obtains a line of text from the end user
      calls a method named addDigits to get the sum of digits in the line
The addDigits method in lines 15-25
      accesses characters one-by-one.
      In line 21 the getNumericValue() method is used.

                 Listing 5.4: Types of characters.

1   import java.util.Scanner;

2   /**

3      * The sum of numeric characters is calculated.

4      */

5   public class SumNumericValues

6   {

7          public static void main(String[] args) {

8             Scanner kb = new Scanner(System.in);

9             System.out.print("\nEnter a line: ");

10            String line = kb.nextLine();

11            int sum = addDigits(line);

12            System.out.println("sum = \t"+sum);

13         }

14

15         public static int addDigits(String s){

16            int sum = 0;

17            // characters are examined one-by-one

18            for (int i = 0; i < s.length(); i++){

19               char c = s.charAt(i);

20               if(Character.isDigit(c)){

21                  sum += Character.getNumericValue(c);

22               }

23            }

24            return sum;

25         }
                                                                    139

26  }

Below is the output where the user provides the string "1A 4c!6" .
140

Example 3

In many situations a user's input must be validated. Suppose a user is prompted for a
student number that must comprise only digits. If the user enters invalid characters, and
the program executes the Scanner method nextInt(), then the program would crash.
Instead the programmer must use the Scanner method nextInt() and then analyze
the characters to determine if the user entered a correctly formatted value.

isDigit(...) can be used to check if a character is a digit or not. Consider Listing 5.5.

                        Listing 5.5: Validation of input.

     1     import java.util.Scanner;

     2     /**

     3        * A string provided by the user is examined

     4        * to determine whether or not it is numeric.

     5        */

     6     public class ValidateStudentNumber

     7     {

     8            public static void main(String[] args)

     9            {

     10              Scanner kb = new Scanner(System.in);

     11              System.out.println("Enter a number: ");

     12              String number = kb.next();

     13              // characters are examined one-by-one

     14              boolean valid = true;

     15              for (int i = 0; i < number.length(); i++){

     16                 char c = number.charAt(i);

     17                 If ( ! Character.isDigit(c)) valid = false;

     18              }

     19              if (valid) System.out.println("Valid");

     20              else System.out.println("Invalid");

     21           }

Output from ValidateStudentNumber.java for two runs of the program is shown below.
                                                                                                           141

Exercises
   5. Java allows char values to be used directly in arithmetic expressions. Modify
        Example 2 to just add characters instead of the character's numerical value using
        a statement such as sum += c; The sum in this case is the sum of the internal
        representations of those characters.

   6. Modify Example 3 so it stops examining characters if it encounters a non-numeric
        character. Consider using a for that begins: for (int i=0; valid && i<number.length();
        i++)

   7. Write a program to validate a phone number where the number is expected to be
        a string of 10 digits. For example if the user entered 2343214567 the number
        would be valid, but if the user entered ADG3214567 the number would be invalid.

   8. The standard US zip code is five digits. Write a program that prompts the user for
        a zip code and then determines if it is valid or not. To be valid the code must be
        five characters in length and all characters must be digits.

   9. In 1983 the US Postal Service extended zip codes (ZIP+4) to include the five digits
        of the ZIP code, a hyphen, and four more digits that determine a more specific
        location within a given ZIP code. Write a program to validate a zip code entered
        by the user where the user might have entered a standard zip code (5 characters)
        or a zip+4 code (10 characters including the dash separating the first 5 digits from
        the last 4 digits).

   10. Sweden has a personal identity number (personnummer) that is issued by the
        Swedish Tax Agency. This identity number has 10 digits with a hyphen between
        the 6th and 7th digits, and is such that the 10th digit is a check digit. The check digit
        is calculated using the first 9 digits. A weighted sum of products is calculated as
        P(digiti × weighti) where the weights are 2, 1, 2, 1, 2, 1, 2, 1, 2. However if a product
        is more than 9 it is replaced by the sum of its digits. The check digit must be equal
        to 10 minus the last digit (but note that if the last digit of the sum is zero, the check
        digit is 0). Write a program to verify the user has entered a valid personnummer:

        · 10 digits with a dash between the 6th and 7th digits, and

        · the check digit is correctly based on the first 9 digits.

        For example consider the personnummer 811228-9874. To verify the check digit
        (the last digit, the 4) is correct we need to follow the above procedure. The sum
        of the weighted products is:
142

        (8×2)+(1×1)+(1×2)+(2×1)+(2×2)+(8×1)+(9×2)+(8×1)+(7×2) which are:
        (16) + 1 + 2 + 2 + 4 + 8 + (18) + 8 + (14) and modifying
        where the product > 9:
        (1 + 6) + 1 + 2 + 2 + 4 + 8 + (1 + 8) + 8 + (1 + 4) we have:
        7 + 1 + 2 + 2 + 4 + 8 + 9 + 8 + 5 = 46
        And finally 10 - 6 = 4. So, the personnummer above is valid.
                                                                                                           143

     Scanner

Previously we used a Scanner object to obtain data from the user via the standard input
device, the keyboard. The input is considered to be a sequence of tokens where tokens
are strings separated by delimiters which by default are whitespace. To Java, whitespace
includes spaces, tabs, newline, and a few other characters. A Scanner object is said to
parse the input stream making tokens available.

A programmer can specify exactly what constitutes a token. Consider that a program
could be reading a file where tokens are separated by commas (e.g. a CSV file that is easily
generated from Excel). The interested reader is referred to the Java documentation for
more information on how to specify delimiter patterns. For our purposes we use the
defaults for a scanner object and so tokens are strings where the strings are delimited
by whitespace.

In this text we cover three usages for the Scanner class:

    · As discussed earlier for handling input from standard input: System.in.
    · Obtaining tokens from a string.
    · Obtaining tokens from a file.

To use the methods in the Scanner class we must instantiate a Scanner, for example:

    · Scanner s = new Scanner("System.in");
    · Scanner s = new Scanner(s); //s is of type String
    · Scanner s = new Scanner(f); //f is of type File

The Scanner class is in the java.util package and so programs need to include:

      import java.util.Scanner;

We will illustrate the use of a scanner object for reading a file and another for scanning
a string.

Declaring a Scanner for a text file
Recall that each class we create in BlueJ is stored as a file with the .java extension, and
the compilation process creates another file with the .class extension. In a BlueJ project
there is another file you will have noticed called Readme.txt. The .java files and the .txt
file are both text files whereas the class file is a binary file. Text files are human-readable
144

but a class file contains Java bytecode and to view and make sense of its contents would
be quite difficult.

To read a text file we can declare a Scanner object which is associated with that file. Let
us consider only files that are in our project. When the file is contained in our project we
only need to name it as a string, as in: Scanner f = new Scanner(new File("Readme.txt"));

Consider the following table of Scanner methods. We will use a number of these in the
examples that follow.

method name          description

next()               Gets next token

nextBoolean()        Gets next token and converts it to an boolean

nextInt()            Gets next token and converts it to an int

nextDouble()         Gets next token and converts it to an double

hasNext()            Returns true if there is at least one more token
                     available, false otherwise

hasNextBoolean(...)  Returns true if there is at least one more token
                     available and that token is of type boolean, false
                     otherwise

hasNextInt()         Returns true if there is at least one more token
                     available and that token is of type int, false
                     otherwise

hasNextDouble()      Returns true if there is at least one more token
                     available and that token is of type double, false
                     otherwise

hasNextLine()        Returns true if there is at least one more line
                     available, false otherwise

nextLine()           Returns an entire line, up to the next end-of-line
                     character and returns the line as a String (the
                     end-of-line character is consumed but it is not
                     part of the return value).

Note that the above methods can result in errors that cause a program to fail. For
instance, if a program uses nextInt(), but the next token is a character string, then an
exception will occur. If a program executes next(), but the input stream is empty, then an
exception will occur.
                                                                                                           145

Example 1. Reading Readme.txt

Consider the following program the reads the file Readme.txt and displays its lines
including line numbers. Note the program has three import statements to direct the
compiler to definitions for Scanner, File and FileNotFoundException.

The File class itself is quite complex but for our purposes we are just naming the file and
instantiating a File object. Errors can arise when a program processes a file - the obvious
one is trying to read a file that does not exist. The Java file FileNotFoundException is
associated with that condition. Note the program also contains a throws clause - Java
requires this and for our purposes here we are declaring that we know this situation
might arise.

Two Scanner methods used here are:
   1. hasNext() which returns true or false according to whether or not there are more
       tokens to be retrieved.
   2. nextLine() which retrieves the next line (of course this may retrieve several tokens
       embedded in one string).
146

               Listing 5.6: Displaying contents of Readme.txt.

1    import java.util.Scanner;

2    import java.io.File;

3    import java.io.FileNotFoundException;

4    /**

5       * Display contents of Readme.txt with line numbers

6       */

7    public class DisplayReadme

8    {

9           public static void main(String[] args)

10          throws FileNotFoundException

11          {

12             Scanner f = new Scanner(new File("Readme.txt"));

13             int i=1;

14             System.out.println("<<<< File Readme.txt >>>>");

15             while (f.hasNext()) {

16                String line = f.nextLine();

17                System.out.println((i++)+" "+line);

18             }

19             System.out.println("<<<< end of listing >>>>");

20          }

21   }

When BlueJ creates Readme.txt it initializes the file with default contents. The
programmer can edit this file to store relevant information about the project. If the file
has not been edited then it has certain contents by default which are:
147
148

Example 2. Scanning a string
     You can define a Scanner object to process a string with Scanner methods. The
      method hasNext() returns true if there is another token in the string, and the
      method next() will return the next token in the string. Consider the following
      program that scans a string obtaining its tokens one-by-one.

              Listing 5.7: Display tokens in a string.

1   import java.util.Scanner;

2   /**

3      * Display tokens in a string

4      */

5   public class ScanString

6   {

7          public static void main(String[] args)

8          {

9             String sample = "one two \tthree";

10            Scanner s = new Scanner(sample);

11            System.out.println("<<<<"+sample+">>>>");

12            while (s.hasNext()){

13               String token = s.next();

14               System.out.println(token);

15            }

16            System.out.println("<< end of tokens >>");

17         }

18  }

                 Output from ScanString.java
                                                                                                           149

Exercises
  11. Modify Example 1 to use next() instead of nextLine(). Display each token on a
       separate line.

  12. Modify Example 2 to get the value for the variable sample from the user.

  13. Write a program that prompts the user for 10 boolean values. Display the number
       of true values entered by the user.
150

     Math

The class Math contains fields for  and e and methods for performing basic numeric
operations including exponential, logarithm, square root, and trigonometric functions.

The methods in the Math class are static methods and so one does not instantiate an
instance. To use a method you must prefix the method name by Math.. For example to
get the absolute value of an int x the programmer uses:

       int y = Math.abs(x);

or to determine the circumference of a circle of radius r:

       double circumference = 2.0 * Math.PI * r;

Next we list a number of the Math methods and then we present an example.

                             The Math Class

Fields

field      type description

E          double e

PI         double 

Static Methods

method type description

sin        double sine of an angle (in radians). e.g. Math.sin(2.5)

cos        double cosine of an angle (in radians). e.g. Math.cos(2.5)

tan        double tangent of an angle (in radians). e.g. Math.tan(2.5)

toRadians  double  converts an angle in degrees to an angle in radians. e.g.
                   Math.toRadians(180.0)

toDegrees double converts an angle in radians to an angle in degrees. e.g.
                            Math.toDegrees(3.14)

exp        double Euler's number e raised to a power. e.g. Math.exp(2.5)
                                                                                   151

log     double natural logarithm (base e). e.g. Math.log(2.5)
log10
pow     double base 10 logarithm. e.g. Math.log10(2.5)

random  double Returns the value of the first argument raised to the power of the second
                    argument. e.g. Math.pow(x, y)
abs
abs     double  Returns a double value with a positive sign, greater than or equal to 0.0
max             and less than 1.0.
max
min             e.g. Math.random()
min
hypot   int     returns the absolute value of an int. e.g. Math.abs(i)

        double returns the absolute value of a double. e.g. Math.abs(x)

        int     returns the larger of two int values. e.g. Math.max(5, 2)

        double returns the larger of two double values. e.g. Math.max(5.6, 2.0)

        int     returns the smaller of two int values. e.g. Math.min(5, 20)

        double returns the smaller of two double values. e.g. Math.min(5.3, 20.7)

        double  returns thepx2 + y2.
                e.g. Math.hypot(2.5, 3.3)
152

Example 1

     The following program prompts the user for three int values and reports the largest
     of the three.

         Listing 5.8: Use Math.max() to find largest of 3 values.

     1   import java.util.Scanner;

     2   /**

     3      * Prompt for 3 int values and report the

         largest

     4      */

     5   public class FindMax

     6   {

     7          public static void main(String[] args){

     8             Scanner kb = new Scanner(System.in);

     9             System.out.println(

     10            "Please enter 3 int values");

     11            int i = kb.nextInt();

     12            int j = kb.nextInt();

     13            int k = kb.nextInt();

     14            int mx = Math.max(i, Math.max(j,k));

     15            System.out.println("largest is "+mx);

     16         }

     17  }
                                                                                                           153

Exercises
   14. Write a program that accepts int values until the user enters a zero. The program
        must display the smallest value greater than zero.

   15. Write a program that obtains the radius of a circle from the user and calculates
        the area of the circle.

   16. Write a program that obtains the radius of a sphere from the user and calculates
        the volume of the sphere.

   17. Write a program that obtains the x and y values of a right-angled triangle from the
        user and calculates the length of the hypotenuse.
154

     Integer

The Integer class has many static fields and methods that can be used. Because these are
static the programmer does not instantiate an object. Instead, when using one of these
class fields or methods it must be prefixed with Integer., for example Integer.MAX_VALUE.
The following lists some common static fields and methods of the Integer class:

     Field       Description
     MAX VALUE
                 A constant holding the maximum value an int
     MIN VALUE   can have, 231-1.

     Method      A constant holding the minimum value an int can
     max()       have, -231.

     min()       Description

     parseInt()  Returns the greater of two int values as if by
                 calling Math.max. E.g Integer.max(34, 55)

                 Returns the smaller of two int values as if by
                 calling Math.min. E.g Integer.min(34, 55)

                 Parses the string argument as a signed decimal
                 integer. E.g. parseInt(" 23 ")

An example follows that demonstrates how to extract an integer value embedded in a
string.

Example 1

Suppose input values to a program are provided in a CSV style. CSV stands for comma-
separated-values and is a format that has been used in computing systems for moving
data from one system to another system. Suppose the data is available in the following
manner: each line has an item name, a comma, and a quantity, with no embedded spaces.
For example:

                 item,quantity

                 monitor,45
                 laptop,55
                 tablet,50
                 desktop,40
                                                                  155

Using a Scanner object a program could use the Scanner method nextLine() to get a line
having three things: an item name, a comma, and an integer. The program can find the
location of the comma and know that what follows in the string is a quantity. The
quantity can be converted to an integer using the parseInt() method. The program below
is designed to obtain 4 lines of such information from a user.

           Listing 5.9: Using parseInt() to get a decimal value.

1   import java.util.Scanner;

2   /**

3      * Four lines are read where each line contains

4      * an item name, a comma, and a quantity

5      * with no embedded spaces.

6      */

7   public class TotalQuantity

8   {

9          public static void main(String[] args)

10         {

11            Scanner kb = new Scanner(System.in);

12            int totalQty = 0;

13            for (int i = 0; i < 4; i++){

14               System.out.print("Enter next line: ");

15               String line = kb.nextLine();

16               int commaAt = line.indexOf(",");

17               String qtyAsString = line.substring(commaAt+1);

18               int qty = Integer.parseInt(qtyAsString);

19               totalQty += qty;

20            }

21            System.out.println("total = "+totalQty);

22         }

23  }

When the program is run with the 4 lines mentioned above we have the output:
156
                                                                                                           157

Exercises
  18. Modify Example 1 to find the item for which the quantity on hand is the largest.

  19. Write a program that accepts one line that holds an unknown number of integers
       in a CSV format. The program must print each value on a separate line and then
       display the largest and smallest of the values.
158
6 ArrayLists

There are several techniques for handling collections of data. In this chapter we
introduce the ArrayList. An ArrayList can be visualized as a linear list of objects at index
positions 0, 1, ....

The ArrayList is a data structure that grows and shrinks gracefully as objects are added
and removed. This is a distinct contrast to the array structure covered in Part II of these
notes (with an array once you have defined its size the size cannot be changed).

An ArrayList holds a collection of objects whereas arrays can be collections of either a
primitive data type or objects. If you wanted to use an ArrayList to hold data of a primitive
data type you would need to use a wrapper class (e.g. Integer, Double, Boolean,
Character) where wrapper objects contain data of a primitive data type. At this point
in your study of Java you have at least used strings that are instances of String (objects
of type String), and so our examples will deal with ArrayLists of type String.

We illustrate ArrayLists using these examples:
   1. Basic operations on an ArrayList
   2. Preventing duplicate entries in an ArrayList
   3. Creating an ArrayListfrom an array 4. A non-typesafe ArrayList.

Below we list some important methods that are defined for ArrayList.

Method         Description plus examples using:
               ArrayList¡String¿ people = new Arraylist()

add(...)       Can be used to either
               a) append a given element to the end of a list,
               or,
               b) if a position is specified insert the given
               elementat the specified position (following
               elements are shifted down).
               people.add("Jaime");
               people.add(4, "Jaime") ;

clear()        Removes all elements from a list.
               people.clear();

contains(...)  Returns true if this list contains the specified
               element.
               boolean found = people.add("Jaime");

               159
160

     get(...)      Returns the element at a specified position in this
     indexOf(...)  list.
     isEmpty()     String person = people.get(4);
     remove(...)
                   Returns the index of the first occurrence of the
     set(...)      specified element in this list, or -1 if this list does
     size()        not contain the element.
                   int pos = people.indexOf("Jaime");

                   Returns true if the list has no elements.
                   boolean empty = people.isEmpty();

                   Can be used to remove either
                   a) the element at a specified position in this
                   list, or
                   b) the first element matching a given
                   object;returns the deleted element and shifts
                   other elements up.
                   String removed = people.remove(4);
                   String removed = people.remove("Jaime");

                   Replaces an element with another element; returns
                   the previous element.
                   String previous = people.set(4, "Jaime");

                   Returns the number of elements in this list.
                   int numElts = people.size();
                                                                                                           161

    The enhanced for

     There is a variation on the for called the enhanced for that can be used when a
     program iterates from the first element through to the last element of an ArrayList
     and does not change any values. Using collection to represent the ArrayList and
     type to represent the type of elements in the collection, the syntax is

         for ( type variable : collection ) statement

     A for statement to iterate through an ArrayList names of Strings is:

          for (String s : names)
                     System.out.print(s+"");

     Examples

Example 1. Basic Operations

It is considered a good programming practice to specify the data type for the elements
of an ArrayList. The way to express this is to declare the type inside a pair of angle
brackets: < >. By specifying this a program cannot accidentally add a different type of
object to the ArrayList. We say this makes the ArrayList typesafe. In this example we
use the basic add() and remove() methods to add 4 elements and remove 1 element, and
then we use an enhanced for to display the elements one by one.
162

            Listing 6.1 Basic operations on an ArrayList.

     1   import java.util.ArrayList;

     2   /**

     3      * Create an ArrayList from an array of strings

     4      */

     5   public class BasicOperationsOnArrayList

     6   {

     7          public static void main(String[] args){

     8             // new, empty ArrayList of people

     9             ArrayList<String> people=new ArrayList();

     10            // add some names

     11            people.add("Joe");

     12            people.add("Jasper");

     13            people.add("Dick");

     14            people.add("Abigail");

     15            // remove a name

     16            people.remove("Dick");

     17            // display the names in people

     18            for (String p: people)

     19            System.out.print(p+" ");

     20         }

     21  }

     The output, of course, does not include "Dick":
                                                                  163

Example 2 (Prevent Duplicates)

     The contains() method returns true when a given element exists in an ArrayList.
     The program below uses contains() and prevents duplicate elements. The user is
     prompted for names to add to the list - the process stops when the user enters the
     word stop.

              Listing 6.2 Prevent duplicate elements.

1   import java.util.Scanner;

2   import java.util.ArrayList;

3   /**

4      * Prevent duplicate elements in ArrayList

5      */

6   public class PreventDuplicatesInArrayList

7   {

8          public static void main(String[] args){

9             ArrayList<String> people=new ArrayList();

10            // add some names

11            Scanner kb = new Scanner(System.in);

12            System.out.println("enter names followed"

13               +" by the word stop: ");

14            String name = kb.next();

15            while (!name.equals("stop")) {

16               if (!people.contains(name))

17               people.add(name);

18               name = kb.next();

19            }

20            // display the names in people

21            for (String p: people)

22               System.out.print(p+" ");

23         }

24  }

The following shows the prompt to the user, the user's response:
     Joe Joe Jasper Abigail Abigail Jasper stop
     and the output generated:
164

Example 3 (Legacy Code Issues)

This example is included to show how ArrayLists are specified in some legacy code.
When ArrayLists were added to the Java language they were not typesafe - the declaration
of an ArrayList did not include a type specification, for example:

ArrayList name = new ArrayList();

This declaration has no angle brackets and so no type specification, and so its possible to
add any kind of object to the ArrayList. Currently, the recommended practice is always to
include a type in the declaration so the program is more robust - certain errors at
runtime cannot occur. This example is included only for demonstration purposes and is
not recommended practice. The output follows the code listing.

         Listing 6.3 Do not declare an ArrayList this way.

     1   import java.util.ArrayList;

     2   import java.util.Scanner;

     3   import java.util.Random;

     4   /**

     5      * Declaring an ArrayList that is not typesafe.

     6      * Not a recommended practice, but something

     7      * you might see in legacy code.

     8      */

     9   public class OldStyleArrayList

     10  {

     11         public static void main(String[] args){

     12            // No type specification for people

     13            // Hence, any old object will do

     14            ArrayList people=new ArrayList();

     15            // Add some elements

     16            people.add("Abigail");

     17            people.add("Jim");

     18            // these two adds are for demonstration

     19            people.add(System.out);

     20            people.add(new Random());

     21            // display the people

     22            for (Object p: people)

     23            System.out.println(p);

     24         }

     25  }
                                                                                                           165

The output below shows two String objects, a System.out object, and a Scanner object - all
of which were added to the ArrayList.
166

     Sieve of Eratosthenes

A Greek mathematician, Eratosthenes of Cyrene, who lived more than 2, 000 years ago
developed an algorithm that enables us to find prime numbers. In our adaptation we are
going to store a list of prime numbers in an ArrayList.

With a sieve of size n we can find all the prime numbers between 1 and n. Recall that a
prime number is an integer greater than 1 that has no positive divisors other than 1 and
itself. For instance, 7 is a prime number since the only integers that evenly divide 7 are
1 and 7 itself; the number 7 can only be expressed as the product of two numbers: 1 ×7.
Any integer that is not prime can be expressed as the product of two integers other than
1 and itself. For example, 8 is not a prime number since it can be expressed as a product
of 2 and 4. The integer 8 is divisible by 1, 2, 4, and 8; we say the integer 8 is a composite
integer.

There are many references to the Sieve of Eratosthenes on the web . At the time of writing
an article could be found in Wikipedia that illustrates a sieve for finding all primes less
than 120.

To use the sieve we first construct a list of positive integers ranging up to a limit. The
algorithm is iterative; it begins by crossing off all multiples of 2. Then the list is scanned
for the next integer following 2 that is not crossed off (this will be 3), and its multiples
are crossed off. This process of finding the next non-crossed off integer and crossing off
its multiples continues until no more can be found. In the implementation we represent
the list with a list of integers where the ith entry is simply i, and we cross off an integer
by setting it to 0.

Sieve of Eratosthenes Algorithm:

          1. next  2 // begin crossing-off multiples starting with 2

          2. for next ranging from 2 to limit in increments of 1

                   If listnext is not crossed-off // cross-off all multiples of next

                   i. p  2*next

                   ii. while p <= limit

                             A. listp  0 // cross-off this multiple
                                                                                                           167
                             B. p  p+next // next multiple
Lets look at applying the algorithm for limit=25
· The algorithm requires the list:
         0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
         Note the list starts at 0 in order that listi = i.
· When step 2 executes for the first time (next is 2) the list becomes
         0 1 2 3 0 5 0 7 0 9 0 11 0 13 0 15 0 17 0 19 0 21 0 23 0 25
         where all the even numbers larger than 2 are replaced by 0.
· When step 2 executes again (next is 3) the list becomes
         0 1 2 3 0 5 0 7 0 0 0 11 0 13 0 0 0 17 0 19 0 0 0 23 0 25
         where all the numbers that are multiples of 3 are replaced by 0.
· This process continues and the list eventually becomes:
         0 1 2 3 0 5 0 7 0 0 0 11 0 13 0 0 0 17 0 19 0 0 0 23 0 0
· From the above, starting at 2, we easily see primes less than or equal
         to 25 are: 2 3 5 7 11 13 17 19 23
Listing 6.4 is an implementation of the algorithm where:
          Line 10 prompts the user for the sieve limit;
          Line 12 declares the list that will hold the numbers;
          Lines 13-15 initialize the list so that its elements are 0, 1, 2, 3, ... .;
          Lines 17-27 iterate applying the sieve technique
          Line 23 crosses-off an element using:

                     list.set(p, 0);

          Lines 29-32 place the prime numbers in a list named result.
168

Listing 6.4 Sieve of Eratosthenes

1    import javax.swing.JOptionPane;

2    import java.util.ArrayList;

3

4    public class SieveOfEratosthenes

5    {

6       public static void main(String[] args){

7          // get limit from user

8          String limitAsString = JOptionPane.showInputDialog(

9                                                   "Enter upper limit:");

10         int limit = Integer.parseInt(limitAsString);

11         // set up the list of integers

12         ArrayList<Integer> list = new ArrayList<>();

13         for (int i=0; i<=limit; i++){

14            list.add(i);

15         }

16         // apply the sieve technique

17         for (int next=2; next<limit; next++){

18            if (list.get(next)!=0){

19               // cross off multiple of next

20               int p = 2*next;

21               while (p <= limit){

22                                 // cross off this element

23                                 list.set(p, 0);

24                                 p+=next;

25               }

26            }

27         }

28         // display primes

29         ArrayList<Integer> result = new ArrayList<>();

30         for (int i=2; i<limit; i++){

31            if (list.get(i)!=0) result.add(i);

32         }

33         JOptionPane.showMessageDialog(null,

34                                 "primes < "+limit+" are "+result);

35      }

36   }
                                                                    169

    Parallel Lists

There are situations where more than one list is needed. When it is also the case that
elements of the lists at the same index are related to one another, we say we are using
parallel lists.

Example 5

Suppose we are interested in words and how many times each word occurs. To do this
we could use two Arraylists, one for words and the other for the frequency of words.

    ArrayList<String> word = new ArrayList<>();
    ArrayList<Integer> frequency = new ArrayList<>();

Let us consider that the ith element of frequency is the frequency of occurrence for the
word stored as the ith element of word. In this case frequency and word are parallel
Arraylists.

Consider Listing 6.5 where words are stored in word, and frequencies in a parallel list
frequency.

Listing 6.5 Storing words and their frequencies in parallel lists

1   import java.util.ArrayList;

2   public class WordFrequency

3   {

4          public static void main(String[] args){

5                // two parallel lists: words and frequencies

6                ArrayList<String> word = new ArrayList<>();

7                ArrayList<Integer> frequency = new ArrayList<>();

8                // try adding words: today, tomorrow, today

9                addWord(word, frequency, "today");

10               addWord(word, frequency, "tomorrow");

11               addWord(word, frequency, "today");

12               // display the two lists

13               System.out.println(word);

14               System.out.println(frequency);

15         }

16

17         /**

18            * addWord: add a new word to the list of words, or

19            *     increment frequency for existing word
170

20             *

21             * parameters:

22             * wordList     a list of words

23             * frequencyList frequencies for words

24             * newWord      potential new word

25             */

26          public static void addWord(

27                            ArrayList<String> wordList,

28                            ArrayList<Integer> frequencyList,

29                            String newWord)

30          {

31

32                 int i = wordList.indexOf(newWord);
                   if ( i>=0 ) {
33
                          // new word found in list
34                        int currentFrequency = frequencyList.get(i)+1;
                          frequencyList.set(i,currentFrequency);
35                 }
                   else {
36                        // new word not found
                          wordList.add(newWord);
37                        frequencyList.add(1);
                   }
38          }

39

40

41

42

43

44       }

Output:
                                                                                                           171

Exercises
    1. There is a class called Collections which can be used in a program if one includes
         the import statement:

          import java.util.Collections;

         The ArrayList is part of the Java Collections framework and there is a method
         sort(...) in Collections that can be used to sort an ArrayList. For instance, to
         sort the ArrayList named people you use the statement:

                Collections.sort(people);

         Modify Example 2 so that the list of names appears in alphabetical order.

      2. Write a program to analyze text. Each word (token) found is stored in an
           ArrayList. Your program must read the file Readme.txt. Dispaly the list of words.

      3. Modify the previous program to use parallel arrays to determine and display
           each word and its frequency.

      4. Modify the previous program so that duplicate words are not stored in the
           ArrayList.

      5. Determine the punctuation used in Readme.txt. Remove all punctuation from
           the tokens and store the words in lowercase in the ArrayList.

      6. Modify Example 3 to make the ArrayList people typesafe. What happens now
           when you compile the program?

      7. Modify the Sieve example so the main method becomes:

                             public static void main(String[] args){
                                    int limit = getLimitFromUser();
                                    ArrayList<Integer> result = applySieve(limit);
                                    displayResults(result);

                             }
172
7 Designing Java Classes

Up to this point our programming has involved the coding of a single class but often we
have demonstrated the use of one or more classes defined in the Java class libraries.
These pre-defined classes include: Character, Integer, JOptionPane, Math, Random,
Scanner, String, and System. In this chapter we will see how to create programs where we
can code several classes ourselves. A class comprises fields, constructors, and methods
which make up the subject matter of this chapter. But before we get into those, we
discuss a few points regarding our use of these pre-defined classes.

The Math class contains various mathematical constants and utility methods for
common mathematical operations. For instance, the Math class has a field named PI. In
a program we can have a statement such as

           double circumference = 2.0 * Math.PI * r;

where we reference PI using the name of the class, Math. In particular we did not create
an object of type Math. It's a similar case for the method max() in the Math class. To find
the maximum of two numbers we can use the expression Math.max(num1, num2). PI is
a static field and max() is a static method; these types of fields and methods can be
accessed without the need for an object.

So to use the facilities of the Math class we did not need an object, but there are other
times when it was necessary for us to create an object. For example consider the Scanner
class and the instantiation of an object:

           Scanner scanner = new Scanner(source);

In order to get the next token from scanner we use expressions like scanner.next().
The object (also called an instance) named scanner must keep track of its source and its
current position on that source. When a scanner object executes the next() method, the
method obtains the next token on the source, advances its position on that source, and
returns the token.

With respect to methods we have seen another difference: sometimes we have used a
method that returned a value and other times we invoked a method knowing that
something will happen. When we simulate the tossing of a six-sided die we use:

                                                     173
174

           int throw = generator.nextInt(6)+1;

where we understand nextInt(6) returns a value that is used in the arithmetic
expression generator.nextInt(6)+1. The method nextInt() is an example of a value-
returning method.

When we display something in the user's terminal window we use a statement like:

           System.out.println("Enter a number: ");

where we understand that the string "Enter a number: " will be displayed,

and where there is no value returned that we make any use of. The method println()
is an example of a void method (one that does not return a value).

In the rest of this chapter we:
    · present an example from an educational setting where multiple classes are useful;
    · explore the use of fields, methods, and constructors;
    · discuss modifiers named public and private used to control access to classes,
       fields, methods, and constructors;
    · discuss the concept of overloading;
    · describe the implementation of associations between classes;
    · describe the passing of values to parameters;
    · describe variable length parameter lists;
    · discuss the use of methods to simplify the logic of a program.

The above list is lengthy and indicates this chapter covers several new Java programming
concepts.
                                                                                                           175

     Using Multiple Classes

So far we have always used a single class for our examples and exercises. However it is
very common for Java-based systems to involve several classes where each class
encompasses the requirements (fields, constructors, and methods) of a significant
concept. For example, if you were developing a system for your educational institution
you would need to implement things having to do with students, subject areas, courses,
instructors, etc. What should happen is that you design separate classes for each of these
concepts: a class for student, a class for subject, a class for course, and so on:

        public class
        Student{

          ...
        public class
        Subject{

          ...
        public class
        Course{
        ...
        public class
        Instructor{ ...

Before writing any code we recommend drawing a Class Diagram to illustrate the
concepts you are thinking about. To simplify we present a diagram in Figure 8.1 that
shows just a subset of the concepts mentioned above: two classes and a relationship. The
relationship is based on a business rule for the institution: a student declares a major in
one subject, and that for a subject there can be many students majoring in that subject.

                         Figure 8.1: A simple Class Diagram.

Each class is shown in its own compartment and a relationship is shown as a named line.
The small filled arrow shape gives the viewer an indication of how to read the diagram.
The 1 and the * are called multiplicities that stand for one and many respectively, and are
used to express how many of one object can be related to another object through the
relationship. In this example the association line represents a two-part business rule:
176

a student is majoring in one subject

a subject has many majors who are students

As we continue we will be developing Student and Subject, and in Section 8.11 you will
find complete listings of these two classes.

     Fields

We have learned to define variables when we needed to keep track of information.
Suppose we were developing a class to represent the concept of student. We would need
variables for student identifier, first name, last name, gender, active, etc. Formally these
variables are referred to as fields and previously we would have defined these similar to:

        public class Student() {
               int id;
               String firstName;
               String lastName;
               char gender;
               boolean active;

However, it generally recommended that one define the above fields using a different
modifier named private. By specifying private we make it impossible for these fields
to be referenced from outside the class. We will say more about this idea later. Now we
have:

public class Student() {
          private int id;
          private String firstName;
          private String lastName;
          private char gender;
          private boolean active;

The above is Java code that defines part of a class named Student. A less formal way to
illustrate the above is to use a class diagram. Now we show two compartments, one for
the name of the class, and one for the names of the fields and types, as shown in Figure
8.2.

Student objects can be created where each object would have its own copy of these fields,
and so each student object could have different values stored in its fields. Figure 8.3 is
                                                                                                           177

an Object Diagram where each object is represented by two compartments. In the upper
compartment we show a name for an object (e.g. jill) and the class of the object (e.g.
Student). By convention this information is underlined. In the lower compartment we
show values for fields. The diagram makes it clear there are three students and each
student object has its own fields to hold values for id, first name, etc.
178
Figure 8.2: Class diagram with two compartments

               Figure 8.3: Object Diagram with 3 student objects.

Instance and class fields
If we define a field in a class and specify it as static that field is referred to as a class field.
Only one copy of a class field exists regardless of the number of objects that exist.
Suppose we are developing a system where we generate student identifiers sequentially.
Consider a field named lastId where we store the id used for the last student object
created. Consider the following for our Student class:
public class Student {

          // class fields
          private private int lastId; // a static field
          // instance fields
          private int id;
          private String firstName;
          private String lastName;
          private char gender;
          private boolean active;
                                                                                                           179

In Figure 8.4 we show the Student class and 3 student objects. Note that we show the
lastId field in the Student class with its current value. Later we will discuss methods and
how the value of lastId is used and updated.

               Figure 8.4: Static field in class and instance fields in objects.
180

     Methods

A method is a named collection of Java statements. Optionally a method can have a
parameter list to provide for data to be passed in and can be designed to return a value
back to the point where it is invoked. Methods are an important tool when we write Java
programs. We use methods for two purposes.

     1. To eliminate code redundancy: If we find that we are repeating the same code as
          elsewhere in our program we write that code as a method and call it from
          wherever it's needed. Now, if this code ever needs to change there is only place
          where the change needs to be performed.

     2. To create readable programs: Programs are subject to change. Change happens
          if errors are discovered in existing code, or, if the business rules change. In real
          systems it has been found that more time and effort is spent maintaining a
          program that what was required to create it in the first place. Whenever code
          must be maintained the program must be understood first before changes are
          made - the more readable your code is, the easier and more reliably the code can
          be modified.

When we are designing a program and we decide that certain functionality must be
placed into a method we determine

      1. whether or not the method returns a value

      2. if the method is a class method

      3. if the method is an instance method

      4. whether or not the method can be accessed from other classes.

Value-returning methods

A method can be designed to return a value of any primitive type, array, or object type.
We have seen many examples of these including max() and min() in the Math class, and
the nextInt() and nextBoolean() of the Random class.

In our educational example that we are developing we have made the fields of Student
private. Instead of giving other classes direct access to fields the convention is to provide
methods for this purpose. One reason to do things this way is to hide the implementation
                                                                                                           181

of fields which then makes it easier to change an implementation later. So, for each field
of the Student getters/accessors class we can design a group of methods that are called
getters (sometimes called accessors). For each of these we specify the data type they
return and the last statement in a getter method is a return statement. Consider the
following code in the Student class:

public class Student {
         private static int lastId;
         private int id;
         private String firstName;
         private String lastName;
         private char gender;
         public static int getLastId(){
                    lastId;
         }
         public int getId(){
                   return id;
         }
         public String getFirstName(){
                   return firstName;
         }
         public String getLastName(){
                   return lastName;
         }
         public char getGender(){
                   return gender;
         }
         public boolean isActive(){
                   return active;
         }

Observe how methods are named above. Because they are getters, each method name
(but one) begins with "get" prepended to a field name where the first character of the
field name is capitalized. Since active is boolean its getter begins with is. As for variable
names, we use "camel case" for method names.

Consider getLastId() above. It is defined as static since the lastId() field is static. To
invoke this method we use:
182

           int lastOne = Student.getLastId();

Calling the other methods above only make sense in the context of some object, and so
these methods are examples of instance methods. If joe is the name we are using to
reference a student object then we can write meaningful statements to get, for example,
the gender of this student:

           Student joe = new Student();
           ...
           char g = joe.getGender();

Two other standard value-returning methods normally provided for a class are the
toString() and equals() methods.

When an object is being displayed via println(); it is the toString() method that
determines what will be displayed. The toString() method returns a string that
represents an object. As an example, we will use the following toString() in our
system:

           public String toString(){
                return id+" "+firstName+" "+lastName;

           }

If the statement

           System.out.println(jill);

was executed then the output to the terminal window would be:

           1 Jill Lee

When objects are compared for equality a programmer normally uses the equals()
method. Previously we have used the equals() method to compare two strings for
equality. The idea that two strings are equal is simple: the two strings are either the same
string, or they are of the same length comprising the same characters. In a program to
compare two names, say name1 and name2, we can use either:

           name1.equals(name2)

or
                                                                                                           183

          name2.equals(name1)

For more complex objects like student objects it is not always so simple to decide on the
equality test. A student object has several fields that could enter into consideration. At
this time we will take a simple viewpoint on this and consider two student objects the
same if they have the same value for the student identifier. Consider the method:

          public boolean equals(Student s){
          return id == s.id;
          }

Note how this method has a parameter s of type Student. The equals method is invoked
for a particular student object and that object is being compared to the object s. If some
code were to check two student objects (say jill and sam) to see if the objects have the
same content the programmer could code either

          if (jill.equals(sam))

or

          if (sam.equals(jill))

If instead one uses jill == sam it is memory addresses (and not content) that are being
compared for equality. We use == only to determine if two object references are to the
same object, as in:

                     Student s1, s2; ...
                     // test to see id s1 and s2 refer to the
                     // same student object
                     if (s1 == s2) ...
184

void methods

Sometimes we need methods just to complete some task and for which there is no value
that needs to be returned. One of the conventions in java programming is to provide
setter methods that are used only to set, or change, the value of a field. Consider this
partial listing of Student:

     public class Student {
         // constructors ...
         // field declarations ...
         // getters ...
         // setters:

     // but no setter for the id field

     //       public void setId(int newId){

     //       id = newId;

     // }

     public void setFirstName(String newFirstName){
              firstName = newFirstName;

     }

     public void setLastName(String newLastName){
              lastName = newLastName;

     }

     public void setGender(char newGender){
              gender = newGender;

     }

     public void setActive(boolean newActive){
             active = newActive;

     }

In the above we have commented out a setter that could have been included for id. A
reason for not having a setter for id is the idea that once a student is assigned a unique
identifier that identifier would never change.

Observe how methods are named above. Because they are setters, each method name
begins with "set" prepended to a field name where the first character of the field name
is capitalized. As mentioned before, we use
                                               185

   Constructors

Constructors are used to instantiate an object.If you do not explicitly code a constructor,
then the Java compiler creates a no-arg constructor for you. A no-arg constructor is a
constructor that takes no arguments - the parameter list is empty. A constructor is
invoked any time you use the new operator, for example:

   Scanner keyboard = new Scanner(System.in);

A constructor is similar to a method in that it is a block of code that may have a parameter
list, but there are two major differences:

   1. A constructor returns an object but the code for a constructor does not include
       any return statements.

   2. Although a constructor returns an object created from a specific class, the
       constructor does not explicitly declare the type.

Its common for a class to have multiple constructors that will differ from one another in
their parameter lists (see overloading, Section 8.6). To illustrate we introduce two
constructors for the Student class:

   1. A no-arg constructor: This constructor has no values passed in to it and so it
      creates a student object with a generated value for the student identifier but
      has to make up values for the other fields. Presumably those fields will
      eventually be filled in with calls to setter methods.

   2. A constructor with four parameters. This constructor assigns a generated
      value to the student identifier and the other fields are set according to the
      caller's supplied values.

The first part of our Student class is now (note that the code for nextId() is shown
on page 199 ):

1  /**

2  * A student.

3  */

4  public class Student {

5       // class fields

6       private static int lastId;

7       // instance fields
186

8    private int id;

9    private String firstName;

10   private String lastName;

11   private char gender;

12   private boolean active;

13   private Subject major;

14   // first constructor, no arguments

15   public Student(){

16      id = nextId();

17      // default values for a student:

18      firstName = "unknown";

19      lastName = "unknown";

20      gender = '?';

21      active = false;

22   }

23   // second constructor, four arguments

24   public Student (String firstName, String lastName, char

     gender, boolean active){

25      id = nextId();

26      //

27      // when parameters and fields have the same

28      // name they are distinquished this way:

29      // a field name alone refers to the parameter

30      // a field name prefixed with "this."

31      // refers to an object's fields.

32      this.firstName = firstName;

33      this.lastName = lastName;

34      this.gender = gender;

35      this.active = active;

36   }

37
           // other methods ...

The second constructor (lines 23-35) illustrates a style of coding that is quite common
for constructors and methods. In the parameter list of the constructor the parameters
have the exact same name as the corresponding fields. Formally, in the Java language, we
say the field is shadowed by the parameter. To reference the field within the method you
must use the this keyword. When the name is used alone (e.g. firstName) in a
                                                                                                           187

constructor it is a reference to the parameter. When a name is prefixed with "this." it is
a reference to the object's field. Consider line 31:

          this.firstName = firstName;

The right hand side of the assignment statement is a reference to a parameter and the
left hand side of the assignment statement is a reference to the the object's field. And so
this assignment statement assigns a value passed in via the parameter to an object's field.

We illustrate the class diagram for the Student class with three compartments, where
the third shows constructors and methods. Note that we have left out some details such
as the field types and parameter types. We have included plus and minus signs to show
whether a method or constructor is public('+') or private('-').

                       Figure 8.5: Student class with 3 compartments.
188

Using constructors

A constructor is invoked any time a program executes a new operator. Consider the code
below where we invoke each of the above constructors. For the no-arg constructor we
follow up with setters to fill out the student object.

                    Listing 7.1 Using constructors.

1 /**

2 * Create two student objects

3 * using the two constructors

4 */

5 public class UseConstructors

6 {

7      public static void main(String[] args){

8         // first, with the no-arg constructor

9         Student jill = new Student();

10        // use setters to complete the student object

11        jill.setFirstName("Jill");

12        jill.setLastName("Lee");

13        jill.setGender('F');

14        jill.setActive(true);

15        // now with the other constructor

16        Student sam = new Student("Samantha","Jones",'F',true);

17        // display the students

18        System.out.println(jill);

19        System.out.println(sam);

20     }

21 }

     The output from UseConstructors is shown below. We can see from the output
     that when a student object is displayed the toString() method was used.
                                                                                                           189

     Visibility Specifications: Public, Private

In our introduction to Java we are only concerned with the modifiers public and private
which can be used on classes, fields, methods, and constructors.

Classes

When complex systems are developed Java classes will be organized into packages. We
have used several packages (i.e. the Java class libraries) where each library is a package
containing related classes. For example,

         1. the package java.lang contains fundamental classes such as Character,
         Double, Integer, Math, and String;
         2. the package java.util contains utility classes such as Arrays, ArrayList,

          Collections, Random, and Scanner.

The packages we have been using are all designated as public meaning that any other
class can use them. If there is a need to provide different accessibility then other
modifiers such as private and protected can be used. Please see Volume II of these notes
for further information.

For introductory programming we will only use public for our classes. With BlueJ all of
our classes will be in one default package. For more information with respect to BlueJ
consult the BlueJ documentation.

Fields

If a field is designated private the field can only be accessed from within the class where
it is defined. This is considered good practice because the class has control over the
implementation of the field and exposes the field only through methods. This idea of
keeping the implementation aspects hidden is called Information Hiding.

As an example, suppose a three-dimensional point (x,y,z) is represented in a program
with three floating point variables. Suppose the representation must change to be an
array of size three, then that change would only affect this class and no others. The
methods that were in place to provide information about x, y, and z can continue to serve
190

(with minor modification) the needs of other classes. So, information hiding is a way of
controlling the scope of changes in a system.

When a field is designated public the field can be accessed from any other class. What
can happen then is that other classes become dependent on the data type that is used.
However, there are situations where public is appropriate - consider the utility class
Math. Math has two public fields PI and E for  and e.

Methods

When a method is designated public then any other class can invoke that method. For
getter and setter methods this is the usual practice.

When a method is designated as private the method can only be called from within the
class where it is defined. In our Student example we use a private method that controls
the value of the field lastId. Consider the constructor below and the utility method
nextId(). This utility method is only called from a constructor and nothing outside the
class can call it. In this way the value of lastId can never be changed except when a
Student object is created.

           public Student(){
                  id = nextId();

           }
           private int nextId(){
           // increment lastId and return the new value // to be used for
           the new student.

                  return ++lastId;

         }

     Constructors

When a constructor is designated public then any other class can use that constructor to
create an object. This is the usual case for constructors.

When a constructor is designated as private the constructor can only be called from
within the class where it is defined. One class we have used that has a private constructor
is Math. Math is a utility class made up of static fields and static methods, and so there
                                                                                                           191

would be no benefit to ever havinga Math object. The private constructor prevents
anyone from instantiating a Math object.

If you try to instantiate an instance of Math your program will not compile; the message
you receive back from the compiler is "Math() has private access in java.lang.Math".

     Overloading

The Java language allows you to define more than one method with the same method
name as long as the parameter lists are different. If two or overloaded more methods
have the same name we say the name is overloaded. The same is true for constructors -
a class can have more than one constructor as long as their parameters lists are different.
We have seen overloading in practice with the previous example where two constructors
were coded for the Student class.
192

     Associations

Recall the class diagram from Figure 8.1 reproduced below.

                                 Figure 8.6: A simple Class Diagram.

To implement this system of classes we need to define a Subject class. Later we discuss
the implementation of the association. To keep our example simple Subject is defined to
have two fields - see below.

1   /**

2   * Subject area in which a student * may declare a major.

3   */

4   public class Subject

5        {

6   // fields

7   private String code;

8   private String name;

9   //constructor

10  public Subject(String code, String name)

11  {

12  this.code = code;

13  this.name = name;

14  }

15  // getters

16  public String getCode(){

17          return code;

18  }

19  public String getName(){

20          return name;

21  }

22  // setters

23  public void setCode(String code){

24          this.code = code;

25  }

26  public void setName(String name){

27          this.name = name;

28  }

29  // toString()

30  public String toString(){
                                           193

31     return code+" ("+name+")";

32  }

33  // equals(...)

34  public boolean equals(Subject other){

35     return this.code == other.code;

36  }

37  }

Implementing the association

When we implement an association we must consider that the association can be viewed
from either side of the association. So in this case we can say there is a student side and
a subject side. Such an association is sometimes called a one-to-many association
because for each student there is only one subject area, and for each subject area there
can be many related students.

Let us consider the student side, is majoring in, first. We have stated that a student
chooses one major and so a simple field could be used for this purpose. We add a field
named major and so the fields in Student now become:

    private  static int       lastId;
    private  int              id;
    private  String           firstName;
    private  String           lastName;
    private  char             gender;
    private  boolean          active;
    private  Subject          major;

Notice that the last field major, of type Subject, is the field that implements the
association for a student object. For each student object there is field that can be set to
the student's major subject. Following the convention of getters and setters we add the
following two methods to Student:

          // getter
          public Subject getMajor(){

                  return major;
          }
          // setter
          public void setMajor(Subject newMajor){

                  major = newMajor;
194

     }

To show how we can make use of the above field, consider the code segment below
where a student sam and a subject area math are instantiated, and then we add math as
sam's major.

public static void main(String[] args{                   sam.setMajor(math);
          Subject math = new
                  Subject("Math","Mathematics");
          Student sam = new
                  Student("Samantha","Jones",'F',true);

Now, we consider the other side of the association ...the subject side. To implement the
subject side of the association, has majors, we need to add a field to the Subject class.
Since many students could have the same major a good name for the field is majors and
a good choice for type is ArrayList<Student> as this allows for any number of
students.

We show selected lines of the Subject class listed below. In line 5 we declare an
ArrayList of Students, and in the constructor (lines 8-13) an empty ArrayList is
created. There is a getter for majors in lines 18-20 that returns majors, and a setter in
lines 24-26 where there is a parameter of type ArrayList. In addition to the getters and
setters we include one more method addMajor( ), in lines 28-30, that allows one to
add a student to the existing list of majoring students.

We show selected lines of the Subject class listed below. In line 5 we declare an ArrayList
of Students, and in the constructor (lines 8-13) an empty ArrayList<Student> is created.
There is a getter for majors that returns majors, and a setter where there is a parameter
of type ArrayList<Student>. In addition to the getters and setters we include one more
method addMajor( ) that allows one to add a student to the existing list of majoring
students.

1       public class Subject

2       {

3          // fields

4          ...

5          private ArrayList<Student> majors;

6          //constructor

7          public Subject(String code, String name)
                                                                195

8      {

9                this.code = code;

10               this.name = name;

11               majors = new ArrayList();

12     }

13     // getters

14          ...

15     public ArrayList<Student> getMajors(){

16               return majors;

17     }

18     // setters

19     ...

20     public void setMajors(ArrayList<Student> majors){

21               this.majors = majors;

22     }

23     // add a student to those majoring in this area

24     public void addMajor(Student newMajor){

25               majors.add(newMajor);

26     }

27          ...

Now reconsider the case where there is a student sam and a subject area math, and
where sam declares math as the major. There are two actions we must perform relating
to the two sides of an association. Not only do we add math as the major for sam, but we
add sam to the list of majoring students for math. Consider the following program where
lines 12 and 13 perform the transaction for declaring a major.

Listing 7.2: Sam declares a Math major

1 /**

2 * Create a student Sam and a subject area Math

3 * and then code the action of

4 * Sam declaring a major in Math

5 */

6 public class SamDeclaresMathMajor

7 {

8      public static void main(String[] args){

9           Subject math = new Subject("Math","Mathematics");

10          Student sam = new Student("Samantha","Jones",'F',true);

11          // two actions for the "declare major" transaction

12          sam.setMajor(math);

13          math.addMajor(sam);
196

14        System.out.println("Math majors = "

15                        +math.getMajors());

16     }

17 }

     Reusing code

Consider a case where we want to declare a major for several students. We can choose
to duplicate lines 12 and 13 in Listing 7.2 several times, or, we can create a method that
contains the equivalent of those, and invoke that method as many times as necessary. In
this way we can eliminate code redundancy and can make the overall program easier to
comprehend. And if the code for declaring a major has to change, the change affects the
small method declareMajor(). Consider the following example where we call
declareMajor() several times:

          Listing 7.3 Invoking a method several times.

1 /**

2 * Instead of duplicating code, use a method to

3 * perform the same action three times.

4 */

5 public class DeclareSubjectAreaForMultipleStudents

6 {

7      public static void main(String[] args){

8         Subject math = new Subject("Math","Mathematics");

9         Student jill = new Student("Jill","Lee",'F',true);

10        Student sam = new Student("Samantha","Jones",'F',true);

11        Student bob = new Student("Robert","Smith",'M',true);

12        // Each student is majoring in Math

13        declareMajors(jill, math);

14        declareMajors(sam, math);

15        declareMajors(bob, math);

16        System.out.println("Math majors = "

17                        +math.getMajors());

18     }

19     public static void declareMajors(Student s, Subject m){

20        // student s declares a major in m

21        s.setMajor(m);

22        m.addMajor(s);

23     }

24 }
                                                                                                           197
The output below shows the students who have declared their major to be Mathematics.
198

       Parameter lists and arguments

Constructors and methods can be defined with a parameter list that comprises one or
more variables, and these variables can be primitive types, classes, arrays, ArrayLists,
etc. When one method (the caller) invokes another method (the called method) control
transfers from the caller to the called method, but before this occurs the values of the
arguments are copied to corresponding parameters in the called method. It is required
that the caller's arguments match in number and type with the called method's
parameters.

When the called method completes and control returns back to the caller the opposite
does not occur - parameter values are not copied back into the arguments. The caller's
fields are not altered unless an argument is an object and the called method has modified
the object. If the called method alters the object then the caller's argument (object) is
changed.

Recall that a variable that represents an object holds a reference to (the memory address
of) the object. So when an object is passed it is the reference that is copied to the
parameter. When the called method accesses the object through the parameter it is
accessing the object and not some copy of the object.

Consider the program below and the method removeMajors() that has two parameters:
the first is n, an int which is a primitive data type, but the second one is an object - an
ArrayList named x. The method removes n elements from x decrementing n in the process.
From the output you will see the arguments before and after the call. The ArrayList is
changed, but the int variable is not changed.
                                                                   199

       Listing 7.4 Objects can be modified through a method call.

1 import java.util.ArrayList;

2 /**

3 *

4 * Arrange for 3 students to major in Math.

5 * The method removeMajors() has 2 parameters.

6 * removeMajors() alters both parameters.

7 * In the caller only the ArrayList changes,

8 * the "int" is not changed.

9 *

10 */

11 public class ObjectModifiedByCalledMethod

12 {

13     public static void main(String[] args){

14        Subject math = new Subject("Math","Mathematics");

15        Student jill = new Student("Jill","Lee",'F',true);

16        Student sam = new Student("Samantha","Jones",'F',true);

17        Student bob = new Student("Robert","Smith",'M',true);

18        // Each student is majoring in Math

19        declareMajors(jill, math);

20        declareMajors(sam, math);

21        declareMajors(bob, math);

22        // the majors

23        ArrayList<Student> majors = math.getMajors();

24        // n is the number of Math majors

25        int n = majors.size();

26        System.out.println(n+" majors: "+majors);

27        removeMajors(n, majors);

28        // n is not changed

29        // majors has been changed

30        System.out.println(n+" majors: "+majors);

31     }

32

33

34     public static void removeMajors

35        (int n, ArrayList<Student> x)

36     {

37        while (n>0){

38           n--;        // decrement n

39           x.remove(n); // remove the nth. element

40        }

41     }
200   public static void declareMajors
             (Student s, Subject m)
42
43    {
44           // s declares a major in m
45           s.setMajor(m);
46           m.addMajor(s);
47
48    }
49
50 }

The output below shows the arguments, an int and an ArrayList, before and after the call.
                                                                                                           201

7.10.1 Varargs: a variable number of arguments

A method can be defined such that the last parameter can accept multiple values.
Between the parameter type and the parameter name for the last parameter we include
an ellipsis (...). In the method the last parameter is then an array.

Recall the last program, Listing 7.4, where each student declares a Mathematics major.
That program invokes declareMajors() 3 times, once per student. In the program
listing below we have changed the method in such a way that all students who declare
the same major can be handled in a single call to the method.

In line 13 of the calling method there are three Student variables passed to
declareMajors():

          declareMajors(math, jill, sam, bob);

In lines 18-19 we have declared a parameter list as:

          public static void declareMajors(Subject m, Student ... s)

where the last parameter is defined as "Student ... s".

In lines 22-25 you can see the elements of s are accessed using an enhanced for
statement.

          for (Student student: s){
                  student.setMajor(m);
                  m.addMajor(student);

          }
202

       Listing 7.5 Multiple argument values for the last parameter.

1 /**

2 * 3 students declare Math - one call

3 */

4 public class VarargParameterForStudentObjects

5 {

6      public static void main(String[] args){

7         Subject math = new Subject("Math","Mathematics");

8         Student jill = new Student("Jill","Lee",'F',true);

9         Student sam = new Student("Samantha","Jones",'F',true);

10        Student bob = new Student("Robert","Smith",'M',true);

11        // Each student is majoring in Math

12        // A single call to declareMajors

13        declareMajors(math, jill, sam, bob);

14        System.out.println("Math majors = "

15           +math.getMajors());

16     }

17     // varargs used for last parameter

18     public static void declareMajors(

19        Subject m, Student ... s){

20        // Set each student to have a major in m.

21        // s is an array of Student

22        for (Student student: s){

23           student.setMajor(m);

24           m.addMajor(student);

25        }

26     }

27 }

     When the program is run we get the same output as before - showing three
     Mathematics majors:
                                                                203

7.10.2 Code listings: Student, Subject

                Listing 7.6 The Student class.

1 /**

2 * A student.

3 */

4 public class Student {

5      // class fields

6      private static int lastId;

7      // instance fields

8      private int id;

9      private String firstName;

10     private String lastName;

11     private char gender;

12     private boolean active;

13     private Subject major;

14     // first constructor, no arguments

15     public Student(){

16        id = nextId();

17        // default values for a student:

18        firstName = "unknown";

19        lastName = "unknown";

20        gender = '?';

21        active = false;

22     }

23     // second constructor, four arguments

24     public Student (String firstName, String lastName, char

    gender, boolean active){

25        id = nextId();

26        //

27        // when parameters and fields have the same

28        // name they are distinquished this way:

29        // a field name alone refers to the parameter

30        // a field name prefixed with "this."

31        // refers to an object's fields.

32        this.firstName = firstName;

33        this.lastName = lastName;

34        this.gender = gender;

35        this.active = active;

36     }

37

38     private int nextId(){

39        // increment lastId and return the new value

40        // to be used for the new student.
204           return ++lastId;
       }
   41
   42  public int getId(){
   43         return id;
   44
   45  }
   46
   47  public static int getLastId(){
   48         return lastId;
   49
   50  }
   51
   52  public String getFirstName(){
   53         return firstName;
   54
   55  }
   56
   57  public String getLastName(){
   58         return lastName;
   59
   60  }
   61
   62  public char getGender(){
   63         return gender;
   64
   65  }
   66
   67  public boolean isActive(){
   68         return active;
   69
   70  }
   71
   72  public Subject getMajor(){
   73         return major;
   74
   75  }
   76
   77  public void setLastId(int newLastId){
   78         lastId = newLastId;
   79
   80  }
   81
   82  // no setter for the student's id field
   83
       //  public void setId(int newId){

       //     id = newId;

       //  }

       public void setFirstName(String newFirstName){
              firstName = newFirstName;

       }
                                                         205

 84       public void setLastName(String newLastName){
 85              lastName = newLastName;
 86
 87       }
 88
 89       public void setGender(char newGender){
 90              gender = newGender;
 91
 92       }
 93
 94       public void setActive(boolean newActive){
 95              active = newActive;
 96
 97       }
 98
 99       public void setMajor(Subject newMajor){
100              major = newMajor;
101
102       }
103
104       public String toString(){
105              return id+" "+firstName+" "+lastName;
106
107       }
108 }
          public boolean equals(Student s){
                 return id == s.id;

          }

                         Listing 7.7 The Subject class.

1      import java.util.ArrayList;

2      /**

3         * Subject area in which a

4         * student may declare a major.

5         */

6      public class Subject

7      {

8             // fields

9             private String code;

10            private String name;

11            private ArrayList<Student> majors;

12            //constructor

13            public Subject(String code, String name)
206           {
                     this.code = code;
   14                this.name = name;
   15                majors = new ArrayList();
   16
   17         }
   18         // getters
   19         public String getCode(){
   20
   21                return code;
   22         }
   23
   24         public String getName(){
   25                return name;
   26
   27         }
   28
   29         public ArrayList<Student> getMajors(){
   30                return majors;
   31
   32         }
   33         // setters
   34         public void setCode(String code){
   35
   36                this.code = code;
   37         }
   38
   39         public void setName(String name){
   40                this.name = name;
   41
   42         }
   43
   44         public void setMajors(ArrayList<Student> majors){
   45                this.majors = majors;
   46
   47         }
   48         // add a student to those majoring in this area
   49         public void addMajor(Student newMajor){
   50
   51                majors.add(newMajor);
   52         }
   53         // toString()
   54         public String toString(){
   55
                     return code+" ("+name+")";
              }
              // equals(...)
              public boolean equals(Subject other){

                     return this.code == other.code;
              }
       }
                                                                                                           207

Exercises

      1. Create each of the three students shown in the object diagram of Figure 8.3 and
           the subject areas Computer Science and Mathematics. Write the code to
           implement the transactions: - Samantha declares a major in Computer Science;
           - Robert declares a major in Computer Science; - Jill declares a major in
           Mathematics.

      2. Suppose we must create a way for a student to change their major. This can be
           done by adding another method to Subject that would remove a student from
           the list of students majoring in a subject area. Write this method and then write
           the code necessary for the following transactions:

                   Samantha declares a major in Computer Science;

                   Robert declares a major in Computer Science;

                   Jill declares a major in Mathematics.

                   Robert re-declares his major to be Mathematics.

      3. Add a new method to the Student class that returns a student's full name.
      4. In Listing 7.5 there are three Student objects passed to declareMajors().

           Because the last argument in declareMajors() is an array you can pass an
           array instead of the three Student arguments. Place jill, sam, and bob in a
           Student array and call the method using two arguments: the subject and the
           Student array.
      5. Develop a Course class and then use a program to instantiate the following
           objects:
208
6. Implement the following business rule:

       · A subject offers several courses;
       · A course is offered in one subject.
Write a program that creates two subject areas and four courses as shown in the
following object diagram. Note the lines that connect a subject to a course - these link
lines show which courses are offered by which subject area.

    Then, for each subject area display the courses it off
Bibliography

 [1] http://publications.gc.ca/gazette/archives/p1/2007/2007-03-
      24/pdf/g1-14112.pdf

 [2] http://www.acm.org/press-room/news-releases/2013/fellows-2013

 [3] http://www.ieee.org/documents/vonneumannrl.pdf

 [4] Effective Java; Joshua Bloch; Addison-Wesley; Second edition; 2008;
      ISBN-13: 978-0321356680

 [5] Java in a Nutshell; Benjamin J. Evans, David Flanagan; O'Reilly; Sixth
      edition; 2015; ISBN-13: 978-1-44937082-4

 [6] The Art of Computer Programming, Volume 2; Donald Knuth; Addison-
      Wesley Professional; 3 edition; 1997; ISBN-13: 9780201896848

 [7] Clean Code: A Handbook of Agile Software Craftsmanship; Robert C.
      Martin; Prentice Hall; 2008; ISBN-13: 978-0132350884
