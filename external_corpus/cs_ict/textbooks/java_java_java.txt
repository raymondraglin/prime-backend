        Java, Java, Java

Object-Oriented Problem Solving

                 Third Edition

      R. Morelli and R. Walde

                Trinity College
                  Hartford, CT

                  June 25, 2017
This work is licensed under a
      Creative Commons Attribution 4.0 International License (CC BY 4.0).

      This book was previously published by
      Pearson Education, Inc.
Preface to the Open Source
Edition

Java, Java, Java, 3e was previously published by Pearson Education, Inc.
The first edition (2000) and the second edition (2003) were published by
Prentice-Hall. In 2010 Pearson Education, Inc. reassigned the copyright to
the authors, and we are happy now to be able to make the book available
under an open source license.

   This PDF edition of the book is available under a Creative Commons
Attribution 4.0 International License, which allows the book to be used,
modified, and shared with attribution:
(https://creativecommons.org/licenses/by/4.0/).
- Ralph Morelli and Ralph Walde
- Hartford, CT
- December 30, 2016

                                                i
ii
Preface to the Third Edition

We have designed this third edition of Java, Java, Java to be suitable for
a typical Introduction to Computer Science (CS1) course or for a slightly
more advanced Java as a Second Language course. This edition retains the
"objects first" approach to programming and problem solving that was
characteristic of the first two editions. Throughout the text we emphasize
careful coverage of Java language features, introductory programming
concepts, and object-oriented design principles.

   The third edition retains many of the features of the first two editions,
including:

     Early Introduction of Objects

     Emphasis on Object Oriented Design (OOD)

     Unified Modeling Language (UML) Diagrams

     Self-study Exercises with Answers

     Programming, Debugging, and Design Tips.

     From the Java Library Sections

     Object-Oriented Design Sections

     End-of-Chapter Exercises

     Companion Web Site, with Power Points and other Resources

The In the Laboratory sections from the first two editions have been moved
onto the book's Companion Web Site. Table 1 shows the Table of Contents
for the third edition.

What's New in the Third Edition

The third edition has the following substantive changes:

     Although the book retains its emphasis on a "running example"
       that is revisited in several chapters, the CyberPet examples have
       been replaced with a collection of games and puzzle examples. The
       CyberPet examples from earlier editions will be available on the
       Companion Web Site.

                                               iii
iv
                 Table 1: Table of Contents for the Third Edition.

Chapter     Topic
Chapter 0   Computers, Objects, and Java (revised)
Chapter 1   Java Program Design and Development
Chapter 2   Objects: Defining, Creating, and Using
Chapter 3   Methods: Communicating with Objects (revised)
Chapter 4   Input/Output: Designing the User Interface (new)
Chapter 5   Java Data and Operators
Chapter 6   Control Structures
Chapter 7   Strings and String Processing
Chapter 8   Inheritance and Polymorphism (new)
Chapter 9   Arrays and Array Processing
Chapter 10  Exceptions: When Things Go Wrong
Chapter 11  Files and Streams
Chapter 12  Recursive Problem Solving
Chapter 13  Graphical User Interfaces
Chapter 14  Threads and Concurrent Programming
Chapter 15  Sockets and Networking (expanded)
Chapter 16  Data Structures: Lists, Stacks, and

              Queues (revised and expanded)

 Chapters 0 (Computers, Objects, and Java) and 1 (Java Program De-
   sign and Development) have been substantially reorganized and
   rewritten. The new presentation is designed to reduce the pace
   with which new concepts are introduced. The treatment of object-
   oriented (OO) and UML concepts has also been simplified, and some
   of the more challenging OO topics, such as polymorphism, have
   been moved to a new Chapter 8.

 The new Java 1.5 Scanner class is introduced in Chapter 2 and is
   used to perform simple input operations.

 Chapter 4 (Input/Output: Designing the User Interface) has been
   completely written. Rather than relying primarily on applet inter-
   faces, as in the second edition, this new chapter provides indepen-
   dent introductions to both a command-line interface and a graphi-
   cal user interface (GUI). Instructors can choose the type of interface
   that best suits their teaching style. The command-line interface is
   based on the BufferedReader class and is used throughout the
   rest of the text. The GUI is designed to work with either graphi-
   cal applications or applets. Both approaches are carefully presented
   to highlight the fundamentals of user-interface design. The chapter
   concludes with an optional section that introduces file I/O using the
   new Scanner class.

 Much of the discussion of inheritance and polymorphism, which
   was previously woven through the first five chapters in the second
   edition, has been integrated into a new Chapter 8.

 An optional graphics track is woven throughout the text. Beginning
   with simple examples in Chapters 1 and 2, this track also includes
                                                                                                v

       some of the examples that were previously presented in Chapter 10
       of the second edition.

     Chapter 15, on Sockets and Networking, is expanded to cover some
       of the more advanced Java technologies that have emerged, includ-
       ing servlets and Java Server Pages.

     Chapter 16, on Data Structures, has been refocused on how to use
       data structures. It makes greater use of Java's Collection Framework,
       including the LinkedList and Stack classes and the List inter-
       face. It has been expanded to cover some advanced data structures,
       such as sets, maps, and binary search trees.

The Essentials Edition

An Essentials Edition of the third edition, which will include Chapters 0-
12, will be published as a separate title. The Essentials Edition will cover
those topics (Chapters 0-9) that are covered in almost all introductory
(CS1) courses, but it will also include topics (Exceptions, File I/O, and
Recursion) that many CS1 instructors have requested.

Why Start with Objects?

The Third Edition still takes an objects-early approach to teaching Java,
with the assumption that teaching beginners the "big picture" early gives
them more time to master the principles of object-oriented programming.
This approach seems now to have gained in popularity as more and more
instructors have begun to appreciate the advantages of the object-oriented
perspective.

   Object Orientation (OO) is a fundamental problem solving and design
concept, not just another language detail that should be relegated to the
middle or the end of the book (or course). If OO concepts are introduced
late, it is much too easy to skip over them when push comes to shove in
the course.

   The first time I taught Java in our CS1 course I followed the same ap-
proach I had been taking in teaching C and C++ -- namely, start with the
basic language features and structured programming concepts and then,
somewhere around midterm, introduce object orientation. This approach
was familiar, for it was one taken in most of the textbooks then available
in both Java and C++.

   One problem with this approach was that many students failed to get
the big picture. They could understand loops, if-else constructs, and arith-
metic expressions, but they had difficulty decomposing a programming
problem into a well-organized Java program. Also, it seemed that this
procedural approach failed to take advantage of the strengths of Java's
object orientation. Why teach an object-oriented language if you're going
to treat it like C or Pascal?

   I was reminded of a similar situation that existed when Pascal was the
predominant CS1 language. Back then the main hurdle for beginners was
procedural abstraction -- learning the basic mechanisms of procedure call
vi

and parameter passing and learning how to design programs as a collec-
tion of procedures. Oh! Pascal!, my favorite introductory text, was typical
of a "procedures early" approach. It covered procedures and parameters
in Chapter 2, right after covering the assignment and I/O constructs in
Chapter 1. It then covered program design and organization in Chap-
ter 3. It didn't get into loops, if-else, and other structured programming
concepts until Chapter 4 and beyond.

   Today, the main hurdle for beginners is the concept of object abstraction.
Beginning programmers must be able to see a program as a collection of
interacting objects and must learn how to decompose programming prob-
lems into well-designed objects. Object orientation subsumes both proce-
dural abstraction and structured programming concepts from the Pascal
days. Teaching objects-early takes a top-down approach to these three im-
portant concepts. The sooner you begin to introduce objects and classes,
the better the chances that students will master the important principles
of object orientation.

   Java is a good language for introducing object orientation. Its object
model is better organized than C++. In C++ it is easy to "work around"
or completely ignore OO features and treat the language like C. In Java
there are good opportunities for motivating the discussion of object orien-
tation. For example, it's almost impossible to discuss GUI-based Java ap-
plications without discussing inheritance and polymorphism. Thus rather
than using contrived examples of OO concepts, instructors can use some
of Java's basic features -- the class library, Swing and GUI components --
to motivate these discussions in a natural way.

Organization of the Text

The book is still organized into three main parts. Part I (Chapters 0-4) in-
troduces the basic concepts of object orientation and the basic features of
the Java language. Part II (Chapters 5-9) focuses on remaining language el-
ements, including data types, control structures, string and array process-
ing, and inheritance and polymorphism. Part III (Chapters 10-16) covers
advanced topics, including exceptions, file I/O, recursion, GUIs, threads
and concurrent programming, sockets and networking, data structures,
servlets, and Java Server Pages.

   The first two parts make up the topics that are typically covered in an
introductory CS1 course. The chapters in Part III are self-contained and
can be selectively added to the end of a CS1 course if time permits.

   The first part (Chapters 0 through 4) introduces the basic concepts of
object orientation, including objects, classes, methods, parameter passing,
information hiding, and a little taste of inheritance, and polymorphism.
The primary focus in these chapters is on introducing the basic idea that
an object-oriented program is a collection of objects that communicate and
cooperate with each other to solve problems. Java language elements are
introduced as needed to reinforce this idea. Students are given the basic
building blocks for constructing Java programs from scratch.

   Although the programs in the first few chapters have limited function-
ality in terms of control structures and data types, the priority is placed
                                                                                  vii
               Table 2: A one-semester course.

Weeks          Topics                          Chapters
1              Object Orientation, UML         Chapter 0
               Program Design and Development  Chapter 1
2-3            Objects and Class Definitions   Chapter 2
               Methods and Parameters          Chapter 3
4              Selection structure (if-else)
5              User Interfaces and I/O         Chapter 4
6-7            Data Types and Operators        Chapter 5
               Control Structures (Loops)      Chapter 6
8              Structured Programming
9              String Processing (loops)       Chapter 7
10             Inheritance and Polymorphism    Chapter 8
11             Array Processing                Chapter 9
12             Recursion                       Chapter 12
13             Advanced Topic (Exceptions)     Chapter 10
               Advanced Topic (GUIs)           Chapter 11
               Advanced Topic (Threads)        Chapter 15

on how objects are constructed and how they interact with each other
through method calls and parameter passing.

   The second part (Chapters 5 through 9) focuses on the remaining lan-
guage elements, including data types and operators (Chapter 5), control
structures (Chapter 6), strings (Chapter 7), and arrays (Chapter 9). It
also provides thorough coverage of inheritance and polymorphism, the
primary mechanisms of object orientation: (Chapter 8).

   Part three (Chapters 10 through 16) covers a variety of advanced topics
(Table 1). Topics from these chapters can be used selectively depending
on instructor and student interest.

   Throughout the book, key concepts are introduced through simple,
easy-to-grasp examples. Many of the concepts are used to create a set
of games, which are used as a running example throughout the text. Our
pedagogical approach focuses on design. Rather than starting of with lan-
guage details, programming examples are carefully developed with an
emphasis on the principles of object-oriented design.

   Table2 provides an example syllabus from our one-semester CS1
course. Our semester is 13 weeks (plus one reading week during which
classes do not meet). We pick and choose from among the advanced topics
during the last two weeks of the course, depending on the interests and
skill levels of the students.

Ralph Morelli
June 25, 2017
viii
Contents

0 Computers, Objects, and Java                1

0.1 Welcome . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

0.2 What Is a Computer? . . . . . . . . . . . . . . . . . . . . . . . 2

0.3 Networks, the Internet and the World Wide Web . . . . . . . 4

0.4 Why Study Programming? . . . . . . . . . . . . . . . . . . . . 6

0.5 Programming Languages . . . . . . . . . . . . . . . . . . . . 7

0.6 Why Java? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

0.7 What Is Object-Oriented Programming? . . . . . . . . . . . . 11

1 Java Program Design and Development         23

1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

1.2 Designing Good Programs . . . . . . . . . . . . . . . . . . . . 24

1.3 Designing a Riddle Program . . . . . . . . . . . . . . . . . . . 26

1.4 Java Language Elements . . . . . . . . . . . . . . . . . . . . . 34

1.5 Editing, Compiling, and Running a Java Program . . . . . . 48

1.6 From the Java Library: System and

PrintStream . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

2 Objects: Using, Creating, and Defining      61

2.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

2.2 Using String Objects . . . . . . . . . . . . . . . . . . . . . . 62

2.3 Drawing Shapes with a Graphics Object (Optional) . . . . 66

2.4 Class Definition . . . . . . . . . . . . . . . . . . . . . . . . . . 69

2.5 CASE STUDY: Simulating a Two-Person Game . . . . . . . . 76

2.6 From the Java Library: java.util.Scanner. . . . . . . . . 90

3 Methods: Communicating with Objects         101

3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102

3.2 Passing Information to an Object . . . . . . . . . . . . . . . . 102

3.3 Constructor Methods . . . . . . . . . . . . . . . . . . . . . . . 109

3.4 Retrieving Information from an Object . . . . . . . . . . . . . 114

3.5 Passing a Value and Passing a Reference . . . . . . . . . . . . 118

3.6 Flow of Control: Control Structures . . . . . . . . . . . . . . . 121

3.7 Testing an Improved OneRowNim . . . . . . . . . . . . . . . . 130

3.8 From the Java Library java.lang.Object . . . . . . . . . 135

3.9 Object-Oriented Design: Inheritance and Polymorphism . . 136

3.10 Drawing Lines and Defining Graphical Methods (Optional) 138

4 Input/Output: Designing the User Interface  149

4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

                                ix
x                                            CONTENTS

   4.2 The User Interface . . . . . . . . . . . . . . . . . . . . . . . . . 150
   4.3 A Command-Line Interface . . . . . . . . . . . . . . . . . . . 151
   4.4 A Graphical User Interface (GUI) . . . . . . . . . . . . . . . . 160
   4.5 Case Study: The One Row Nim Game . . . . . . . . . . . . . 176
   4.6 From the Java Library: java.io.File

         and File Input (Optional) . . . . . . . . . . . . . . . . . . . . . 183

5 Java Data and Operators                    197

   5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198

   5.2 Boolean Data and Operators . . . . . . . . . . . . . . . . . . . 199

   5.3 Numeric Data and Operators . . . . . . . . . . . . . . . . . . 205

   5.4 From the Java Library java.lang.Math . . . . . . . . . . . 216

   5.5 Numeric Processing Examples . . . . . . . . . . . . . . . . . 217

   5.6 From the Java Library

   java.text.NumberFormat . . . . . . . . . . . . . . . . . . 229

   5.7 Character Data and Operators . . . . . . . . . . . . . . . . . . 231

   5.8 Example: Character Conversions . . . . . . . . . . . . . . . . 235

   5.9 Problem Solving = Representation + Action . . . . . . . . . . 237

6 Control Structures                         241

   6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242

   6.2 Flow of Control: Repetition Structures . . . . . . . . . . . . . 242

   6.3 Counting Loops . . . . . . . . . . . . . . . . . . . . . . . . . . 243

   6.4 Example: Car Loan . . . . . . . . . . . . . . . . . . . . . . . . 252

   6.5 Graphics Example: Drawing a Checkerboard . . . . . . . . . 255

   6.6 Conditional Loops . . . . . . . . . . . . . . . . . . . . . . . . 259

   6.7 Example: Computing Averages . . . . . . . . . . . . . . . . . 266

   6.8 Example: Data Validation . . . . . . . . . . . . . . . . . . . . 270

   6.9 Principles of Loop Design . . . . . . . . . . . . . . . . . . . . 270

   6.10 The switch Multiway Selection Structure . . . . . . . . . . . 273

   6.11 OBJECT-ORIENTED DESIGN:

   Structured Programming . . . . . . . . . . . . . . . . . . . . . 277

7 Strings and String Processing              297

   7.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298

   7.2 String Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298

   7.3 Finding Things Within a String . . . . . . . . . . . . . . . . . 304

   7.4 Example: Keyword Search . . . . . . . . . . . . . . . . . . . . 306

   7.5 From the Java Library: java.lang.StringBuffer . . . . . . . . . 308

   7.6 Retrieving Parts of Strings . . . . . . . . . . . . . . . . . . . . 310

   7.7 Example: Processing Names and Passwords . . . . . . . . . 312

   7.8 Processing Each Character in a String . . . . . . . . . . . . 313

   7.9 Comparing Strings . . . . . . . . . . . . . . . . . . . . . . . . 317

   7.10 From the Java Library:

   java.util.StringTokenizer . . . . . . . . . . . . . . . . . . . . . 323

   7.11 Handling Text in a Graphics Context

   (Optional) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324

8 Inheritance and Polymorphism               337

   8.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338

   8.2 Java's Inheritance Mechanism . . . . . . . . . . . . . . . . . . 338
CONTENTS                                       xi

8.3 Abstract Classes, Interfaces,
      and Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . 347

8.4 Example: A Toggle Button . . . . . . . . . . . . . . . . . . . . 353
8.5 Example: The Cipher Class Hierarchy . . . . . . . . . . . . . 357
8.6 Case Study: A Two Player Game Hierarchy . . . . . . . . . . 363
8.7 Principles Of Object-Oriented Design . . . . . . . . . . . . . 384

9 Arrays and Array Processing                  393

9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394

9.2 One-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . 394

9.3 Simple Array Examples . . . . . . . . . . . . . . . . . . . . . 401

9.4 Example: Counting Frequencies of Letters . . . . . . . . . . . 403

9.5 Array Algorithms: Sorting . . . . . . . . . . . . . . . . . . . . 406

9.6 Array Algorithms: Searching . . . . . . . . . . . . . . . . . . 414

9.7 Two-Dimensional Arrays . . . . . . . . . . . . . . . . . . . . . 417

9.8 Multidimensional Arrays (Optional) . . . . . . . . . . . . . . 426

9.9 OBJECT-ORIENTED DESIGN:

Polymorphic Sorting (Optional) . . . . . . . . . . . . . . . . . 428

9.10 From the Java Library: java.util.Vector . . . . . . . . . . . . . 430

9.11 Case Study: An N-Player Computer Game . . . . . . . . . . 431

9.12 A GUI-Based Game (Optional Graphics) . . . . . . . . . . . . 437

10 Exceptions: When Things Go Wrong            459

10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460

10.2 Handling Exceptional Conditions . . . . . . . . . . . . . . . . 460

10.3 Java's Exception Hierarchy . . . . . . . . . . . . . . . . . . . 462

10.4 Handling Exceptions Within a Program . . . . . . . . . . . . 466

10.5 Error Handling and Robust

Program Design . . . . . . . . . . . . . . . . . . . . . . . . . . 477

10.6 Creating and Throwing Your Own

Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487

10.7 From the Java Library: JOptionPane . . . . . . . . . . . . . 489

11 Files and Streams: Input/Output Techniques  499

11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 500

11.2 Streams and Files . . . . . . . . . . . . . . . . . . . . . . . . . 500

11.3 CASE STUDY: Reading and Writing Text Files . . . . . . . . 505

11.4 The File Class . . . . . . . . . . . . . . . . . . . . . . . . . . 518

11.5 Example: Reading and Writing Binary Files . . . . . . . . . . 521

11.6 Object Serialization: Reading and Writing Objects . . . . . . 530

11.7 From the Java Library

javax.swing.JFileChooser . . . . . . . . . . . . . . . . 535

11.8 Using File Data in Programs . . . . . . . . . . . . . . . . . . . 536

12 Recursive Problem Solving                   545

12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546

12.2 Recursive Definition . . . . . . . . . . . . . . . . . . . . . . . 549

12.3 Recursive String Methods . . . . . . . . . . . . . . . . . . . . 551

12.4 Recursive Array Processing . . . . . . . . . . . . . . . . . . . 563

12.5 Example: Drawing (Recursive) Fractals . . . . . . . . . . . . 569
xii                                             CONTENTS

     12.6 OBJECT-ORIENTED DESIGN:
           Tail Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . 573

     12.7 OBJECT-ORIENTED DESIGN:
           Recursion or Iteration? . . . . . . . . . . . . . . . . . . . . . . 574

     12.8 From the Java Library:
           javax.swing.JComboBox . . . . . . . . . . . . . . . . . . . . . 577

13 Graphical User Interfaces                                       591

     13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592

     13.2 Java GUIs: From AWT to Swing . . . . . . . . . . . . . . . . . 592

     13.3 The Swing Component Set . . . . . . . . . . . . . . . . . . . . 595

     13.4 OBJECT-ORIENTED DESIGN:

     Model-View-Controller Architecture . . . . . . . . . . . . . . 596

     13.5 The Java Event Model . . . . . . . . . . . . . . . . . . . . . . 598

     13.6 CASE STUDY: Designing a Basic GUI . . . . . . . . . . . . . 602

     13.7 Containers and Layout Managers . . . . . . . . . . . . . . . . 614

     13.8 Checkboxes, Radio Buttons, and Borders . . . . . . . . . . . 620

     13.9 Menus and Scroll Panes . . . . . . . . . . . . . . . . . . . . . 629

14 Threads and Concurrent Programming                              643

     14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644

     14.2 What Is a Thread? . . . . . . . . . . . . . . . . . . . . . . . . . 644

     14.3 From the Java Library: java.lang.Thread . . . . . . . . . 648

     14.4 Thread States and Life Cycle . . . . . . . . . . . . . . . . . . . 654

     14.5 Using Threads to Improve

     Interface Responsiveness . . . . . . . . . . . . . . . . 656

     14.6 CASE STUDY: Cooperating Threads . . . . . . . . . . . . . . 664

     14.7 CASE STUDY: The Game of Pong . . . . . . . . . . . . . . . . 679

15 Sockets and Networking                                          693

     15.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 694

     15.2 An Overview of Networks . . . . . . . . . . . . . . . . . . . . 694

     15.3 Using Multimedia Network Resources for a Graphical Pro-

     gram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 700

     15.4 From the Java Library: java.net.URL . . . . . . . . . . . . 701

     15.5 The Slide Show Program . . . . . . . . . . . . . . . . . . . . . 704

     15.6 Adding Text Network Resources for an

     Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . 708

     15.7 Client/Server Communication via Sockets . . . . . . . . . . 719

     15.8 CASE STUDY: Generic Client/Server Classes . . . . . . . . . 724

     15.9 Playing One Row Nim Over the Network . . . . . . . . . . . 732

     15.10Java Network Security Restrictions . . . . . . . . . . . . . . . 741

     15.11Java Servlets and Java Server Pages . . . . . . . . . . . . . . . 742

16 Data Structures: Lists, Stacks, and Queues                      757

     16.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 758

     16.2 The Linked List Data Structure . . . . . . . . . . . . . . . . . 758

     16.3 OBJECT-ORIENTED DESIGN:

     The List Abstract Data Type (ADT) . . . . . . . . . . . . . . . 770

     16.4 The Stack ADT . . . . . . . . . . . . . . . . . . . . . . . . . . . 776

     16.5 The Queue ADT . . . . . . . . . . . . . . . . . . . . . . . . . . 778
CONTENTS                                xiii

16.6 From the Java Library: The Java Collections Framework
      and Generic Types . . . . . . . . . . . . . . . . . . . . . . . . 782

16.7 Using the Set and Map Interfaces . . . . . . . . . . . . . . . 785
16.8 The Binary Search Tree Data Structure . . . . . . . . . . . . . 789

A Coding Conventions                    801

B The Java Development Kit              809

C The ASCII and Unicode Character Sets  819

D Java Keywords                         821

E Operator Precedence Hierarchy         823

F Java Inner Classes                    825

G Java Autoboxing and Enumeration       831

H Java and UML Resources                837
xiv  CONTENTS
Chapter 0

Computers, Objects, and
Java

OBJECTIVES

After studying this chapter, you will
 Understand basic computer terminology that will be used throughout the book.
 Become familiar with the notion of programming.
 Understand why Java is a good introductory programming language.
 Become familiar with Java objects and classes.
 Know some of the principles of the object-oriented programming approach.

OUTLINE

0.1 Welcome
0.2 What Is a Computer?

         Special Topic: Processors Then and Now
0.3 Networks, the Internet and the World Wide Web
0.4 Why Study Programming?
0.5 Programming Languages
0.6 Why Java?
0.7 What Is Object-Oriented Programming?

          Chapter Summary
          Exercises

                                                1
                                   2                 CHAPTER 0  Computers, Objects, and Java

                                   0.1 Welcome

                                   Welcome to Java, Java, Java, a book that introduces you to object-oriented
                                   programming using the Java language. When considering the purpose
                                   of this text, three important questions might come to mind: Why study
                                   programming? Why study Java? What is object-oriented programming?
                                   This chapter will address these questions. First, we provide a brief in-
                                   troduction to computers and the Internet and World Wide Web (WWW).
                                   Then, we address why someone would study programming and we ex-
                                   amine types of programming languages. We introduce the Java program-
                                   ming language and conclude the chapter by exploring object-oriented pro-
                                   gramming principles and how Java is an object-oriented programming
                                   language.

                                   0.2 What Is a Computer?

                                   A computer is a machine that performs calculations and processes infor-
                                   mation. A computer works under the control of a computer program, a
                                   set of instructions that tell a computer what to do. Hardware refers to the
                                   electronic and mechanical components of a computer. Software refers to
                                   the programs that control the hardware.

                                      A general-purpose computer of the sort that we will be programming can
                                   store many different programs in its memory. That is what gives it the
                                   ability to perform a wide variety of functions, from word processing to
                                   browsing the Internet. This is in contrast to a special-purpose computer, such
                                   as the one that resides in your microwave oven or the one that controls
                                   your digital watch or calculator. These types of computers contain control
                                   programs that are fixed and cannot be changed.

                                      A computer's hardware is organized into several main subsystems or
                                   components (Fig. 1).

Figure 1: A diagram of the main         Central      Main Memory
functional components in a com-       Processing
puter system. The arrows indicate
the flow of information between          Unit
various components.                     (CPU)

                                      Input Devices  Output Devices     Secondary
                                      Keyboard       Printer              Storage
                                      Mouse          Monitor
                                      Optical        Audio           Disk Drive
                                      Scanner        Speakers        CD-ROM
                                                                     DVD

                                    Output devices provide a means by which information held in the com-
                                     puter can be displayed in some understandable or usable form. Com-
                                     mon output devices include printers, monitors, and audio speakers.
SECTION 0.2  What Is a Computer?      3

 Input devices bring data and information into the computer. Some of       Fetch-execute cycle
  the more common input devices are the keyboard, mouse, microphone,
  and scanner.

 Primary memory or main memory of a computer is used to store both
  data and programs. This type of memory, which is often called RAM,
  short for Random Access Memory, is built entirely out of electronic
  components--integrated circuit chips--which makes it extremely fast.
  A computer's main memory is volatile, which means that any informa-
  tion stored in it is lost when the computer's power is turned off. In a
  sense, main memory acts as the computer's scratch pad, storing both
  programs and data temporarily while a program is running.

 Secondary storage devices are used for long-term or permanent stor-
  age of relatively large amounts of information. These devices include
  hard drives or magnetic disks, compact disks (CDs), digital video disks
  (DVDs), and magnetic tapes. All of these devices are non-volatile, mean-
  ing that they retain information when the computer's power is turned
  off. Compared to a computer's primary memory, these devices are
  relatively slow.

 The central processing unit (CPU) is the computer's main engine. The
  CPU is the computer's microprocessor, such as the Intel Pentium pro-
  cessor, which serves as the foundation for most Windows PCs, or the
  Power-PC processor, which serves as the foundation for Macintosh
  computers. The CPU is designed to perform the fetch-execute cycle,
  whereby it repeatedly gets the next machine instruction from memory
  and executes it. Under the direction of computer programs (software),
  the CPU issues signals that control the other components that make up
  the computer system. One portion of the CPU, known as the arithmetic-
  logic unit (ALU), performs all calculations, such as addition and sub-
  traction, and all logical comparisons, such as when one piece of data is
  compared to another to determine if they are equal.

There are two main types of software:

 Application software refers to programs designed to provide a particular
   task or service, such as word processors, computer games, spreadsheet
   programs, and Web browsers.

 System software includes programs that perform the basic operations
   that make a computer usable. For example, an important piece of
   system software is the operating system, which contains programs that
   manage the data stored on the computer's disks.

   An operating system assists application software in performing tasks
that are considered primitive or low-level, such as managing the com-
puter's memory and its input and output devices.

   Another important thing that the operating system does is to serve as
an interface between the user and the hardware. The operating system
determines how the user will interact with the system, or conversely, how
the system will look and feel to the user. For example, in command-line
systems, such as Unix and DOS (short for Disk Operating System), a pro-
gram is run by typing its name on the command line. By contrast, in
                         4  CHAPTER 0  Computers, Objects, and Java

                         graphically based systems, such as Windows and Macintosh, a program
                         is run by clicking on its icon with the mouse. Thus, this "point-and-click"
                         interface has a totally different "look and feel" but does the same thing.

                         Special Topic: Processors Then and Now

                         To give you some idea of how rapidly computer hardware technology
                         has advanced, let's compare the first digital processor with one of today's
                         models.

                            The ENIAC (which stood for Electronic Numerical Integrator and Cal-
                         culator) was developed in 1946 at the University of Pennsylvania primar-
                         ily for calculating ballistic trajectories for the U.S. Army. ENIAC occupied
                         more than 640 square feet of floor space and weighed nearly 30 tons. In-
                         stead of the integrated circuits or chip technology used in today's comput-
                         ers, ENIAC's digital technology was based on over 17,000 vacuum tubes.
                         ENIAC, which could perform around 300 multiplications per second, ran
                         more than 500 times faster than other computing machines of that day and
                         age. To program the ENIAC, you would have to manipulate hundreds of
                         cables and switches. It took two or three days for a team of several pro-
                         grammers, most of whom were young women, to set up a single program
                         that would then run for a few seconds.

                            One of today's most advanced and powerful processors for desktop
                         computers is Intel's Pentium IV processor. This chip contains 42 million
                         transistors and runs at speeds over 3 GHz (3 gigahertz or 3 billion cycles
                         per second). The Pentium processor is small enough to fit in a space the
                         size of your pinky finger's fingernail. Despite its size, it executes millions
                         of instructions per second, thereby enabling it to support a huge range of
                         multimedia applications, including three-dimensional graphics, stream-
                         ing audio and video, and speech recognition applications. To write pro-
                         grams for the Pentium, you can choose from a wide range of high-level
                         programming languages, including the Java language.

Client/server computing  0.3 Networks, the Internet and the World Wide

                               Web

                         Most personal computers contain software that enables them to be con-
                         nected to various-sized networks of computers. Networks allow many in-
                         dividual users to share costly computer resources, such as a high-speed
                         printer or a large disk drive or application server that is used to store and
                         distribute both data and programs to the computers on the network. Net-
                         works can range in size from local area networks (LANs), which connect
                         computers and peripherals over a relatively small area, such as within a
                         lab or a building, through wide area networks (WANs), which can span large
                         geographic areas, such as cities and nations.

                            Application servers are just one example of client/server computing, a
                         computing approach made possible by networks. According to this ap-
                         proach, certain computers on the network are set up as servers, which pro-
                         vide certain well-defined services to client computers. For example, one
                         computer in a network may be set up as the email server, with the responsi-
SECTION 0.3  Networks, the Internet and the World Wide Web 5

bility of sending, receiving, and storing mail for all users on the network.
To access their email on the email server, individual users employ client
application software that resides on their desktop computers, such as Out-
look Express or Eudora or Pine. Similarly, another server may be set up as
a Web server, with the responsibility of storing and serving up Web pages
for all the users on the network. Users can run Web browsers, another type
of client software, to access Web pages on the server. Java is particularly
well suited for these types of networked or distributed applications, where
part of the application software resides on a server and part resides on the
client computer.

   The Internet (with a capital I) is a network of networks whose geo-
graphical area covers the entire globe. The World Wide Web (WWW) is
another example of distributed, client/server computing. The WWW is
not a separate physical network. Rather it is a subset of the Internet that
uses the HyperText Transfer Protocol (HTTP). A protocol is a set of rules
and conventions that govern how communication takes place between
two computers. HTTP is a multimedia protocol, which means that it
supports the transmission of text, graphics, sound, and other forms of
information. Certain computers within a network run special software
that enables them to play the role of HTTP (or Web) servers. They store
Web documents and are capable of handling requests for documents
from client browser applications. The servers and clients can be located
anywhere on the Internet.

   The documents stored on Web servers are encoded in a special text-
based language known as HyperText Markup Language, or HTML. Web
browsers, such as Netscape's Navigator and Microsoft's Internet Explorer,
are designed to interpret documents coded in this language. The language
itself is very simple. Its basic elements are known as tags, which consist
of certain keywords or other text contained within angle brackets, < and
>. For example, if you wanted to italicize text on a Web page, you would
enclose it between the < I > and < /I > tags. Thus, the following HTML
code

                                                                              

$<I>$ I t a l i c f o n t $ </I>$ can be used f o r $<I>$emphasis$</I>$ .     


would be displayed by the Web browser as

Italic font can be used for emphasis.

When you use a Web browser to surf the Internet, you repeatedly instruct
your browser to go to a certain location and retrieve a page that is encoded
in HTML. For example, if you typed the following URL (Uniform Resource
Locator)

                                                                              

h t t p : //www. p r e n h a l l . com/ m o r e l l i /index . html           


into your browser, the browser would send a message to the Web server
www located in the prenhall.com domain--the prenhall portion of
this address specifies Prentice Hall and the com portion specifies the com-
mercial domain of the Internet--requesting that the document named
index.html in the morelli directory be retrieved and sent back to your
                                                 6     yDiysplyay      CHAPTER 0  Computers, Objects, and Java
Figure 2: WWW: The client's
browser requests a page from a                      yyyyyyyy                      ument
Web server. When the HTML doc-                      y yyyyyy              d a doc
ument is returned, it is interpreted                 yy                Sen
and displayed by the browser.
                                                             Text
                                                                                          HTML      HTTP
                                                             Browser                     document  software
                                                             software
                                                                       Internet

                                                                            uest a document  Server
                                                                       Req

                                                    Client

computer (Fig. 2). The beauty of the Web is that it is possible to embed
text, sound, video, and graphics within an HTML document, making it
possible to download a wide range of multimedia resources through this
(relatively) simple mechanism.

   The Web has begun to change business, entertainment, commerce, and
education. The fact that it is possible to download computer games and
other application software from the Web is changing the way software and
other digital products are purchased and distributed. Similarly, as noted
earlier, many businesses have begun to organize their information systems
into intranets--private networks that implement the HTTP protocol. Cur-
rently, one of the biggest areas of development on the Web is commerce.
As consumers become more comfortable that credit-card information can
be securely transmitted over the Web (as it can over a telephone), the Web
will explode as a marketing medium as powerful, perhaps, as television
is today. Because Java has been designed to support secure, distributed,
networked applications, it is ideally suited to be used as the language for
these types of applications.

0.4 Why Study Programming?

A computer program is a set of instructions that directs the computer's
behavior. Computer programming is the art and science of designing and
writing programs. Years ago it was widely believed that entrance into
the computer age would require practically everyone to learn how to pro-
gram. But this did not prove to be true. Today's computers come with so
much easy-to-use software that knowing how to use a computer no longer
requires programming skills.

   Another reason to study programming might be to enter into a career
as a computer scientist. However, although programming is one of its
primary tools, computer science is a broad and varied discipline, which
ranges from engineering subjects, such as processor design, to mathemat-
ical subjects, such as performance analysis. There are many computer sci-
entists who do little or no programming as part of their everyday work.
If you plan to major or minor in computer science, you will certainly
learn to program, but good careers in the computing field are available
to programmers and nonprogrammers alike.
SECTION 0.5  Programming Languages  7

   One of the best reasons to study programming is because it is a cre-
ative and enjoyable problem-solving activity. This book will teach you to
develop well-designed solutions to a range of interesting problems. One
of the best things about programming is that you can actually see and
experience your solutions as running programs. As many students have
indicated, there's really nothing like the kick you get from seeing your
program solving a problem you've been struggling with. Designing and
building well-written programs provides a powerful sense of accomplish-
ment and satisfaction. What's more, Java is a language that makes pro-
gramming even more fun, because once they're finished, many Java pro-
grams can be posted on the World Wide Web (WWW) for all the world to
see!

0.5 Programming Languages

Most computer programs today are written in a high-level language, such        
as Java, C, C++, or FORTRAN. A programming language is considered              
high level if its statements resemble English-language statements. For
example, all of the languages just mentioned have some form of an "if"          Platform independence
statement, which says, "if some condition holds, then take some action."

   Computer scientists have invented hundreds of high-level program-
ming languages, although relatively few of these have been put to prac-
tical use. Some of the widely used languages have special features that
make them suitable for one type of programming application or another.
COBOL (COmmon Business-Oriented Language), for example, is still
widely used in commercial applications. FORTRAN (FORmula TRANsla-
tor) is still preferred by some engineers and scientists. C and C++ are still
the primary languages used by operating system programmers.

   In addition to having features that make them suitable for certain types
of applications, high-level languages use symbols and notation that make
them easily readable by humans. For example, arithmetic operations in
Java make use of familiar operators such as "+" and "-" and "/", so that
arithmetic expressions look more or less the way they do in algebra. So,
to take the average of two numbers, you might use the expression

 

    (a + b) / 2
 

The problem is that computers cannot directly understand such expres-
sions. In order for a computer to run a program, the program must first
be translated into the computer's machine language, which is the language
understood by its CPU or microprocessor. Each type of microprocessor
has its own particular machine language. That's why when you buy soft-
ware it runs either on a Macintosh, which uses the Power-PC chip, or on a
Windows machine, which uses the Pentium chip, but not on both. When a
program can run on just one type of chip, it is known as platform dependent.

   In general, machine languages are based on the binary code, a two-
valued system that is well suited for electronic devices. In a binary repre-
sentation scheme, everything is represented as a sequence of 1's and 0's,
which corresponds closely to the computer's electronic "on" and "off"
states. For example, in binary code, the number 13 would be repre-
8                   CHAPTER 0  Computers, Objects, and Java

sented as 1101. Similarly, a particular address in the computer's memory
might be represented as 01100011, and an instruction in the computer's
instruction set might be represented as 001100.

   The instructions that make up a computer's machine language are very
simple and basic. For example, a typical machine language might in-
clude instructions for ADD, SUBTRACT, DIVIDE, and MULTIPLY, but it
wouldn't contain an instruction for AVERAGE. In most cases, a single in-
struction, called an opcode, carries out a single machine operation on one
or more pieces of data, called its operands. Therefore, the process of av-
eraging two numbers would have to be broken down into two or more
steps. A machine language instruction itself might have something sim-
ilar to the following format, in which an opcode is followed by several
operands, which refer to the locations in the computer's primary memory
where the data are stored. The following instruction says ADD the num-
ber in LOCATION1 to the number in LOCATION2 and store the result in
LOCATION3:

     Opcode Operand 1  Operand 2  Operand 3

     011110 110110     111100     111101

     (ADD) (LOCATION 1) (LOCATION 2) (LOCATION 3)

Given the primitive nature of machine language, an expression like
(a + b)/2 would have to be translated into a sequence of several machine
language instructions that, in binary code, might look as follows:

                                                                               

     011110110110111100111101

     000101000100010001001101

     001000010001010101111011                                                  

   In the early days of computing, before high-level languages were de-
veloped, computers had to be programmed directly in their machine
languages, an extremely tedious and error-prone process. Imagine how
difficult it would be to detect an error that consisted of putting a 0 in the
preceding program where a 1 should occur!

   Fortunately, we no longer have to worry about machine languages, be-
cause special programs can be used to translate a high-level or source
code program into machine language code or object code, which is the
only code that can be executed or run by the computer. In general, a pro-
gram that translates source code to object code is known as a translator
(Fig. 3). Thus, with suitable translation software for Java or C++ we can
write programs as if the computer could understand Java or C++ directly.

   Source code translators come in two varieties. An interpreter trans-
lates a single line of source code directly into machine language and ex-
ecutes the code before going on to the next line of source code. A com-
piler translates the entire source code program into executable object code,
which means that the object code can then be run directly without further
translation.

   There are advantages and disadvantages to both approaches. Inter-
preted programs generally run less efficiently than compiled programs,
SECTION 0.6  Why Java?                        Machine   9
                                              language        Figure 3: Translator software
                      High-level                              translates high-level source code to
                       language               000110101       machine language object code.
                                              101000110
(a+b)/ 2                          Translator  101000110
                                   software
                                                Object
Source                                           code
 code

because they must translate and execute each line of the program before
proceeding to the next line. If a line of code is repeated, an interpreter
would have to translate the line each time it is encountered. By contrast,
once compiled, an object program is just executed without any need for
further translation. It is also much easier to refine compiled code to make
it run more efficiently. But interpreters are generally quicker and easier
to develop and provide somewhat better error messages when things go
wrong. Some languages that you may have heard of, such as BASIC, LISP,
and Perl, are mostly used in interpreted form, although compilers are also
available for these languages. Programs written in COBOL, FORTRAN,
C, C++, and Pascal are compiled. As we will see in the next section,
Java programs use both compilation and interpretation in their translation
process.

0.6 Why Java?

Originally named "Oak" after a tree outside the office of its developer,      Object-oriented Languages
James Goslin, Java is a relatively young programming language. It was
initially designed by Sun Microsystems in 1991 as a language for em-
bedding programs into electronic consumer devices, such as microwave
ovens and home security systems. However, the tremendous popularity
of the Internet and the World Wide Web (WWW) led Sun to recast Java as
a language for embedding programs into Web-based applications. As you
recall, the Internet is a global computer network, and the WWW is that
portion of the network that provides multimedia access to a vast range of
information. Java has become one of the most important languages for
Web and Internet applications.

   Java has also generated significant interest in the business community,
where it is has proved to have tremendous commercial potential. In addi-
tion to being a useful tool for helping businesses to promote their products
and services over the Internet, Java is also a good language for distribut-
ing software and providing services to employees and clients on private
corporate networks or intranets.

   Because of its original intended role as a language for programming mi-
croprocessors embedded in consumer appliances, Java has been designed
with a number of interesting features:

 Java is object oriented. Object-oriented languages divide programs
   into separate modules, called objects, that encapsulate the program's
   data and operations. Thus, object-oriented programming (OOP) and
   object-oriented design (OOD) refer to a particular way of organizing pro-
                       10  CHAPTER 0  Computers, Objects, and Java

Platform independence    grams, one which is rapidly emerging as the preferred approach for
                         building complex software systems. Unlike the C++ language, in which
                         object-oriented features were grafted onto the C language, Java was
                         designed from scratch as an object-oriented language.
                        Java is robust, meaning that errors in Java programs don't cause system
                         crashes as often as errors in other programming languages. Certain
                         features of the language enable many potential errors to be detected
                         before a program is run.
                        Java is platform independent. A platform, in this context, is just a particu-
                         lar kind of computer system, such as a Macintosh or Windows system.
                         Java's trademark is "Write once, run anywhere." This means that a Java
                         program can be run without changes on different kinds of computers.
                         This is not true for other high-level programming languages. This porta-
                         bility - the ability to run on virtually any platform - is one reason that
                         Java is well suited for WWW applications.
                        Java is a distributed language, which means that its programs can be
                         designed to run on computer networks. In addition to the language it-
                         self, Java comes with an extensive collection of code libraries--software
                         that has been designed to be used directly for particular types of
                         applications--that make it particularly easy to build software systems
                         for the Internet and the WWW. This is one of the reasons why Java is so
                         well suited for supporting applications on corporate networks.
                        Java is a secure language. Designed to be used on networks, Java con-
                         tains features that protect against untrusted code--code that might in-
                         troduce a virus or corrupt your system in some way. For example,
                         once they are downloaded into your browser, Web-based Java pro-
                         grams are prevented from reading and writing information from and
                         to your desktop computer.

                       Despite this list of attractive features, perhaps the best reason for choosing
                       Java as an introductory programming language is its potential for bring-
                       ing fun and excitement into learning how to program. There are few other
                       languages in which a beginning programmer can write a computer game
                       or a graphically based application that can be distributed on a Web page to
                       just about any computer in the world. The simplicity of Java's design and
                       its easily accessible libraries bring such accomplishments within reach of
                       the most novice programmers.

                          For example, we will work on projects throughout the text that involve
                       games and puzzles. We start out in Chapter 2 by designing very simple
                       games that involve storing and retrieving data. As we learn more sophisti-
                       cated programming techniques, we gradually build more complexity into
                       the games and puzzles. For example, we learn how to create interactive,
                       two-person games in Chapter 4. In Chapter 8, we develop some games
                       and puzzles that are played on virtual game boards. Finally, in Chapter 14
                       we learn how to introduce games with multiple players on different com-
                       puters. To get a look at where we are headed you might want to visit the
                       authors' companion Web site:

                                                                                                        

                           h t t p : //www. c s . t r i n c o l l . edu /~ram/ j j j /                  
                       
SECTION 0.7  What Is Object-Oriented Programming?  11

0.7 What Is Object-Oriented Programming?

Java is an object-oriented (OO) language, and this book takes an object-       Figure 4: A model of a kitchen.
oriented approach to programming. So before beginning our discussion
of Java, it is important that we introduce some of the underlying con-
cepts involved in object-oriented programming. We need to talk about
what an object is, how objects are grouped into classes, how classes are
related to each other, and how objects use messages to interact with and
communicate with each other.

0.7.1 Basic Object-Oriented Programming Metaphor:
         Interacting Objects

A Java program, and any object-oriented program, is a collection of inter-
acting objects that models a collection of real-world

   objects. Think of the model that a kitchen designer might use to layout
your new kitchen (Fig. 4). It will contain objects that represent the various
kitchen appliances and cabinets. Each object in the model is a simplified
version of the corresponding real object. For example, a rectangle might
be used to represent the refrigerator.

   A kitchen model is mostly static. It doesn't change. Once put into place,
its various objects just stand there in a certain relation to each other. By
contrast, a computer program is dynamic. It changes. It does things and
performs certain actions. The objects in a computer program communi-
cate with each other and they change over time. In this respect, the objects
that make up our computer programs are very anthropomorphic, a big word
that means "like people." If we are eating together and I want you to pass
me the salt, I say, "Please pass me the salt," and you invariably comply.
Similarly, when you (Student X) put your ATM card into an ATM machine,
the ATM object asks the bank's database object "Give me Student X's bank
account object" and the database invariably complies. If you tell the ATM
you want to withdraw $100 dollars it tells your bank account object to
deduct $100 from your current balance. And so it goes. Both you and
your bank account are changed objects as a result of the transaction.

0.7.2 What is an Object?

So what is an object? Just as in the real world, an object is any thing
whatsoever. An object can be a physical thing, such as a Car, or a mental
thing, such as an Idea. It can be a natural thing, such as an Animal, or
an artificial, human-made thing, such as a ATM. A program that manages
an ATM would involve BankAccounts and Customer objects. A chess
program would involve a Board object and ChessPiece objects.

   Throughout this text, we will use the notation shown in Figure 5 to
depict objects and to illustrate object-oriented concepts. The notation is
known as the Unified Modeling Language, or UML for short, and it is a
standard in the object-oriented programming community. As the diagram
shows, an object is represented by a rectangle whose label consists of the
object's (optional) id and its type. An object's id is the name by which
it is referred to in the computer program. In this case we show a ATM
object, who's id is not given, and a ChessPiece object, named pawn1.
An object's label is always underlined.
                                                 12  CHAPTER 0  Computers, Objects, and Java
Figure 5: In UML, objects are rep-
resented by rectangles that are la-
beled with a two-part label of the
form id:Type. The object's label is
always underlined.

                                    0.7.3 Attributes and Values

                                    Just as with real objects, the objects in our programs have certain char-
                                    acteristic attributes. For example, an ATM object would have a current
                                    amount of cash that it could dispense. A ChessPiece object might
                                    have a pair of row and column attributes that specify its position on the
                                    chess board. Notice that an object's attributes are themselves objects. The
                                    ATM's cash attribute and the chess piece's row and column attributes
                                    are Numbers.

                                       Figure 6 shows two ATM objects and their respective attributes. As you
                                    can see, an object's attributes are listed in a second partition of the UML
                                    diagram. Notice that each attribute has a value. So the lobby:ATM has a
                                    $8650.0 in cash, while the drivethru:ATM has only $150.0 in cash.

Figure 6: A second partition of an
object diagram is used to display
the object's attributes and their
values.

                                       We sometimes refer to the collection of an object's attributes and values
                                    as its state. For example, the current state of the lobby:ATM is $8650.0 in
                                    cash. Of course, this is a gross simplification of an ATM's state, which
                                    would also include many other attributes. But, hopefully, you see the
                                    point.

                                    0.7.4 Actions and Messages

                                    In addition to their attributes, objects also have characteristic actions or
                                    behaviors. As we have already said, objects in programs are dynamic.
                                    They do things or have things done to them. In fact, programming in
                                    Java is largely a matter of getting objects to perform certain actions for
                                    us. For example, in a chess program the ChessPieces have the ability to
                                    moveTo() a new position on the chess board. Similarly, when a customer
                                    pushes the "Current Balance" button on an ATM machine, this is telling
                                    the ATM to report() the customer's current bank balance. (Note how
                                    we use parentheses to distinguish actions from objects and attributes.)

                                       The actions that are associated with an object can be used to send mes-
                                    sages to the objects and to retrieve information from objects. A message
                                    is the passing of information or data from one object to another. Figure 7
                                    illustrates how this works. In UML, messages are represented by arrows.
SECTION 0.7  What Is Object-Oriented Programming?  13
                                                          Figure 7: Messages in UML are
                                                          represented by labeled arrows. In
                                                          this example, we are telling a
                                                          pawn to move from its current po-
                                                          sition to row 3 column 4.

In this example, we are telling pawn1:ChessPiece to moveTo(3,4).
The numbers 3 and 4 in this case are arguments that tell the pawn what
square to move to. (A chess board has 8 rows and 8 columns and each
square is identified by its row and column coordinates.) In general, an
argument is a data value that specializes the content of a message in some
way. In this example we are telling the pawn to move forward by 1 row.
If we wanted the pawn to move forward by 2 rows, we would send the
message moveTo(4,4).

   The diagram in Figure 8 depicts a sequence of messages representing
an idealized ATM transaction. First, an ATM customer asks the ATM ma-
chine to report his current balance. The ATM machine in turn asks the
customer's bank account to report the customer's balance. The ATM re-
ceives the value $528.52 from the bank account and passes it along to the
customer. In this case, the message does not involve an argument. But it
does involve a result. A result is information or data that is returned to
the object that sent the message.

                                                                                Figure 8: This UML diagram
                                                                                illustrates an ATM transaction
                                                                                in which a customer asks the
                                                                                ATM machine for his current bal-
                                                                                ance. The ATM gets this informa-
                                                                                tion from an object representing
                                                                                the customer's bank account and
                                                                                passes it to the customer.

   Obviously, in order to respond to a message, an object has to know
how to perform the action that is requested. The pawn has to know how
to move to a designated square. The ATM has to know how to find out
the customer's current balance. Indeed, an object can only respond to
messages that are associated with its characteristic actions and behaviors.
You can't tell an ATM to move forward 2 squares. And you can't ask a
chess piece to tell you your current bank balance.

   Responding to a message or performing an action sometimes causes
a change in an object's state. For example, after performing moveTo(3,
4), the pawn will be on a different square. Its position will have changed.
On the other hand, some messages (or actions) leave the object's state un-
changed. Reporting the customer's bank account balance doesn't change
the balance.

0.7.5 What is a Class?

A class is a template for an object. A class encapsulates the attributes and
actions that characterize a certain type of object. In an object-oriented pro-
gram, classes serve as blueprints or templates for the objects that the pro-
                                                 14  CHAPTER 0  Computers, Objects, and Java
Figure 9: A UML diagram of the
Rectangle class.

gram uses. We say that an object is an instance of a class. A good analogy
here is to think of a class as a cookie cutter and its objects, or instances, as
individual cookies. Just as we use the cookie cutter to stamp out cookies
of a certain type, in an object-oriented program, we use a definition of a
class to create objects of a certain type.

   Writing an object-oriented program is largely a matter of designing
classes and writing definitions for those classes in Java. Designing a
class is a matter of specifying all of the attributes and behaviors that are
characteristic of that type of object.

   For example, suppose we are writing a drawing program. One type
of object we would need for our program is a rectangle. A Rectangle
object has two fundamental attributes, a length and a width. Given
these attributes, we can define characteristic rectangle actions, such as the
ability to calculate its area and the ability to draw itself. Identifying an
object's attributes and actions is the kind of design activity that goes into
developing an object-oriented program.

   Figure 9 shows a UML diagram of our Rectangle class. Like the sym-
bol for an object, a UML class symbol has up to three partitions. Unlike the
UML object symbol, the label for a UML class gives just the class's name
and it is not underlined. The second partition lists the class's attributes
and the third partition lists the classes actions. Our rectangle has four
attributes. The first two, x and y, determine a rectangles position on a
two-dimensional graph. The second two, length and width, determine
a rectangle's dimensions. Note that the attributes have no values. This is
because the class represents a general type of rectangle. It specifies what
all rectangles have in common, without representing any particular rect-
angle. Like a cookie cutter for a cookie, a class gives the general shape of
an object. The content is not included.

0.7.6 Variables and Methods

Up to this point we have been using the terms attribute and action to de-
scribe an object's features. We will continue to use this terminology when
talking in general about objects or when talking about an object or class
represented by a UML diagram.

   However, when talking about a programming language, the more com-
mon way to describe an object's features are to talk about its variables
and methods. A variable, which corresponds to an attribute, is a named
memory location that can store a certain type of value. You can think of a
variable as a special container that can only hold objects of a certain type.
For example, as Figure 9 shows, Rectangle's length and width are
SECTION 0.7  What Is Object-Oriented Programming?  15

variables that can store a certain type of numeric value known as an int.
An int value is a whole number, such as 76 or -5.

   A method, which corresponds to an action or a behavior, is a named
chunk of code that can be called upon or invoked to perform a certain
pre-defined set of actions. For example, in our Rectangle object, the
calculateArea() method can be called upon to calculate the rectan-
gle's area. It would do this, of course, by multiplying the rectangle's
length by its width. Similarly, the draw() method can be invoked to draw
a picture of the rectangle. It would take the actions necessary to draw a
rectangle on the console.

0.7.7 Instance versus Class Variables and Methods

Variables and methods can be associated either with objects or their
classes. An instance variable (or instance method) is a variable (or
method) that belongs to an object. By contrast, a class variable (or class
method) is a variable (or method) that is associated with the class itself.
An example will help make this distinction clear.

   An instance variable will have different values for different instances.
For example, individual Rectangles will have different values for their
length, width, x, and y variables. So these are examples of instance
variables. The calculateArea() method is an example of an instance
method because it uses the instance's current length and width values
in its calculation. Similarly, the draw() method is an instance method,
because it uses the object's length and width to draw the object's shape.

   An example of a class variable would be a variable in the Rectangle
class that is used to keep track of how many individual Rectangles
have been created. (Our drawing program might need this information
to help manage its memory resources.) Suppose we name this variable
nRectangles and suppose we add 1 to it each time a new Rectangle
instance is created.

   An example of a method that is associated with the class is a special
method known as a constructor. This is a method used to create an object.
It is used to create an instance of a class. Calling a constructor to create an
object is like pressing the cookie cutter into the cookie dough: the result is
an individual cookie (object).

   Figure 10 illustrates these concepts. Note that class variables are un-
derlined in the UML diagram. We have modified the Rectangle class
to include its constructor method, which is named Rectangle(). Note
that it takes four arguments, representing the values that we want to give
as the rectangle's x, y, length and width respectively. Note also how the
Rectangle class's nRectangles variable has a value of 2, representing
that two Rectangle instances have been created. These are shown as
members of the Rectangle class.

   It won't be obvious to you at this point, but nRectangles is a value
that has to be associated with the Rectangle class, not with its instances.
To see this let's imagine what happens when a new Rectangle instance
is created. Figure 11 illustrates the process. When the Rectangle()
constructor is invoked, its arguments (100, 50, 25, 10) are used by the
Rectangle class to create a Rectangle object located at x=100, y=50 and
with a length of 25 and width of 10. The constructor method also increases
                                                 16  CHAPTER 0  Computers, Objects, and Java
Figure 10: The Rectangle class
and two of its instances. Note that
the class variable, nRectangles,
is underlined to distinguish it
from length and width, the in-
stance variables.

                                                 the value of nRectangles by 1 as a way of keeping count of how many
                                                 objects it has created.

Figure 11: Constructing a
Rectangle instance.

Superclass and subclass  0.7.8 Class Hierarchy and Inheritance

                         How are classes related to each other? In Java, and in any other object-
                         oriented language, classes are organized in a class hierarchy. A class hier-
                         archy is like an upside-down tree. At the very top of the hierarchy is the
                         most general class. In Java, the most general class is the Object class. The
                         classes below Object in the hierarchy are known as its subclasses. Since
                         all of the objects we use in our programs belong to some class or other,
                         this is like saying that all objects are Objects.

                            Figure 12 illustrates the concept of a class hierarchy using the classes
                         that we have described in this section. Notice that the Object class oc-
                         curs at the top of the hierarchy. It is the most general class. It has fea-
                         tures that are common to all Java objects. As you move down the hierar-
                         chy, the classes become more and more specialized. A Rectangle is an
                         Object but it contains attributes - length and width - that are common
                         to all rectangles but not to other objects in the hierarchy. For example, an
                         ATM object does not necessarily have a length and a width. Notice that we
                         have added a Square class to the hierarchy. A Square is a special type
                         of Rectangle, namely one who's length equals its width.

                            To introduce some important terminology associated with this kind of
                         hierarchy, we say that the Rectangle class is a subclass of the Object
                   SECTION 0.7  What Is Object-Oriented Programming?  17

hierarchy of Java

                   class. The Square class is a subclass of both Rectangle and Object.             Class inheritance
                   Classes that occur above a given class in the hierarchy are said to be its
                   superclasses. Thus Rectangle class is superclass of the Square class.
                   The Object class is also a superclass of Square. In general, we say that
                   a subclass extends a superclass, meaning that it adds additional elements
                   (attributes and/or methods) to those contained in its superclasses. We saw
                   this in the case of the Square class. It adds the feature that its length and
                   width are always equal.

                      Another important concept associated with a class hierarchy is the no-
                   tion of class inheritance, whereby a subclass inherits elements (attributes
                   and/or methods) from its superclasses. To take an example from the nat-
                   ural world, think of the sort of inheritance that occurs between a horse
                   and a mammal. A horse is a mammal. So horses inherit the characteristic
                   of being warm blooded by virtue of also being mammals. (This is dif-
                   ferent from the kind of individual inheritance whereby you inherit your
                   mother's blue eyes and your father's black hair.)

                      To illustrate how inheritance works, lets go back to our chess program.
                   There are several different types of ChessPieces. There are Pawns, and
                   Knights, and Queens and Kings. Figure 13 illustrates the chess piece
                   hierarchy. A pair of attributes that all chess pieces have in common is
                   their row and column position on the chess board. Because all chess
                   pieces have these attributes in common, they are located at the top of the
                   ChessPiece hierarchy and inherited by all ChessPiece subclasses. Of
                   course, the row and column attributes are given different values in each
                   ChessPiece object.

                      One of the actions that all chess pieces have in common is that they can
                   moveTo() a given square on the chess board. But different types of chess
                   pieces have different ways of moving. For example, a Bishop can only
                   move along diagonals on the chess board, whereas a Rook can only move
                   along a row or column on the chess board. So, clearly, we can't describe
                   a moveTo() method that will work for all ChessPieces. This is why
                   we put the moveTo() method in all of the ChessPiece subclasses. The
                   ChessPiece class also has a moveTo() method, but note that its name is
                   italicized. This indicates that it cannot be completely defined at that level.

                      Finally, note that in chess, the king has certain special attributes and
                   actions. Thus only the king can be put in check. This means that the king is
                   under attack and in danger of being captured, thereby ending the game.
                   Similarly, only the king has the ability to castle. This is special move that
                                                 18  CHAPTER 0  Computers, Objects, and Java
Figure 13: The ChessPiece hier-
archy.

a king can make together with one of its rooks under certain conditions.
Thus, the reason we show the inCheck attribute and castle() action in
the King class is because these are characteristics that particular to Kings.

   In this way, a class hierarchy represents a specialization of classes as you
move from top to bottom. The most general class, ChessPiece, is at the
top of the hierarchy. Its attributes and methods are passed on to (inher-
ited by) its subclasses. However, in addition to the attributes and methods
they inherit from their superclasses, the subclasses define their own spe-
cial attributes and methods. Each of the subclasses, Pawn, Bishop, and
so on, represents some kind of specialization of the superclass. In this ex-
ample, each of the subclasses have their own distinctive ways of moving.
And the King subclass has unique attributes and actions (inCheck and
castle().

0.7.9 Principles of Object-Oriented Design

As we have discussed, an object-oriented program is composed of many
objects communicating with each other. The process of designing an
object-oriented program to solve some problem or other involves several
important principles:

 Divide-and-Conquer Principle. Generally, the first step in designing
   a program is to divide the overall problem into a number of objects
   that will interact with each other to solve the problem. Thus, an object-
   oriented program employs a division of labor much as we do in organiz-
   ing many of our real-world tasks. This divide-and-conquer approach is
   an important problem-solving strategy.

 Encapsulation Principle. Once the objects are identified, the next step
   involves deciding, for each object, what attributes it has and what ac-
   tions it will take. The goal here is to encapsulate within each object
SECTION 0.7  What Is Object-Oriented Programming?  19

   the expertise needed to carry out its role in the program. Each object
   is a self-contained module with a clear responsibility and the tools (at-
   tributes and actions) necessary to carry out its role. Just as a dentist
   encapsulates the expertise needed to diagnose and treat a tooth ache, a
   well-designed object contains the information and methods needed to
   perform its role.
 Interface Principle. In order for objects to work cooperatively and effi-
   ciently, we have to clarify exactly how they should interact, or interface,
   with one another. An object's interface should be designed to limit the
   way the object can be used by other objects. Think of how the different
   interfaces presented by a digital and analog watch determine how the
   watches are used. In a digital watch, time is displayed in discrete units,
   and buttons are used to set the time in hours, minutes and seconds. In
   an analog watch, the time is displayed by hands on a clock face, and
   time is set, less precisely, by turning a small wheel.
 Information Hiding Principle. In order to enable objects to work to-
   gether cooperatively, certain details of their individual design and per-
   formance should be hidden from other objects. To use the watch anal-
   ogy again, in order to use a watch we needn't know how its time keep-
   ing mechanism works. That level of detail is hidden from us. Hiding
   such implementation details protects the watch's mechanism, while not
   limiting its usefulness.
 Generality Principle. To make objects as generally useful as possible,
   we design them not for a particular task but rather for a particular kind
   of task. This principle underlies the use of software libraries. As we will
   see, Java comes with an extensive library of classes that specialize in
   performing certain kinds of input and output operations. For example,
   rather than having to write our own method to print a message on the
   console, we can use a library object to handle our printing tasks.
 Extensibility Principle. One of the strengths of the object-oriented ap-
   proach is the ability to extend an object's behavior to handle new tasks.
   This also has its analogue in the everyday world. If a company needs
   sales agents to specialize in hardware orders, it would be more eco-
   nomical to extend the skills of its current sales agents instead of train-
   ing a novice from scratch. In the same way, in the object-oriented ap-
   proach, an object whose role is to input data might be specialized to
   input numeric data.
 Abstraction Principle. Abstraction is the ability to focus on the impor-
   tant features of an object when trying to work with large amounts of
   information. For example, if we are trying to design a floor plan for a
   kitchen, we can focus on the shapes and relative sizes of the appliances
   and ignore attributes such as color, style, and manufacturer. The ob-
   jects we design in our Java programs will be abstractions in this sense
   because they ignore many of the attributes that characterize the real
   objects and focus only on those attributes that are essential for solving
   a particular problem.

These, then, are the principles that will guide our discussion as we learn
how to design and write object-oriented Java programs.
                 20                 CHAPTER 0  Computers, Objects, and Java

CHAPTER SUMMARY  Technical Terms

                 action (behavior)  constructor          object oriented
                 argument           high-level language  result
                 attribute          instance             source code
                 class              instance method      subclass
                 class inheritance  instance variable    superclass
                 class hierarchy    interpreter          Unified Modeling
                 class method       method
                 class variable     message                 Language (UML)
                 compiler           object               variable
                 computer program   object code

                 Summary of Important Points

                  A computer system generally consists of input/output devices, pri-
                    mary and secondary memory, and a central processing unit. A com-
                    puter can only run programs in its own machine language, which is
                    based on the binary code. Special programs known as compilers and in-
                    terpreters translate source code programs written in a high-level language,
                    such as Java, into machine language object code programs.

                  Application software refers to programs designed to provide a particu-
                    lar task or service; systems software assists the user in using application
                    software.

                  The client/server model is a form of distributed computing in which part
                    of the software for a task is stored on a server and part on client comput-
                    ers.

                  HyperText Markup Language (HTML) is the language used to encode
                    WWW documents.

                  A Java program is a set of interacting objects. This is the basic
                    metaphor of object-oriented programming.

                  An object in a Java program encapsulates the program's attributes (or
                    variables) and actions (or methods). A variable is a named memory lo-
                    cation where data of appropriate type can be stored. A method is a
                    named section of code that can be called (or invoked) when needed.

                  An object's methods are used to pass messages to it.
                  A class is an abstract template that defines the characteristics and be-

                    haviors of all objects of a certain type.
                  An object is an instance of a class. An object has instance methods and in-

                    stance variables. A class method (or class variable) is a method (or variable)
                    that is associated with the class itself, not with its instances.
                  A constructor is a special method that is used to construct objects.
                  Java classes are organized into a class hierarchy, with the Object class
                    at the top of the hierarchy. For a given class, classes that occur below it
                    in the hierarchy are called its subclasses, while classes that occur above
                    it are called its superclasses.
                  Classes inherit attributes and methods from their superclasses. This is
                    known as class inheritance.
                  The main principles of the object-oriented programming approach are
                    as follows:
                      Divide and Conquer: Successful problem solving involves breaking

                        a complex problem into objects.
CHAPTER 0  Exercises                                                        21

 Encapsulation and Modularity: Each object should be assigned a
  clear role.

 Public Interface: Each object should present a clear public interface
  that determines how other objects will use it.

 Information Hiding: Each object should shield its users from unnec-
  essary details of how it performs its role.

 Generality: Objects should be designed to be as general as possible.
 Extensibility: Objects should be designed so that their functionality

  can be extended to carry out more specialized tasks.
 Abstraction is the ability to group a large quantity of information into

  a single chunk so it can be managed as a single entity.

EXERCISE 0.1 Fill in the blanks in each of the following statements.                   EXERCISES

a. Dividing a problem or a task into parts is an example of the

principle.

b. Designing a class so that it shields certain parts of an object from other objects

is an example of the                 principle.

c. Java programs that can run without change on a wide variety of computers is

an example of                     .

d. The fact that social security numbers are divided into three parts is an example

of the                principle.

e. To say that a program is robust means that              .

f. An                 is a separate module that encapsulates a Java program's

attributes and actions.

EXERCISE 0.2 Explain the difference between each of the following pairs of
concepts.

a. hardware and software
b. systems and application software
c. compiler and interpreter
d. machine language and high-level language
e. general-purpose and special-purpose computer
f. primary and secondary memory
g. the CPU and the ALU
h. the Internet and the WWW
i. a client and a server
j. HTTP and HTML
k. source and object code

EXERCISE 0.3 Fill in the blanks in each of the following statements.

a. A           is a set of instructions that directs a computer's behavior.

b. A disk drive would be an example of a                   device.

c. A mouse is an example of an                    device.

d. A monitor is an example of an                  device.

e. The computer's                    functions like a scratch pad.

f. Java is an example of a                programming language.

g. The Internet is a network of                .
22                             CHAPTER 0  Computers, Objects, and Java

h. The protocol used by the World Wide Web is the  protocol.

i. Web documents are written in  code.

j. A  is a networked computer that is used to store data for other

    computers on the network.

EXERCISE 0.4 Identify the component of computer hardware that is responsi-
ble for the following functions.

a. executing the fetch-execute cycle
b. arithmetic operations
c. executing instructions
d. storing programs while they are executing
e. storing programs and data when the computer is off

EXERCISE 0.5 Explain why a typical piece of software, such as a word proces-
sor, cannot run on both a Macintosh and a Windows machine.

EXERCISE 0.6 What advantages do you see in platform independence? What
are the disadvantages?

EXERCISE 0.7 In what sense is a person's name an abstraction? In what sense
is any word of the English language an abstraction?

EXERCISE 0.8 Analyze the process of writing a research paper in terms of the
divide-and-conquer and encapsulation principles.

EXERCISE 0.9 Analyze your car by using object-oriented design principles. In
other words, pick one of your car's systems, such as the braking system, and ana-
lyze it in terms of the divide-and-conquer, encapsulation, information-hiding, and
interface principles.

EXERCISE 0.10 Make an object oriented analysis of the interaction between, a
student, librarian, and a library database when a student checks a book out of a
college library.
Chapter 1

Java Program Design and
Development

OBJECTIVES

After studying this chapter, you will
 Know the basic steps involved in program development.
 Understand some of the basic elements of the Java language.
 Know how to use simple output operations in a Java program.
 Be able to distinguish between different types of errors in a

   program.
 Understand how a Java program is translated into machine language.
 Understand the difference between a Java console application and a Java

   Swing application.
 Know how to edit, compile, and run Java programs.

OUTLINE

1.1 Introduction
1.2 Designing Good Programs
1.3 Designing a Riddle Program

         Special Topic: Grace Hopper and the First Computer Bug
1.4 Java Language Elements
1.5 Editing, Compiling, and Running a Java Program
1.6 From the Java Library: System and PrintStream
1.7 From the Java Library: System and PrintStream

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                               23
24  CHAPTER 1  Java Program Design and Development

1.1 Introduction

This chapter introduces some of the basic concepts and techniques in-
volved in Java program design and development. We begin by identi-
fying the main steps in designing an object-oriented program. The steps
are illustrated by designing a program that "asks" and "answers" riddles.
As an example of a riddle, consider the question "What is black and white
and read all over?" The answer, of course, is a newspaper. Following
the design phase, we then focus on the steps involved in coding a Java
program, including the process of editing, compiling, and running a pro-
gram. Because Java programs can be text based applications or window
based graphical applications, we describe how the coding process differs
for these two varieties.

   Next we begin to familiarize ourselves with Java's extensive class li-
brary by studying its PrintStream and System classes. These classes
contain objects and methods that enable us to print output from a pro-
gram. By the end of the chapter you will be able to design and write a
Java application that "sings" your favorite song.

1.2 Designing Good Programs

Programming is not simply a question of typing Java code. Rather, it in-
volves a considerable amount of planning and careful designing. Badly
designed programs rarely work correctly. Even though it is tempting for
novice programmers to start entering code almost immediately, one of the
first rules of programming is

 JAVA PROGRAMMING TIP The sooner you begin to type code,
 the longer the program will take to finish, because careful design of
 the program must precede coding. This is particularly true of
 object-oriented programs.

In other words, the more thought and care you put into designing a pro-
gram, the more likely you are to end up with one that works correctly. The
following subsections provide a brief overview of the program develop-
ment process.

1.2.1 The Software Engineering Life Cycle

Software engineering is the process of designing and writing software.
The software life cycle refers to the different phases involved in the design
and development of a computer program. Our presentation of examples
in the book will focus on four phases of the overall life cycle. In the spec-
ification phase we provide a statement of the problem and a detailed de-
scription of what the program will do. In the design phase we describe
the details of the various classes, methods, and data that will be used in
the program. The implementation phase refers to the actual coding of the
program into Java. In the testing phase we test the program's performance
to make sure it is correct, recoding it or redesigning it as necessary.

   Figure 1.1 gives a more detailed overview of the program development
process, focusing most of the attention on the design phase of the software
SECTION 1.2  Designing Good Programs                                      25

life cycle. It shows that designing an object-oriented program is a matter     Divide and conquer
of asking the right questions about the classes, data, and methods that
make up the program.                                                           Figure 1.1: An overview of the
                                                                               program development process.
   Overall, the program development process can be viewed as one that
repeatedly applies the divide-and-conquer principle. That is, most pro-
gramming problems can be repeatedly divided until you have a collection
of relatively easy-to-solve subproblems, each of which can be handled by
an object. In this way the program is divided into a collection of interact-
ing objects. For each object we design a class. During class design, each
object is divided further into its variables and methods.

        Problem Specification                Program Development
                                                       Process
What exactly is the problem?
How will the program be used?
How will the program behave?

      Problem Decomposition                  The problem is divided into
                                             objects. For each object we
What objects will be used and how            design a class.
  will they interact with each other?

                    Class Design             The object's role
                                             decomposes into
What role or roles will the object perform?  tasks. Each task
What variables (attributes) will it need?    can be assigned to
What methods (behaviors) will it use?        a method.
What interface will it present?
What information will it hide?

              Data Design                           Method Design

What types of instance variables       What task will the method perform?
  are needed?                          What information will it need?
                                       What algorithm will it use?
Should they be public or private?      What result will it produce?

            Algorithm Design                 Method design involves
                                             designing an algorithm.
What information is needed?
What control structures are needed?

           Coding into Java                  Errors may require
        Stepwise refinement                  recoding or
        Fixing syntax errors                 redesigning.

   Testing, Debugging, Revising
Designing test data and test cases
Fixing semantic errors

   When should we stop subdividing? How much of a task should be
assigned to a single object or a single method? The answers to these and
similar questions are not easy. Good answers require the kind of judg-
ment that comes through experience, and frequently there is more than
one good way to design a solution. Here again, as we learn more about
                    26  CHAPTER 1  Java Program Design and Development

                    object-oriented programming, we'll learn more about how to make these
                    design decisions.

                    1.3 Designing a Riddle Program

                    The first step in the program-development process is making sure you un-
                    derstand the problem (Fig. 1.1). Thus, we begin by developing a detailed
                    specification, which should address three basic questions:

                     What exactly is the problem to be solved?
                     How will the program be used?
                     How should the program behave?

                    In the real world, the problem specification is often arrived at through
                    an extensive discussion between the customer and the developer. In an
                    introductory programming course, the specification is usually assigned
                    by the instructor.

                       To help make these ideas a little clearer, let's design an object-oriented
                    solution to a simple problem.

                     Problem Specification. Design a class that will represent a riddle with
                     a given question and answer. The definition of this class should make
                     it possible to store different riddles and to retrieve a riddle's question
                     and answer independently.

Divide and conquer  1.3.1 Problem Decomposition

                    Most problems are too big and too complex to be tackled all at once. So
                    the next step in the design process is to divide the problem into parts that
                    make the solution more manageable. In the object-oriented approach, a
                    problem is divided into objects, where each object will handle one specific
                    aspect of the program's overall job. In effect, each object will become an
                    expert or specialist in some aspect of the program's overall behavior.

                       Note that there is some ambiguity here about how far we should go
                    in decomposing a given program. This ambiguity is part of the design
                    process. How much we should decompose the program before its parts
                    become "simple to solve" depends on the problem we're trying to solve
                    and on the problem solver.

                       One useful design guideline for trying to decide what objects are
                    needed is the following:

                     JAVA EFFECTIVE DESIGN Looking for Nouns. Choosing a
                     program's objects is often a matter of looking for nouns in the problem
                     specification.

                    Again, there's some ambiguity involved in this guideline. For example,
                    the key noun in our current problem is riddle, so our solution will involve
                    an object that serves as a model for a riddle. The main task of this Java
                    object will be simply to represent a riddle. Two other nouns in the spec-
                    ification are question and answer. Fortunately, Java has built-in String
SECTION 1.3  Designing a Riddle Program  27

objects that represent strings of characters such as words or sentences. We      Figure 1.2: Design specification
can use two String objects for the riddle's question and answer. Thus,           for the Riddle class.
for this simple problem, we need only design one new type of object--a
riddle--whose primary role will be to represent a riddle's question and
answer.

   Don't worry too much if our design decisions seem somewhat myste-
rious at this stage. A good understanding of object-oriented design can
come only after much design experience, but this is a good place to start.

1.3.2 Object Design

Once we have divided a problem into a set of cooperating objects, de-
signing a Java program is primarily a matter of designing and creating
the objects themselves. In our example, this means we must now design
the features of our riddle object. For each object, we must answer the
following basic design questions:

 What role will the object perform in the program?
 What data or information will it need?
 What actions will it take?
 What interface will it present to other objects?
 What information will it hide from other objects?

   For our riddle object, the answers to these questions are shown in Fig-
ure 1.2. Note that although we talk about "designing an object," we are
really talking about designing the object's class. A class defines the col-
lection of objects that belong to it. The class can be considered the ob-
ject's type. This is the same as for real-world objects. Thus, Seabiscuit is a
horse--that is, Seabiscuit is an object of type horse. Similarly, an individ-
ual riddle, such as the newspaper riddle, is a riddle. That is, it is an object
of type Riddle.

   The following discussion shows how we arrived at the decisions for the
design specifications for the Riddle class, illustrated in Figure 1.2.

   Class Name: Riddle
   Role: To store and retrieve a question and answer
   Attributes (Information)

       question: A variable to store a riddle's question (private)
       answer: A variable to store a riddle's answer (private)
   Behaviors
       Riddle(): A method to set a riddle's question and answer
       getQuestion(): A method to return a riddle's question
       getAnswer(): A method to return a riddle's answer

   The role of the Riddle object is to model an ordinary riddle. Because         What is the object's role?
a riddle is defined in terms of its question and answer, our Riddle ob-
ject will need some way to store these two pieces of information. As we
learned in Chapter 0, an instance variable is a named memory location that
belongs to an object. The fact that the memory location is named, makes
it easy to retrieve the data stored there by invoking the variable's name.
For example, to print a riddle's question we would say something like
"print question," and whatever is stored in question would be retrieved
and printed.
                                     28  CHAPTER 1  Java Program Design and Development

What information will the object        In general, instance variables are used to store the information that an
need?                                object needs to perform its role. They correspond to what we have been
                                     calling the object's attributes. Deciding on these variables provides the
                                     answer to the question, "What information does the object need?"

                                        Next we decide what actions a Riddle object will take. A useful design
                                     guideline for actions of objects is the following:

                                     JAVA EFFECTIVE DESIGN Looking for Verbs. Choosing the
                                     behavior of an object is often a matter of looking for verbs in the
                                     problem specification.

What actions will the object take?   For this problem, the key verbs are set and retrieve. As specified in Fig-
                                     ure 1.2, each Riddle object should provide some means of setting the
What interface will it present, and  values of its question and answer variables and a means of retrieving each
what information will it hide?       value separately.

                                        Each of the actions we have identified will be encapsulated in a Java
                                     method. As you recall from Chapter 0, a method is a named section of
                                     code that can be invoked, or called upon, to perform a particular action.
                                     In the object-oriented approach, calling a method (method invocation) is
                                     the means by which interaction occurs among objects. Calling a method
                                     is like sending a message between objects. For example, when we want to
                                     get a riddle's answer, we would invoke the getAnswer() method. This
                                     is like sending the message "Give me your answer." One special method,
                                     known as a constructor, is invoked when an object is first created. We will
                                     use the Riddle() constructor to give specific values to riddle's question
                                     and answer variables.

                                        In designing an object, we must decide which methods should be made
                                     available to other objects. This determines what interface the object should
                                     present and what information it should hide from other objects. In gen-
                                     eral, those methods that will be used to communicate with an object are
                                     designated as part of the object's interface. Except for its interface, all
                                     other information maintained by each riddle should be kept "hidden"
                                     from other objects. For example, it is not necessary for other objects to
                                     know where a riddle object stores its question and answer. The fact that
                                     they are stored in variables named question and answer, rather than
                                     variables named ques and ans, is irrelevant to other objects.

                                     JAVA EFFECTIVE DESIGN Object Interface. An object's interface
                                     should consist of just those methods needed to communicate with or
                                     to use the object.

                                     JAVA EFFECTIVE DESIGN Information Hiding. An object should
                                     hide most of the details of its implementation.
SECTION 1.3  Designing a Riddle Program  29

   Taken together, these various design decisions lead to the specification    Figure 1.3: A UML class diagram
shown in Figure 1.3. As our discussion has illustrated, we arrived at the      representing the Riddle class.
decisions by asking and answering the right questions. In most classes the     What type of data will be used?
attributes (variables) are private. This is represented by a minus sign (-).   How will each method carry out its
In this example, the operations (methods) are public, which is represented     task?
by the plus sign (+). The figure shows that the Riddle class has two
hidden (or private) variables for storing data and three visible (or public)   Algorithm design
methods that represent the operations that it can perform.

1.3.3 Data, Methods, and Algorithms

Among the details that must be worked out in designing a riddle object is
deciding what type of data, methods, and algorithms we need. There are
two basic questions involved:

 What type of data will be used to represent the information needed by
   the riddle?

 How will each method carry out its task?

Like other programming languages, Java supports a wide range of differ-
ent types of data, some simple and some complex. Obviously a riddle's
question and answer should be represented by text. As we noted earlier,
Java has a String type, which is designed to store text, which can be
considered a string of characters.

   In designing a method, you have to decide what the method will do. In
order to carry out its task, a method will need certain information, which
it may store in variables. Plus, it will have to carry out a sequence of
individual actions to perform the task. This is called its algorithm, which
is a step-by-step description of the solution to a problem. And, finally, you
must decide what result the method will produce. Thus, as in designing
objects, it is important to ask the right questions:

 What specific task will the method perform?
 What information will it need to perform its task?
 What algorithm will the method use?
 What result will the method produce?

Methods can be thought of as using an algorithm to complete a required
action. The algorithm required for the Riddle() constructor is very sim-
ple but also typical of constructors for many classes. It takes two strings
and assigns the first to the question instance variable and then assigns
the second to the answer instance variable. The algorithms for the other
two methods for the Riddle class are even simpler. They are referred to
as get methods that merely return or produce the value that is currently
stored in an instance variable.

   Not all methods are so simple to design, and not all algorithms are so
simple. Even when programming a simple arithmetic problem, the steps
involved in the algorithm will not always be as obvious as they are when
doing the calculation by hand. For example, suppose the problem were
to calculate the sum of a list of numbers. If we were telling our classmate
how to do this problem, we might just say, "add up all the numbers and
report their total." But this description is far too vague to be used in a
program. By contrast, here's an algorithm that a program could use:

1. Set the initial value of the sum to 0.
                        30           CHAPTER 1  Java Program Design and Development

                        2. If there are no more numbers to total, go to step 5.
                        3. Add the next number to the sum.
                        4. Go to step 2.
                        5. Report the sum.

Pseudocode              Note that each step in this algorithm is simple and easy to follow. It would
                        be relatively easy to translate it into Java. Because English is somewhat
                        imprecise as an algorithmic language, programmers frequently write al-
                        gorithms in the programming language itself or in pseudocode, a hy-
                        brid language that combines English and programming language struc-
                        tures without being too fussy about programming language syntax. For
                        example, the preceding algorithm might be expressed in pseudocode as
                        follows:

                                                                                                       

                            sum = 0

                            while ( more numbers remain )

                            add next number t o sum

                            p r i n t t h e sum
                                                                                                       

Sum    List of Numbers     Of course, it is unlikely that an experienced programmer would take
                        the trouble to write out pseudocode for such a simple algorithm. But
    0  54 30 20         many programming problems are quite complex and require careful de-
   54  30 20            sign to minimize the number of errors that the program contains. In such
   84  20               situations, pseudocode could be useful.
 104   -
                           Another important part of designing an algorithm is to trace it--that is,
                        to step through it line by line--on some sample data. For example, we
                        might test the list-summing algorithm by tracing it on the list of numbers
                        shown in the margin.

                           Initially, the sum starts out at 0 and the list of numbers contains 54,
                        30, and 20. On each iteration through the algorithm, the sum increases
                        by the amount of the next number, and the list diminishes in size. The
                        algorithm stops with the correct total left under the sum column. While
                        this trace didn't turn up any errors, it is frequently possible to find flaws
                        in an algorithm by tracing it in this way.

                        1.3.4 Coding into Java

Stepwise refinement     Once a sufficiently detailed design has been developed, it is time to start
                        generating Java code. The wrong way to do this would be to type the en-
                        tire program and then compile and run it. This generally leads to dozens
                        of errors that can be both demoralizing and difficult to fix.

                           The right way to code is to use the principle of stepwise refinement.
                        The program is coded in small stages, and after each stage the code is
                        compiled and tested. For example, you could write the code for a single
                        method and test that method before moving on to another part of the pro-
                        gram. In this way, small errors are caught before moving on to the next
                        stage.

                           The code for the Riddle class is shown in Figure 1.4. Even though
                        we have not yet begun learning the details of the Java language, you
                        can easily pick out the key parts in this program: the instance variables
                        question and answer of type String, which are used to store the
                        riddle's data; the Riddle() constructor and the getQuestion() and
SECTION 1.3  Designing a Riddle Program                                    31

                                                                            

/

   File : Riddle . java

   Author : Java , Java , Java

   Description : Defines a simple riddle .

  /

public class Riddle extends Object   // C l a s s h e a d e r
{                                    // B e g i n c l a s s body

     private String question ;       // I n s t a n c e v a r i a b l e s
     private String answer ;

     public Riddle ( String q , String a ) // C o n s t r u c t o r method
     {

        question = q;
        answer = a ;
     } // R i d d l e ( )

     public String getQuestion ()    // I n s t a n c e method
     {

        return question ;
     } // g e t Q u e s t i o n ( )

     public String getAnswer ( )     // I n s t a n c e method

     {

        return answer ;

     } // getAnswer ( )

  } //  Riddle  class                // End c l a s s body

                                                                           

                Figure 1.4: The Riddle class definition.

getAnswer() methods make up the interface. The specific language de-
tails needed to understand each of these elements will be covered in this
and the following chapter.

1.3.5 Syntax and Semantics

Writing Java code requires that you know its syntax and semantics. A             Syntax
language's syntax is the set of rules that determines whether a partic-         
ular statement is correctly formulated. As an example of a syntax rule,         
consider the following two English statements:

 

    The r a i n in Spain f a l l s mainly on the p l a i n . // V a l i d
    Spain r a i n the mainly in on the f a l l s p l a i n . // I n v a l i d
 

The first sentence follows the rules of English syntax (grammar), and it
means that it rains a lot on the Spanish plain. The second sentence does
not follow English syntax, and, as a result, it is rendered meaningless. An
example of a Java syntax rule is that a Java statement must end with a
semicolon.

   However, unlike in English, where one can still be understood even
when one breaks a syntax rule, in a programming language the syntax
rules are very strict. If you break even the slightest syntax rule--for ex-
                 32             CHAPTER 1  Java Program Design and Development

Semantics        ample, if you forget just a single semicolon--the program won't work at
                 all.
Syntax errors
Semantic errors     Similarly, the programmer must know the semantics of the language--
                 that is, the meaning of each statement. In a programming language, a
                 statement's meaning is determined by what effect it will have on the pro-
                 gram. For example, to set the sum to 0 in the preceding algorithm, an as-
                 signment statement is used to store the value 0 into the memory location
                 named sum. Thus, we say that the statement

                                                                                                 

                     sum = 0 ;                                                                   
                 

                 assigns 0 to the memory location sum, where it will be stored until some
                 other part of the program needs it.

                    Learning Java's syntax and semantics is a major part of learning to
                 program. This aspect of learning to program is a lot like learning a for-
                 eign language. The more quickly you become fluent in the new language
                 (Java), the better you will be at expressing solutions to interesting pro-
                 gramming problems. The longer you struggle with Java's rules and con-
                 ventions, the more difficult it will be to talk about problems in a common
                 language. Also, computers are a lot fussier about correct language than
                 humans, and even the smallest syntax or semantic error can cause tremen-
                 dous frustration. So, try to be very precise in learning Java's syntax and
                 semantics.

                 1.3.6 Testing, Debugging, and Revising

                 Coding, testing, and revising a program is an repetitive process, one
                 that may require you to repeat the different program-development stages
                 shown in (Fig. 1.1). According to the stepwise-refinement principle, the
                 process of developing a program should proceed in small, incremental
                 steps, where the solution becomes more refined at each step. However,
                 no matter how much care you take, things can still go wrong during the
                 coding process.

                    A syntax error is an error that breaks one of Java's syntax rules. Such er-
                 rors will be detected by the Java compiler. Syntax errors are relatively easy
                 to fix once you understand the error messages provided by the compiler.
                 As long as a program contains syntax errors, the programmer must correct
                 them and recompile the program. Once all the syntax errors are corrected,
                 the compiler will produce an executable version of the program, which
                 can then be run.

                    When a program is run, the computer carries out the steps specified
                 in the program and produces results. However, just because a program
                 runs does not mean that its actions and results are correct. A running
                 program can contain semantic errors, also called logic errors. A semantic
                 error is caused by an error in the logical design of the program causing it
                 to behave incorrectly, producing incorrect results.

                    Unlike syntax errors, semantic errors cannot be detected automatically.
                 For example, suppose that a program contains the following statement for
                 calculating the area of a rectangle:

                                                                                                 

                     return length + width ;                                                     
                 
SECTION 1.3  Designing a Riddle Program  33

Because we are adding length and width instead of multiplying them,            Programming style
the area calculation will be incorrect. Because there is nothing syntacti-
cally wrong with the expression length + width, the compiler won't
detect an error in this statement. Thus, the computer will still execute this
statement and compute the incorrect area.

   Semantic errors can only be discovered by testing the program and they
are sometimes very hard to detect. Just because a program appears to run
correctly on one test doesn't guarantee that it contains no semantic errors.
It might just mean that it has not been adequately tested.

   Fixing semantic errors is known as debugging a program, and when sub-
tle errors occur it can be the most frustrating part of the whole program
development process. The various examples presented will occasionally
provide hints and suggestions on how to track down bugs, or errors, in
your code. One point to remember when you are trying to find a very sub-
tle bug is that no matter how convinced you are that your code is correct
and that the bug must be caused by some kind of error in the computer,
the error is almost certainly caused by your code!

1.3.7 Writing Readable Programs

Becoming a proficient programmer goes beyond simply writing a pro-
gram that produces correct output. It also involves developing good pro-
gramming style, which includes how readable and understandable your
code is. Our goal is to help you develop a programming style that satisfies
the following principles:

 Readability. Programs should be easy to read and understand. Com-
  ments should be used to document and explain the program's code.

 Clarity. Programs should employ well-known constructs and standard
  conventions and should avoid programming tricks and unnecessarily
  obscure or complex code.

 Flexibility. Programs should be designed and written so that they are
  easy to modify.

Special Topic: Grace Hopper and

    the First Computer Bug

Rear Admiral Grace Murray Hopper (1906-1992) was a pioneer computer
programmer and one of the original developers of the COBOL program-
ming language, which stands for COmmon Business-Oriented Language.
Among her many achievements and distinctions, Admiral Hopper also
had a role in coining the term computer bug.

   In August 1945, she and a group of other programmers were working
on the Mark I, an electro-mechanical computer developed at Harvard that
was one of the ancestors of today's electronic computers. After several
hours of trying to figure out why the machine was malfunctioning, some-
one located and removed a two-inch moth from one of the computer's
circuits. From then on whenever anything went wrong with a computer,
Admiral Hopper and others would say "it had bugs in it." The first bug
itself is still taped to Admiral Hopper's 1945 log book, which is now in the
collection of the Naval Surface Weapons Center.
    34     CHAPTER 1  Java Program Design and Development

       In 1991, Admiral Hopper was awarded the National Medal of Tech-
    nology by President George Bush. To commemorate and honor Admiral
    Hopper's many contributions, the U.S. Navy recently named a warship
    after her. For more information on Admiral Hopper, see the Web site at

                                                                                          

        h t t p : //www. c h i p s . navy . mil/
                                                                                          

    1.4 Java Language Elements

    In this section we will introduce some of the key elements of the Java
    language by describing the details of a small program. We will look at how
    a program is organized and what the various parts do. Our intent is to
    introduce important language elements, many of which will be explained
    in greater detail in later sections.

       The program we will study is a Java version of the traditional Hel-
    loWorld program--"traditional" because practically every introductory
    programming text begins with it. When it is run, the HelloWorld program
    (Fig. 1.5) just displays the greeting "Hello, World!" on the console.

                                                                                          

1       /

2        File : HelloWorld . java

3        Author : Java Java Java

4        D e s c r i p t i o n : P r i n t s Hello , World ! g r e e t i n g .

5       /

6 public class HelloWorld extends Object // C l a s s h e a d e r

7{                                                // S t a r t c l a s s body

8       private S t r i n g gr eeti ng = " Hello , World ! " ;

9       public void greet ( )                     // Method d e f i n i t i o n

10      {                                         // S t a r t method body

11         System . out . println ( greeting ) ; // O u t p u t s t a t e m e n t

12      } // g r e e t ( )                        // End method body

13      public s t a t i c void main ( S t r i n g args [ ] ) // M e t h o d h e a d e r

14 {

15         HelloWorld helloworld ;                // d e c l a r e

16         h e l l o w o r l d = new HelloWorld ( ) ; // c r e a t e

17         helloworld . greet ( ) ;               // Method c a l l

18      } // main ( )

19 }       // H e l l o W o r l d                 // End c l a s s body
   
                                                                                        

           Figure 1.5: The HelloWorld application program.

    1.4.1 Comments

    The first thing to notice about the HelloWorld program is the use of com-
    ments. A comment is a non-executable portion of a program that is used
    to document the program. Because comments are not executable instruc-
    tions they are just ignored by the compiler. Their sole purpose is to make
    the program easier for the programmer to read and understand.

       The HelloWorld program contains examples of two types of Java
    comments. Any text contained within /* and */ is considered a comment.
SECTION 1.4  Java Language Elements                                      35

As you can see in HelloWorld, this kind of comment can extend over
several lines and is sometimes called a multiline comment. A second type

of comment is any text that follows double slashes (//) on a line. This is
known as a single-line comment because it cannot extend beyond a single

line.

When the compiler encounters the beginning marker (/*) of a multiline

comment, it skips over everything until it finds a matching end marker

(*/). One implication of this is that it is not possible to put one multiline
comment inside of another. That is, one comment cannot be nested, or con-

tained, within another comment. The following code segment illustrates

the rules that govern the use of /* and */:

                                                                                 

  /    T h i s f i r s t comment b e g i n s and ends on t h e same l i n e . /
  /    A second comment s t a r t s on t h i s l i n e . . .
       and goes on . . .
  /    and t h i s i s the l a s t l i n e of the second comment .
  /
       A t h i r d comment    s t a r t s on t h i s l i n e . . .
  /      / T h i s i s NOT    a f o u r t h comment . I t i s j u s t
                 part of the  t h i r d comment .
  /                           l a s t l i n e of the t h i r d comment .
       And t h i s i s t h e

       This i s an error because i t i s an unmatched end marker .
                                                                                                

As you can see from this example, it is impossible to begin a new com-
ment inside an already-started comment because all text inside the first
comment, including /*, is ignored by the compiler.

JAVA LANGUAGE RULE Comments. Any text contained within
/* and */, which may span several lines, is considered a comment and
is ignored by the compiler. Inserting double slashes (//) into a line
turns the rest of the line into a comment.

   Multiline comments are often used to create a comment block that pro-         Single-line comment
vides useful documentation for the program. In HelloWorld, the pro-
gram begins with a comment block that identifies the name of file that
contains the program and its author and provides a brief description of
what the program does.

   For single-line comments, double slashes (//) can be inserted any-
where on a line of code. The result is that the rest of the line is ignored by
the compiler. We use single-line comments throughout the HelloWorld
program to provide a running commentary of its language elements.

JAVA PROGRAMMING TIP Use of Comments. A well-written
program should begin with a comment block that provides the name
of the program, its author, and a description of what the program does.
36        CHAPTER 1  Java Program Design and Development

1.4.2 Program Layout

Another thing to notice about the program is how neatly it is arranged
on the page. This is done deliberately so that the program is easy to read
and understand. In Java, program expressions and statements may be ar-
ranged any way the programmer likes. They may occur one per line, sev-
eral per line, or one per several lines. But the fact that the rules governing
the layout of the program are so lax makes it all the more important that
we adopt a good programming style, one that will help make programs
easy to read.

   So look at how things are presented in HelloWorld. Notice how
beginning and ending braces, and , are aligned, and note how we use
single-line comments to annotate ending braces. Braces are used to mark
the beginning and end of different blocks of code in a Java program and
it can sometimes be difficult to know which beginning and end braces
are matched up. Proper indentation and the use of single-line comments
make it easier to determine how the braces are matched up.

   Similarly, notice how indentation is used to show when one element
of the program is contained within another element. Thus, the elements
of the HelloWorld class are indented inside of the braces that mark the
beginning and end of the class. And the statements in the main() method
are indented to indicate that they belong to that method. Use of indenta-
tion in this way, to identify the program's structure, makes the program
easier to read and understand.

JAVA PROGRAMMING TIP Use of Indentation. Indent the code
within a block and align the block's opening and closing braces. Use a
comment to mark the end of a block of code.

1.4.3 Keywords and Identifiers

The Java language contains 48 predefined keywords (Table 1.1). These
are words that have special meaning in the language and whose use is
reserved for special purposes. For example, the keywords used in the
HelloWorld program (Fig. 1.5) are: class, extends, private, public,
static, and void.

                                Table 1.1: Java keywords.

abstract  default  goto        package       this
boolean   do       if          private       throw
break     double   implements  protected     throws
byte      enum     import      public        transient
case      elses    instanceof  return        try
catch     extend   int         short         void
char      final    interface   static        volatile
class     finally  long        super         while
const     float    native      switch
continue  for      new         synchronized
SECTION 1.4  Java Language Elements  37

   Because their use is restricted, keywords cannot be used as the names      Identifier syntax
of methods, variables, or classes. However, the programmer can make up
his or her own names for the classes, methods, and variables that occur in
the program, provided that certain rules and conventions are followed.

   The names for classes, methods, and variables are called identifiers,
which follow certain syntax rules:

JAVA LANGUAGE RULE Identifier. An identifier must begin with
a capital or lowercase letter and may be followed by any number of
letters, digits, underscores ( ), or dollar signs ($). An identifier may not
be identical to a Java keyword.

Names in Java are case sensitive, which means that two different identifiers  Identifier style
may contain the same letters in the same order. For example, thisVar          Java naming conventions
and ThisVar are two different identifiers.

   In addition to the syntax rule that governs identifiers, Java program-
mers follow certain style conventions in making up names for classes,
variables, and methods. By convention, class names in Java begin with
a capital letter and use capital letters to distinguish the individual words
in the name--for example, HelloWorld and TextField. Variable and
method names begin with a lowercase letter but also use capital letters
to distinguish the words in the name--for example, main(), greeting,
greet(), getQuestion(), and getAnswer(). The advantage of this
convention is that it is easy to distinguish the different elements in a
program--classes, methods, variables--just by how they are written. (For
more on Java style conventions, see Appendix A.).

   Another important style convention followed by Java programmers
is to choose descriptive identifiers when naming classes, variables, and
methods. This helps to make the program more readable.

JAVA PROGRAMMING TIP Choice of Identifiers. To make your
program more readable, choose names that describe the purpose of the
class, variable, or method.

1.4.4 Data Types and Variables                                                Primitive types

A computer program wouldn't be very useful if it couldn't manipulate
different kinds of data, such as numbers and strings. The operations that
one can do on a piece of data depend on the data's type. For example, you
can divide and multiply numbers, but you cannot do this with strings.
Thus, every piece of data in a Java program is classified according to its
data type.

   Broadly speaking, there are two categories of data in Java: various
types of objects and eight different types of built-in primitive data types.
In addition to new types of objects that are created by programmers, Java
has many different types of built-in objects. Two types that we will en-
counter in this chapter are the String and PrintStream objects. Java's
primitive types include three integer types, three real number types, a
character type, and a boolean type with values true and false. The names
                                      38              CHAPTER 1  Java Program Design and Development

Figure 1.6: Variables are like typed  of the primitive types are keywords like int for one integer type, double
containers.                           for one real number type, and boolean.
Executing a program
                                         As we noted in Chapter 0, a variable is a named storage location that
Declaration statement                 can store a value of a particular type. Practically speaking, you can think
                                      of a variable as a special container into which you can place values, but
                                      only values of a certain type (Fig. 1.6). For example, an int variable
                                      can store values like 5 or -100. A String variable can store values like
                                      "Hello". (Actually, this is not the full story, which is a little more compli-
                                      cated, but we will get to that in Chapter 2.)

                                         In the HelloWorld class, the instance variable greeting (line 8)
                                      stores a value of type String. In the main() method, the variable
                                      helloworld is assigned a HelloWorld object (line 16).

                                         A literal value is an actual value of some type that occurs in a program.
                                      For example, a string enclosed in double quotes, such as "Hello, World!",
                                      is known as a String literal. A number such as 45.2 would be an example
                                      of a literal of type double, and -72 would be an example of a literal of
                                      type int. Our HelloWorld program contains just a single literal value,
                                      the "HelloWorld!" String.

                                      1.4.5 Statements

                                      A Java program is a collection of statements. A statement is a segment of
                                      code that takes some action in the program. As a program runs, we say
                                      it executes statements, meaning it carries out the actions specified by those
                                      statements. In our HelloWorld program, statements of various types
                                      occur on lines 8, 11, 15, 16, and 17. Notice that all of these lines end with a
                                      semicolon. The rule in Java is that statements must end with a semicolon.
                                      Forgetting to do so would cause a syntax error.

                                         A declaration statement is a statement that declares a variable of a par-
                                      ticular type. In Java, a variable must be declared before it can be used in a
                                      program. Failure to do so would cause a syntax error. In its simplest form,
                                      a declaration statement begins with the variable's type, which is followed
                                      by the variable's name, and ends with a semicolon:

                                          Type VariableName ;

                                      A variable's type is either one of the primitive types we mentioned, such
                                      as int, double, or boolean, or for objects, it is the name of the object's
                                      class, such as String or HelloWorld. A variable's name may be any
                                      legal identifier, as defined earlier, although the convention in Java is to be-
                                      gin variable names with a lowercase letter. In our HelloWorld program,
                                      an example a simple declaration statement occurs on line 15:

                                                                                                                       

                                          HelloWorld helloworld ;
                                                                                                                       

                                      This example declares a variable for an object. The variable's name is
                                      helloworld and its type is HelloWorld, the name of the class that is
                                      being defined in our example. To take another example the following
                                      statements declare two int variables, named int1 and int2:

                                                                                                                       

                                          int int1 ;

                                          int int2 ;                                                                   
                                      
SECTION 1.4  Java Language Elements                                  39

As we noted, an int is one of Java's primitive types and the word int is a
Java keyword.

   Without going into too much detail at this point, declaring a variable
causes the program to set aside enough memory for the type of data that
will be stored in that variable. So in this example, Java would reserve
enough space to store an int.

   An assignment statement is a statement that stores (assigns) a value
in a variable. An assignment statement uses the equal sign (=) as an as-
signment operator. In its simplest form, an assignment statement has a
variable on the left hand side of the equals sign and some type of value on
the right hand side. Like other statements, an assignment statement ends
with a semicolon:

VariableName = Value ;

When it executes an assignment statement, Java will first determine what
value is given on the right hand side and then assign (store) that value to
(in) the variable on the left hand side. Here are some simple examples:

                                                                                   
                                                                                    Figure 1.7: This illustrates how
gre et in g = " Hello , World" ;                                                    the state of the variables num1 and

num1 = 5 0 ;            // ( a ) A s s i g n 50 t o num1                           쯰um2 changes over the course of
                                                                                    the three assignments, (a), (b), (c),
num2 = 10 + 1 5 ; // ( b ) A s s i g n 2 5 t o num2                                 given in the text.

 num1 = num2 ;          // ( c ) Copy num2 ' s v a l u e  (25)  into  num1         
                                                                                   

In the first case, the value on the right hand side is the string literal "Hello,
World!", which gets stored in greeting. Of course, greeting has to be
the right type of container-in this case, a String variable. In the next
case, the value on the right hand side is 50. So that is the value that gets
stored in num1, assuming that num1 is an int variable. The situation
after this assignment is shown in the top drawing in Figure 1.7. In the
third case, the value on the right hand side is 25, which is determined
by adding 10 and 15. So the value that gets assigned to num2 is 25. After
this assignment we have the situation shown in the middle drawing in the
figure. Of course, this assumes that num2 is an int variable. In the last
case, the value on the right hand side is 25, the value that we just stored in
the variable num2. So, 25 gets stored in num1. This is the bottom drawing
in the accompanying figure.

   The last of these examples



 num1 = num2 ;  // Copy num2 ' s v a l u e i n t o num1


can be confusing to beginning programmers, so it is worth some addi-
tional comment. In this case, there are variables on both the left and right
of the assignment operator. But they have very different meaning. The
variable on the right is treated as a value. If that variable is storing 25,
then that is its value. In fact, whatever occurs on the right hand side of an
assignment operator is treated as a value. The variable on the left hand
side is treated as a memory location. It is where the value 25 will be stored
as a result of executing this statement. The effect of this statement is to
copy the value stored in num2 into num1, as illustrated in Figure 1.8.

   Java has many other kinds of statements and we will be learning
about these in subsequent examples. The following examples from the
40            CHAPTER 1  Java Program Design and Development

HelloWorld program are examples of statements in which a method is
called:

                                                                                              

    System . out . println ( greeting ) ; // C a l l p r i n t l n ( ) method

  helloworld . greet ( ) ;  // C a l l g r e e t ( ) method

                                                                            

We will discuss these kinds of statements in greater detail as we go along.
One final type of statement that should be mentioned at this point is the
compound statement (or block), which is a sequence of statements con-
tained within braces (). We see three examples of this in the HelloWorld
program. The body of a class definition extends from lines 7 through 19.
The body of the greet() method is a block that extends from lines 10
through 12. The body of the main() method is a block that extends from
lines 14 to 19.

1.4.6 Expressions and Operators

The manipulation of data in a program is done by using some kind of ex-
pression that specifies the action. An expression is Java code that specifies
or produces a value in the program. For example, if you want to add two
numbers, you would use an arithmetic expression, such as num1 + num2. If
you want to compare two numbers, you would use a relation expression
such as num1 < num2. As you can see, these and many other expressions
in Java involve the use of special symbols called operators. Here we see
the addition operator (+) and the less-than operator (<). We have already
talked about the assignment operator (=).

   Java expressions and operators have a type that depends on the type
of data that is being manipulated. For example, when adding two int
values, such as 5 + 10, the expression itself produces an int result. When
comparing two numbers with the less than operator, num1 < num2, the
expression itself produces a boolean type, either true or false.

   It is important to note that expressions cannot occur on their own.
Rather they occur as part of the program's statements. Here are some
additional examples of expressions:

                                                                                              

    num = 7   // An a s s i g n m e n t e x p r e s s i o n o f t y p e i n t

    num = s q u a r e ( 7 ) / / An m e t h o d c a l l e x p r e s s i o n o f t y p e i n t

    num == 7  // An e q u a l i t y e x p r e s s i o n o f t y p e b o o l e a n

                                                                                              

The first of these is an assignment expression. It has a value of 7, because
it is assigning 7 to num. The second example is also an assignment expres-
sion, but this one has a method call, square(7), on its right hand side.
(We can assume that a method named square() has been appropriately
defined in the program.) A method call is just another kind of expression.
In this case, it has the value 49. Note that an assignment expression can
be turned into a stand-alone assignment statement by placing a semicolon
after it.

   The third expression is an equality expression, which has the value
true, assuming that the variable on its left is storing the value 7. It is
SECTION 1.4  Java Language Elements             41

important to note the difference between the assignment operator (=) and
the equality operator (==).

JAVA LANGUAGE RULE Equality and Assignment. Be careful not
to confuse = and ==. The symbol = is the assignment operator. It
assigns the value on its right-hand side to the variable on its left-hand
side. The symbol == is the equality operator. It evaluates whether the
expressions on its left- and right-hand sides have the same value and
returns either true or false.

SELF-STUDY EXERCISES

EXERCISE 1.1 What is stored in the variable num after the following
two statements are executed?

   int num = 11;

   num = 23 - num;

EXERCISE 1.2 Write a statement that will declare a variable of type int         Class header
called num2, and store in it the sum of 711 and 712.

1.4.7 Class Definition

A Java program consists of one or more class definitions. In the
HelloWorld example, we are defining the HelloWorld class, but there
are also three predefined classes involved in the program. These are the
Object, String, and System classes all of which are defined in the
Java class library. Predefined classes, such as these, can be used in any
program.

   As the HelloWorld program's comments indicate, a class definition
has two parts: a class header and a class body. In general, a class header
takes the following form, some parts of which are optional (opt):

  ClassModifiersopt class ClassName Pedigreeopt

The class header for the HelloWorld class is:

                                                                                

public class HelloWorld extends Object                                          


The purpose of the header is to give the class its name (HelloWorld),
identify its accessibility (public as opposed to private), and describe
where it fits into the Java class hierarchy (as an extension of the Object
class). In this case, the header begins with the optional access modi-
fier, public, which declares that this class can be accessed by any other
classes. The next part of the declaration identifies the name of the class,
HelloWorld. And the last part declares that HelloWorld is a subclass
of the Object class. We call this part of the definition the class's pedigree.

   As you recall from Chapter 0, the Object class is the top class of the
entire Java hierarchy. By declaring that HelloWorld extends Object,
we are saying that HelloWorld is a direct subclass of Object. In fact, it
is not necessary to declare explicitly that HelloWorld extends Object
because that is Java's default assumption. That is, if you omit the extends
clause in the class header, Java will automatically assume that the class is
a subclass of Object.
                    42  CHAPTER 1  Java Program Design and Development

                       The class's body, which is enclosed within curly brackets (), contains       Class body
                    the declaration and definition of the elements that make up the objects of
                    the class. This is where the object's attributes and actions are defined.

                    1.4.8 Declaring an Instance Variable

                    There are generally two kinds of elements declared and defined in the
                    class body: variables and methods. As we described in Chapter 0, an
                    instance variable is a variable that belongs to each object, or instance, of
                    the class. That is, each instance of a class has its own copies of the class's
                    instance variables. The HelloWorld class has a single instance variable,
                    (greeting), which is declared as follows:

                                                                                                    

                        private S t r i n g gr eetin g = " Hello , World ! " ;                      
                    

                    In general, an instance variable declaration has the following syntax, some
                    parts of which are optional:

Information hiding             Modifiersopt Type VariableName InitializerExpressionopt

                    Thus, a variable declaration begins with optional modifiers. In declaring
                    the greeting variable, we use the access modifier, private, to declare
                    that greeting, which belongs to the HelloWorld class, cannot be di-
                    rectly accessed by other objects. The next part of the declaration is the
                    variable's type. In this case, the greeting variable is a String, which
                    means that it can store a string object. The type is followed by the name
                    of the variable, in this case (greeting). This is the name that is used to
                    refer to this memory location throughout the class. For example, notice
                    that the variable is referred to on line 11 where it is used in a println()
                    statement.

                       The last part of the declaration is an optional initializer expression. In
                    this example, we use it to assign an initial value, "Hello, World!," to the
                    greeting variable.

                    1.4.9 Defining an Instance Method

                    Recall that a method is a named section of code that can be called or in-
                    voked to carry out an action or operation. In a Java class, the methods
                    correspond to the object's behaviors or actions. The HelloWorld pro-
                    gram has two method definitions: the greet() method and the main()
                    method.

                       A method definition consists of two parts: the method header and the
                    method body. In general, a method header takes the following form,
                    including some parts which are optional:

                          Modifiersopt ReturnType MethodName ( ParameterListopt)

                    As with a variable declaration, a method definition begins with optional
                    modifiers. For example, the definition of the greet() method on line
                    9 uses the access modifier, public, to declare that this method can be
                    accessed or referred to by other classes. The main() method, whose def-
                    inition begins on line 13, is a special method, and is explained in the next
                    section.
SECTION 1.4  Java Language Elements                                    43

   The next part of the method header is the method's return type. This
is the type of value, if any, that the method returns. Both of the methods
in HelloWorld have a return type of void. This means that they don't
return any kind of value. Void methods just execute the sequence of state-
ments given in their bodies. For an example of a method that does return a
value, take a look again at the declaration of the getQuestion() method
in the Riddle class, which returns a String (Fig. 1.4).

   The method's name follows the method's return type. This is the name
that is used when the method is called. For example, the greet() method
is called on line 17.

   Following the method's name is the method's parameter list. A param-
eter is a variable that temporarily stores data values that are being passed
to the method when the method is called. Some methods, such as the
greet() method, do not have parameters, because they are not passed
any information. For an example of a method that does have parameters,
see the Riddle() constructor, which contains parameters for the riddle's
question and answer (Fig. 1.4).

   The last part of method definition is its body, which contains a sequence
of executable statements. An executable statement is a Java statement
that takes some kind of action when the program is run. For example, the
statement in the greet() method,

                                                                                

System . out . println ( greeting ) ; // O u t p u t s t a t e m e n t
                                                                                

prints a greeting on the console.

1.4.10 Java Application Programs

The HelloWorld program is an example of a Java application program,             
or a Java application, for short. An application program is a stand-alone       
program, "stand-alone" in the sense that it does not depend on any other
program, like a Web browser, for its execution. Every Java application pro-      Class method
gram must contain a main() method, which is where the program begins
execution when it is run. For a program that contains several classes, it is
up to the programmer to decide which class should contain the main()
method. We don't have to worry about that decision for the HelloWorld,
because it contains just a single class.

   Because of its unique role as the starting point for every Java applica-
tion program, it is very important that the header for the main method be
declared exactly as shown in the HelloWorld class:

 

    public s t a t i c void main ( S t r i n g args [ ] )
 

It must be declared public so it can be accessed from outside the class
that contains it. The static modifier is used to designate main() as
a class method. As you might recall from Chapter 0, a class method is
a method that is associated directly with the class that contains it rather
than with the objects of the class. A class method is not part of the class's
objects. Unlike instance methods, which are invoked through a class's ob-
jects, a class method is called through the class itself. Thus, a class method
can be called even before the program has created objects of that class.
                     44  CHAPTER 1  Java Program Design and Development

                     Because of main()'s special role as the program's starting point, it is nec-
                     essary for main() to be a class method because it is called, by the Java
                     runtime system, before the program has created any objects.

                        The main() method has a void return type, which means it does not
                     return any kind of value. Finally, notice that main()'s parameter list con-
                     tains a declaration of some kind of String parameter named args. This is
                     actually an array that can be used to pass string arguments to the program
                     when it is started up. We won't worry about this feature until our chapter
                     on arrays.

                     1.4.11 Creating and Using Objects

                     The body of the main() method is where the HelloWorld program cre-
                     ates its one and only object. Recall that when it is run the HelloWorld
                     program just prints the "Hello World!" greeting. As we noted earlier,
                     this action happens in the greet() method. So in order to make this ac-
                     tion happen, we need to call the greet() method. However, because the
                     greet() method is an instance method that belongs to a HelloWorld
                     object, we first need to create a HelloWorld instance. This is what
                     happens in the body of the main() method (Fig. 1.5).

                        The main() method contains three statements:

                                                                                                              

                         HelloWorld helloworld ;  // V a r i a b l e d e c l a r a t i o n

                         h e l l o w o r l d = new HelloWorld ( ) ; // O b j e c t i n s t a n t i a t i o n

                       helloworld . greet ( ) ;   // Method i n v o c a t i o n
                     
                                                                                             

Default constructor  The first statement declares a variable of type HelloWorld, which is
Interacting objects  then assigned a HelloWorld object. The second statement creates a
                     HelloWorld object. This is done by invoking the HelloWorld() con-
                     structor method. Creating an object is called object instantiation because
                     you are creating an instance of the object. Once a HelloWorld instance
                     is created, we can use one of its instance methods to perform some task
                     or operation. Thus, in the third statement, we call the greet() method,
                     which will print "Hello World!" on the console.

                        If you look back at the HelloWorld program in Figure 1.5 you won't
                     find a definition of a constructor method. This is not an error because Java
                     will provide a default constructor if a class does not contain a constructor
                     definition. The default constructor is a trivial constructor method, "triv-
                     ial" because its body contains no statements. Here is what the default
                     HelloWorld() constructor would look like:

                                                                                                              

                         public HelloWorld ( ) { } // D e f a u l t c o n s t r u c t o r                     
                     

                     For most of the classes we design, we will design our own constructors,
                     just as we did in the Riddle class (Fig. 1.4). We will use constructors to
                     assign initial values to an object's instance variables or to perform other
                     kinds of tasks that are needed when an object is created. Because the
                     HelloWorld object doesn't require any startup tasks, we can make do
                     with the default constructor.

                        The HelloWorld program illustrates the idea that an object-oriented
                     program is a collection of interacting objects. Although we create just a
                     single HelloWorld object in the main() method, there are two other ob-
SECTION 1.4  Java Language Elements                                      45

jects used in the program. One is the greeting, which is a String ob-
ject consisting of the string "Hello, World!". The other is the System.out
object, which is a special Java system object used for printing.

1.4.12 Java JFrames

Java cann run a program in a JFrame so that the output and interaction
occurs in a Window (or Frame). Figure 1.9 shows a Java program named
HelloWorldSwing. This program does more or less the same thing as
the HelloWorld application--it displays the "Hello, World!" greeting.

                                                                          

  / F i l e : H e l l o W o r l d S w i n g program /

import javax . swing . JFrame ; // I m p o r t c l a s s names
import java . awt . Graphics ;
import java . awt . Canvas ;

public class HelloWorldCanvas extends                   Canvas //  Class  header
{                                                       10 , 10);

         // S t a r t o f body

       public void paint ( Graphics g)

                  // The p a i n t method

       {
              g . drawString ( " Hello , World ! " ,

       } // End o f p a i n t

  public s t a t i c void main ( S t r i n g [ ] args ){

     HelloWorldCanvas c = new HelloWorldCanvas ( ) ;

     JFrame f = new JFrame ( ) ;

     f . add ( c ) ;

     f . setSize (150 ,50);

     f . setVisible ( true );

  }

} // End o f H e l l o W o r l d C a n v a s

                                                                          

     Figure 1.9: HelloWorldCanvas program.

The difference is that it displays the greeting within a Window rather than
directly on the console.

   As in the case of the HelloWorld console application program,
HelloWorldCanvas consists of a class definition. It contains a single
method definition, the paint() method, which contains a single exe-
cutable statement:

                                                                                  

  g . drawString ( " Hello , World ! " , 1 0 , 1 0 ) ;                            


This statement displays the "Hello, World!" message directly in a Win-
dow. The drawString() method is one of the many drawing and paint-
ing methods defined in the Graphics class. Every Java Canvas comes
with its own Graphics object, which is referred to here simply as g.
Thus, we are using that object's drawString() method to draw on the
window. Don't worry if this seems a bit mysterious now. We'll explain it
more fully when we take up graphics examples again.
46  CHAPTER 1  Java Program Design and Development

   The HelloWorldSwing also contains some elements, such as the
import statements, that we did not find in the HelloWorld application.
We will now discuss those features.

1.4.13 Java Library Packages

Recall that the HelloWorld application program used two pre-defined

classes, the String and the System classes. Both of these classes are

basic language classes in Java. The HelloWorldSwing program also uses

pre-defined classes, such as JFrame and Graphics. However, these two

classes are not part of Java's basic language classes. To understand the

difference between these classes, it will be necessary to talk briefly about

how the Java class library is organized.

    A package is a collection a inter-related classes in the Java class library.

For example, the java.lang package contains classes, such as Object,

String, and System, that are central to the Java language. Just about

all Java programs use classes in this package. The java.awt package

provides classes, such as Button, TextField, and Graphics, that are

used in graphical user interfaces (GUIs). The java.net package provides

classes used for networking tasks, and the java.io package provides

classes used for input and output operations.

    All Java classes belong to some package, including those that are pro-

grammer defined. To assign a class to a package, you would provide a

package statement as the first statement in the file that contains the class

definition. For example, the files containing the definitions of the classes

in the java.lang package all begin with the following statement.

                                                                                  

    package java . lang ;                                                         


If you omit package statement, as we do for the programs in this book,
Java places such classes into an unnamed default package.

   Thus, for any Java class, its full name includes the name of the
package that contains it. For example, the full name for the System
class is java.lang.System and the full name for the String class is
java.lang.String. Similarly, the full name for the Graphics class is
java.awt.Graphics. In short, the full name for a Java class takes the
following form:

                                       package.class

In other words, the full name of any class provides its package name as a
prefix.

   Of all the packages in the Java library, the java.lang package is the
only one whose classes are available by their shorthand names to all
Java programs. This means that when a program uses a class from the
java.lang package, it can refer to it simply by its class name. For exam-
ple, in the HelloWorld program we referred directly to the String class
rather than to java.lang.String.

1.4.14 The import Statement

The import statement makes Java classes available to programs under
their abbreviated names. Any public class in the Java class library is avail-
able to a program by its fully qualified name. Thus, if a program was using
SECTION 1.4  Java Language Elements       47

the Graphics class, it could always refer to it as java.awt.Graphics.
However, being able to refer to Graphics by its shorthand name, makes
the program a bit shorter and more readable.

   The import statement doesn't actually load classes into the program.
It just makes their abbreviated names available. For example, the im-
port statements in HelloWorldSwing allow us to refer to the JFrame,
Canvas, and Graphics classes by their abbreviated names (Fig. 1.9).

   The import statement takes two possible forms:

  import package.class

                         import package.*

The first form allows a specific class to be known by its abbreviated name.
The second form, which uses the asterisk as a wildcard characters ('*'),
allows all the classes in the specified package to be known by their short
names. The import statements in HelloWorldSwing are examples of
the first form. The following example,

                                                                              

import java . lang .  ;                                                       


allows all classes in the java.lang package to be referred to by their class
names alone. In fact, this particular import statement is implicit in every
Java program.

1.4.15 Qualified Names in Java

In the previous subsections we have seen several examples of names in
Java programs that used dot notation. A qualified name is a name that is
separated into parts using Java's dot notation. Examples include package
names, such as java.awt, class names, such as javax.swing.JFrame,
and even method names, such as helloworld.greet().

   Just as in our natural language, the meaning of a name within a
Java program depends on the context. For example, the expression
helloworld.greet() refers to the greet() method, which belongs to
the HelloWorld class. If we were using this expression from within that
class, you wouldn't need to qualify the name in this way. You could just
refer to greet() and it would be clear from the context which method
you meant.

   This is no different than using someone's first name ("Kim") when
there's only one Kim around, but using a full name ("Kim Smith") when
the first name alone would be too vague or ambiguous.

   One thing that complicates the use of qualified names is that they are
used to refer to different kinds of things within a Java program. But
this is no different, really, than in our natural language, where names
("George Washington") can refer to people, bridges, universities, and so
on. Here again, just as in our natural language, Java uses the context
to understand the meaning of the name. For example, the expression
java.lang.System refers to the System class in the java.lang pack-
age, whereas the expression System.out.print() refers to a method
in the System.out object.

   How can you tell these apart? Java can tell them apart because the
first one occurs as part of an import statement, so it must be referring
48  CHAPTER 1  Java Program Design and Development

to something that belongs to a package. The second expression would
only be valid in a context where a method invocation is allowed. You
will have to learn a bit more about the Java language before you'll be able
to completely understand these names, but the following provide some
naming rules to get you started.

JAVA LANGUAGE RULE Library Class Names. By convention,
class names in Java begin with an uppercase letter. When referenced as
part of a package, the class name is the last part of the name. For
example, java.lang.System refers to the System class in the
java.lang package.

 JAVA LANGUAGE RULE Dot Notation. Names expressed in Java's
 dot notation depend for their meaning on the context in which they are
 used. In qualified names--that is, names of the form X.Y.Z--the last
 item in the name (Z) is the referent--that is, the element being referred
 to. The items that precede it (X.Y.) are used to qualify or clarify the
 referent.

The fact that names are context dependent in this way certainly compli-
cates the task of learning what's what in a Java program. Part of learn-
ing to use Java's built-in classes is learning where a particular object or
method is defined. It is a syntax error if the Java compiler can't find the
object or method that you are referencing.

 JAVA DEBUGGING TIP Not Found Error. If Java cannot find the
 item you are referring to, it will report an "X not found" error, where X
 is the class, method, variable, or package being referred to.

1.5 Editing, Compiling, and Running a Java Pro-
      gram

In this section we discuss the nuts and bolts of how to compile and run
a Java program. Because we are exploring two different varieties of Java
programs, console applications and Swing applications, the process dif-
fers slightly for each variety. We have already discussed some of the main
language features of console and Swing applications, so in this section we
focus more on features of the programming environment itself. Because
we do not assume any particular programming environment in this book,
our discussion will be somewhat generic. However, we do begin with
a brief overview of the types of programming environments one might
encounter.
diting, compiling,  SECTION 1.5  Editing, Compiling, and Running a Java Program 49
lloWorld.java.
                                     User types program into a file
                                      using a standard text editor.

                    text editor       Correct the syntax errors

                    HelloWorld.java               Editor creates the source
                                                    program in a disk file.

                    javac                         syntax Y javac generates
                                                  errors  a list of error

                                                  ?               messages

                                      N

                    HelloWorld.class              javac creates the bytecode
                                                          in a disk file.

                    appletviewer                Hello.html
                       or Web
                       browser                   Applets require
                                                  an HTML file.
                                      Applet Programming

                    java

                     The Java Virtual Machine
                       loads the class file into

                    memory and interprets and
                         runs the bytecode.

                    1.5.1 Java Development Environments

                    A Java programming environment typically consists of several pro-
                    grams that perform different tasks required to edit, compile, and run
                    a Java program. The following description will be based on the
                    software development environment provided by Oracle, the company
                    that owns and maintains Java. It is currently known as the Java
                    Platform, Standard Edition 8.0 (Java SE 8). Versions of Java SE are
                    available for various platforms, including Linux, Windows, and ma-
                    cOS computers. Free downloads are available at Sun's Web site at
                    http://www.oracle.com/technetwork/java/. (For more details
                    about the Java SE, see Appendix B.)

                       In some cases, the individual programs that make up the Java SE are
                    available in a single program development environment, known as an
                    integrated development environment (IDE). Some examples include Eclipse,
                    jGrasp, and Oracle's own NetBeans IDE. Each of these provides a com-
                    plete development package for editing, compiling, and running Java ap-
                    plications on a variety of platforms, including Linux, macOS, and Win-
                    dows.

                       Figure 1.10 illustrates the process involved in creating and running a
                    Java program. The discussion that follows here assumes that you are us-
50  CHAPTER 1  Java Program Design and Development

ing the Java SE as your development environment to edit, compile and run
the example program. If you are using some other environment, you will
need to read the documentation provided with the software to determine
exactly how to edit, compile, and run Java programs in that environment.

1.5.2 Editing a Program

Any text editor may be used to edit the program by merely typing the
program and making corrections as needed. Popular Unix and Linux
editors include vim and emacs. These editors are also available on ma-
cOS and Windows. However, free macOS editors include TextMate and
TextWrangler, and Windows has Notepad++ for free.

   As we have seen, a Java program consists of one or more class def-
initions. We will follow the convention of placing each class definition
in its own file. (The rule in Java is that a source file may contain only
one public class definition.) The files containing these classes' defini-
tions must be named ClassName.java where ClassName is the name of the
public Java class contained in the file.

JAVA LANGUAGE RULE File Names. A file that defines a public
Java class named ClassName must be saved in a text file named
ClassName.java. Otherwise an error will result.

For example, in the case of our HelloWorld application program, the file
must be named HelloWorld.java, and for HelloWorldSwing, it must
be named HelloWorldSwing.java. Because Java is case sensitive, which
means that Java pays attention to whether a letter is typed uppercase or
lowercase, it would be an error if the file containing the HelloWorld
class were named helloworld.java or Helloworld.java. The er-
ror in this case would be a semantic error. Java would not be able to
find the HelloWorld class because it will be looking for a file named
HelloWorld.java.

 JAVA LANGUAGE RULE Case Sensitivity. Java is case sensitive,
 which means that it treats helloWorld and Helloworld as different
 names.

1.5.3 Compiling a Program

Recall that before you can run a Java source program you have to com-
pile it into the Java bytecode, the intermediate code understood by the
Java Virtual Machine (JVM). Source code for both applets and applica-
tions must be compiled. To run a Java program, whether an applet or an
application, the JVM is then used to interpret and execute the bytecode.

   The Java SE comes in two parts, a runtime program, called the Java
Runtime Environment (JRE) and a development package, called the Software
Development Kit (SDK). If you are just going to run Java programs, you
need only install the JRE on your computer. In order to run Java applets,
browsers, such as Internet Explorer and Netscape Navigator, must contain
a plugin version of the JRE. On the other hand, if you are going to be
developing Java programs, you will need to install the SDK as well.
SECTION 1.5  Editing, Compiling, and Running a Java Program 51

   The Java SDK compiler is named javac. In some environments--
such as within Linux or at the Windows command prompt --
HelloWorld.java would be compiled by typing the following com-
mand at the system prompt:

                                                                               

javac HelloWorld . java
                                                                               

As Figure 1.10 illustrates, if the HelloWorld.java program does not
contain errors, the result of this command is the creation of a Java bytecode
file named HelloWorld.class--a file that has the same prefix as the
source file but with the suffix .class rather than .java. By default,
the bytecode file will be placed in the same directory as the source file.
If javac detects errors in the Java code, a list of error messages will be
printed.

1.5.4 Running a Java Application Program

In order to run (or execute) a program on any computer, the program's
executable code must be loaded into the computer's main memory. For
Java environments, this means that the program's .class file must be
loaded into the computer's memory, where it is then interpreted by the
Java Virtual Machine. To run a Java program on Linux systems or at the
Windows command prompt, type

                                                                               

java HelloWorld                                                                


on the command line. This command loads the JVM, which will then
load and interpret the application's bytecode (HelloWorld.class). The
"HelloWorld" string will be displayed on the command line.

   On Macintosh systems, or within an IDE, which do not typically have a
command line interface, you would select the compile and run commands
from a menu. Once the code is compiled, the run command will cause the
JVM to be loaded and the bytecode to be interpreted. The "Hello, World!"
output would appear in a text-based window that automatically pops
up on your computer screen. In any case, regardless of the system you
use, running the HelloWorld console application program will cause the
"Hello, World!" message to be displayed on some kind of standard output
device (Fig. 1.11).

1.5.5 Running a Java Swing Program

When you run a Java Swing Program, there is typically no console output.        Figure 1.11: Compiling and Run-
You only see your output in the Window (JFrame) that your Graphics are          ning the HelloWorld.java con-
displayed in. This makes automated testing more difficult since you need        sole application program.
to visually inspect that the program is working correctly.
                                                                               
   When you run
                                                                               
 

    java HelloWorldSwing
 

A window will open, and you won't be able to type in the console until
you close the window, quit the program, or type ctl-c to send a kill signal
to the Swing program. The result of running, as shown in Figure 1.12,
                                     52  CHAPTER 1  Java Program Design and Development

                                     is that the "Hello, World!" message will be displayed within it's own
                                     window.

                                     1.6 From the Java Library: System and
                                           PrintStream

java.sun.com/j2se/1.5.0/docs/api/    Java comes with a library of classes that can be used to perform common
                                     tasks. The Java class library is organized into a set of packages, where each
Figure 1.12:        Running          package contains a collection of related classes. Throughout the book we
                                     will identify library classes and explain how to use them. In this section
HelloWorldSwing.java                 we introduce the System and PrintStream classes, which are used for
                                     printing a program's output.
graphical program.
                                        Java programs need to be able to accept input and to display output.
                                     Deciding how a program will handle input and output (I/O) is part of
                                     designing its user interface, a topic we take up in detail in Chapter 4. The
                                     simplest type of user interface is a command-line interface, in which input
                                     is taken from the command line through the keyboard, and output is dis-
                                     played on the console. Some Java applications use this type of interface.
                                     Another type of user interface is a Graphical User Interface (GUI), which
                                     uses buttons, text fields, and other graphical components for input and
                                     output. Java applets use GUIs as do many Java applications. Because we
                                     want to be able to write programs that generate output, this

                                        section describes how Java handles simple console output.
                                        In Java, any source or destination for I/O is considered a stream of bytes
                                     or characters. To perform output, we insert bytes or characters into the
                                     stream. To perform input, we extract bytes or characters from the stream.
                                     Even characters entered at a keyboard, if considered as a sequence of
                                     keystrokes, can be represented as a stream.
                                        There are no I/O statements in the Java language. Instead, I/O is han-
                                     dled through methods that belong to classes contained in the java.io
                                     package. We have already seen how the output method println()
                                     is used to output a string to the console. For example, the following
                                     println() statement

                                                                                                                    

                                         System . out . p r i n t l n ( " Hello , World" ) ;
                                                                                                                    

                    PrintStream      prints the message "Hello, World" on the Java console. Let's now exam-
                                     ine this statement more carefully to see how it makes use of the Java I/O
        +print(in data : String)     classes.
        +print(in data : boolean)
        +print(in data : int)           The java.io.PrintStream class is Java's printing expert, so to
        +println(in data : String)   speak. It contains a variety of print() and println() methods that
        +println(in data : boolean)  can be used to print all of the various types of data we find in a Java pro-
        +println(in data : int)      gram. A partial definition of PrintStream is shown in Figure 1.13. Note
                                     that in this case the PrintStream class has no attributes, just operations
Figure 1.13: A UML class diagram     or methods.
of the PrintStream class.
                                        Because the various print() and println() methods are instance
                                     methods of a PrintStream object, we can only use them by finding a
SECTION 1.6  From the Java Library: System and PrintStream 53

PrintStream object and "telling" it to print data for us. As shown in        
Figure 1.15, Java's java.lang.System class contains three predefined
streams, including two PrintStream objects. This class has public (+)           System
attributes. None of its public methods are shown here.
                                                                                +out : PrintStream
   Both the System.out and System.err objects can be used to write
output to the console. As its name suggests, the err stream is used            +err : PrintStream
primarily for error messages, whereas the out stream is used for other
printed output. Similarly, as its name suggests, the System.in object can       +in : InputStream
be used to handle input, which will be covered in Chapter 2.
                                                                             
   The only difference between the print() and println() methods
is that println() will also print a carriage return and line feed after      쯊igure 1.14: The System class.
printing its data, thereby allowing subsequent output to be printed on a
new line. For example, the following statements

 

    System . out . print ( " hello " ) ;
    System . out . println ( " hello again" ) ;
    System . out . println ( "goodbye" ) ;
 

would produce the following output:

 

    hellohello again
    goodbye
 

Now that we know how to use Java's printing expert, let's use it to "sing"
a version of "Old MacDonald Had a Farm." As you might guess, this
program will simply consist of a sequence of System.out.println()
statements each of which prints a line of the verse. The complete Java
application program is shown in Figure 1.15.

                                                                           

public c l a s s OldMacDonald
{

  public s t a t i c void main ( S t r i n g args [ ] )

// Main method

     {

  System . out . p r i n t l n ( "Old MacDonald had a farm" ) ;

  System . out . println ( "E I E I O. " ) ;

  System . out . p r i n t l n ( "And on h i s farm he had a duck . " ) ;

  System . out . println ( "E I E I O. " ) ;

  System . out . p r i n t l n ( "With a quack quack here . " ) ;

  System . out . p r i n t l n ( "And a quack quack t h e r e . " ) ;

  System . out . println ( "Here a quack , there a quack , " ) ;

  System . out . println ( "Everywhere a quack quack . " ) ;

  System . out . p r i n t l n ( "Old MacDonald had a farm" ) ;

  System . out . println ( "E I E I O. " ) ;

  } // End o f main

} // End o f OldMacDonald

                                                                           

  Figure 1.15: The OldMacDonald.java class.

   This example illustrates the importance of using the Java class library.
If there's a particular task we want to perform, one of the first things we
                 54  CHAPTER 1  Java Program Design and Development

                 should ask is whether there is already an "expert" in Java's class library
                 that performs that task. If so, we can use methods provided by the expert
                 to perform that particular task.

                 JAVA EFFECTIVE DESIGN Using the Java Library. Learning how to
                 use classes and objects from the Java class library is an important part
                 of object-oriented programming in Java.

**********       SELF-STUDY EXERCISES
* ** ** *
* ** *           EXERCISE 1.3 One good way to learn how to write programs is to
** **            modify existing programs. Modify the OldMacDonald class to "sing"
* **** *         one more verse of the song.
**********
                 EXERCISE 1.4 Write a Java class that prints the design shown on the
                 left.

CHAPTER SUMMARY  Technical Terms

                 algorithm            declaration statement  parameter
                 applet               default constructor    primitive data type
                 application program  executable statement   pseudocode
                 assignment           expression             qualified name
                                      identifier             semantics
                    statement         literal value          statement
                 comment              object instantiation   stepwise refinement
                 compound statement   operator               syntax
                                      package
                    (block)
                 data type

                 Summary of Important Points

                  Good program design requires that each object and method have a
                    well-defined role and clear definition of what information is needed
                    for the task and what results will be produced.

                  Good program design is important; the sooner you start coding, the
                    longer the program will take to finish. Good program design strives
                    for readability, clarity, and flexibility.

                  Testing a program is very important and must be done with care, but it
                    can only reveal the presence of bugs, not their absence.

                  An algorithm is a step-by-step process that solves some problem. Al-
                    gorithms are often described in pseudocode, a hybrid language that
                    combines English and programming language constructs.

                  A syntax error occurs when a statement breaks a Java syntax rules. Syn-
                    tax errors are detected by the compiler. A semantic error is an error in
                    the program's design and cannot be detected by the compiler.

                  Writing Java code should follow the stepwise refinement process.
CHAPTER 1  Chapter Summary  55

 Double slashes (//) are used to make a single-line comment. Com-
  ments that extend over several lines must begin with /* and end with
  */.

 An identifier must begin with a letter of the alphabet and may consist
  of any number of letters, digits, and the special characters and $. An
  identifier cannot be identical to a Java keyword. Identifiers are case
  sensitive.

 A keyword is a term that has special meaning in the Java language
  (Table 1.1).

 Examples of Java's primitive data types include the int, boolean, and
  double types.

 A variable is a named storage location. In Java, a variable must be
  declared before it can be used.

 A literal value is an actual value of some type, such as a String
  ("Hello") or an int (5).

 A declaration statement has the form: Type VariableName ;
 An assignment statement has the form:VariableName = Expression ;

  When it is executed it determines the value of the Expression on the
  right of the assignment operator (=) and stores the value in the variable
  named on the left.
 Java's operators are type dependent, where the type is dependent on
  the data being manipulated. When adding two int values (7 + 8), the
  + operation produces an int result.
 A class definition has two parts: a class header and a class body. A
  class header takes the form of optional modifiers followed by the word
  class followed by an identifier naming the class followed, optionally,
  by the keyword extends and the name of the class's superclass.
 There are generally two kinds of elements declared and defined in the
  class body: variables and methods.
 Object instantiation is the process of creating an instance of a class using
  the new operator in conjunction with one of the class's constructors.
 Dot notation takes the form qualifiers.elementName. The expression
  System.out.print("hello") uses Java dot notation to invoke the
  print() method of the System.out object.
 A Java application program runs in stand-alone mode. A Java applet is
  a program that runs within the context of a Java-enabled browser. Java
  applets are identified in HTML documents by using the <applet> tag.
 A Java source program must be stored in a file that has a .java exten-
  sion. A Java bytecode file has the same name as the source file but a
  .class extension. It is an error in Java if the name of the source file is
  not identical to the name of the public Java class defined within the file.
 Java programs are first compiled into bytecode and then interpreted by
  the Java Virtual Machine (JVM).
                      56              CHAPTER 1  Java Program Design and Development

SOLUTIONS TO          SOLUTION 1.1 The value 12 is stored in num.
SELF-STUDY EXERCISES
                      SOLUTION 1.2 int num2 = 711 + 712;

                      SOLUTION 1.3 The definition of the OldMacDonald class is:

                                                                                                     

                      public c l a s s OldMacDonald
                      {

                          public s t a t i c void main ( S t r i n g args [ ] )

                      // Main method

                           {

                          System . out . p r i n t l n ( "Old MacDonald had a farm" ) ;
                          System . out . println ( "E I E I O. " ) ;
                          System . out . p r i n t l n ( "And on h i s farm he had a duck . " ) ;
                          System . out . println ( "E I E I O. " ) ;
                          System . out . p r i n t l n ( "With a quack quack here . " ) ;
                          System . out . p r i n t l n ( "And a quack quack t h e r e . " ) ;
                          System . out . println ( "Here a quack , there a quack , " ) ;
                          System . out . println ( "Everywhere a quack quack . " ) ;
                          System . out . p r i n t l n ( "Old MacDonald had a farm" ) ;
                          System . out . println ( "E I E I O. " ) ;

                          System . out . p r i n t l n ( "Old MacDonald had a farm" ) ;

                          System . out . println ( "E I E I O. " ) ;

                          System . out . p r i n t l n ( "And on h i s farm he had a pig . " ) ;

                          System . out . println ( "E I E I O. " ) ;

                          System . out . p r i n t l n ( "With an oink oink here . " ) ;

                          System . out . p r i n t l n ( "And an oink oink t h e r e . " ) ;

                          System . out . p r i n t l n ( "Here an oink , there an oink , " ) ;

                          System . out . p r i n t l n ( "Everywhere an oink oink . " ) ;

                          System . out . p r i n t l n ( "Old MacDonald had a farm" ) ;

                          System . out . println ( "E I E I O. " ) ;

                          } // End o f main

                      } // End o f OldMacDonald

                                                                                                     

                      SOLUTION 1.4 The definition of the Pattern class is:

                                                                                                     

                      public class Pattern
                      {

                          public s t a t i c void main ( S t r i n g args [ ] ) // Main m e t h o d

                          {

                             System . out . println ( "" ) ;

                             System . out . println ( "   " ) ;

                             System . out . println ( "  " ) ;

                             System . out . println ( "   " ) ;

                             System . out . println ( "  " ) ;

                             System . out . println ( "" ) ;

                          } // End o f main

                      } // End o f P a t t e r n

                                                                                                     
CHAPTER 1  Exercises                                                 57

EXERCISE 1.1 Fill in the blanks in each of the following statements.               EXERCISES

a. A Java class definition contains an object's  and .
b. A method definition contains two parts, a     and a .

EXERCISE 1.2 Explain the difference between each of the following pairs of
concepts.

a. Application and applet.
b. Single-line and multiline comment.
c. Compiling and running a program.
d. Source code file and bytecode file.
e. Syntax and semantics.
f. Syntax error and semantic error.
g. Data and methods.
h. Variable and method.
i. Algorithm and method.
j. Pseudocode and Java code.
k. Method definition and method invocation.

EXERCISE 1.3 For each of the following, identify it as either a syntax error or a
semantic error. Justify your answers.

a. Write a class header as public Class MyClass.
b. Define the init() header as public vid init().
c. Print a string of five asterisks by System.out.println("***");.
d. Forget the semicolon at the end of a println() statement.
e. Calculate the sum of two numbers as N - M.

EXERCISE 1.4 Suppose you have a Java program stored in a file named
Test.java. Describe the compilation and execution process for this program,
naming any other files that would be created.

EXERCISE 1.5 Suppose N is 15. What numbers would be output by the fol-
lowing pseudocode algorithm? Suppose N is 6. What would be output by the
algorithm in that case?

                                                                      

0. Print N.

1. If N equals 1 , stop .

2 . I f N i s even , divide i t by 2 .

3 . I f N i s odd , t r i p l e i t and add 1 .

4 . Go t o s t e p 0 .
                                                                      

EXERCISE 1.6 Suppose N is 5 and M is 3. What value would be reported by the
following pseudocode algorithm? In general, what quantity does this algorithm
calculate?

                                                                      

0 . Write 0 on a piece of paper .

1 . I f M equals 0 , report what ' s on the paper and stop .

2 . Add N t o t h e q u a n t i t y w r i t t e n on t h e paper .

3 . S u b t r a c t 1 from M.

4 . Go t o s t e p 1 .
                                                                      
58  CHAPTER 1  Java Program Design and Development

EXERCISE 1.7 Puzzle Problem: You are given two different length ropes that
have the characteristic that they both take exactly one hour to burn. However,
neither rope burns at a constant rate. Some sections of the ropes burn very fast;
other sections burn very slowly. All you have to work with is a box of matches
and the two ropes. Describe an algorithm that uses the ropes and the matches to
calculate when exactly 45 minutes have elapsed.

EXERCISE 1.8 Puzzle Problem: A polar bear that lives right at the North Pole
can walk due south for one hour, due east for one hour, and due north for one
hour, and end up right back where it started. Is it possible to do this anywhere
else on earth? Explain.

EXERCISE 1.9 Puzzle Problem: Lewis Carroll, the author of Alice in Wonder-
land, used the following puzzle to entertain his guests: A captive queen weighing
195 pounds, her son weighing 90 pounds, and her daughter weighing 165 pounds,
were trapped in a very high tower. Outside their window was a pulley and rope
with a basket fastened on each end. They managed to escape by using the baskets
and a 75-pound weight they found in the tower. How did they do it? The problem
is that anytime the difference in weight between the two baskets is more than 15
pounds, someone might get hurt. Describe an algorithm that gets them down
safely.

EXERCISE 1.10 Puzzle Problem: Here's another Carroll favorite: A farmer
needs to cross a river with his fox, goose, and a bag of corn. There's a rowboat
that will hold the farmer and one other passenger. The problem is that the fox will
eat the goose if they are left alone on the river bank, and the goose will eat the corn
if they are left alone on the river bank. Write an algorithm that describes how he
got across without losing any of his possessions.

EXERCISE 1.11 Puzzle Problem: Have you heard this one? A farmer lent the
mechanic next door a 40-pound weight. Unfortunately, the mechanic dropped
the weight and it broke into four pieces. The good news is that, according to the
mechanic, it is still possible to use the four pieces to weigh any quantity between
one and 40 pounds on a balance scale. How much did each of the four pieces
weigh? (Hint: You can weigh a 4-pound object on a balance by putting a 5-pound
weight on one side and a 1-pound weight on the other.)

EXERCISE 1.12 Suppose your little sister asks you to show her how to use a
pocket calculator so that she can calculate her homework average in her science
course. Describe an algorithm that she can use to find the average of 10 homework
grades.

EXERCISE 1.13 A Caesar cipher is a secret code in which each letter of the al-
phabet is shifted by N letters to the right, with the letters at the end of the alphabet
wrapping around to the beginning. For example, if N is 1, when we shift each
letter to the right, the word daze would be written as ebaf. Note that the z has
wrapped around to the beginning of the alphabet. Describe an algorithm that can
be used to create a Caesar encoded message with a shift of 5.

EXERCISE 1.14 Suppose you received the message, "sxccohv duh ixq," which
you know to be a Caesar cipher. Figure out what it says and then describe an
algorithm that will always find what the message said regardless of the size of the
shift that was used.

EXERCISE 1.15 Suppose you're talking to your little brother on the phone and
he wants you to calculate his homework average. All you have to work with is
a piece of chalk and a very small chalkboard--big enough to write one four-digit
number. What's more, although your little brother knows how to read numbers,
he doesn't know how to count very well so he can't tell you how many grades
there are. All he can do is read the numbers to you. Describe an algorithm that
will calculate the correct average under these conditions.
CHAPTER 1  Exercises                                                 59

EXERCISE 1.16 Write a header for a public applet named SampleApplet.

EXERCISE 1.17 Write a header for a public method named getName.

EXERCISE 1.18 Design a class to represent a geometric rectangle with a given
length and width, such that it is capable of calculating the area and the perimeter
of the rectangle.

EXERCISE 1.19 Modify the OldMacDonald class to "sing" either "Mary Had a
Little Lamb" or your favorite nursery rhyme.

EXERCISE 1.20 Define a Java class, called Patterns, modeled after OldMac-
Donald, that will print the following patterns of asterisks, one after the other
heading down the page:

                                                                      

     

      

      

      

     

                                                                      

EXERCISE 1.21 Write a Java class that prints your initials as block letters, as      ******  *   *
shown in the example in the margin.                                                  **
                                                                                     **      **  **
EXERCISE 1.22 Challenge: Define a class that represents a Temperature ob-            ******
ject. It should store the current temperature in an instance variable of type        **      ** **
double, and it should have two public methods, setTemp(double t), which              **
assigns t to the instance variable, and getTemp(), which returns the value of        **      * ** *
the instance variable. Use the Riddle class as a model.                              **
                                                                                             ***
EXERCISE 1.23 Challenge: Define a class named TaxWhiz that computes the
sales tax for a purchase. It should store the current tax rate as an instance                *   *
variable. Following the model of the Riddle class, you can initialize the rate
using a TaxWhiz() method. This class should have one public method,                          *   *
calcTax(double purchase), which returns a double, whose value is
purchases times the tax rate. For example, if the tax rate is 4 percent, 0.04, and           *   *
the purchase is $100, then calcTax() should return 4.0.

EXERCISE 1.24 What is stored in the variables num1 and num2 after the follow-
ing statements are executed?

   int num1 = 5;

   int num2 = 8;

   num1 = num1 + num2;

   num2 = nmm1 + num2;

EXERCISE 1.25 Write a series of statements that will declare a variable
of type int called num and store in it the difference between 61 and 51.

UML EXERCISES

EXERCISE 1.26 Modify the UML diagram of the Riddle class to con-
tain a method named getRiddle() that would return both the riddle's
question and answer.

EXERCISE 1.27 Draw a UML class diagram representing the follow-
ing class: The name of the class is Circle. It has one attribute, a
radius that is represented by a double value. It has one operation,
calculateArea(), which returns a double. Its attributes should be
designated as private and its method as public.
                                60  CHAPTER 1  Java Program Design and Development

                     Person     EXERCISE 1.28 To represent a triangle we need attributes for each of
              -name : String    its three sides and operations to create a triangle, calculate its area, and
              -phone : String   calculate its perimeter. Draw a UML diagram to represent this triangle.
              +printName()
              +printPhone()     EXERCISE 1.29 Try to give the Java class definition for the class de-
                                scribed in
Figure 1.16: The Person class.  the UML diagram shown in Figure 1.17.
Chapter 2

Objects: Using, Creating,
and Defining

OBJECTIVES

After studying this chapter, you will
 Be familiar with using variables to store and manipulate simple data.
 Be familiar with creating and using objects.
 Understand the relationship between classes and objects.
 Understand the difference between objects and data of primitive type.
 Understand the difference between static and and instance elements of a class.
 Be able to understand and design a simple class in Java.
 Understand some of the basic principles of object-oriented programming.

OUTLINE

2.1 Introduction
2.2 Using String Objects
2.3 Drawing Shapes with the Graphics Object (Optional)
2.4 Class Definition
2.5 Case Study: Simulating a Two-Person Game
2.6 From the Java Library: java.util.Scanner

         Special Topic: Alan Kay and the Smalltalk Language
          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                               61
                                   62  CHAPTER 2  Objects: Using, Creating, and Defining

                                   2.1 Introduction

                                   This chapter introduces some more of the basic principles of object-
                                   oriented programming. We begin by looking at some examples of creat-
                                   ing and using objects of type String and Graphics. Then, we examine
                                   how user defined classes are used by doing a detailed walk-through of the
                                   Riddle class we saw in Chapter 1. We focus on the basic Java language
                                   elements involved. By the end of these sections, you should know how to
                                   identify the key elements that make up a Java program.

                                      We then present a detailed example of the programming development
                                   process by designing a class that models a certain two person game and
                                   implements the class. The design is represented using UML notation.

                                   2.2 Using String Objects

Figure 2.1: A partial representa-  As we know, a Java program is a collection of interacting objects, where
tion of the String class.          each object is a module that encapsulates a portion of the program's at-
                                   tributes and actions. Objects belong to classes, which serve as templates
                                   or blueprints for creating objects. Think again of the cookie cutter analogy.
                                   A class is like a cookie cutter. Just as a cookie cutter is used to shape and
                                   create individual cookies, a class definition is used to shape and create
                                   individual objects.

                                      Programming in Java is primarily a matter of designing and defining
                                   class definitions, which are then used to construct objects. The objects
                                   perform the program's desired actions. To push the cookie cutter analogy
                                   a little further, designing and defining a class is like building the cookie
                                   cutter. Obviously, very few of us would bake cookies if we first had to
                                   design and build the cookie cutters. We'd be better off using a pre-built
                                   cookie cutter. By the same token, rather than designing our own classes,
                                   it will be easier to get into "baking" programs if we begin by using some
                                   predefined Java classes.

                                      The Java library contains many pre-defined classes that we will use in
                                   our programs. So let's begin our study of programming by using two of
                                   these classes, the String and Graphics classes.

                                   2.2.1 Creating and Combining Strings

                                   Strings are very useful objects in Java and in all computer programs. They
                                   are used for inputting and outputting all types of data. Therefore, it
                                   essential that we learn how to create and use String objects.

                                      Figure 2.1 provides an overview of a very small part of Java's String
                                   class. In addition to the two String() constructor methods, which are
                                   used to create strings, it lists several useful instance methods that can
                                   be used to manipulate strings. The String class also has two instance
                                   variables. One stores the String's value, which is a string of characters
                                   such as "Hello98", and the other stores the String's count, which is the
                                   number of characters in its string value.

                                      Recall from Chapter 0 that in order to get things done in a program we
                                   send messages to objects. The messages must correspond to the object's
                                   instance methods. Sending a message to an object is a matter of calling
                                   one of its instance methods. In effect, we use an object's methods to get the
SECTION 2.2  Using String Objects  63

object to perform certain actions for us. For example, if we have a String,               
named str and we want to find out how many characters it contains, we
can call its length() method, using the expression str.length(). If                       
we want to print str's length, we can embed this expression in a print                     Dot notation
statement:

 

    System . out . println ( s t r . length ( ) ) ; // P r i n t s t r ' s l e n g t h
 

In general, to use an object's instance method, we refer to the method in
dot notation by first naming the object and then the method:

objectName.methodName() ;

The objectName refers to a particular object, and the methodName() refers                 
to one of its instance methods.                                                           

   As this example makes clear, instance methods belong to objects, and in                쭲igure 2.2: A String object stores
order to use a method, you must first have an object that has that method.                 a sequence of characters and a
So, to use one of the String methods in a program, we must first create
a String object.                                                                          쯢ount giving the number of char-
                                                                                           acters.
   To create a String object in a program, we first declare a String
variable.                                                                                 
                                                                                          
 
                                                                                           Figure 2.3: The empty string has a
    String str ; // D e c l a r e a S t r i n g v a r i a b l e named s t r                value of "" and a its length is 0.
 

We then create a String object by using
   the new keyword in conjunction with one of the String() construc-

tors. We assign the new object to the variable we declared:

 

    s t r = new S t r i n g ( " H e l l o " ) ; // C r e a t e a S t r i n g o b j e c t
 

This example will create a String that contains, as its value, the word
"Hello" that is passed in by the constructor. The String object that this
creates is shown in Figure 2.2.

   We can also use a constructor with an empty parameter list. Note that
in this case we combine the variable declaration and the object creation into
one statement:

 

    S t r i n g s t r 2 = new S t r i n g ( ) ; // C r e a t e a S t r i n g
 

This example will create a String object that contains the empty string
as its value. The empty string has the literal value "" - that is, a pair of
double quotes that contain no characters. Because the empty string has no
characters, the count variable stores a zero (Fig. 2.3).

   Note that we use a constructor to assign an initial value to a variable of
type String (or of a type equal to any other class). This differs from how
we assign an initial value to variables of primitive type, for which we use
a simple assignment operator. This difference is related to an important
difference in the way Java treats these two types of variables. Variables
of primitive type are names for memory locations where values of prim-
itive type are stored. As soon as they are declared they are assigned a
default value of that primitive type. The default value for int is 0 and
64  CHAPTER 2  Objects: Using, Creating, and Defining

the default value for boolean is false. On the other hand, variables
that are declared to be of a type equal to a class name are designed to store
a reference to an object of that type. (A reference is also called a pointer
because it points to the memory address where the object itself is stored.)
A constructor creates an object somewhere in memory and supplies a ref-
erence to it that is stored in the variable. For that reason, variables that
are declared as a type equal to a class name are said to be variables of
reference type or reference variables. Reference variables have a special
default value called null after they are declared and before they are as-
signed a reference. It is possible to check whether or not a reference vari-
able contains a reference to an actual object by checking whether or not it
contains this null pointer.

   Once you have constructed a String object, you can use any of the
methods shown in Figure 2.1 on it. As we already saw, we use dot no-
tation to call one of the methods. Thus, we first mention the name of the
object followed by a period (dot), followed by the name of the method. For
example, the following statements print the lengths of our two strings:

                                                                               

    System . out . println ( s t r . length ( ) ) ;

    System . out . println ( str2 . length ( ) ) ;                             


   Another useful String method is the concat(String) method,
which can be used to concatenate two strings. This method takes a String
argument. It returns a String that combines the String argument to the
String that the method is called on. Consider this example:

                                                                               

    S t r i n g s1 = new S t r i n g ( " George " ) ;

    S t r i n g s2 = new S t r i n g ( " Washington " ) ;

    System . out . println ( s1 . concat ( s2 ) ) ;                            


In this case, the concat() method adds the String s2 to the end of the
String s1. The result, which gets printed, will be the String "George
Washington".

   Because strings are so important, Java allows a number of shortcuts
to be used when creating and concatenating strings. For example, you
don't have to use new String() when creating a new string object. The
following code will also work:

                                                                               

    String s1 = "George " ;

    String s2 = "Washington" ;
                                                                               

Similarly, an easier way to concatenate two String objects is to use the
plus sign (+), which serves as a concatenation operator in Java:

                                                                               

    System . out . println ( s1 + s2 ) ;                                       


   Another useful String method is the equals() method. This is
a boolean method, which is used to compare two Strings. If both
Strings have the same characters, in the same order, it will return true.
SECTION 2.2  Using String Objects                                         65

Otherwise it will return false. For example, consider the following code
segment:

                                                                               

  String s1 = "Hello" ;

  String s2 = "Hello" ;

  String s3 = "hello" ;
                                                                               

In this case, the expression s1.equals(s2) will be true, but s1.equals(s3)
will be false.

   It is important to note that the empty string is not the same as a String
variable that contains null. Executing the statements:

                                                                               

  String s1 ;

  String s2 = "" ;

  System . out . println ( s1 . equals ( s2 ) ) ;
                                                                               

will not only not print out true; it will cause the the program to terminate
abnormally. It is an error to use the method of a String variable, or any
other variable whose type is a class, before it has been assigned an object.
When the above code is executed, it will report a null pointer exception,
one of the most common runtime errors. When you see that error mes-
sage, it means that some method was executed on a variable that does not
refer to an object. On the other hand, the empty string is a perfectly good
String object which just happens to contain zero characters.

   Figure 2.4 shows a program that uses string concatenation to create

                                                                           

public class StringPuns
{

  public s t a t i c void main ( S t r i n g args [ ] )

  { S t r i n g s = new S t r i n g ( " s t r i n g " ) ;

  String s1 = s . concat ( " puns . " ) ;

  System . out . println ( "Here are the top 5 " + s1 ) ;

  S t r i n g s2 = " 5 . Hey baby , wanna " ;

  S t r i n g s3 = s + " along with me . " ;

  System . out . println ( s2 + s3 ) ;

  System . out . p r i n t l n ( " 4 . I ' ve got the world on a " +

                                                           s + ".");

  S t r i n g s4 = new S t r i n g ( "two" ) ;

  S t r i n g s5 = " . You have more c l a s s than a " ;

  System . out . print ( s4 . length ( ) ) ;

  System . out . println ( s5 + s + " of pearls . " ) ;

  System . out . print ( " 2. I t i s " ) ;

  System . out . print ( s . equals ( " string " ) ) ;

  System . out . p r i n t l n ( " t h a t I am no " + s + " bean . " ) ;

  String s6 = " quintet . " ;

  System . out . p r i n t l n ( " 1 . These puns form a " + s + s6 ) ;

  } // main ( )

} // S t r i n g P u n s c l a s s

                                                                           

  Figure 2.4: A program that prints silly string puns.
66     CHAPTER 2  Objects: Using, Creating, and Defining

some silly sentences. The programs declares a number of string variables,
named s, s1, and so on, and it instantiates a String object for each vari-
able to refer to. It then prints out a top-five list using the concatenation
operator to combine strings. Can you figure out what it prints without
running it?

SELF-STUDY EXERCISES

EXERCISE 2.1 What is the output to the console window when the
following Java code fragment is executed:

                                                                         

String s = "ing" ;

System . out . p r i n t l n ( "The s " + s + s + " k" + s + " . " ) ;
                                                                         

2.3 Drawing Shapes with a Graphics Object
      (Optional)

All of the instance methods of the String class that we examined return
values. The length() method return an int value, and the concat()
method returned a String. It is also very common for classes to define
instance methods that perform actions but do not return a value. The
Graphics object, g, that appears in Chapter 1's HelloWorldSwing is
one example. The program is reproduced in Figure 2.5

                                                                         

  / F i l e : H e l l o W o r l d S w i n g program /

import javax . swing . JFrame ; // I m p o r t c l a s s names
import java . awt . Graphics ;
import java . awt . Canvas ;

public class HelloWorldCanvas extends                  Canvas //  Class  header
{                                                      10 , 10);

         // S t a r t o f body

       public void paint ( Graphics g)

                  // The p a i n t method

       {
              g . drawString ( " Hello , World ! " ,

       } // End o f p a i n t

    public s t a t i c void main ( S t r i n g [ ] args ){

       HelloWorldCanvas c = new HelloWorldCanvas ( ) ;

       JFrame f = new JFrame ( ) ;

       f . add ( c ) ;

       f . setSize (150 ,50);

       f . setVisible ( true );

    }

} // End o f H e l l o W o r l d C a n v a s

                                                                         

       Figure 2.5: HelloWorldCanvas program source code.
SECTION 2.3  Drawing Shapes with a Graphics Object (Optional) 67

   At this point we will not worry about the language features that en-         
able the paint() method to draw on the Java Swing window. We                    
will focus instead on the information needed to make good use of the            
g.drawString() method. The first thing you should know is that, when            
the paint() method is executed, its parameter, g, refers to an instance of
the Graphics class. Unlike our other examples involving variables that           Figure 2.6: Coordinate system of a
refer to objects, in this case there is no need to use a constructor to create   Java window.
an object of type Graphics. We can assume g already refers to such an
object.                                                                         
                                                                                
   We already know that the statement

 

    g . drawString ( " Hello , World ! " , 1 0 , 1 0 ) ;
 

displays the String "Hello, World!" in the program window. More gen-
erally, if str is a literal String value or a reference to a String object
and x and y are literal int values or int variables then

 

    g . drawString ( str , x , y)
 

displays the String str from left to right in the program window be-
ginning at a point which is x pixels from the left edge of the window and
y pixels down from the top edge of the window. In a graphics window,
the point with coordinates (0,0) is at the top-left corner. The horizontal
axis grows positively from left to right. The vertical axis grows positively
from top to bottom (Fig. 2.6).

   (A pixel is a dot on the console window that can be set to a certain
color.) Notice that increasing the value of y will cause str to be displayed
lower. This is the opposite of the usual x and y coordinate system used in
mathematics where increasing the y value designates a higher point.

   With this information about g.drawString(), we can calculate
where to display any message in the program window. For example, if
we wish to display the message "Welcome to Java" 25 pixels below where
"Hello, World!" is displayed we could use the statements

 

    g . drawString ( " Hello , World ! " , 1 0 , 1 0 ) ;
    g . drawString ( "Welcome t o Java " , 1 0 , 3 5 ) ;
 

in the body of HelloWorldCanvas's paint() method. The result of
these statements would appear as shown in Figure 2.7.

2.3.1 Graphics Drawing Methods

The Graphics class discussed in the previous section also has methods
that can be used to draw geometric shapes in different colors. These meth-
ods can be used to create graphical user interfaces that are more interest-
ing or to give a visual representation of data, such as a pie chart or a bar
graph.

   There are two Graphics methods for drawing rectangles, fillRect()
and drawRect() (Fig. 2.8). The first draws a rectangle and fills it with the
current drawing color and the second just draws the outline of the rectan-
gle. Using the Graphics object, g, each of these is called in the same way
                                 68  CHAPTER 2  Objects: Using, Creating, and Defining

                                                                                                             Figure 2.7

                                                                                                             drawn at

                                                                                                             "Welcome

                                                                                                             the JFram

                                 as the drawString() method from the previous example. Each of these
                                 methods takes four int arguments, which specify the rectangle's location
                                 and size. Thus, a call to fillRect() would take the form

                                                                                                             

                                     g . f i l l R e c t ( x , y , width , height ) ;
                                                                                                             

Figure 2.8: Some of the drawing  where x and y arguments specify the location of the upper left corner of
methods in the Graphics class.   the rectangle as being x pixels from the left edge of the window and y
                                 pixels down from the top edge of the window. The width and height
                                 arguments specify the width and height of the rectangle in pixels. The
                                 drawRect() method also takes the same four arguments.

                                    A Graphics object stores a single color for use in drawing shapes or
                                 displaying strings with drawString(). If we wish to draw an interesting
                                 scene in the JFrame, we need to understand how to use colors.

                                    For a given Graphics object, such as g, the setColor() method will
                                 set its color for all subsequent drawing commands. The setColor()
                                 method takes, as an argument, an object of type Color. All we need
                                 to know about the Color class is that it is contained in the java.awt
                                 package and that it contains 13 constant Color objects corresponding to
                                 13 common colors. Table 2.1 lists the 13 Color constants. Each name
                                 corresponds to the color it will represent in the program.

                                     Color.black     Color.green                       Color.red
                                     Color.blue      Color.lightGreen                  Color.white
                                     Color.cyan      Color.magenta                     Color.yellow
                                     Color.darkGray  Color.orange
                                     Color.gray      Color.pink

                                     Table 2.1: Predefined color constants in the Color class.

                                    To demonstrate how the new Graphics methods can be used for cre-
                                 ating more interesting graphical programs, let's develop a plan for dis-
                                 playing the two messages, "Hello, World!" and "Welcome to Java.", on
                                 an JFrame, but this time we will draw the first inside a colored rectan-
                                 gle and the second inside a colored oval. For the rectangle, let's use the
SECTION 2.4  Class Definition                       69

drawRect() method to create its border. We can choose some arbitrary
colors, say, cyan for filling the rectangle, blue for its border, and black
for the string itself. In order to have the message visible we should fill a
rectangle with the color cyan first, then draw the border of the rectangle
in blue and, finally, display the message in black.

   Drawing and filling a Graphics oval is very similar to drawing
and filling a rectangle. Notice in Figure 2.8 that the fillOval() and
drawOval() methods take the same four arguments as the correspond-
ing rectangle methods. An oval is inscribed within an enclosing rectangle.
The x and y arguments give the coordinates of the enclosing rectangle's
top left point. And the width and height arguments give the enclosing
rectangles dimensions.

   All that remains is to choose the location and dimensions of the rect-
angles. We could specify one rectangle as having its upper left corner 25
pixels to the right of the left edge of the JFrame and 25 pixels down from
the top edge. A medium sized rectangle could have a width of 140 pixels
and a height of 40 pixels. The statement

                                                                                  

g. fillRect (25 , 25 , 140 , 40);
                                                                                  

will fill this rectangle with whatever color happens to be g's current color.
A location 25 pixels to the right of the left edge of the rectangle and 25
pixels down from the top edge of the rectangle would have coordinates
x = 50 and y = 50. Thus, the statement

                                                                                  

g . drawString ( " Hello , World ! " , 50 , 5 0 ) ;                               


will display "Hello, World!" inside the rectangle. We can use similar
planning to locate the oval and its enclosed message.

   Thus, we now have sufficient information to finish the paint()
method for accomplishing our plan. The completed program is displayed
in Figure 2.9. Note how we repeatedly use the g.setColor() method to
change g's current color before drawing each element of our picture.

   Figure 2.10 shows what this program looks like. To experiment with
this Java Swing application, download its sourcecode from the book's Web
site and compile and run it on your computer. Additional drawing capa-
bilities will be explored throughout the text in sections that can either be
covered or skipped.

2.4 Class Definition

To program in Java the main thing you do is write class definitions for the       The class as template
various objects that will make up the program. A class definition encapsu-        Variables and methods
lates its objects' data and behavior. Once a class has been defined, it serves
as a template, or blueprint, for creating individual objects or instances of the
class.

   A class definition contains two types of elements: variables and meth-
ods. Variables are used to store the object's information. Methods are used
                                 70                   CHAPTER 2        Objects: Using, Creating, and Defining
                                                                                                                         
                                          java . awt .  ;
                                  import  javax . swing . JFrame ;
                                  import

                                public class HelloWorldGraphic extends Canvas
                                {

                                  // c a l l e d a f t e r s e t V i s i b l e ( t r u e )

                                  public void paint ( Graphics g) {

                                          g . setColor ( Color . cyan ) ;                   // S e t c o l o r

                                          g . f i l l R e c t (25 , 25 , 140 , 40); // F i l l r e c t a n g l e

                                          g . setColor ( Color . blue ) ;                   // S e t c o l o r

                                          g . drawRect (25 , 25 , 140 , 4 0 ) ; // O u t l i n e r e c t a n g l e

                                          g . setColor ( Color . black ) ;                  // S e t c o l o r

                                          g . drawString ( " Hello , World ! " , 50 , 5 0 ) ; // D i s p l a y      string

                                          g . setColor ( Color . yellow ) ;

                                          g . fillOval (25 , 75 , 140 , 40); // F i l l o v a l

                                          g . setColor ( Color . red ) ;

                                          g . drawOval ( 2 5 , 75 , 140 , 4 0 ) ; // O u t l i n e o v a l

                                          g . setColor ( Color . black ) ;

                                          g . drawString ( "Welcome t o Java " , 5 0 , 1 0 0 ) ;

                                  }// p a i n t ( )

                                  // t h e program

                                  public s t a t i c void main ( S t r i n g [ ] args ){

                                          HelloWorldCanvas c = new HelloWorldCanvas ( ) ;

                                          JFrame f = new JFrame ( ) ;

                                          f . add ( c ) ;

                                          f . setSize (150 ,50);

                                          f . setVisible ( true );

                                  }

                                } // H e l l o W o r l d G r a p h i c

                                                                                                                    

                                Figure 2.9: The HelloWorldGraphic class is a Java Swing program that
                                shows how to use color and drawing methods.

Figure 2.11: The Riddle class.  to process the information. To design an object you need to answer five
                                basic questions:

                                   1. What role will the object perform in the program?
                                   2. What data or information will it need?
                                   3. What actions will it take?
                                   4. What interface will it present to other objects?
                                   5. What information will it hide from other objects?

                                2.4.1 The Riddle Class

                                Recall our definition of the Riddle class from Chapter 1, which is sum-
                                marized in the UML diagram in Figure 2.11. A Riddle has two attributes,
                                question and answer. Each of these variables stores a string of charac-
                                ters, which Java treats as data of type String. The Riddle class contains
                                three methods. The Riddle() constructor method assigns initial values
                                (q and a) to its question and answer variables. The getQuestion()
                                and getAnswer() methods return the data stored in question ands
                                answer respectively.
                 SECTION 2.4  Class Definition                                         71

This is how the

raphic program

run.

                    The instance variables question and answer are designated as
                 private (-), but the Riddle(), getQuestion() and getAnswer()
                 methods are designated as public (+). These designations follow two
                 important object-oriented design conventions, whose justification will be-
                 come apparent as we discuss the Riddle class:

                  JAVA EFFECTIVE DESIGN Private Variables. Instance variables are
                  usually declared private so that they cannot be directly accessed by
                  other objects.

                 JAVA EFFECTIVE DESIGN Public Methods. An object's public
                 methods can be used by other objects to interact with the object. The
                 public methods and variables of an object make up its interface.

                    Figure 2.12 shows the Java class definition that corresponds to the de-       Access modifier
                 sign given in the UML diagram. It contains the two private instance              Class as blueprint
                 variables and defines the three public methods listed in the UML dia-
                 gram. In a Java class definition, access to a class element, such as a vari-
                 able or a method, is controlled by labeling it with either the private, or
                 public access modifier. An access modifier is a declaration that controls
                 access to a class or one of its elements. Note also that the Riddle class
                 itself is declared public. This lets other classes have access to the class
                 and to its public variables and methods.

                    Recall that a class is like a blueprint or a cookie cutter. The Riddle class
                 defines the type of information (attributes) that each individual Riddle
                 has, but it doesn't contain any actual values. It defines the methods (op-
                 erations) that each Riddle can perform, but it doesn't actually perform
                 the methods. In short, a class serves as a template, providing a detailed
                 blueprint of the objects (or instances) of that class.
                                   72  CHAPTER 2  Objects: Using, Creating, and Defining

                                                                                                       

                                   public class Riddle          // I n s t a n c e  variables
                                   { private String question ;

                                      private String answer ;

                                       public Riddle ( String q , String a ) // C o n s t r u c t o r
                                       { question = q;

                                          answer = a ;
                                       } // R i d d l e c o n s t r u c t o r

                                       public String getQuestion ( ) // I n s t a n c e method
                                       { return question ;
                                       } // g e t Q u e s t i o n ( )

                                       public String getAnswer ( ) // I n s t a n c e method

                                       { return answer ;

                                       } // getAnswer ( )

                                   } // R i d d l e c l a s s

                                                                                                       

                                       Figure 2.12: Definition of the Riddle class.

User interface                     2.4.2 The RiddleUser Class

Figure 2.13: The user interfaces   Now that we have defined the Riddle class, we can test that it works
handles interaction between the    correctly by creating Riddle objects and "asking" them to tell us their
user and the rest of the program.  riddles. To do this we need to define a main() method, which can be
                                   defined either within the Riddle class itself or in a second class named
                                   something like RiddleUser.

                                      One advantage of using a second class is that it gets us in the habit of
                                   thinking about the need for a separate class to serve as a user interface,
                                   with a separate set of tasks from the Riddle class. A user interface is an
                                   object or class that handles the interaction between a program's user and
                                   the rest of the program's computational tasks. This concept is illustrated
                                   in Figure 2.13. Note that we use the general term computational object to
                                   distinguish the rest of the program's computations from the user interface.
                                   Obviously, the exact nature of the computation will vary from program to
                                   program, just as will the details of the user interface. The computation
                                   done by our Riddle class is just the storing and displaying of a riddle's
                                   question and answer.

                                      By separating user interface tasks from riddle tasks this design em-
                                   ploys the divide-and-conquer principle: the RiddleUser class will cre-
                                   ate Riddle objects and handle interactions with the user, and the Riddle
                                   class will handle the storing and transmission of riddle information. Thus,
                                   as shown in Figure 2.14, this particular Java program will involve inter-
                                   action between two types of objects: a RiddleUser and one or more
                                   Riddles. Note that we characterize the relationship between Riddle
                                   and RiddleUser with a one-way arrow labeled "Uses." This is because
                                   the RiddleUser will create an instance of Riddle and use its methods
                                   to display (for the user) a riddle.

                                      Because almost all of our programs will involve some form of a user in-
                                   terface, we can generalize this design approach and follow it throughout
                                   the book. One way to think about this approach is as a division of labor
                    SECTION 2.4  Class Definition                                          73

his UML class di-

nts an association

RiddleUser and

. The Riddle-

use one or more

iddle class.

                    between a user interface class and a second computational class, which per-
                    forms whatever computations are needed by the particular program. In
                    this case the computations are the simple Riddle methods that we have
                    defined. In subsequent programs the computations will become more
                    complex, which will make all the more clear that they should be separated
                    from the user interface.

                    2.4.3 Object Instantiation: Creating Riddle Instances

                    Figure 2.15 shows the complete definition of the RiddleUser class,
                    which serves as a very simple user interface. It creates two Riddle ob-
                    jects, named riddle1 and riddle2. It then asks each object to request
                    each riddle's question and answer and displays them on the console.

                                                                                                         

                    public class RiddleUser
                    {

                      public s t a t i c void main ( S t r i n g argv [ ] )

                      { Riddle r i d d l e 1 = new Riddle (

                      "What i s b l a c k and white and red a l l over ? " ,

                      "An embarrassed zebra . " ) ;

                      Riddle r i d d l e 2 = new Riddle (

                      "What i s b l a c k and white and read a l l over ? " ,

                      "A newspaper . " ) ;

                      System . out . p r i n t l n ( "Here are two r i d d l e s : " ) ;

                      System . out . println ( riddle1 . getQuestion ( ) ) ;

                      System . out . println ( riddle2 . getQuestion ( ) ) ;

                      System . out . p r i n t l n ( "The answer to the f i r s t r id d le i s : " ) ;

                      System . out . println ( riddle1 . getAnswer ( ) ) ;

                      System . out . p r i n t l n ( "The answer to the second i s : " ) ;

                      System . out . println ( riddle2 . getAnswer ( ) ) ;

                      } // main ( )

                    } // R i d d l e U s e r

                                                                                                         

                                              Figure 2.15: The RiddleUser class.
             74  CHAPTER 2  Objects: Using, Creating, and Defining

             Let's now discuss the statements that make up RiddleUser's main()
             method. The following statements use the Riddle() constructor to cre-
             ate, or instantiate, two instances of the Riddle class:

                                                                                          

                 Riddle r i d d l e 1 = new Riddle (

                 "What i s b l a c k and white and red a l l over ? " ,

                 "An embarrassed zebra . " ) ;

                 Riddle r i d d l e 2 = new Riddle (

                 "What i s b l a c k and white and read a l l over ? " ,

                 "A newspaper . " ) ;                                                     

             Note how the constructor gives each object a pair of Strings that serve
             as the values of their two instance variables. Each object has its own
             question and its own answer, and each object has its own unique name,
             riddle1 and riddle2.

             2.4.4 Interacting with Riddles

             Once we have created Riddle instances with values assigned to their
             question and answer instance variables, we can ask each riddle to tell
             us either of its values. The following expression is an example of a method
             call:

                                                                                          

                 riddle1 . getQuestion ()
                                                                                          

Method call  Calling (or invoking) a method is a means of executing its code. The above
             method call just gets the String value that is stored in the question
             instance variable of riddle1.

             JAVA PROGRAMMING TIP Method Call versus Method
             Definition. Don't confuse method calls with method definitions. The
             definition specifies the method's actions. The method call takes those
             actions.

             If we want to display the value of riddle1's question, we can embed
             this method call within a println() statement

                                                                                          

                 System . out . println ( riddle1 . getQuestion ( ) ) ;
                                                                                          

             This tells the System.out object to execute its println() method,
             which displays the string given to it by riddle1 on the console. Thus,
             the output produced by this statement will be

                                                                                          

                 What i s b l a c k and white and red a l l over ?                        

             2.4.5 Define, Create, Use

             As our Riddle example illustrates, writing a Java program is a matter of
             three basic steps:

              Define one or more classes (class definition).
SECTION 2.4  Class Definition                                        75

 Create objects as instances of the classes (object instantiation).
 Use the objects to do tasks (object use).

The Java class definition determines what information will be stored in
each object and what methods each object can perform. Instantiation cre-
ates an instance and associates a name with it in the program. The ob-
ject's methods can then be called as a way of getting the object to perform
certain tasks.
76  CHAPTER 2  Objects: Using, Creating, and Defining

SELF-STUDY EXERCISES

EXERCISE 2.2 Identify the following elements in the Riddle class
(Fig. 2.12):

   The name of the class.
   The names of two instance variables.
   The names of three methods.

EXERCISE 2.3 Identify the following elements in the RiddleUser
class (Fig. 2.15):

   The names of two Riddle instances.
   All six method calls of the Riddle objects in the program.
   Two examples of qualified names.

2.5 CASE STUDY: Simulating a Two-Person
      Game

In this section, we will design and write the definition for a class that keeps
track of the details of a well known, two-person game. We will focus on
details of designing the definition of a class in the Java language. Our
objective is to understand what the program is doing and how it works
without necessarily understanding why it works the way it does. We will
get to "why" later in the book.

   The game we will consider is played by two persons with a row of
sticks or coins or other objects. The players alternate turns. A player must
remove one, two, or three sticks from the row on his or her turn. The
player who removes the last stick from the row loses. The game can be
played with any number of sticks but starting with twenty one sticks is
quite common. This game is sometimes referred to as the game of "Nim",
but there is a similar game involving multiple rows of sticks that is more
frequently given that name. Thus we will refer to this game as "One Row
Nim".

2.5.1 Designing a OneRowNim class

Problem Specification

Let's design a class named OneRowNim that simulates the game of One
Row Nim with a row of sticks. An object constructed with this class
should manage data that corresponds to having some specified number
of sticks when the game begins. It should keep track of whose turn it is
and it should allow a player to diminish the number of sticks remaining by
one, two, or three. Finally, a OneRowNim object should be able to decide
when the game is over and which player has won.

Problem Decomposition

Let's design OneRowNim so that it can be used in with different kinds of
user interfaces. One user interface could manage a game played by two
persons who alternately designate their moves to the computer. Another
user interface could let a human player play against moves made by the
 SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 77

computer. In either of these cases we could have a human player desig-
nate a move by typing from the keyboard after being prompted in a con-
sole window or, alternatively, by inputting a number into a text field or se-
lecting a radio button on a window. In this chapter, we will be concerned
only with designing an object for managing the game. We will design user
interfaces for the game in subsequent chapters.

Class Design: OneRowNim                                                        What data do we need?

As we saw in the Riddle example, class definitions can usually be broken
down into two parts: (1) the information or attributes that the object needs
which must be stored in variables, and (2) the behavior or actions the ob-
ject can take which are defined in methods. In this chapter, we will focus
on choosing appropriate instance variables and on designing methods as
blocks of reusable code. Recall that a parameter is a variable that tem-
porarily stores data values that are being passed to a method when that
method is called. In this chapter, we will restrict our design to methods
that do not have parameters and do not return values. We will return to
the problem of designing changes to this class in the next chapter after an
in-depth discussion of method parameters and return values.

   The OneRowNim object should manage two pieces of information that
vary as the game is played. One is the number of sticks remaining in the
row and the other is which player has the next turn. Clearly, the number
of sticks remaining corresponds to a positive integer that can be stored in
a variable of type int. One suitable name for such a variable is nSticks.
For this chapter, let us assume that the game starts with 7 sticks, rather
than 21, to simplify discussion of the program.

   Data designating which player takes the next turn could be stored in
different ways. One way to do this is to think of the players as player one
and player two and store a 1 or 2 in an int variable. Let's use player as
the name for such a variable and assume that player one has the first turn.

   The values of these two variable for a particular OneRowNim object at a
particular time describes the object's state. An object's state at the begin-
ning of a game is a 7 stored in nSticks and 1 stored in player. After
player one removes, say, two sticks on the first turn, the values 5 and 2
will be stored in the two variables.

Method Decomposition                                                           What methods do we need?

Now that we have decided what information the OneRowNim object
should manage, we need to decide what actions it should be able to per-
form. We should think of methods that would be needed to communicate
with a user interface that is both prompting some human players as well
as receiving moves from them. Clearly, methods are needed for taking a
turn in the game. If a message to a OneRowNim object has no argument
to indicate the number of sticks taken, there will need to be three meth-
ods corresponding to taking one, two, or three sticks. The method names
takeOne(), takeTwo(), and takeThree() are descriptive of this ac-
tion. Each of these methods will be responsible for reducing the value of
nSticks as well as changing the value of player.
                                  78     CHAPTER 2  Objects: Using, Creating, and Defining

Figure 2.16: A UML class diagram     We should also have a method that gives the information that a user
for OneRowNim.                    needs when considering a move. Reporting the number of sticks remain-
                                  ing and whose turn it is to the console window would be an appropriate
                                  action. We can use report() as a name for this action.

                                     Figure 2.16 is a UML class diagram that summarizes this design of the
                                  OneRowNim class. Note that the methods are declared public (+) and
                                  will thereby form the interface for a OneRowNim object. These will be the
                                  methods that other objects will use to interact with it. Similarly, we have
                                  followed the convention of designating an object's instance variables--the
                                  OneRowNim's instance variables--be kept hidden from other objects, and
                                  so we have designated them as private(-).

                                  2.5.2 Defining the OneRowNim Class

                                  Given our design of the OneRowNim class as described in Figure 2.16,
                                  the next step in building our simulation is to begin writing the Java class
                                  definition.

                                  The Class Header

                                  We need a class header, which will give the class a name and will spec-
                                  ify its relationship to other classes. Like all classes that are designed to
                                  create objects that could be used by other objects or classes, the class
                                  OneRowNim should be preceded by the public modifier. Because the
                                  class OneRowNim has not been described as having any relationship to
                                  any other Java class, its header can omit the extends clause so it will
                                  be a direct subclass of Object (Figure 2.17). Thus, the class header for
                                  OneRowNim will look like:

                                                                                                                 

Figure 2.17:    By default,           public c l a s s OneRowNim  // C l a s s h e a d e r
OneRowNim is  a subclass of           {                           // B e g i n n i n g o f c l a s s body
Object.
                                      }                           // End o f c l a s s body

                                                                                                                 

Variables and methods             The Class's Instance Variables
Class-level vs. local variables
                                  The body of a class definition consists of two parts: the class-level vari-
                                  ables and the method definitions. A class-level variable is a variable
                                  whose definition applies to the entire class in which it is defined. Instance
                                  variables, which were introduced in Chapter 1, are one kind of class-level
                                  variable.

                                     In general, a class definition will take the form shown in Figure 2.18.
                                     Although Java does not impose any particular order on variable and
                                  method declarations, in this book we'll define the class's class-level vari-
                                  ables at the beginning of the class definition, followed by method defini-
                                  tions. Class-level variables are distinguished from local variables. A local
                                  variable is a variable that is defined within a method. Examples would
                                  be the variables q and a that were defined in the Riddle(String q,
                                  String a) constructor (Fig. 2.12). As we will see better in Chapter 3,
                                  Java handles each type of variable differently.
                                     A declaration for a variable at class level must follow the rules for
                                  declaring variables that were described in Section 1.4.8 with the added
SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 79

                                                                          

public c l a s s ClassName
{ // I n s t a n c e and c l a s s v a r i a b l e s

         VariableDeclaration1
         VariableDeclaration2
         ...

       // I n s t a n c e and c l a s s methods

       MethodDefinition1

       MethodDefinition2

       ...

} // End o f c l a s s

                                                                          

       Figure 2.18: A template for constructing a Java class definition.

restriction that they should be modified by one of the access modifiers
public, private, or protected. The rules associated with these access
modifiers are:

     A private class-level variable cannot be accessed outside the class
       in which it is declared.

     A public class-level variable can be referenced and, hence, modi-
       fied by any other class.

     A protected class-level variable can only be accessed by sub-
       classes of the class in which it is declared or by other classes that
       belong to the same package.

When a class, instance variable, or method is defined, you can declare it
public, protected, or private. Or you can leave its access unspeci-
fied, in which case Java's default accessibility will apply.

   Java determines accessibility in a top-down manner. Instance vari-
ables and methods are contained in classes, which are contained in pack-
ages. To determine whether a instance variable or method is accessible,
Java starts by determining whether its containing package is accessible,
and then whether its containing class is accessible. Access to classes, in-
stance variables, and methods is defined according to the rules shown in
Table 2.2.

TABLE 2.2 Java's accessibility rules.

Element             Modifier    Rule

Class               public      Accessible if its package is accessible.
                    by default  Accessible only within its package.

Instance variable   public      Accessible to all other objects.
   or               protected   Accessible to its subclasses and to
   instance method
                    private        other classes in its package.
                    by default  Accessible only within the class.
                                Accessible only within the package.

   Recall the distinction we made in Chapter 0 between class variables
and instance variables. A class variable is associated with the class it-
80  CHAPTER 2  Objects: Using, Creating, and Defining

self, whereas an instance variable is associated with each of the class's in-
stances. In other words, each object contains its own copy of the class's in-
stance variables, but only the class itself contains the single copy of a class
variable. To designate a variable as a class variable it must be declared
static.

   The Riddle class that we considered earlier has the following two
examples of valid declarations of instance variables:

                                                                                 

    private String question ;

    private String answer ;
                                                                                 

Class Level Variables for OneRowNim

Let's now consider how to declare the class level variables for the
OneRowNim class. The UML class diagram for OneRowNim in Figure 2.16
contains all the information we need. The variables nSticks and player
will store data for playing one game of One Row Nim, so they should
clearly be private instance variables. They both will store integer values,
so they should be declared as variables of type int. Because we wish
to start a game of One Row Nim using 7 sticks with player one making
the first move, we will assign 7 as the initial value for nSticks and 1 as
the initial value for player. If we add the declarations for our instance
variable declarations to the class header for the OneRowNim class, we get
the following:

                                                                                 

    public c l a s s OneRowNim
    {

    private int nSticks = 7;
    private int player = 1;

    // Method d e f i n i t i o n s go h e r e

    } // OneRowNim

                                                                                 

   To summarize, despite its apparent simplicity, a class level variable
declaration actually accomplishes five tasks:

1. Sets aside a portion of the object's memory that can be used to store a
    certain type of data.

2. Specifies the type of data that can be stored in that location.
3. Associates an identifier (or name) with that location.
4. Determines which objects have access to the variable's name.
5. Assigns an initial value to the location.

OneRowNim's Methods

Designing and defining methods is a form of abstraction. By defining a
certain sequence of actions as a method, you encapsulate those actions
under a single name that can be invoked whenever needed. Instead of
having to list the entire sequence again each time you want it performed,
you simply call it by name. As you recall from Chapter 1, a method def-
inition consists of two parts, the method header and the method body.
SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 81

The method header declares the name of the method and other general
information about the method. The method body contains the executable
statements that the method performs.

                                                                             

p u b l i c void methodName ( ) // M e t h o d h e a d e r

{                   // B e g i n n i n g o f method body

}                   // End o f method body

                                                                             

The Method Header

The method header follows a general format that consists of one or
more MethodModifiers, the method's ResultType, the MethodName, and the
method's FormalParameterList, which is enclosed in parentheses. The fol-
lowing table illustrates the method header form, and includes several ex-
amples of method headers that we have already encountered. The method
body follows the method header.

MethodModifiersopt  ResultType  MethodName   (FormalParameterList)

public static       void        main         (String argv[])
public              void        paint        (Graphics g)
public                          Riddle       (String q, String a)
public              String      getQuestion  ()
public              String      getAnswer    ()

   The rules on method access are the same as the rules on instance vari-
able access: private methods are accessible only within the class it-
self, protected methods are accessible only to subclasses of the class
in which the method is defined and to other classes in the same package,
and public methods are accessible to all other classes.

 JAVA EFFECTIVE DESIGN Public versus Private Methods. If a
 method is used to communicate with an object, or if it passes
 information to or from an object, it should be declared public. If a
 method is intended to be used solely for internal operations within the
 object, it should be declared private. These methods are sometimes
 called utility methods or helper methods.

   Recall the distinction from Chapter 0 between instance methods and
class methods. Methods declared at the class level are assumed to be in-
stance methods unless they are also declared static. The static modifier
is used to declare that a class method or variable is associated with the
class itself, rather than with its instances. Just as for static variables,
methods that are declared static are associated with the class and are
therefore called class methods. As its name implies, an instance method can
only be used in association with an object (or instance) of a class. Most
of the class-level methods we declare will be instance methods. Class
methods are used only rarely in Java and mainly in situations where it
                                      82  CHAPTER 2  Objects: Using, Creating, and Defining

                                      is necessary to perform some kind calculation before objects of the class
                                      are created. We will see examples of class methods when we discuss the
                                      Math class, which has such methods as sqrt(N) to calculate the square
                                      root of N.

                                        JAVA PROGRAMMING TIP Class versus Instance Methods. If a
                                        method is designed to be used by an object, it is referred to as an
                                        instance method. No modifier is needed to designate an instance
                                        method. Class methods, which are used infrequently compared to
                                        instance methods, must be declared static.

                                      All four of the methods in the OneRowNim class are instance methods
                                      (Fig. 2.19). They all perform actions associated with a particular instance

                                                                                                             

                                      public c l a s s OneRowNim
                                      { private int nSticks = 7; // S t a r t with 7 s t i c k s .

                                         private int player = 1; // P l a y e r 1 p l a y s f i r s t .

                                          public void takeOne ( ) { } // Method b o d i e s need

                                          public void takeTwo ( ) { } // t o be d e f i n e d .

                                          public void takeThree (){ }

                                          public void report (){ }

                                      } // OneRowNim c l a s s

                                                                                                             

                                      Figure 2.19: The Instance variables and method headers for the
                                      OneRowNim class.

                                      of OneRowNim. That is, they are all used to manage a particular One Row
                                      Nim game. Moreover, all four methods should be declared public, be-
                                      cause they are designed for communicating with other objects rather than
                                      for performing internal calculations. Three of the methods are described
                                      as changing the values of the instance variables nSticks and player
                                      and the fourth, report(), writes information to the console. All four
                                      methods will receive no data when being called and will not return any
                                      values. Thus they should all have void as a return type and should all
                                      have empty parameter lists.

                                         Given these design decisions, we now can add method headers to our
                                      class definition of OneRowNim, in Figure 2.19. The figure displays the class
                                      header, instance variable declarations, and method headers.

Designing a method is an application  The Method Body
of the encapsulation principle.
                                      The body of a method definition is a block of Java statements enclosed
                                      by braces, , which are executed in sequence when the method is called.
                                      The description of the action required of the takeOne() method is typ-
                                      ical of many methods that change the state of an object. The body of
                                      the takeOne() method should use a series of assignment statements
                                      to reduce the value stored in nSticks by one and change the value in
SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 83

player from 2 to 1 or from 1 to 2. The first change is accomplished in a
straightforward way by the assignment:

                                                                                        

nSticks = nSticks - 1;                                                                  


This statement says subtract 1 from the value stored in nSticks and
assign the new value back to nSticks.

   Deciding how to change the value in player is more difficult because
we do not know whether its current value is 1 or 2. If its current value is 1,
its new value should be 2; if its current value is 2, its new value should be
1. Notice, however, that in both cases the current value plus the desired
new value are equal to 3. Therefore, the new value of player is equal to
3 minus its current value. Writing this as an assignment we have:

                                                                                        

player = 3 - player ;
                                                                                        

One can easily verify that this clever assignment assigns 2 to player if its
current value is 1 and assigns 1 to it if its current value is 2. In effect, this
assignment will toggle the value off player between 1 and 2 each time
it is executed. In the next chapter we will introduce the if-else control
structure that would allow us to accomplish this same toggling action in
a more straightforward manner. The complete definition of takeOne()
method becomes:

                                                                                        

public void takeOne ( )
{

   nSticks = nSticks - 1; // Take one s t i c k

   player = 3 - player ;  // Change t o o t h e r p l a y e r

}

                                                                                        

The takeTwo() and takeThree() methods are completely analogous
to the takeOne() method with the only difference being the amount
subtracted from nSticks.

   The body of the report() method must merely print the cur-
rent values of the instance variables to the console window with
System.out.println(). To be understandable to someone using a
OneRowNim object, the values should be clearly labeled. Thus the body
of report() could contain:

                                                                                        

System . out . p r i n t l n ( "Number o f s t i c k s l e f t : " + n S t i c k s ) ;

System . out . p r i n t l n ( "Next turn by player " + player ) ;                      


This completes the method bodies of the OneRowNim class. The com-
pleted class definition is shown in Figure 2.20. We will discuss alterna-
tive methods for this class in the next chapter. In Chapter 4, we will de-
velop several One Row Nim user interface classes that will facilitate a user
indicating certain moves to make.
84  CHAPTER 2  Objects: Using, Creating, and Defining

                                                                                              

public c l a s s OneRowNim      // S t a r t    with 7 sticks .
{ private int nSticks = 7;      // P l a y e r  1 plays f i r s t .

   private int player = 1;

    public void takeOne ( )
    { nSticks = nSticks - 1;

       player = 3 - player ;
    } // takeOne ( )

    public void takeTwo ( )
    { nSticks = nSticks - 2;

       player = 3 - player ;
    } // takeTwo ( )

    public void takeThree ( )
    { nSticks = nSticks - 3;

       player = 3 - player ;
    } // t a k e T h r e e ( )

    public void report ( )

    { System . out . p r i n t l n ( "Number o f s t i c k s l e f t : " + n S t i c k s ) ;

    System . out . p r i n t l n ( "Next turn by player " + player ) ;

    } // r e p o r t ( )

} // OneRowNim1 c l a s s

                                                                                              

    Figure 2.20: The OneRowNim class definition.

2.5.3 Testing the OneRowNim Class

Recall our define, create, and use mantra from Section 2.4.5. Now that we
have defined the OneRowNim class, we can test whether it works correctly
by creating OneRowNim objects and using them to perform the actions as-
sociated with the game. At this point, we can test OneRowNim by defining
a main() method. Following the design we used in the riddle example,
we will locate the main() method in separate, user interface class, named
OneRowNimTester.

   The body of main() should declare a variable of type OneRowNim and
create an object for it to refer to. The variable can have any name, but a
name like game would be consistent with it recording moves in a single
game. To test the OneRowNim class, we should make a typical series of
moves. For example, three moves taking 3, 3, and 1 sticks respectively
would be one way that the 7 sticks could be removed. Also, executing
the report() method before the first move and after each move should
display the current state of the game in the console window so that we can
determine whether it is working correctly.

   The following pseudocode outlines an appropriate sequence of state-
ments in a main() method:
SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 85

1. Declare a variable of type OneRowNim named game.
2. Instantiate a OneRowNim object to which game refers.
3. Command game to report.
4. Command game to remove three sticks.
5. Command game to report.
6. Command game to remove three sticks.
7. Command game to report.
8. Command game to remove one stick.
9. Command game to report.

It is now an easy task to convert the steps in the pseudocode outline
into Java statements. The resulting main() method is shown with the
complete definition of the OneRowNimTester class:

                                                                             

public c l a s s OneRowNimTester

{ public s t a t i c void main ( S t r i n g args [ ] )

   { OneRowNim1 game = new OneRowNim ( ) ;

   game . r e p o r t ( ) ;

   game . takeThree ( ) ;

   game . r e p o r t ( ) ;

   game . takeThree ( ) ;

   game . r e p o r t ( ) ;

   game . takeOne ( ) ;

   game . r e p o r t ( ) ;

   } // main ( )

}

                                                                             

When it is run, OneRowNimTester produces the following output:

                                                                             

   Number o f s t i c k s l e f t : 7

   Next turn by player 1

   Number o f s t i c k s l e f t : 4

   Next turn by player 2

   Number o f s t i c k s l e f t : 1

   Next turn by player 1

   Number o f s t i c k s l e f t : 0

   Next turn by player 2                                                     

This output indicates that player 1 removed the final stick and so player 2
is the winner of this game.

SELF-STUDY EXERCISES

EXERCISE 2.4 Add a new declaration to the Riddle class for a
private String instance variable named hint. Assign the variable
an initial value of "This riddle is too easy for a hint".

EXERCISE 2.5 Write a header for a new method definition for Riddle
named getHint(). Assume that this method requires no parameters
and that it simply returns the String value stored in the hint instance
variable. Should this method be declared public or private?
                                    86  CHAPTER 2  Objects: Using, Creating, and Defining

                                    EXERCISE 2.6 Write a header for the definition of a new public
                                    method for Riddle named setHint() which sets the value of the hint
                                    instance variable to whatever String value it receives as a parameter.
                                    What should the result type be for this method?

                                    EXERCISE 2.7 Create a partial definition of a Student class. Create
                                    instance variables for the first name, last name, and an integer student
                                    identification number. Write the headers for three methods. One method
                                    uses three parameters to set values for the three instance variables. One
                                    method returns the student identification number. The last method re-
                                    turns a String containing the student's first name and last name. Write
                                    only the headers for these methods.

                                    2.5.4 Flow of Control: Method Call and Return

                                    A program's flow of control is the order in which its statements are ex-
                                    ecuted. In an object-oriented program, control passes from one object to
                                    another during the program's execution. It's important to have a clear
                                    understanding of this process.

                                       In order to understand a Java program, it is necessary to understand the
                                    method call and return mechanism. We will encounter it repeatedly. A
                                    method call causes a program to transfer control to a statement located in
                                    another method. Figure 2.21 shows the method call and return structure.

Figure 2.21: The method call and           method1()     method2()
return control structure. It's im-                       statement1;
portant to realize that method1()       method2();
and method2() may be con-               nextstatement1;     return;
tained in different classes.

                                       In this example, we have two methods. We make no assumptions about
                                    where these methods are in relation to each other. They could be defined
                                    in the same class or in different classes. The method1() method executes
                                    sequentially until it calls method2(). This transfers control to the first
                                    statement in method2(). Execution continues sequentially through the
                                    statements in method2() until the return statement is executed.

                                     JAVA LANGUAGE RULE Return Statement. The return
                                     statement causes a method to return control to the calling
                                     statement--that is, to the statement that called the method in the first
                                     place.

Default returns                     Recall that if a void method does not contain a return statement, then
                                    control will automatically return to the calling statement after the invoked
                                    method executes its last statement.

                                    2.5.5 Tracing the OneRowNim Program

                                    To help us understand the flow of control in OneRowNim, we will perform
                                    a trace of its execution. Figure 2.22 shows all of the Java code involved in
                                    the program. In order to simplify our trace, we have moved the main()
                                    method from OneRowNimTester to the OneRowNim class. This does not
       SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 87

                                                                                                

    public c l a s s OneRowNim

2 { private int nSticks = 7;       // S t a r t    with 7 sticks .
                                   // P l a y e r  1 plays f i r s t .
3      private int player = 1;

       public void takeOne ( )

20     { nSticks = nSticks - 1;

21     player = 3 - player ;

       } // takeOne ( )

       public void takeTwo ( )

       { nSticks = nSticks - 2;

       player = 3 - player ;

       } // takeTwo ( )

       public void takeThree ( )

8 ,14 { nSticks = nSticks - 3;

9 ,15  player = 3 - player ;

       } // t a k e T h r e e ( )

       public void report ( )

5 , 1 1 , 1 7 , 2 3 { System . out . p r i n t l n ( "Number o f  sticks left : " + nSticks );
                                                                  by player " + player ) ;
6 ,12 ,18 ,24 System . out . println ( "Next turn

       } // r e p o r t ( )

       public s t a t i c void main ( S t r i n g args [ ] )

1      { OneRowNim1 game = new OneRowNim1 ( ) ;

4      game . r e p o r t ( ) ;

7      game . tak eThree ( ) ;

10     game . r e p o r t ( ) ;

13     game . t akeThree ( ) ;

16     game . r e p o r t ( ) ;

19     game . takeOne ( ) ;

22     game . r e p o r t ( ) ;

23     } // main ( )

    } // OneRowNim1 c l a s s

                                                                                                

                             Figure 2.22: A trace of the OneRowNim program.

       affect the program's order of execution in any way. But keep in mind that                                     game : OneRowNim
       the code in the main() method could just as well appear                                               nSticks : int=7
                                                                                                             player : int=1
          in the OneRowNimTester class. The listing in Figure 2.22 also adds
       line numbers to the program to show the order in which its statements are                   Figure 2.23: The initial state of
       executed.                                                                                   game, a OneRowNim object.

          Execution of the OneRowNim program begins with the first statement
       in the main() method, labeled with line number 1. This statement de-
       clares a variable of type OneRowNim named game and calls a constructor
       OneRowNim() to create and initialize it. The constructor, which in this
       case is a default constructor, causes control to shift to the declaration of
       the instance variables nSticks and player in statements 2 and 3, and as-
       signs them initial values of 7 and 1 respectively. Control then shifts back to
       the second statement in main(), which has the label 4. At this point, game
       refers to an instance of the OneRowNim class with an initial state shown in
       Figure 2.23. Executing statement 4 causes control to shift to the report()
                                    88  CHAPTER 2  Objects: Using, Creating, and Defining

                                    method where statements 5 and 6 use System.out.println() to write
                                    the following statements to the console.

                                                                                                                   

                                        Number o f s t i c k s l e f t : 7

                                        Next turn by player 1                                                      

                  game : OneRowNim  Control shifts back to statement 7 in the main() method, which calls
          nSticks : int=4           the takeThree() method, sending control to the first statement of that
          player : int=2            method. Executing statement 8 causes 3 to be subtracted from the int
                                    value stored in the instance variable nSticks of game, leaving the value
Figure 2.24: The state of game af-  of 4. Executing statement 9 subtracts the value stored in the player vari-
ter line 9 is executed.             able, which is 1, from 3 and assigns the result (the value 2) back to player.
                                    The state of the object game, at this point, is shown in Figure 2.24. Tracing
                                    the remainder of the program follows in a similar manner. Notice that
                                    the main() method calls game.report() four different times so that
                                    the two statements in the report() method are both executed on four
                                    different occasions. Note also that there is no call of game.takeTwo()
                                    in main(). As a result, the two statements in that method are never
                                    executed.

                                    2.5.6 Object-Oriented Design: Basic Principles

                                    We complete our discussion of the design and this first implementation
                                    of the OneRowNim class with a brief review of some of the object-oriented
                                    design principles that were employed in this example.

                                     Encapsulation. The OneRowNim class was designed to encapsulate a
                                      certain state and a certain set of actions. It was designed to simulate
                                      playing the One Row Nim game. In addition, OneRowNim's methods
                                      were designed to encapsulate the actions that make up their particular
                                      tasks.

                                     Information Hiding. OneRowNim's instance variables, nSticks and
                                      player are declared private so other objects can only change the
                                      values of these variables with the public methods of a OneRowNim in-
                                      stance. The bodies of the public methods are also hidden from users
                                      of OneRowNim instances. An instance and its methods can be used
                                      without any knowledge of method definitions.

                                     Clearly Designed Interface. OneRowNim's interface is defined in terms
                                      of the public methods. These methods constrain the way users can in-
                                      teract with OneRowNim objects and ensures that OneRowNim instances
                                      remain in a valid state. Those are the main purposes of a good interface.

                                     Generality and Extensibility. There is little in our design of
                                      OneRowNim that limits its use and its extensibility. Moreover, as we
                                      will see later, we can create several different kinds of user interfaces
                                      which interact with OneRowNim objects.

                                       The OneRowNim class has some obvious shortcomings that are a result
                                    of our decision to limit methods to those without parameters or return
                                    values. These shortcomings include:

                                     A OneRowNim object cannot communicate to another object the number
                                      of remaining sticks, which player makes the next turn, or whether the
                                      game is over. It can only communicate by writing a report to the console
                                      window.
 SECTION 2.5  CASE STUDY: Simulating a Two-Person Game 89

 The takeOne(), takeTwo() and takeThree() methods all have
   similar definitions. It would be a better design if a single method could
   take away a specified number of sticks.

 There is no way to play a OneRowNim game starting with a different
   number of sticks than 7. It would be nice to have a way of playing a
   game that starts with any number of sticks.

 In order to for a user to play a OneRowNim game, a user interface
   class would need to be developed that would allow the user to receive
   information about the state of the game and to input moves to make.

As we study other features of Java in the next two chapters, we will
modify the OneRowNim class to address these identified shortcomings.

Special Topic: Alan Kay and
    the Smalltalk Language

Although Simula was the first programming language to use the con-
cept of an object, the first pure object-oriented language was Smalltalk.
Smalltalk was first started by Alan Kay in the late 1960s. Kay is an
innovative thinker who has had a hand in the development of several
advances, including windowing interfaces, laser printing, and the clien-
t/server model, all of which are now commonplace today.

   One of the abiding themes throughout Kay's career has been the idea
that computers should be easy enough for kids to use. In the late 1960s,
while still in graduate school, Kay designed a computer model that con-
sisted of a notebook-sized portable computer with a keyboard, screen,
mouse, and high-quality graphics interface. He had become convinced
that graphics and icons were a far better way to communicate with a
computer than the command-line interfaces that were prevalent at the
time.

   In the early 1970s Kay went to work at the Xerox Palo Alto Research
Center (PARC), where he developed a prototype of his system known as
the Dynabook. Smalltalk was the computer language Kay developed for
this project. Smalltalk was designed along a biological model, in which
individual entities or "objects" communicate with each other by passing
messages back and forth. Another goal of Smalltalk was to enable children
to invent their own concepts and build programs with them--hence, the
name Smalltalk.

   Xerox's management was unable to see the potential in Kay's innova-
tions. However, during a visit to Xerox in 1979, Steve Jobs, the founder
of Apple Computer, was so impressed by Kay's work that he made it the
inspiration of the Macintosh computer, which was first released in 1984.

   Kay left Xerox in 1983 and became an Apple Fellow in 1984. In ad-
dition to working for Apple, Kay spent considerable time teaching kids
how to use computers at his Open School in West Hollywood. In 1996
Kay became a Fellow (an "Imagineer") at the Walt Disney Imagineering's
Research and Development Organization, where he continues to explore
innovative ways to enhance the educational and entertainment value of
computers.
                                   90  CHAPTER 2  Objects: Using, Creating, and Defining

                                   2.6 From the Java Library: java.util.Scanner.

Figure 2.25: The Scanner class,    If we wish to write useful interactive programs, we must be able to re-
with a partial list of its public  ceive information from the user as well as send information to him or
methods.                           her. We saw, in the previous chapter, that output from a program can be
                                   sent to the console window by simply using the System.out.print()
                                   and System.out.println() statements. In this section we describe
                                   two simple ways that Java can handle keyboard input. Receiving input
                                   from the keyboard, together with sending output to the console window,
                                   creates one of the standard user interfaces for programs.

                                      Recall, that in Java, any source or destination for I/O is considered a
                                   stream of bytes or characters. To perform keyboard input, we will extract
                                   characters from System.in, the input stream connected to the keyboard.
                                   Getting keyboard input from System.in involves two complications that
                                   are not present in dealing with System.out.println(). First, normal
                                   keyboard input data requested of a user consists of a sequence of char-
                                   acters or digits which represent a word, phrase, integer, or real number.
                                   Normally, an entire sequence of characters typed by the user will repre-
                                   sent data to be stored in a single variable with the user hitting the return
                                   or enter key to signal the end of a piece of requested data. Java has a spe-
                                   cial class, BufferedReader, that uses an input stream and has a method
                                   that collects characters until it reads the character or characters that corre-
                                   spond to hitting the return or enter key. A second complication for reading
                                   input involves the problem of how to handle receiving data that is not in
                                   the same format as expected. The BufferedReader class handles this
                                   problem by using certain exceptions, a special kind of error message, that
                                   must be handled by the programmer. Chapter 11 is devoted to exceptions
                                   and we will avoid their use, as far as possible, until that time.

                                      There is an alternate way to handle keyboard input in the Java 2 Plat-
                                   form Standard Edition 5.0 (Java SE 5.0). A Scanner class has been added
                                   to the java.util package which permits keyboard input without forc-
                                   ing the programmer to handle exceptions. We introduce the Scanner
                                   class in the next subsection and then describe how a user defined class
                                   introduced in Chapter 4 can function in an equivalent fashion to permit
                                   simple keyboard input.

                                   2.6.1 Keyboard Input with the Scanner Class

                                   A partial definition of Scanner is shown in Figure 2.25. Note that the
                                   Scanner methods listed are but a small subset of the public methods of
                                   this class. The Scanner class is in the java.util package so classes that
                                   use it should import it with the following statement:

                                                                                                                    

                                       import java . u t i l . Scanner ;                                            
                                   

                                   The Scanner class is designed to be a very flexible way to recognize
                                   chunks of data that fit specified patterns from any input stream. To use
                                   the Scanner class for keyboard input, we must create a Scanner in-
SECTION 2.6  From the Java Library: java.util.Scanner. 91

stance and associate it with System.in. The class has a constructor for
this purpose, so the statement

                                                                              

   Scanner s c = new Scanner ( System . i n ) ;
                                                                              

declares and instantiates an object that can be used for keyboard input.
After we create a Scanner object, we can make a call to nextInt(),
nextDouble(), or next() to read, respectively, an integer, real number,
or string from the keyboard. The program in Figure 2.26 demonstrates
how an integer would be read and used. When the nextInt() method

                                                                              

import java . u t i l . Scanner ;

public class TestScanner

{

   public s t a t i c void main ( S t r i n g [ ] args )

   {              // C r e a t e S c a n n e r o b j e c t

      Scanner s c = new Scanner ( System . i n ) ;

      System . out . print ( " Input an i n t e g e r : " ) ; // P r o m p t

      i n t num = s c . n e x t I n t ( ) ;  // Read an i n t e g e r

      System . out . p r i n t l n (num + " squared = " + numnum ) ;

   } // main ( )

} // T e s t S c a n n e r c l a s s

                                                                              

Figure 2.26: A very brief program with a Scanner object used for keyboard
input

is executed, no further statements are executed until an int value is re-
turned by the method. Normally this does not happen until the user has
typed in the digits of an integer and hit the return or enter key. Thus ex-
ecuting the main() method of the TestScanner class will result in the
output

                                                                              

   Input an integer :
                                                                              

to the console window and the program will wait for the user to type in
an integer and hit the return or enter key. After this has been done the
output will look something like:

                                                                              

   Input an integer :123

   123 squared = 15129                                                        
   

Keyboard input of real numbers and strings are handled in a similar
manner.
92  CHAPTER 2  Objects: Using, Creating, and Defining

   Keyboard input will allow us to create examples of command line
interfaces for interactive programs. For example, the code

                                                                                                

    Scanner s c = new Scanner ( System . i n ) ;

    Riddle r i d d l e = new Riddle (

    "What i s b l a c k and white and red a l l over ? " ,

    "An embarrassed zebra . " ) ;

    System . out . println ( "Here i s a riddle : " ) ;

    System . out . println ( riddle . getQuestion ( ) ) ;

    System . out . p r i n t ( "To see the answer , " ) ; // P r o m p t

    System . out . p r i n t l n ( " type a l e t t e r and enter . " ) ;

    String str = sc . next ( ) ;            // Wait f o r i n p u t

    System . out . println ( riddle . getAnswer ( ) ) ;                                         


will display a riddle question and prompt the user to type a letter and to
hit the enter key to see the answer. In the next chapter, we will develop
new methods for the OneRowNim class that will be able to use int values
input from the keyboard for the next move.

   We must mention that, since the Scanner class is designed as a flexi-
ble tool for recognizing chunks of data from any input stream, it has some
properties that may be unexpected and not totally compatible with sim-
ple keyboard input. A Scanner object has a set of character strings that
separate or delimit the chunks of data that it is looking for. By default,
this set of delimiters consists of any non-empty sequence of white space
characters, that is, the space, tab, return, and newline characters. This will
allow a user to input several integers separated by spaces before hitting
the enter key. This might be handled by code like:

                                                                                                

    System . out . p r i n t ( " Input two i n t e g e r s and an en ter : " ) ;

    i n t num1 = s c . n e x t I n t ( ) ;

    i n t num2 = s c . n e x t I n t ( ) ;
                                                                                                

White space as delimiters also means that the next() method cannot re-
turn an empty string nor can it return a string that contains any spaces.
For example, consider the code:

                                                                                                

    System . out . p r i n t ( " Input t h e f i r s t p r e s i d e n t o f t h e USA : " ) ;

    String str = sc . next ( ) ;                                                                


If one types "George Washington" and hits the enter key, the string str
will store only "George". In order to get a Scanner object to read strings
that contain spaces, we must use the useDelimiter() method to de-
fine the set of delimiters as just that character string generated by hitting
the enter key. For example, for some Windows operating systems, the
statement

                                                                                                

    sc = sc . useDelimiter ( "\r\n" ) ;
                                                                                                
SECTION 2.6  From the Java Library: java.util.Scanner. 93

will result in the next() method returning the entire string of charac-                           Figure 2.27: A UML class diagram
ters input from the keyboard up to but not including those generated by                           of the KeyboardReader class.
hitting the enter key.

   You should also be aware that just because we can use a Scanner object
to write Java code that ignores exceptions does not mean that exceptions
will not be generated by keyboard input. If the user enters letters rather
than digits for the nextInt() method to process, the program will be
terminated with an error message.

   It must be stressed that the strategy for handling keyboard input out-
lined above is a temporary strategy until the topic of exceptions is cov-
ered in Chapter 11. Real software applications that use keyboard input
should carefully handle the possibility that a user will enter something
unexpected. In Java, this can only be done by handling exceptions.

2.6.2 Keyboard Input with the KeyboardReader Class

If you are using an older version of Java that does not have the Scanner
class, a user-defined class can be used instead. A KeyboardReader
class that uses the BufferedReader class will be developed in Chap-
ter 4. It has methods that read data from the keyboard in a manner very
similar to those of the Scanner class. A partial list of its public meth-
ods is given in the UML class diagram shown in Figure 2.27. To use
the KeyboardReader class for keyboard input, copy the source code
KeyboardReader.java from Chapter 4 into the same directory as the
source code of your current Java class (and add it to your current project
if you are using a integrated development environment).

   To use a KeyboardReader object, we need to create an instance of
the class with a constructor. Then calling one of the three methods will
return an int, double, or String when data is input from the keyboard.
Any of the three methods of a KeyboardReader object will attempt to
process the entire string input from the keyboard up to the point that the
enter key is hit. That is, the character or characters generated by hitting
the return or enter key is the delimiter used by KeyboardReader. The
TestKeyboardReader class definition in Figure 2.28 reads an integer

                                                                                               

public class TestKeyboardReader

{

   public s t a t i c void main ( S t r i n g [ ] args )

   {              // C r e a t e K e y b o a r d R e a d e r o b j e c t

      KeyboardReader kb = new KeyboardReader ( ) ;

      System . out . print ( " Input an i n t e g e r : " ) ; // P r o m p t

      i n t num = kb . g e t K e y b o a r d I n t e g e r ( ) ; // R e a d a n i n t e g e r

      System . out . p r i n t l n (num + " squared = " + numnum ) ;

   } // main ( )

} // T e s t K e y b o a r d R e a d e r c l a s s

                                                                                               

Figure 2.28: A very brief program with a KeyboardReader object used for
keyboard input.

from the keyboard and squares it just like the TestScanner class. In the
remainder of the text, any time the Scanner class is used for keyboard
                 94  CHAPTER 2  Objects: Using, Creating, and Defining

                 input, the same program can be run using the KeyboardReader class
                 after making the obvious substitutions.

                 SELF-STUDY EXERCISES

                 EXERCISE 2.8 Modify the main() method of the TestScanner class
                 so that it reads a real number from the keyboard rather than an integer.

CHAPTER SUMMARY  Technical Terms

                 access modifier       local variable   reference
                 class-level variable  method call and  reference variable
                 default value                          static modifier
                 delimiter                return        user interface
                 empty string          null pointer
                 flow of control       null pointer
                 interface
                                          exception
                                       pointer

                 Summary of Important Points

                  Dot notation is used to refer to an object's public elements.
                  Designing a class is a matter of deciding what role it will play and what

                    information and actions it will have.
                  Writing a Java program is a matter of defining one or more classes. A

                    class definition serves as a template for creating instance of the class.
                  Classes typically contain two kinds of elements, variables and meth-

                    ods. An object's state is defined by its instance variables.
                  Class elements that are declared public can be accessed by other

                    objects. Elements that are declared private are hidden from other
                    objects.
                  A class's instance variables are usually declared private so they can-
                    not be accessed directly by other objects.
                  An object's public instance methods can be called by other objects.
                    Thus, they make up the object's interface with other objects.
                  Object instantiation is the process of creating an object, using the new
                    operator in conjunction with a constructor method.
                  A class definition consists of a header and a body. The header gives
                    the class a name, specifies its accessibility (public), and its place in
                    the Java class hierarchy (extends Object). The class body contains
                    declarations of the class's variables and definitions of its methods.
                  By default, a newly defined class is consider a subclass of Object.
                  Class elements that are declared static, such as the main() method,
                    are associated with the class (not with its instances).
                  A Java application program must contain a main() method, which is
                    where it begins execution.
                  Methods that are used solely for the internal operations of the class
                    should be declared private.
                  An instance variable declaration reserves memory for the instance
                    variable within the object, associates a name and a type with the lo-
                    cation, and specifies its accessibility.
CHAPTER 2  Solutions to Self-Study Exercises                           95

 A method definition consists of two parts: a header, which names the
  method and provides other general information about it, and a body,
  which contains its executable statements.

 Declaring a variable creates a name for an object but does not create
  the object itself. An object is created by using the new operator and a
  constructor method.

  SOLUTION 2.1 The Java code fragment prints out the following:             SOLUTIONS TO
                                                                         SELF-STUDY EXERCISES

  The singing king .                                                    


SOLUTION 2.2 For the Riddle class (Fig. 2.12),
 The name of the class: Riddle
 The names of two instance variables: question, answer
 The names of three methods: Riddle(), getQuestion(), getAnswer()

SOLUTION 2.3 For RiddleUser class (Fig. 2.15),
 The names of two Riddle instances: riddle1, riddle2
 All six method calls of the Riddle objects in the program:

                                                                                       

  Riddle ( "What i s b l a c k and white and red a l l over ? " ,

                             "An embarrassed zebra . " )

  Riddle ( "What i s b l a c k and white and read a l l over ? " ,

                                          "A newspaper . " )

  riddle1 . getQuestion ()

  riddle1 . getAnswer ( )

  riddle2 . getQuestion ()

  riddle2 . getAnswer ( )
                                                                                       

 Qualified names: riddle1.getQuestion() and riddle1.getAnswer()

SOLUTION 2.4 Definition of new instance variable in the Riddle class:

                                                                        

private String hint = "This riddle is to easy for a hint" ;             


SOLUTION 2.5 The header for a getHint() method of the Riddle class,
which should be a public method, is:

                                                                        

public String getHint ( ) ;                                             


SOLUTION 2.6 The header for a setHint() method of the Riddle class is:

                                                                        

  public void setHint ( String aHint ) ;                                

The result type is void. Although the identifier used for the parameter is arbitrary,
it is a good practice to make it descriptive, by referring in some way to the hint
instance variable.
                                  96             CHAPTER 2  Objects: Using, Creating, and Defining

                                  SOLUTION 2.7 The partial definition of the Student class is given below.

                                                                                                                     

                                  public class Student
                                  { private String firstName ;

                                       private String lastName ;
                                       private int studentID ;

                                      public void s e t S t u d e n t ( S t r i n g fName , S t r i n g lName ,

                                                                                                   int anID ) ;

                                      public int getStudentID ( ) ;

                                      public String getStudentName ( ) ;

                                  }

                                                                                                                     

                                  SOLUTION 2.8 A main method that reads and squares a real number is given
                                  below.

                                                                                                                      

                                  public s t a t i c void main ( S t r i n g [ ] args )

                                  {              // C r e a t e S c a n n e r o b j e c t

                                      Scanner sc = Scanner . create ( System . in ) ;

                                      System . out . p r i n t ( " Input a r e a l number : " ) ;  // Prompt

                                      double realNum= sc . nextDouble ( ) ;                // Read a d o u b l e

                                      System . out . p r i n t l n (num + " squared = " + realNumrealNum ) ;

                                  } // main ( )

                                                                                                                      

EXERCISES                         EXERCISE 2.1 Consider the transaction of asking your professor for your grade
                                  in your computer science course. Identify the objects in this transaction and the
Note: For programming exercises,  types of messages that would be passed among them.
first draw a UML class diagram
describing all classes and their  EXERCISE 2.2 Now suppose the professor in the previous exercise decides to
inheritance relationships and/or  automate the transaction of looking up a student's grade and has asked you to
associations.                     design a program to perform this task. The program should let a student type in
                                  his or her name and ID number and the program then should display his or her
                                  grades for the semester, with a final average. Suppose there are five quiz grades,
                                  three exams, and two programming exercise grades. Identify the objects in this
                                  program and the type of messages that would be passed among them. (Hint: The
                                  grades themselves are just data values, not objects.)

                                  EXERCISE 2.3 In the RiddleUser class (Fig. 2.15), give two examples of object
                                  instantiation and explain what is being done.

                                  EXERCISE 2.4 Explain the difference between a method definition and a
                                  method call. Give an example of each from the Riddle and RiddleUser ex-
                                  amples discussed in this chapter.

                                  EXERCISE 2.5 In the RiddleUser class (Fig. 2.15), identify three examples of
                                  method calls and explain what is being done.

                                  EXERCISE 2.6 Describe how the slogan "define, create, manipulate" applies to
                                  the Riddle example.

                                  EXERCISE 2.7 An identifier is the name for a             ,       , or a         .
CHAPTER 2  Exercises                                                    97

EXERCISE 2.8 Which of the following would be valid identifiers?

                                                                         

int 74 ElmStreet Big N  L$&%# boolean Boolean

number

Int public          Private Joe  j1      2K

b i g numb
                                                                         

EXERCISE 2.9 Explain the difference between a class variable and an
instance variable.

EXERCISE 2.10 Identify the syntax error (if any) in each declaration. Remember
that some parts of an instance variable declaration are optional.

a. public boolean isEven ;
b. Private boolean isEven ;
c. private boolean isOdd
d. public boolean is Odd ;
e. string S ;
f. public String boolean ;
g. private boolean even = 0;
h. private String s = helloWorld ;

EXERCISE 2.11 Write declarations for each of the following instance variables.

a. A private boolean variable named bool that has an initial value of true.
b. A public String variable named str that has an initial value of "hello".
c. A private int variable named nEmployees that is not assigned an initial

    value.

EXERCISE 2.12 Identify the syntax error (if any) in each method header:

a. public String boolean()
b. private void String ()
c. private void myMethod
d. private myMethod()
e. public static void Main (String argv[])

EXERCISE 2.13 Identify the syntax error (if any) in each assignment statement.
Assume that the following variables have been declared:

                                                                         

public int m;

public boolean b ;

public String s ;                                                        


a. m = "86" ;           e. s = "1295" ;

b. m = 86 ;             f. b = "true" ;

c. m = true ;           g. b = false

d. s = 1295 ;

EXERCISE 2.14 Given the following definition of the NumberAdder class, add
statements to its main() method to create two instances of this class, named
adder1 and adder2. Then add statements to set adder1's numbers to 10 and
98     CHAPTER 2  Objects: Using, Creating, and Defining

  15, and adder2's numbers to 100 and 200.  Then add statements to print their
  respective sums.                                                                  


  public c l a s s NumberAdder
  {

         p r i v a t e i n t num1 ;
         p r i v a t e i n t num2 ;

    public void setNums ( i n t n1 , i n t n2 )
    {

       num1 = n1 ;
       num2 = n2 ;
    }
    public int getSum ( )
    {
       r e t u r n num1 + num2 ;
    }

    public s t a t i c void main ( S t r i n g args [ ] )

    {

    }

}

                                                           

EXERCISE 2.15 For the NumberAdder class in the previous exercise, what are
the names of its instance variables and instance methods? Identify three expres-
sions that occur in the program and explain what they do. Identify two assignment
statements and explain what they do.

EXERCISE 2.16 Explain the difference between each of the following pairs of
concepts.

a. A method definition and a method call.
b. Declaring a variable of reference type and creating an instance.
c. A variable of reference type and a variable of primitive type.

EXERCISE 2.17 Define a Java class named NumberCruncher that has a single
int variable as its only instance variable. Then define methods that perform the
following operations on its number: get, double, triple, square, and cube. Set
the initial value of the number with a constructor as was done with the instance
variables in the Riddle class.

EXERCISE 2.18 Write a main() method and add it to the NumberCruncher
class defined in the previous problem. Use it to create a NumberCruncher in-
stance, with a certain initial value, and then get it to report its double, triple,
square, and cube.

EXERCISE 2.19 Write a Java class definition for a Cube object, that has an inte-
ger attribute for the length of its side. The object should be capable of reporting
its surface area and volume. The surface area of a cube is six times the area of any
side. The volume is calculated by cubing the side.

EXERCISE 2.20 Write a Java class definition for a CubeUser object that will use
the Cube object defined in the previous exercise. This class should create three
Cube instances, each with a different side, and then report their respective surface
areas and volumes.

EXERCISE 2.21 Challenge: Modify your solution to the previous exercise so
that it lets the user input the side of the cube. Follow the example shown in this
chapter's "From the Java Library" section.
CHAPTER 2  Exercises  99

EXERCISE 2.22 Challenge: Define a Java class that represents an address book
entry, Entry, which consists of a name, address, and phone number, all repre-
sented as Strings. For the class's interface, define methods to set and get the
values of each of its instance variables. Thus, for the name variable, it should have
a setName() and a getName() method.

UML EXERCISES

EXERCISE 2.23 Draw a UML class diagram to represent the following class hi-
erarchy: There are two types of languages, natural languages and programming
languages. The natural languages include Chinese, English, French, and German.
The programming languages include Java, Smalltalk and C++, which are object-
oriented languages, FORTRAN, COBOL, Pascal, and C, which are imperative lan-
guages, Lisp and ML, which are functional languages, and Prolog, which is a logic
language.

EXERCISE 2.24 Draw a UML class diagram to represent different kinds of au-
tomobiles, including trucks, sedans, wagons, SUVs, and the names and manufac-
turers of some popular models in each category.

EXERCISE 2.25 Draw a UML object diagram of a triangle with attributes for
three sides, containing the values 3, 4, and 5.

EXERCISE 2.26 Suppose you are writing a Java program to implement an elec-
tronic address book. Your design is to have two classes, one to represent the user
interface and one to represent the address book. Draw a UML diagram to depict
this relationship. See Figure 2.14.

EXERCISE 2.27 Draw an UML object diagram to depict the relationship be-
tween an applet, which serves as a user interface, and three Triangles, named
t1, t2, and t3.
100  CHAPTER 2  Objects: Using, Creating, and Defining
Chapter 3

Methods: Communicating
with Objects

OBJECTIVES

After studying this chapter, you will
 Understand the role that methods play in an object-oriented program.
 Know how to use parameters and arguments to pass data to an object.
 Understand how constructor methods are used to instantiate objects.
 Know the difference between passing a value and passing a reference to an object.
 Be able to design your own methods.
 Know how to use the if-else and while control structures.

OUTLINE

3.1 Introduction
3.2 Passing Information to an Object
3.3 Constructor Methods
3.4 Retrieving Information from an Object
3.5 Passing a Value and Passing a Reference
3.6 Flow of Control: Control Structures
3.7 Testing an Improved OneRowNim

         Special Topic: Intelligent Agents
3.8 From the Java Library: java.lang.Object
3.9 Object-Oriented Design: Inheritance and Polymorphism
3.10 Drawing Lines and Defining Graphical Methods (Optional)

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              101
102  CHAPTER 3  Methods: Communicating with Objects

3.1 Introduction

In this chapter, we take a look at Java methods and parameters. Methods
and parameters are the primary mechanisms for passing information into
and out of an object. We will once again focus on the OneRowNim simula-
tion that we designed in the previous chapter. That version was sufficient
to introduce us to Java objects and classes, but it was limited in its ability
to communicate with other objects.

   In this chapter, we want to expand OneRowNim to make our simulation
more realistic. We begin by learning how to pass information to an ob-
ject. That will enable us to specify the number of sticks to remove using
a single method. We then consider special methods called constructors,
which are used to initialize an object's state when it is created. We also
learn how to retrieve information from an object. That will enable us to
request a OneRowNim object for several different bits of information. Then
we consider the if-else and while control structures which allow us to
define more useful methods and write more realistic test programs.

3.2 Passing Information to an Object

One convention of object-oriented programming is to provide public
methods to set and get the values of some of its private instance vari-
ables. Methods that set or modify an object's instance variables are called
mutator methods. Methods that get or retrieve the value of an instance
variable are called accessor methods.

JAVA EFFECTIVE DESIGN Accessor and Mutator Methods. An
accessor method is a public method used to get the value of an object's
instance variable. Such methods are often named getVarName() where
VarName is the name of the variable that's being accessed. A mutator
method is a public method used to modify the value of one or more
instance variables. The special type of mutator method that sets or
assigns a variable a specified value is often called setVarName().

It is up to the designer of the class to determine which private vari-
ables require accessor and mutator methods. If you were designing a
BankAccount class, you might want a public getAccountNumber()
method, so that clients could retrieve information about their bank ac-
counts, but you would probably not want a public getAccountPassword()
method or a public setAccountBalance() method.

   In the remainder of this section, we will be concerned with muta-
tor methods. We defined three mutator methods named takeOne(),
takeTwo(), and takeThree as part of the OneRowNim class in the pre-
vious chapter. All three of these method change the values of the instance
SECTION 3.2  Passing Information to an Object                103

variables nSticks and player. All three methods have very similar             
bodies. The definition of the takeOne() is:                                   

                                                                               Formal parameter

    public void takeOne ( )
    { nSticks = nSticks - 1;

           player = 3 - player ;
     }
 

The only difference in the bodies of the other two methods is that they
subtract 2 and 3 from nSticks instead of 1. Instead of having three, vir-
tually identical methods, It would be a more efficient design to define a
single method where the number to be subtracted from nSticks would
be supplied as an argument when the method is called. In order to be able
to handle such an argument, we must design a new method that uses a
parameter to handle the argument.

   A formal parameter, or more simply, parameter, is a variable used to
pass information into a method when the method is invoked. The type and
variable name of the formal parameter must appear in the formal parameter
list that follows the method's name in the method header. The formal
parameter is used to hold a value that it is passed while the method is
executing.

JAVA LANGUAGE RULE Formal Parameter. A formal parameter
is a variable that serves as a storage location for information that is
passed to a method. To specify a formal parameter, you must provide
a type identifier followed by variable identifier, and you must place
this declaration inside the parentheses that follow the method's name.

Consider the following definition for a takeSticks() method:

                                                                              

public void t a k e S t i c k s ( i n t num)

{  n S t i c k s = n S t i c k s - num ;

   player = 3 - player ;

}

                                                                              

Notice that executing the body of takeSticks() when the parameter
num stores the value 1 accomplishes precisely the same task as executing
takeOne(). If, instead, a value of 2 or 3 is stored in num, then calling the
method acts like takeTwo() or takeThree() respectively. Thus, using
parameters enables us to design methods that are more general in what
they do, which is an important principle of good program design.

   Another example of a mutator method is one in which define a set
method to allow the starting number of sticks to be set for an instance of
OneRowNim. For this, we could define:

                                                                              

public void setSticks ( int sticks )

{  nSticks = sticks ;

} // s e t S t i c k s ( )

                                                                              

As we will see in Section 3.3, we can also define a constructor method that
can be used, when the game is created, to set the initial value of nSticks.
             104  CHAPTER 3  Methods: Communicating with Objects

             It is often desirable to have more than one method that sets the values of
             an objects' instance variables.

                If a method uses more than one parameter, use a comma to separate the
             individual parameter declarations in the method header. For example, if
             we wanted a method for OneRowNim that specified both the number of
             sticks for the start of a game and which player takes a turn first, it could
             be defined:

                                                                                           

             public void setGame ( int sticks , int s t a r t e r )

             { nSticks = sticks ;

                  player = starter ;

             } // setGame ( )

                                                                                           

Scope        The Scope of Parameters, Variables, and Methods
Local scope
             The bodies of the mutator methods in the previous section make use of
Class scope  both instance variables and parameters. It is important to note that there
             is a difference in where these two types of variables can be used. The
             scope of a variable or method refers to where it can be used in a program.

                A parameter's scope is limited to the body of the method in which it is
             declared. Variables that are declared in the body of a method have scope
             which extends from the point where they are declared to the end of the
             block of code in which they are declared. Parameters are local variables
             which are declared in the parameter list of a method's header and which
             have initial values specified by the arguments in a method call. The scope
             of a parameter is the same as the scope of a variable declared at the very
             beginning of the body of a method. Once the flow of execution leaves a
             method, its parameters and other local variables cease to exist. The scope
             of local variables is referred to as local scope.

              JAVA LANGUAGE RULE Scope. Local variables, that is,
              parameters and variables declared in the body of a method, have local
              scope which extends from the point at which they are defined to the
              end of the block of code in which they are defined. In particular, the
              scope of a parameter is the entire body of the method in which it is
              declared.

                By contrast, instance variables, class variables, and all methods have
             scope that extends throughout the entire class, that is, class scope. They
             can be used in the body of any method and in the expressions that as-
             sign initial values to class level variables. There are two restrictions to
             remember. First, instance variables and instance methods cannot be used
             in the body of a class method, one modified with static, unless an in-
             stance of the class is created there and then the dot notation of qualified
             names must be used to refer to the variable or method. This is because
             class methods are called without reference to a particular instance of the
             class. The main() method of the OneRowNim class that we defined in the
             previous chapter is an example of such a class method. In that case, to
SECTION 3.2  Passing Information to an Object                       105

test the instance methods of OneRowNim we first created an instance of
OneRowNim and used it to call its instance methods:

                                                                                

OneRowNim game = new OneRowNim ( ) ; // C r e a t e i n s t a n c e

game . r e p o r t ( ) ; // C a l l a n i n s t a n c e m e t h o d
                                                                                

The second restriction involved in class scope is that one class level vari-
able can be used in the expression that initializes a second class level vari-
able only if the first is declared before the second. There is no similar
restriction on methods.

JAVA LANGUAGE RULE Scope. Class level variables, that is,
instance variables and class variables have class scope, which extends
throughout the class. Methods also have class scope.

   Except for the restrictions noted above, methods and class level vari-       Simple vs. qualified names
ables can be referred to within the same class by their simple names,
with just the method (or variable) name itself, rather than by their quali-
fied names, with the dot operator. Thus, in OneRowNim, we can refer to
nSticks and report() in the bodies of other instance methods. In a
class method, such as main(), we would have to create an instance of
OneRowNim with a name like game and refer to game.report().

JAVA LANGUAGE RULE Qualified Names. Within the same class,
references to class methods or class variables can be made in terms of
simple names. Within the bodies of instance methods, references to
instance variables and references to other instance methods can also be
made in terms of simple names. However, within the bodies of class
methods, qualified names, or dot notation, must be used to refer to
instance methods or instance variables just like how they are referred
to in other classes.

 JAVA DEBUGGING TIP Scope Error. It would be a syntax error to
 refer to a method's parameters or other local variables from outside
 the method.

3.2.1 Arguments and Parameters

The new class definition for OneRowNim is given in Figure 3.1. Note that
now that we have a single method, takeSticks(), that can be used
to take away a variable number of sticks, we have removed the three
methods we wrote in the previous chapter, takeOne(), takeTwo(), and
takeThree(), from OneRowNim. Using a single method, with a parame-
ter, is clearly a better design. To see this, just imagine what we would have
to do if we didn't use a parameter and we wanted to be able to take away
four sticks, or five, or more. If we didn't have parameters, we'd have to
write a separate method for each case, which is clearly a bad idea. Using
parameters in this way leads to a more general useful method and thus is
an example of the generality principle.
106  CHAPTER 3  Methods: Communicating with Objects

                                                                                            

public c l a s s OneRowNim                // S t a r t    with 7 sticks
{ private int nSticks = 7;                // P l a y e r  1 plays f i r s t

   private int player = 1;

  public void takeSticks ( int             num)
  { n S t i c k s = n S t i c k s - num ;

     player = 3 - player ;
  } // t a k e S t i c k s ( )

  public void report ( )

  { System . out . p r i n t l n ( "Number o f s t i c k s l e f t : " + n S t i c k s ) ;

     System . out . p r i n t l n ( "Next turn by player " + player ) ;

  } // r e p o r t ( )

} // OneRowNim1 c l a s s

                                                                                            

Figure 3.1: The OneRowNim class definition with takeSticks() method.

   Now let's consider how we would create a OneRowNim instance and
use the new method in the main() method or in a different class. If we
want to have an instance of OneRowNim object to remove 3 sticks on the
first move by using the takeSticks() method, we need to pass the int
value 3 to the method. In order to effect this action, we would use the
following statements:

                                                                                            

  OneRowNim game = new OneRowNim ( ) ;

  game . t a k e S t i c k s ( 3 ) ;
                                                                                            

Because the definition of takeSticks() includes a single int parame-
ter, we must supply a single int value (such as 3), when we invoke it.
When the method is invoked, its formal parameter (num) will be set to the
value we supply (3). The value we supply does not have to be a literal
int value. We can supply any expression or variable that evaluates to an
int value. For example:

                                                                                            

  int val = 7 - 5;

  game . t a k e S t i c k s ( v a l ) ;                                                    


In this case, the value being passed to takeSticks() is 2, the value that
val has at the time the method call is made.

   It would be an error to try to pass a value that was not a int to
takeSticks(). For example, each of the following invocations of
takeSticks() results in a syntax error:

                                                                                            

  game . t a k e S t i c k s ( ) ;        // no argument i s s u p p l i e d

  game . t a k e S t i c k s ( " 3 " ) ; // " 3 " i s a S t r i n g , n o t a n i n t

  game . t a k e S t i c k s ( i n t ) ; // i n t n o t i s a n i n t v a l u e             

SECTION 3.2  Passing Information to an Object                                   107

As you recall from Chapter 0, the value that is passed to a method when               Parameter vs. argument
it is invoked is called an argument. Even though the terms argument and
parameter are sometimes used interchangeably, it will be useful to ob-
serve a distinction. We will use the term parameter to refer to the formal
parameter--the variable used to pass data to a method--that occurs in the
method definition. We use the term argument to refer to the actual value
that is supplied when the method is invoked.

  JAVA DEBUGGING TIP Type Error. It would be a syntax error to
  use an argument whose type doesn't match the type of its
  corresponding parameter.

The distinction between parameter and argument is related to the differ-               Defining vs. calling a method
ence between defining a method and invoking a method. Defining a method
is a matter of writing a method definition, such as                                   

                                                                                      

    public void printStr ( String s )                                                  Invoking a method
    { System . out . println ( s ) ;                                                  
    }                                                                                 
 

This definition defines a method that takes a single String parameter, s,
and simply prints the value of its parameter. On the other hand, invoking
a method is a matter of writing a method call statement, such as

 

    printStr ( "HelloWorld" ) ;
 

This statement calls the printStr() method and passes it the string
"HelloWorld". This notation assumes that the call to the instance method
printStr() is made within the body of another instance method of the
same class.

3.2.2 Passing an int value to a OneRowNim method.

To get a clearer picture of the interaction that takes place when we invoke
takeSticks() and pass it an int value, let's write a main() method to
test our new version of OneRowNim.

   Our first version of main() is shown in Figure 3.2. We will use it to
trace how the parameter of takeSticks() interacts with the instance

                                                                                 

public s t a t i c void main ( S t r i n g argv [ ] )

{ OneRowNim game ;                    // D e c l a r e a OneRowNim o b j e c t

  game = new OneRowNim ( ) ; // I n s t a n t i a t e t h e r e f e r e n c e s

  game . t a k e S t i c k s ( 3 ) ;  // remove 3 s t i c k s

} // main ( )

                                                                                 

  Figure 3.2: A main() method to test the takeSticks() method.

variables nSticks and player. The statements in the main() program
simply create an instance of OneRowNim that is referenced by game and
invoke the setSticks() method with an argument of 3.
                                 108  CHAPTER 3  Methods: Communicating with Objects

Figure 3.3: Tracing the state

of game (a) Just before calling

takeSticks(3).  (b) Just

before executing the body of

takeSticks(3).  (c) Just

after executing the body of

takeSticks(3). (d) After flow

of control leaves takeSticks().

                                    To get a clearer understanding of how a parameter works, it will be
                                 instructive to trace through the code in main(). Figure 3.3 displays
                                 how the states of the instance variables of game and the parameter of
                                 takeSticks() interact.

                                    Executing the first two statements of main() creates the instance game
                                 of OneRowNim. Figure 3.3(a) shows the initial state of game. When the
                                 takeSticks(3) method call is made, a parameter (which is a local vari-
                                 able) named num is created and the value 3 is stored in it. The state of
                                 the instance variables and the parameter are shown in (b). Then the body
                                 of takeSticks() is executed. The new state of game is shown in (c).
                                 After the flow of control leaves the body of takeSticks() and returns
                                 to main(), the memory location which stored the value of the parameter
                                 num is released for other uses. The state of game at this point is shown in
                                 (d). Notice that the value of nSticks has been reduced to 4.

                                 3.2.3 Passing keyboard input to takeSticks()

                                 To complete this section, let's modify our main() method in Figure 3.2
                                 so that it prompts the user to input an integer from the keyboard and
                                 then uses a Scanner object, introduced in the previous chapter, to read
                                 the integer. That integer will then be used as the argument in a call to
                                 takeSticks(). These modifications have been incorporated into the
                                 revised version of the main() method shown in Figure 3.4. If we now
                                 run this program the following output will be generated in the console
                                 window before waiting for keyboard input:

                                                                                                              

                                 Number o f s t i c k s l e f t : 7

                                 Next turn by player 1

                                 Input 1 , 2 , or 3 and h i t enter :                                         
                                 
   SECTION 3.3  Constructor Methods                                                    109
                                                                                          

  import java . u t i l . Scanner ;

public s t a t i c void main ( S t r i n g argv [ ] )

{ Scanner sc ;                        // D e c l a r e a S c a n n e r v a r i a b l e

  sc = Scanner . create ( System . in ) ; // I n s t a n t i a t e i t

  OneRowNim game ;                    // D e c l a r e a OneRowNim v a r i a b l e

  game = new OneRowNim ( ) ; // I n s t a n t i a t e i t

  game . r e p o r t ( ) ;            // R e p o r t s t a t e o f game

  System . out . p r i n t l n ( " Input 1 , 2 , or 3 and h i t enter : " ) ;

  i n t num = s c . n e x t I n t ( ) ; // R e a d a n i n t f r o m k e y b o a r d

  game . t a k e S t i c k s (num ) ; // U s e t h e v a l u e r e a d

  game . r e p o r t ( ) ;            // R e p o r t s t a t e o f game

} // main ( )

                                                                                        

  Figure 3.4: A main() method with keyboard input for OneRowNim.

If the user then inputs a 2 from the keyboard, that input will be read
and the takeSticks() method will remove 2 sticks. The output in the
console window will now look like:

                                                                                        

  Number o f s t i c k s l e f t : 7

  Next turn by player 1

  Input 1 , 2 , or 3 and h i t enter : 2

  Number o f s t i c k s l e f t : 5

  Next turn by player 2                                                                 


SELF-STUDY EXERCISES

EXERCISE 3.1 Explain the difference between a method declaration and
a method invocation.

EXERCISE 3.2 Explain the difference between a formal parameter and an
argument.

EXERCISE 3.3 Modify the OneRowNim class of Figure 3.4 by adding
two instance variables of type String to store names of the two play-
ers. Choose names for the instance variables that would be appropri-
ate for storing names for player one and player two. Write a method
named setNames() with two string parameters which assigns the first
parameter to the instance variable that you created for the name of player
one. The second parameter should be assigned to the other new instance
variable.

EXERCISE 3.4 Write a statement that calls the setName() method of
the previous exercise and sets the name of player one of game to "Xena"
and sets the name of player two to "Yogi".

3.3 Constructor Methods

In the previous section, we looked at several examples of mutator meth-
ods that change the values of private instance variables of an object. It
                                   110  CHAPTER 3  Methods: Communicating with Objects

Constructor names                  is possible to define mutator methods to set the initial values of instance
Constructing an object             variables after an object is created, but initial values can also be set by
Initializing variables             constructors.
Constructors can't return a value
                                      As you recall from Chapter 0, a constructor method is used to create
                                   an instance (or object) of a class and to assign initial values to instance
                                   variables. A constructor declaration looks just like a method definition
                                   except it must have the same name as the class, and it cannot declare a
                                   result type. Unlike the class level variables and methods of a class, con-
                                   structors are not considered members of the class. Therefore, they are not
                                   inherited by a class's subclasses. Access to constructors is governed by the
                                   access modifiers public and private. Here is a simple constructor for
                                   our OneRowNim class:

                                                                                                                  

                                   public OneRowNim ( )

                                   { nSticks = 7;

                                        player = 1;

                                   }

                                                                                                                  

                                   This constructor merely sets the initial values of the instance variables,
                                   nSticks and player. In our current version of OneRowNim these vari-
                                   ables are given initial values by using initializer statements when they are
                                   first declared:

                                                                                                                  

                                        private int nSticks = 7;

                                        private int player = 1;                                                   

                                   So we now have two ways to initialize a class's instance variables. In the
                                   OneRowNim class it doesn't really matter which way we do it. However,
                                   the constructor provides more flexibility because it allows the state of the
                                   object to be initialized at runtime. Of course, it would be somewhat redun-
                                   dant (though permissible) to initialize the same variable twice, once when
                                   it is declared and again in the constructor, so we should choose one or
                                   the other way to do this. For now, let's stick with initializing the instance
                                   variables when they are declared.

                                   JAVA EFFECTIVE DESIGN Constructors. Constructors provide a
                                   flexible way to initialize an object's instance variables when the object
                                   is created.

                                   A constructor cannot return a value and, therefore, its declaration cannot
                                   include a return type. Because they cannot return values, constructors
                                   cannot be invoked by a regular method invocation. Instead, constructors
                                   are invoked as part of an instance creation expression when instance objects
                                   are created. An instance creation expression involves the keyword new
                                   followed by the constructor invocation:

                                                                                                                  

                                   OneRowNim game // D e c l a r e

                                        = new OneRowNim ( ) ; // a n d i n s t a n t i a t e g a m e 1

                                   OneRowNim game2 // D e c l a r e

                                        = new OneRowNim ( ) ; // a n d i n s t a n t i a t e g a m e 2            
SECTION 3.3  Constructor Methods                            111

Note here that we have combined variable declaration and instantiation
into a single statement, whereas in some previous examples we used sep-
arate declaration and instantiation statements. Either way is acceptable.

JAVA LANGUAGE RULE Constructors. Constructors cannot
return a value. Therefore, no return type should be declared when the
constructor is defined.

JAVA DEBUGGING TIP When to Use Return. All method
definitions except constructors must declare a return type.

Constructors should be used to perform the necessary initialization op-        State initialization
erations during object creation. In the case of a OneRowNim object, what      
initializations could be performed? One initialization that would seem        
appropriate is to initialize the initial number of sticks to a number speci-  
fied. In order to do this, we would need a constructor with a single int      
parameter:

 

    public OneRowNim( i n t s t i c k s )
    { nSticks = sticks ;
    }
 

Now that we have this constructor we can use it when we create instances
of OneRowNim:

 

   OneRowNim game1 = new OneRowNim ( 2 1 ) ;
   OneRowNim game2 = new OneRowNim ( 1 3 ) ;
 

The effect of these statements is the same as if we had used the
setSticks() method that was discussed briefly on page 103. The dif-
ference is that we can now set the number of sticks when we create the
object.

   Should we keep the preceding constructor, or keep the setSticks()
method or keep both in our class definition? The constructor can only
be invoked as part of a new statement when the object is created but the
setSticks() method could be called anytime we want. In many cases,
having redundant methods for doing the same task in different ways
would be an asset, because it allows for more flexibility in how the class
could be used. However, for a game like One Row Nim, a major concern
is that the two instance variables get changed only in a manner consistent
with the rules for One Row Nim. The best way to guarantee this is to have
takeSticks() as the only method that changes the instance variables
nSticks and player. The only time that it should be possible to set the
number of sticks for a game is when a constructor is used to create a new
instance of OneRowNim.

SELF-STUDY EXERCISES
                 112  CHAPTER 3  Methods: Communicating with Objects

                 EXERCISE 3.5 What's wrong with the        following          constructor   defini-
                 tion?                                                                            

                                                                                                  

                   public void OneRowNim( i n t  sticks )

                   { nSticks = sticks ;

                   }
                 

                 EXERCISE 3.6 Change the OneRowNim(int sticks) constructor so
                 that it sets the number of sticks and also have it also set player two as the
                 player who takes the first turn.

                 3.3.1 Default Constructors

                 As we noted in Chapter 2, Java automatically provides a default constructor
                 when a class does not contain a constructor.

                   JAVA LANGUAGE RULE Default Constructor. If a class contains
                   no constructor declarations, Java will automatically supply a default
                   constructor. The default constructor takes no parameters. If the class is
                   public, the default constructor will also be public and, hence,
                   accessible to other objects.

                 The default constructor's role is simply to create an instance (an object) of
                 that class. It takes no parameters. In terms of what it does, the default
                 constructor for OneRowNim would be equivalent to a public constructor
                 method with an empty body:

                                                                                                

                   public OneRowNim ( ) { }                                                     
                 

                 This explains why the following statement was valid when a class defini-
                 tion of OneRowNim contained no explicit definition of a constructor:

                                                                                                

                   OneRowNim game = new OneRowNim ( ) ;
                                                                                                

                 3.3.2 Constructor Overloading and Method Signatures

Flexible design  It is often quite useful to have more than one constructor for a given class.
                 For example, consider the following two OneRowNim constructors:

                                                                                                

                   p u b l i c OneRowNim ( ) {} // C o n s t r u c t o r # 1

                   p u b l i c OneRowNim( i n t s t i c k s ) // C o n s t r u c t o r # 2

                   { nSticks = sticks ;

                   }

                                                                                                

                 The first is an explicit representation of the default constructor. The sec-
                 ond is the constructor we defined earlier to initialize the number of sticks
                 in a OneRowNim object. Having multiple constructors lends flexibility to
                 the design of a class. In this case, the first constructor merely accepts
                 OneRowNim's default initial state. The second enables the user to initialize
                 the number of sticks to something other than the default value.
SECTION 3.3  Constructor Methods                            113

   In Java, as in some other programming languages, when two different            Method overloading
methods have the same name, it is known as method overloading. In
this case, OneRowNim is used as the name for two distinct constructor            
methods. What distinguishes one constructor from another is its signa-           
ture, which consists of its name together with the number and types of
formal parameters it takes. Thus, our OneRowNim constructors have the             Methods are known by their
following distinct signatures:                                                    signatures

 

   OneRowNim ( )
   OneRowNim( i n t )
 

Both have the same name, but the first takes no parameters, whereas the
second takes a single int parameter.

   The same point applies to methods in general. Two methods can have
the same name as long as they have distinct signatures. A method signa-
ture consists of its name, and the number, types, and order of its formal
parameters. A class may not contain two methods with the same signa-
ture, but it may contain several methods with the same name, provided
each has a distinct signature.

JAVA LANGUAGE RULE Method Signature. A method signature
consists of the method's name, plus the number, types, and order of its
formal parameters. A class may not contain two methods with the
same signature.

There is no limit to the amount of overloading that can be done in design-
ing constructors and methods. The only restriction is that each method
have a distinct signature. For example, suppose in addition to the two
constructors we have already defined, we want a constructor that would
let us set both the number of sticks and the player who starts first. The
following constructor will do what we want:

                                                                                 

public OneRowNim( i n t s t i c k s , i n t s t a r t e r )

{ nSticks = sticks ; // S e t t h e number of s t i c k s

   player = s t a r t e r ; // S e t who s t a r t s

}

                                                                                 

When calling this constructor, we would have to take care to pass the num-
ber of sticks as the value of the first argument and either 1 or 2 as the value
of the second argument:

                                                                                 

OneRowNim game3 = new OneRowNim( 1 4 , 2 ) ;

OneRowNim game4 = new OneRowNim( 3 1 , 1 ) ;
                                                                                 

If we mistakenly reversed 14 and 2 in the first of these statements, we
would end up with a OneRowNim game that starts with 2 sticks and has
player 14 as the player with the first move.
                                       114            CHAPTER 3  Methods: Communicating with Objects

                                          We have now defined three constructor methods for the OneRowNim
                                       class. Each constructor has the name OneRowNim, but each has a distinct
                                       signature:

                                                                                                                      

                                       OneRowNim ( )

                                       OneRowNim( i n t )

                                       OneRowNim( i n t , i n t )
                                                                                                                      

                                       3.3.3 Constructor Invocation

                                       A constructor method is invoked only as part of a new expression when

A constructor is invoked once to cre-  an instance object is first created. Each of these is a valid invocation of a
ate an object
                                       OneRowNim constructor:

                                                                                                                      

                                                               // D e f a u l t c o n s t r u c t o r

                                       OneRowNim game1 = new OneRowNim ( ) ;

                                                               // S e t s number o f s t i c k s

                                       OneRowNim game2 = new OneRowNim ( 2 1 ) ;

                                                               // S e t s b o t h i n s t a n c e v a r i a b l e s

                                       OneRowNim game3 = new OneRowNim( 1 9 , 2 ) ;
                                                                                                                      

                                       The following constructor invocations are invalid because there are no

                                       matching constructor definitions:

                                                                                                                      

                                                               // No m a t c h i n g c o n s t r u c t o r s

                                       OneRowNim game4 = new OneRowNim( " 21 " ) ;

                                       OneRowNim game5 = new OneRowNim( 1 2 , 2 , 5 ) ;                               
                                       

                                       In the first case, there is no constructor method that takes a String pa-
                                       rameter, so there's no matching constructor. In the second case, there is no
                                       constructor that takes three int arguments. In both cases, the Java com-
                                       piler would complain that there is no constructor method that matches the
                                       invocation.

                                       JAVA DEBUGGING TIP Method Call. The signature of the method
                                       call--its name and the number, types, and order of its
                                       arguments--must exactly match the signature of the method
                                       definition.

                                       3.4 Retrieving Information from an Object

                                       The modifications we've made to the OneRowNim class allow us to set the
                                       instance variables of a OneRowNim object with a constructor, but there is
                                       no way for us to retrieve their values other than to use the report()
                                       method to write a message to the console. We will want to be able to
                                       ask a OneRowNim object to provide us with the number of sticks remain-
                                       ing and who plays next when we develop a graphical user interface for
                                       OneRowNim in the next chapter. We declared nSticks and player as
                                       private variables, so we cannot access them directly. Therefore, we will
SECTION 3.4  Retrieving Information from an Object  115

need accessor methods to get the values of each of the instance variables.
Consider the following method definitions:

                                                                             

public int getSticks ()
{ return nSticks ;
}

public int getPlayer ()

{ return player ;

}

                                                                             

Recall that a method's ResultType is specified just in front of the Method-
Name. We want the two methods to return int values that represent
OneRowNim's instance variables. Therefore, their result types are both
declared int.

   Before we discuss how the value that is returned by a method is used
when the method is called, let's consider one more method definition.
Many methods that return a value do a computation rather than simply
returning the value of an instance variable. For example, suppose we wish
to define a method for the OneRowNim class that will notify the user of an
instance of the class whether the game is over. Thus we want a method
that, when called, returns a true or false depending on whether or
not all the sticks have been taken. gameOver() is a descriptive name
of such a method and the method should have a boolean result type.
This method should return true when the instance variable nSticks no
longer contains a positive int value. Thus we can define:

                                                                             

public boolean gameOver ( )

{ r e t u r n ( n S t i c k s <= 0 ) ;

}

                                                                             

The expression (nSticks <= 0) evaluates to a false value if nSticks
stores a positive value and it evaluates to true otherwise. Thus the value
returned is precisely what is required.

3.4.1 Invoking a Method That Returns a Value

When we invoke a method that returns a value, the invocation expression       Retrieving information
takes on, or is replaced by, the value that is returned. For example, if we  
execute the statements                                                       

 

   OneRowNim game1 = new OneRowNim ( 1 1 ) ;
    i n t s t i c k s L e f t = game1 . g e t S t i c k s ( ) ;
 

the expression game1.getSticks() will take on the value 11 after the
getSticks() method is finished executing. At that point, the second
statement above can be treated as if expression game1.getSticks() is
                            116  CHAPTER 3  Methods: Communicating with Objects

                            replaced with the value 11, which is assigned to sticksLeft. In effect,
                            the second statement is equivalent to the following statement:

                                                                                                          

                            int sticksLeft = 11;                                                          
                            

                            JAVA LANGUAGE RULE Evaluating Method Calls. A nonvoid
                            method call is an expression that has a value of a particular type. After
                            the method is executed, the method call expression becomes the value
                            returned.

                               We can use a value returned by a method call the same way we use a
                            literal value of the same type. It can be assigned to variables, be part of
                            a numerical expression, or be an argument of another method. All of the
                            following statements involve valid calls of methods that return values:

                                                                                                          

                            i n t f e w e r S t i c k s = game1 . g e t S t i c k s ( ) - 1 ;

                            boolean done = game1 . gameOver ( ) ;

                            System . out . p r i n t l n ( game1 . g e t P l a y e r ( ) ) ;

                            game1 . g e t S t i c k s ( ) ;
                                                                                                          

                            In each statement, the method call can be replaced with the value it re-
                            turns. Notice that the last statement is valid but does nothing useful. In
                            Java and some other languages like C and C++, methods that return a
                            value can simply be called without making use of the value returned. This
                            may be useful to do if the method changes the state of instance variables
                            or sends a message to another object or an output device. The method
                            getSticks() does nothing but return the value of nSticks, so simply
                            calling the method accomplishes nothing.

                            3.4.2 An Expanded OneRowNim Class

Redundancy and flexibility  Let's add the new methods that return values to our OneRowNim class. We
                            might note that the report() method from the previous chapter displays
                            the values of nSticks and player in the console window which now
                            could be done by using the methods getSticks() and getPlayer()
                            with System.out.println(). However, calling report() is an easy
                            way to display the values of both instance variables but it cannot provide
                            access to either variable as an int value. So let's keep all three methods
                            in our class definition. The inconvenience of a small amount of redun-
                            dancy is outweighed by the added flexibility of being able to call all three
                            methods.

                            JAVA EFFECTIVE DESIGN Using Redundancy. Incorporating some
                            redundancy into a class, such as providing more than one way to
                            access the value of an instance variable, makes the class more widely
                            usable.

                            Figure 3.5 provides a UML class diagram of the expanded OneRowNim
                            class.
SECTION 3.4  Retrieving Information from an Object                117

               OneRowNim
               - nSticks: int
               - player: int
               + OneRowNim()
               + OneRowNim(in sticks:int)
               + OneRowNim(in sticks:int,in starter:int)
               + takeSticks(in num:int)
               + getSticks():int
               + getPlayer():int
               + gameOver():boolean
               + report()

  Figure 3.5: A UML class diagram for the expanded OneRowNim.

   Let's also consider a new main() method to test the new methods of
the class. A very short list of statements that call each of the three new
methods returning values is given in the main() method in Figure 3.6

                                                                   

public s t a t i c void main ( S t r i n g [ ] args )

{ OneRowNim game = new OneRowNim ( 1 3 , 2 ) ;

  game . t a k e S t i c k s ( 2 ) ;

  System . out . p r i n t ( "The game i s over i s : " ) ;

  System . out . p r i n t l n ( game . gameOver ( ) ) ;

  System . out . p r i n t ( "The next turn i s by player : " ) ;

  System . out . p r i n t l n ( game . g e t P l a y e r ( ) ) ;

  System . out . print ( " Sticks remaining : " ) ;

  System . out . p r i n t l n ( game . g e t S t i c k s ( ) ) ;

} // main ( )

                                                                   

Figure 3.6: A main() method that tests the new methods for OneRowNim

The output to the console when this program is run will be:

                                                                            

  The game i s over i s : f a l s e

  The next turn i s by player : 1

  Sticks remaining : 11                                                     

Note that the constructor sets player to 2, so player stores the value 1
after one turn.

SELF-STUDY EXERCISES
                           118                 CHAPTER 3  Methods: Communicating with Objects

                           EXERCISE 3.7 What would these segments of Java code display on the
                           screen?

                                                                                                 

                           OneRowNim myGame = new OneRowNim ( 1 0 , 2 ) ;

                           System . out . p r i n t l n (myGame . g e t P l a y e r ( ) ) ;

                           System . out . p r i n t l n ( 2  myGame . g e t S t i c k s ( ) ) ;

                           System . out . p r i n t l n (myGame . gameOver ( ) ) ;               
                           

                           EXERCISE 3.8 Suppose that an int instance variable named nMoves
                           is added to the OneRowNim class that counts the number of moves taken
                           in a One Row Nim game. Write a Java method for the OneRowNim class
                           to get the value stored in nMoves.

                           EXERCISE 3.9 Write a method for the OneRowNim class called
                           playerOneGoesNext() that returns a boolean value. The value re-
                           turned should be true if and only if player one has the next turn.

                           3.5 Passing a Value and Passing a Reference

Passing a primitive value  The effect of passing arguments to a method differs depending on whether
                           you are passing a value of primitive type (such as 5 or true) or a value of
                           reference type (such as "Hello" or game1). When an argument of primi-
                           tive type is passed to a method, a copy of the argument is passed to the for-
                           mal parameter. For example, consider the PrimitiveCall class shown

                                                                                                 

                           public class PrimitiveCall
                           {

                                public s t a t i c void myMethod ( i n t n )
                                { System . out . p r i n t l n ( "myMethod : n= " + n ) ;

                                       n = 100;
                                       System . out . p r i n t l n ( "myMethod : n= " + n ) ;
                                } // myMethod ( )

                                public s t a t i c void main ( S t r i n g argv [ ] )

                                { int k = 5;

                                System . out . p r i n t l n ( "main : k= " + k ) ;

                                myMethod ( k ) ;

                                System . out . p r i n t l n ( "main : k= " + k ) ;

                                } // main ( )

                           } // P r i m i t i v e C a l l

                                                                                                 

                                Figure 3.7: Passing a primitive value to a method.

                           in Figure 3.7. Note that we have an int variable k, which initially stores
                           the value 5, and a method myMethod(), which takes an int parameter n.
                           In this case, when we invoke myMethod(k), k's value (5) is copied into n
                           and stored there during the method.
SECTION 3.5  Passing a Value and Passing a Reference  119

   One implication of passing a copy of a primitive value to a method is
that the original value of k in main() cannot be altered from inside the
method. Thus, the output generated by PrimitiveCall would be

                                                                          

  main : k= 5

  myMethod : n= 5

  myMethod : n= 100

  main : k= 5                                                             

Note that in main(), k's value is printed both before and after
myMethod() is called, but that its value remains unaffected even though
n's value is changed within the method. This is because myMethod()
contains just a copy of k's value, not k itself. Any changes to the copy
within myMethod() leave k unaltered (See Fig. 3.8).

JAVA LANGUAGE RULE Passing a Primitive Value. When a value
of a primitive type, like boolean or int, is passed to a method, a
copy of the value is passed. That's why its original value remains
unchanged outside the method, even if the copy is changed inside the
method.

In contrast to this, when an argument of a reference type is passed to a
method, a copy of the reference to the object itself is assigned to the pa-
rameter. For example, in the case of a String parameter or a OneRowNim
parameter, the method would be given a reference to the object-that is,
the address of the object. The object itself is not passed, because it would
be too inefficient to copy the entire object with all its data and methods.
However, because the object's reference gives the object's location in mem-
ory, the method will have access to the object and can make changes to the
original object from within the method.

                                                                                                     Figure 3.8: Tracing the state
                                                                                                     of variables k and n in
                                                                                                     PrimitiveCall (a) Just be-
                                                                                                     fore calling myMethod(k) in
                                                                                                     main. (b) Just before executing
                                                                                                     the body of myMethod(). (c)
                                                                                                     Just after executing the body of
                                                                                                     myMethod(). (d) After flow of
                                                                                                     control returns to main().
120                CHAPTER 3  Methods: Communicating with Objects

   For example, consider the ReferenceCall class (Fig. 3.9). In this
case, myMethod() takes a parameter g of type OneRowNim. Because

                                                                                   

public class ReferenceCall
{

     public s t a t i c void myMethod (OneRowNim g )
     { System . out . p r i n t ( "myMethod : Number o f s t i c k s : " ) ;

            System . out . println (g . getSticks ( ) ) ;
            g. takeSticks (3);
            System . out . p r i n t ( "myMethod : Number o f s t i c k s : " ) ;
            System . out . println (g . getSticks ( ) ) ;
     } // myMethod ( )

     public s t a t i c void main ( S t r i n g argv [ ] )

     { OneRowNim game = new OneRowNim ( 1 0 ) ;

     System . out . p r i n t ( "main : Number o f s t i c k s : " ) ;

     System . out . p r i n t l n ( game . g e t S t i c k s ( ) ) ;

     myMethod ( game ) ;

     System . out . p r i n t ( "main : Number o f s t i c k s : " ) ;

     System . out . p r i n t l n ( game . g e t S t i c k s ( ) ) ;

     }// main ( )

} // R e f e r e n c e C a l l

                                                                                   

     Figure 3.9: Passing a reference value to a method.

a OneRowNim instance is an object, g is a reference variable. So when
myMethod(game) is invoked in main(), a reference to game is passed
to myMethod(). Note that in myMethod(), we use takeSticks(3) to
change the number of sticks of g from 10 to 7 and that this change persists
even after the method returns control to main(). The reason is that dur-
ing the method's execution, both game and g refer to the exact same object
(see Fig. 3.10). The output generated by ReferenceCall would be

                                                                                   

     main : Number o f s t i c k s : 10

     myMethod : Number o f s t i c k s : 10

     myMethod : Number o f s t i c k s : 7

     main : Number o f s t i c k s : 7                                             

This illustrates that when passing a reference variable to a method, it is
possible for the method to change the state of the object associated with
SECTION 3.6  Flow of Control: Control Structures  121

                                                                                  Figure 3.10:  Tracing the

                                                                                  state of OneRowNim object in

                                                                                  ReferenceCall (a) Just before

                                                                                  calling myMethod(game). (b)

                                                                                  Just before executing the body of

                                                                                  myMethod(). (c) Just after exe-

                                                                                  cuting the body of myMethod().

                                                                                  (d) After flow of control returns

                                                                                  to main().

the reference variable. In subsequent chapters we will see ways to make
use of this feature of reference parameters.

 JAVA LANGUAGE RULE Passing a Reference. When a reference to
 an object is passed to a method, any changes made to the object from
 within the method will persist when the method is finished executing.

JAVA DEBUGGING TIP Side Effects. An unintended change to an
object is called a side effect. Care should be taken in designing
methods that the method does not produce unwanted side effects in
objects passed as reference parameters.

3.6 Flow of Control: Control Structures

We have been ignoring a couple of problems with the definition of the
OneRowNim class. One problem is that we would describe a One Row
Nim game as two players taking turns until there are no more sticks. An
object using OneRowNim would need a way to repeatedly execute a group
of statements. One command in Java that controls the repetition of a block
of statements is called a while loop. We will consider it later in this section.

   A second problem is with the definition of takeSticks():

                                                                                  

  public void t a k e S t i c k s ( i n t num)

  { n S t i c k s - num ;

     player = 3 - player ;

  }

                                                                                  
                     122               CHAPTER 3  Methods: Communicating with Objects

                     It is possible to call this method with an argument greater than 3 or less
                     than 1. The call game.takeSticks(5) will remove 5 sticks even though
                     the rules of One Row Nim say that you must remove 1, 2, or 3. While one
                     might assume that the user interface should prevent the user from break-
                     ing this rule, it is a far better design if it was dealt with in OneRowNim.
                     To do this we need a Java structure that executes different statements de-
                     pending on whether the parameter is greater than 3, less than 1, or be-
                     tween 1 and 3. The Java if-else statement has this capability. A fuller treat-
                     ment of control structures appears in Chapter 6, but in this section, we will
                     briefly introduce a couple of simple control structures. This will enable us
                     to write programs that take more interesting actions.

                     3.6.1 The Simple If Statement

Simple if statement  A selection control structure, allows a program to select between two or
                     more alternative paths of execution. The if statement is the most basic
                     selection control structure in Java. Most programming languages have its
                     equivalent.

                     JAVA LANGUAGE RULE If Statement. The if statement has the
                     following syntax:

                                             if ( boolean expression )

                                                    containedstatement ;

                     The statement contained in the if statement can be any valid Java state-
                     ment, including a compound statement. (Recall from Chapter 1 that
                     a compound statement is a set of statements contained within curly
                     braces.) The boolean expression is an expression that is either true
                     or false. We have seen examples of boolean expressions that involve
                     int variables, int values, and the inequality or equality operators. A
                     method call to a method with a boolean result type is another example
                     of a boolean expression. Given this description of if statement syntax,
                     the following are examples of valid if statements:

                                                                                                     

                     i f ( true ) System . out . println ( "Hello" ) ;

                     i f ( n S t i c k s <= 0 ) System . out . p r i n t l n ( "game i s over " ) ;  
                     

                     For readability, we usually write an if statement with its contained state-
                     ment indented on the next line:

                                                                                                     

                          if ( true )

                          System . out . println ( "Hello" ) ;

                          i f ( n S t i c k s <= 0 )

                          System . out . p r i n t l n ( "game i s over " ) ;                        
SECTION 3.6  Flow of Control: Control Structures                                        123

The following are all examples of syntax errors involving the if statement:

                                                                                              

if true                                    // P a r e n t h e s e s a r e m i s s i n g

  System . out . println ( "Hello" ) ;

i f ( n S t i c k s <= 0 ) r e t u r n // S e m i c o l o n m i s s i n g

if ( "true" ) return ; // " t r u e " i s not a b o o l e a n

  if ( true ) "Hello" ;         // " H e l l o " i s n o t a s t a t e m e n t                              True
                                                                                                               statement
                                                                                                boolean

                                                                                                 condition

Semantically, the if statement has the following interpretation: First, the                      False
boolean condition is evaluated. If it is true, then the contained statement is
executed; if it is false, then the contained statement is not executed. This is                Figure 3.11: Flowchart of the if
shown in Figure 3.11. The flowchart clearly shows that program flow will                       statement. Diamond-shaped sym-
take one or the other of the alternative paths coming out of the diamond-                      bols at the branch points contain
shaped boolean condition box. The branch through the rectangular state-                       쮊oolean expressions. Rectangu-
ment box will be taken when the boolean condition is true; otherwise the                       lar symbols can only contain ex-
statement will be skipped.                                                                     ecutable statements. Circles act
                                                                                               simply as connectors, to connect
   As another example, consider the definition of a getPlayerString()                          two or more paths.
method for the OneRowNim class:
                                                                                              


public String getPlayerString ()
{

      i f ( p l a y e r == 1 )             // E x i t t h e method
         r e t u r n " P l a y e r One" ;
                                           // E x i t t h e method
      i f ( p l a y e r == 2 )                 // E x i t t h e method
         r e t u r n " P l a y e r Two" ;

     return "Player error" ;
  }


The flowchart in Figure 3.12 shows the program flow of the entire
getPlayerString() method. It is important to note that when a

                                                                                              Figure 3.12: Flowchart of the
                                                                                              getPlayerString() method.

                            True
         player == 1

         False                  return "Player One"  exit method

         player == 2 True

                False           return "Player Two"  exit method
         return "Player error"

                               exit method

return statement is executed in a method, control is returned im-
                    124  CHAPTER 3  Methods: Communicating with Objects

Compound statement  mediately to the calling method. Thus, if player == 1 is true,
Local scope         the string "Player One" is returned to the calling method and the
                    getPlayerString() method exits at this point. If it is false, then
                    player == 2 should be true (if we have a consistent state) and the string
                    "Player Two" should be returned and the method exited. Thus, if we have
                    a consistent state --that is, if player has value 1 or 2--then the third
                    return statement should never be reached.

                       The following example shows the more common case where the state-
                    ment contained in an if statement can be a compound statement:

                                                                                                              

                    i f ( p l a y e r == 1 )

                    { S t r i n g s = " P l a y e r One" ;

                         System . out . print ( s ) ;

                         System . out . println ( " plays next" ) ;

                         System . out . p r i n t l n ( " The game i s not over " ) ;

                    }

                                                                                                              

                    If player == 1 is true, then all four statements in the contained com-
                    pound statement will be executed. Note here that we are declaring the
                    local variable, s, in this block. Its scope would extend only to the end of
                    the block. Note also that when we use a compound statement, the com-
                    pound statement itself is not followed by a semicolon because it is already
                    enclosed in braces.

                       A common programming error is to forget the braces around the com-
                    pound statement. Merely indenting the statements following the if clause
                    doesn't alter the logic of the if statement. For example, the following if
                    statement still has only one statement in its if clause:

                                                                                                              

                    if ( condition1 )

                         System . out . p r i n t l n ( "One" ) ;

                         System . out . p r i n t l n ( "Two" ) ; // N o t p a r t o f i f s t a t e m e n t  

                    This segment will always print "Two" because the second println() is
                    not part of the if statement. To include it in the if statement, you must
                    enclose both println() statements within braces:

                                                                                                              

                    if ( condition1 )

                    { System . out . p r i n t l n ( "One" ) ;

                         System . out . p r i n t l n ( "Two" ) ;

                    }

                                                                                                              

                    JAVA DEBUGGING TIP Indentation. Indentation can improve the
                    readability of a program but doesn't affect its logic. Braces must be
                    used to group statements in the if clause.

                    3.6.2 The if-else Statement

                    A second version of the if statement incorporates an else clause into the
                    structure. This allows us to execute either of two separate statements (sim-
SECTION 3.6  Flow of Control: Control Structures            125

ple or compound) as the result of one boolean expression. For example,
the statement

                                                                                        

i f ( p l a y e r == 1 )

      System . out . p r i n t l n ( " P l a y e r One" ) ;

else

      System . out . p r i n t l n ( " P l a y e r Two" ) ;                             

will print "Player One" if player == 1 is true. Otherwise, it will print
"Player Two".

JAVA LANGUAGE RULE If-else Statement.                        The if-else statement has

the following syntax:         ( boolean expression )
                          if

                              statement1 ;

      else

                              statement2 ;

As in the case of the simple if statement, the keyword if is followed by                If-else syntax
a parenthesized boolean expression, which is followed by statement1, which
may be either simple or compound. If statement1 is a simple statement,                     False        boolean    True
then it is followed by a semicolon. The else clause follows immediately                                 condition
after statement1. It begins with the keyword else, which is followed by
statement2, which can also be either a simple or compound statement.                    statement2                 statement1
Note that there is no boolean expression following the else keyword.
In an if-else statement, the boolean expression following the keyword if                Figure 3.13: Flowchart of the
goes with both the if and else clauses.                                                 if-else statement.

   Semantically, the if-else statement has the following interpretation: If
the boolean expression is true, execute statement1; otherwise execute state-
ment2. This interpretation is shown in Figure 3.13.

3.6.3 The Nested if/else Multiway Selection Structure

The statements that one inserts in place of statement1 and statement2 in
the if-else statement can be any executable statement, including another
if statement or if-else statement. In other words, it is possible to embed
one or more if-else statements inside another if-else statement, thereby
creating a nested control structure. As with most things, making a control
structure too complex isn't a good idea, but there is a standard nested if-
else control structure that is very useful. It is known as multiway selec-
tion. As shown in Figure 3.14, the multiway structure is used when you
want to select one and only one option from several alternatives.

   Suppose we have an int variable num that will contain one of the val-
ues 1, 2, or 3 unless there has been an error assigning a value to it. Sup-
pose that we want to write code that will write out the English word for
                                                 126  CHAPTER 3  Methods: Communicating with Objects
Figure 3.14: Flowchart of a nested
if-else statement.

                                                                                   False                 True
                                                                                               num == 1

                                                                                                         One

                                                                     False                    True
                                                                            num == 2

                                                                                                Two

                                                      False                 True
                                                                 num == 3

                                                       Error:               Three
                                                      Unknown value

                       the value in num. In the example shown in Figure 3.14 there are three
                       alternatives plus an error state. Here is the Java code for this example:

                                                                                                                        

                       i f (num == 1 )

                                                      System . out . p r i n t l n ( "One" ) ;

                       e l s e i f (num == 2 )

                                                      System . out . p r i n t l n ( "Two" ) ;

                       e l s e i f (num == 3 )

                                                      System . out . println ( "Three" ) ;

                       else

                                                      System . out . p r i n t l n ( " E r r o r : Unknown value " ) ;  

Multiple alternatives  Note that the multiway structure has a single entry point and that only one
                       of the four possible alternatives is executed. The code will print exactly
                       one of the strings.

                          We will have many occasions to use the if-else structure. Al-
                       though it does not represent a significant change, we could rewrite our
                       takeStick() method to make use of the if-else instead of the somewhat
                       obscure statement :

                                                                                                                        

                       player = 3 - player ;                                                                            
                       
SECTION 3.6  Flow of Control: Control Structures              127

to change the value of player from 1 to 2 or vice versa:

                                                                              

   public S t r i n g t a k e S t i c k s ( i n t num)

   { n S t i c k s = n S t i c k s - num ;

      i f ( p l a y e r == 1 )

      player = 2; // From 1 to 2

      else

      player = 1; // From 2 to 1

   }

                                                                              

In some respects this version of takeSticks() involves four lines of
code instead of one but is simpler to understand. The if-statement tests
whether the value of player is 1. If it is, the value is changed to 2. If
the value of player is not 1, then the value must be 2 and so the value is
changed to 1. Both versions of the code will give precisely the same result,
a programmer could choose to write the code either way.

SELF-STUDY EXERCISES

EXERCISE 3.10 Consider the following method with boolean param-
eter.

                                                               

public String getStatus ( boolean isDone )

{ if ( isDone )

            r e t u r n "Done" ;

      else

            r e t u r n "Not Done" ;

}

                                                               

Draw a flowchart for the if-else version of the getStatus() method, us-       Flowchart symbols
ing the figures in this section as a guide. The if-else structure should be
drawn exactly as shown in Figure 3.11. It should have a single entry point
that leads directly to the top of a diamond-shaped box that contains a
boolean condition. There should be two branches coming out of the con-
dition box. The one going to the right is the true case, and the one going
to the left is the false case. Each of these branches should contain one
rectangular box, which contains the statements that would be executed in
that case. The left and right branches should be connected by a circular
symbol that is aligned directly under the diamond box whose conditions
it connects. There should be a single exit arrow pointing directly down.

EXERCISE 3.11 Identify the error in the following statements:

                                                               

i f ( isHeavy == t r u e )
       System . out . p r i n t l n ( "Heavy" ) ;

else ;
       System . out . println ( "Light" ) ;

i f ( isLong == t r u e )

      System . out . p r i n t l n ( "Long" )

else

      System . out . println ( "Short" ) ;                     
128                  CHAPTER 3  Methods: Communicating with Objects

EXERCISE 3.12 Suppose we have an int instance variable named
player in some class describing a three person game. Write a method
named getPlayerName() that returns a String. It should return
"Ann", "Bill", "Cal", or "Error" when the value of player is respectively
1, 2, 3, or any other value.

EXERCISE 3.13 How does a parameter for a primitive type differ from
a parameter for a reference type?

3.6.4 The While Structure

A repetition structure is a control structure that repeats a statement or
sequence of statements in a controlled way. Repetition structures are also
referred to as loop structures. Many types of programming tasks require
a repetition structure. Consider some examples.

      You want to add up the squares of the numbers from 1 to 100.

      You want to compute compound interest on an amount of money in
        a savings account with a fixed interest rate if it is kept there for 30
        years.

      A computer security employee wants to try every possible password
        in order to break into an account of a suspected spy.

      You want to have players input moves for a turn in a game until the
        game is over. Our OneRowNim is such an example.

   We will study several different repetition structures of Java in depth in
Chapter 6. We will briefly consider the while statement here so as to be
able to define methods that are more powerful and more interesting. Let
us write a method that solves a slight generalization of the first problem
above. We will use the while statement to sum the squares of integers from
1 to a number specified as a parameter of the method. Thus, the method
call sumSquares(3) should return the value 14 since 1  1 + 2  2 + 3  3 =
1 + 4 + 9 = 14.

                                                                                 

public i n t sumSquares ( i n t max )

{ i n t num = 1 ;

     i n t sum = 0 ;

     while (num <= max ) { // W h i l e num <= max

     sum = sum + numnum ; // Add s q u a r e t o sum

     num = num + 1 ;    // Add 1 t o num

     } // w h i l e

     r e t u r n sum ;  // R e t u r n t h e sum

}

                                                                                 

Note that in this example, the variable num gets assigned an initial value
of 1 before the while statement. Note also that the boolean expression
num < max in parentheses after while states the condition for which we
wish to continue summing squares. Finally note that the last statement
in the block following the boolean expression adds 1 to num-that is, this
variable is updated at the end of the block.
SECTION 3.6  Flow of Control: Control Structures                  129

   The while statement is a loop statement in which the loop entry condi-
tion occurs before the loop body. It has the following general form:

JAVA LANGUAGE RULE While Statement. The while statement has
the following syntax:

                        while ( loop entry condition )

                                           loopbody ;

When the while statement is executed, the loop entry condition is evalu-
ated and if this evaluates to false, execution continues at the statement
immediately after the loop body. If the loop entry condition evaluates to
true, the loop body is executed and then the entry condition is evalu-
ated again. The loop body continues to be executed until the loop entry
condition evaluates to false.

   To have a while statement accomplish a task, the variable or variables
in the loop entry condition must be initialized correctly before the while
statement and these variables must be correctly updated at the end of the
loop body. We can refer to the initializer statement followed by a while
statement as a while structure. We can restate the above guidelines as a
design principle:

 JAVA EFFECTIVE DESIGN Loop Structure. A properly designed
 while structure must include an initializer, a loop entry condition, and
 an updater. The updater should guarantee that the loop entry
 condition eventually fails, thereby allowing the loop to terminate.

In pseudocode, the while structure would take the following form:

                                                                             

InitializerStatements ;  // I n i t i a l i z e r

while ( loop entry condition ) { // Bound t e s t

   Statements ;          // Loop body

   UpdaterStatements ;   // U p d a t e r

}

                                                                             

As its form suggests, the while structure is designed so that on some con-
ditions the loop body will never be executed. Because it tests for the loop
entry condition before the loop body, it is possible that the loop body is
never executed. We might say that it is designed to perform 0 or more
iterations.

   For example, if the method call sumSquares(-3) is executed, the loop
body will be skipped, because the loop entry condition num <= max is
false to begin with. No iterations will be performed, and the algorithm
will simply return the value 0.

   Note also that in the while statement the bound test is preceded by
initializer statements, and the loop body contains updater statements. The
semantics of the while structure are shown in Figure 3.15.
                                  130  CHAPTER 3  Methods: Communicating with Objects

Figure 3.15: Flowchart of the          While Statement                          While Structure
while statement and while struc-
ture.

                                                                   Initializer

                                                                                      Updater

                                        Condition True  Statement
                                       False
                                                                     Loop       True   Statement
                                                                     entry            (loop body)
                                                                   condition

                                                                   False

                                  SELF-STUDY EXERCISE

                                  EXERCISE 3.14 Modify the definition of the sumSquares() method
                                  to define a method named sumCubes() that sums the cubes of integers
                                  from a minimum value up to a maximum value and returns that sum.
                                  sumCubes() should have two parameters that will store the minimum
                                  and maximum values. Thus the method call sumCubes(2,3) should
                                  return 35 since 2  2  2 + 3  3  3 = 8 + 27 = 35.

                                  3.7 Testing an Improved OneRowNim

                                  Let's use the control structures that we have discussed to improve the
                                  definition of the takeSticks() method of OneRowNim. We noted ear-
                                  lier that our current definition allows 4 or more sticks to be removed
                                  from nSticks even though the rules of One Row Nim indicate that a
                                  player must take one, two, or three sticks on a turn. We can use if-else
                                  statements to make certain that no more than 3 sticks get removed.

                                     What should happen if the method takeSticks() is called with an
                                  argument that does not represent a legal number of sticks to remove? In
                                  this case, it would probably make sense to remove no sticks at all and to
                                  keep the value of player the same so that the player whose turn it is does
                                  not change. In addition, it would be nice if the method could signal that an
                                  illegal move has been attempted. This can be accomplished if we redefine
                                  takeSticks() to return a boolean value. Let's have a return value of
                                  true represent the case that a valid number of sticks have been removed
                                  and the player to play next has been changed. A return of false will
                                  indicate that an illegal move has been attempted. Making these changes
SECTION 3.7  Testing an Improved OneRowNim      131

to the takeSticks() method will yield a method definition that looks
like:

                                                                                 

public boolean t a k e S t i c k s ( i n t num)

{ i f (num < 1 ) {

  return false ; // E r r o r

  } e l s e i f ( num > 3 ) {

  return false ; // E r r o r

  } else {

  n S t i c k s = n S t i c k s - num ;

  player = 3 - player ;

  return true ;

  } // e l s e

} // t a k e S t i c k s

                                                                                 

Notice that the new definition of the takeSticks() method has a
boolean return type. Also notice that the if/else multiway structure
is used to handle the three cases of the parameter num being less than one,
more than three, or a valid number.

   Let us add one more method to the OneRowNim class. Let's define a
method called getWinner()that will return the number of the winning
player if the game is over. Recall that the player who takes the last stick
loses, so after that last play, the player whose turn it is to play next is the
winner. However, we should be concerned about what value to return if
the game is not over when the method is called. A common strategy is
to have a method return a special value to indicate that it is in a state in
which it cannot return the value requested. Returning a 0 value is a good
way to indicate that the game is not over so a winner cannot be identified.
With this information, the if/else statement can be used in the definition
of getWinner().

                                                                                 

public int getWinner ( )

{ if ( nSticks < 1)

        return player ;

  else

        return 0;

} // g e t W i n n e r ( )

                                                                                 

   We now have the final version (for this chapter) of the OneRowNim
class whose implementation is given in Figure 3.16. We have turned a
very simple class into one that contains quite a few elements. Compared
to our first version (in Chapter 1), this Chapter's version of OneRowNim
presents an interface (to other objects) that is easy and convenient to
use. The constructor methods with parameters provide an easy way
to create a OneRowNim instance with any number of sticks. The use
of private instance variables and a single, carefully designed mutator
method, takeSticks(), prevents other objects from tampering with
the state of a OneRowNim object's state. The other methods provide a
flexible way to find out the state of a OneRowNim object. The complete
implementation of this OneRowNim is shown in Figure 3.16.
132        CHAPTER 3  Methods: Communicating with Objects

                                                                                 

public c l a s s OneRowNim
{ private int nSticks = 7;

       private int player = 1;

     public OneRowNim ( )
     {
     } // OneRowNim ( ) c o n s t r u c t o r

     public OneRowNim( i n t s t i c k s )
     { nSticks = sticks ;
     } // OneRowNim ( ) c o n s t r u c t o r 2

     public OneRowNim( i n t s t i c k s , i n t  starter )
     { nSticks = sticks ;

            player = starter ;
     } // OneRowNim ( ) c o n s t r u c t o r 3

     public boolean t a k e S t i c k s ( i n t num)

     { i f (num < 1 ) r e t u r n f a l s e ;             //  Error
                                                              Error
     e l s e i f ( num > 3 ) r e t u r n f a l s e    ; //
                                                               move
     else                          // t h i s i s a   valid

     { n S t i c k s = n S t i c k s - num ;

           player = 3 - player ;

           return true ;

     } // e l s e

     } // t a k e S t i c k s ( )

     public int getSticks ()
     { return nSticks ;
     } // g e t S t i c k s ( )

     public int getPlayer ()
     { return player ;
     } // g e t P l a y e r ( )

     public boolean gameOver ( )
     { r e t u r n ( n S t i c k s <= 0 ) ;
     } // gameOver ( )

     public int getWinner ( )
     { if ( nSticks < 1) return getPlayer ( ) ;

            else return 0; // game i s not over
     } // g e t W i n n e r ( )

     public void report ( )

     { System . out . p r i n t l n ( "Number o f s t i c k s l e f t : " +

                                                              getSticks ());

     System . out . p r i n t l n ( "Next turn by player " +

                                                              getPlayer ( ) ) ;

     } // r e p o r t ( )

} // OneRowNim c l a s s

                                                                                 

     Figure 3.16: The OneRowNim class with improved methods.
SECTION 3.7  Testing an Improved OneRowNim                              133

   Let's use a while statement to test the new methods of the class. A
pseudocode description of how a game is played might look like:

                                                                              

     Choose t h e i n i t i a l number o f s t i c k s f o r t h e game
     while t h e game i s not over
     { Report t h e s t a t e o f t h e game

            P r o c e s s t h e next move
     }

     Report t h e s t a t e o f t h e game

     Report who t h e winner i s                                              

Translating this pseudocode into Java code in a main() method in a sepa-
rate class gives us the class shown in Figure 3.17. We will use the Scanner
class introduced in the previous chapter to get moves from the keyboard

                                                                         

import java . u t i l . Scanner ;

public c l a s s TestOneRowNim

{

   public s t a t i c void main ( S t r i n g argv [ ] )

   { Scanner sc = Scanner . create ( System . in ) ;

     OneRowNim game = new OneRowNim ( 1 1 ) ;

     while ( game . gameOver ( ) == f a l s e )

     { game . r e p o r t ( ) ; // P r o m p t t h e u s e r

     System . out . print ( "Input 1 , 2 , or 3: " ) ;

     int sticks = sc . nextInt ( ) ; // Get move

     game . t a k e S t i c k s ( s t i c k s ) ; // Do m o v e

     System . out . println ( ) ;

     } // w h i l e

     game . r e p o r t ( ) ; // T h e g a m e i s now o v e r

     System . out . p r i n t ( "Game won by p l a y e r " ) ;

     System . out . p r i n t l n ( game . getWinner ( ) ) ;

   } // main ( )

} // TestOneRowNim

                                                                         

     Figure 3.17: The TestOneRowNim class with a while loop.

for both players. Before each move game.report() describes the state
of the game before the user is prompted to input a move for one of the
players. A reader interested in seeing the lengthy output to the console
when the TestOneRowNim class is run is encouraged to actually run the
program.

   Note that the return value of the takeSticks() method is ignored
in this test program. We will make use of the return value in test pro-
grams in the next chapter when better user interfaces are developed for
OneRowNim. Note, however, that taken together, the public methods for
                        134  CHAPTER 3  Methods: Communicating with Objects

                        OneRowNim provide other objects with an interface that they can use to
                        communicate with individual OneRowNim objects.

                        JAVA EFFECTIVE DESIGN Interfaces. Well-designed objects
                        provide a useful public interface and protect the object's private
                        elements from other objects.

Object-oriented design  To reiterate a point made at the outset, object-oriented programming is a
                        process of constructing objects that will interact with each other. Object-
                        oriented programs must ensure that the objects themselves are well de-
                        signed in terms of their ability to carry out their designated functions.
                        Good design in this sense requires careful selection of instance variables
                        and careful design of methods to ensure that the object can carry out its
                        assigned tasks. However, equal care must be taken to ensure that the
                        interactions that take place among objects are constrained in ways that
                        make sense for that particular program. This aspect of designing ob-
                        jects comes into play in designing the methods--constructor, accessor, and
                        mutator--that make up the object's interface.

                        Special Topic: Intelligent Agents

                        Wouldn't it be nice if we had a computer program that could schedule
                        appointments for us, remind us of meetings and commitments, find in-
                        formation for us on the WWW, and manage our e-mail messages for us?
                        Wouldn't it be nice to have a computerized personal assistant?

                           Actually, such programs are called intelligent agents, which are pro-
                        grams that are capable of acting autonomously to carry out certain tasks.
                        Intelligent agent technology is becoming an important research area in
                        computer science. Most agent programs incorporate some kind of ma-
                        chine learning capability, so that their performance improves over time.

                           As a typical agent activity, suppose I was able to tell my intelligent
                        agent to buy me a copy of a certain book that I just heard about. Given a
                        command like "buy me a copy of X," the agent would perform a search
                        of online book sellers and come up with the best deal. Once it had found
                        the best buy, the agent would communicate with a computer-based agent
                        representing the book seller. My agent would make the order and pay
                        for it (assuming I gave it authority to do so), and the book seller's agent
                        would process the order.

                           As far-fetched as the capability may now seem, this is the direction
                        that research in this area is headed. Researchers are developing agent
                        languages and describing protocols that agents can use to exchange in-
                        formation in a reliable and trustworthy environment. Obviously, you
                        wouldn't want your agent to give your money to a fraudulent book seller,
                        so there are significant problems to solve in this area that go well beyond
                        the problem of simply exchanging information between two agents.

                           The best way to learn more about this research area is to do a Web
                        search using the search string "Intelligent Agent." There are numerous re-
                        search groups and companies that provide online descriptions and demos
                        of their products.
SECTION 3.8  From the Java Library java.lang.Object  135

3.8 From the Java Library java.lang.Object

The most general class in Java's class hierarchy is the java.lang.Object             java.sun.com/j2se/1.5.0/docs/api/
class. It is the superclass of all classes that occur in Java programs. By de-
fault, it is the direct superclass of any class that does not explicitly specify
a pedigree in its class definition.

   All subclasses of Object inherit the public and protected methods
contained in Object, so all such methods can be thought of as belonging
to the subclasses. This means that all classes inherit the methods of the
Object class, because every class is a subclass of it. In this section, let's
look briefly at how we can use an inherited method and also at how we
can override it-that is, redefine the method-if it doesn't exactly suit our
purposes.

   One of the most useful methods in the Object class is the
toString() method:

                                                                                  

public class Object
{

   public String toString () ;

}

                                                                                  

The toString() method returns a String representation of its object.
For example, o1.toString() will return a String that in some sense
describes o1.

   Because OneRowNim is a subclass of Object, it inherits the
toString() method. To illustrate the default behavior of toString(),
let's use it with a OneRowNim instance:

                                                                                  

   OneRowNim g1 = new OneRowNim ( 1 1 ) ;

   OneRowNim g2 = new OneRowNim ( 1 3 ) ;

   System . out . println ( g1 . toString ( ) ) ;

   System . out . println ( g2 . toString ( ) ) ;                                 

This code segment creates two OneRowNim instances, one named g1 and
the other named g2. The inherited toString() method is then invoked
on each OneRowNim instance, which produces the following output:

                                                                                  

   OneRowNim@1dc6077b

   OneRowNim@1dc60776                                                             

What this experiment shows is that the default definition of toString()
returns some kind of internal representation of its object. It looks as if it
returns the name of the object's class concatenated with its memory ad-
dress. This may be useful for some applications. But for most objects
we will want to override the default definition to make the toString()
method return a string that is more appropriate for OneRowNim.

   What String should the g1.toString() method return? Let's have
it return a String that reports the OneRowNim instances's current state,
which are the values stored in the two instance variables. To override
a method, you simply define a method with the same signature in the
             136          CHAPTER 3  Methods: Communicating with Objects

             subclass. If you call toString() with an instance of the subclass, its
             version of the method will be used. In this way, the subclass method over-
             rides the superclass version. Thus, OneRowNim.toString() will have
             the following signature:

                                                                                           

               public String toString ( ) ;                                                
             

             Let us describe the state of a oneRowNim instance very briefly in the string
             returned by the toString() method:

                                                                                           

               public String toString ()

               { return "nSticks = " + nSticks + " , player = " + player ;

               }

                                                                                           

             If we add the toString() method to the OneRowNim class and then run
             the program shown in Figure 3.18, we get the following output:

                                                                                           

                  nSticks = 9 , player = 2

                  nSticks = 13 , player = 1                                                

                                                                      

             public class TestToString
             {

               public s t a t i c void main ( S t r i n g argv [ ] )

               { OneRowNim g1 = new OneRowNim ( 1 1 ) ;

                  OneRowNim g2 = new OneRowNim ( 1 3 ) ;

                  g1 . takeSticks ( 2 ) ;

                  System . out . println ( g1 . toString ( ) ) ;

                  System . out . println ( g2 . toString ( ) ) ;

               } // main

             } // T e s t T o S t r i n g

                                                                      

             Figure 3.18: An application to test the overridden toString() method.

             While this new method may not play an important role in the OneRowNim
             class, it does provide a very brief, understandable description of the state
             of the object. This is the reason that the toString() method was in-
             cluded in the Object class.

Inheritance  3.9 Object-Oriented Design: Inheritance and
                   Polymorphism

             This use of Object's toString() method provides our first look at
             Java's inheritance mechanism and how it promotes the generality and
             extensibility of the object-oriented approach. As a subclass of Object,
             our OneRowNim class automatically inherits toString() and any other
             public or protected methods defined in Object. We can simply use
             these methods as is, insofar as they are useful to us. As we saw in this
             case, the default version of toString() wasn't very useful. In that case,
SECTION 9  OOD: Inheritance and Polymorphism                                       137

we can override the method by defining a method in our class with the
exact same method signature. The new version of toString() can be
customized to do exactly what is most appropriate for the subclass.

   One of the great benefits of the object-oriented approach is the ability
to define a task, such as toString(), at a very high level in the class
hierarchy and let the inheritance mechanism spread that task through-
out the rest of the hierarchy. Because toString() is defined in Object,
you can invoke this method for any Java object. Moreover, if you over-
ride toString() in the classes you define, you will be contributing to its
usefulness. Two important lessons from this example are

JAVA EFFECTIVE DESIGN Inheritance. The higher up in the class
hierarchy that a method is defined, the more widespread its use can be.

JAVA EFFECTIVE DESIGN Overriding toString(). The
toString() method can be overridden in any user defined Java
class. It is a useful thing to do in any class where the state of an object
can be defined briefly.

Obviously there is much more that needs to be explained about Java's
inheritance mechanism. Therefore, we will be revisiting this topic on
numerous occasions in subsequent chapters.

   Another important concept of object-oriented design is polymorphism.
The toString() method is an example of a polymorphic method. The
term polymorphism is from the Greek terms poly, which means "many,"
and morph, which means "form." The toString() method is polymor-
phic because it has different behavior when invoked on different objects.

   For example, suppose we design a class, Student, as a subclass of
Object and define its toString() method to return the student ID
number. Given this design, then obj.toString() will return a student
ID if obj is an instance of Student, but if it is an instance of OneRowNim,
it will return a the description of its state that we defined above. The
following code segment illustrates this point:

                                                                                         

Object obj ;  // o b j can r e f e r t o any O b j e c t

o b j = new S t u d e n t ( " 12345 " ) ; // o b j r e f e r s t o a S t u d e n t

System . out . println ( obj . toString ( ) ) ; // P r i n t s " 1 2 3 4 5 "

o b j = new OneRowNim ( 1 1 ) ; // o b j r e f e r s t o a OneRowNim

System . out . println ( obj . toString ( ) ) ;

// P r i n t s : n S t i c k s = 1 1 , p l a y e r = 1

                                                                                         

In this case, the variable obj is used to refer to a Student and then to a
OneRowNim instance. This is okay because both classes are subclasses of
Object. When toString() is invoked on obj, Java will figure out what
subclass of Object the instance belongs to and invoke the appropriate
toString() method.
138              CHAPTER 3  Methods: Communicating with Objects

3.10  Drawing Lines and Defining Graphical
      Methods (Optional)

We used a Graphics object in the previous chapter to draw rectangles
and ovals in a JFrame window. The Graphics class also possesses a
method for drawing a line segment. Problems involving drawing pic-
tures in an JFrame window using a series of line segments can be a source
of examples of defining useful methods and also of making good use of
loops.

   The Graphics class has a public instance method with the header:

                                                                                 

public void drawLine ( int x1 , int y1 , int x2 , int y2 )
                                                                                 

The method call g.drawLine(x1, y1, x2, y2) draws a line from the
point (x1, y1) to (x2, y2) where (x, y) refers to a point that is x pixels from
the left edge of the area that g is drawing in and y pixels from the top edge.
Thus g.drawLine(10, 10, 10, 60) draws a vertical line segment
that is 50 pixels long and is 10 pixels from the left edge of the drawing
area, that is, a line segment from the point (10, 10) to the point (10, 60).

   Consider the problem of creating an Swing program with a method
called drawSticks() to draw any specified number of vertical line seg-
ments. This method might be useful for an graphical user interface to
the OneRowNim game to draw the number of sticks at a given point in a
game. Suppose that this method must have an int parameter to specify
the number of vertical lines to draw and two int parameters to spec-
ify the location of the top endpoint of the left most line segment. The
drawSticks() method will need to use a Graphics object connected
to the JFrame window for drawing the line segment. The only such
Graphics object available is the parameter in the paint() method of
the Canvas. Thus the method must have a Graphics parameter and it
will be called in the paint() method using the Graphics object there as
an argument. Thus the header of the method should look like:

                                                                                 

public void drawSticks ( Graphics g , i n t x , i n t y , i n t num)             


   The length of the line segments and and the distance between them
are not specified by parameters so we need to choose some fixed values
for these quantities. Let us assume that the line segments are 10 pixels
apart and 50 pixels long. We now have enough information to complete
the definition of an applet to solve this problem. Such a class definition is
reproduced in Figure 3.19.

   Note that the body of drawSticks() uses a while-loop to draw the
lines and declares and initializes a local variable to zero to use for counting
the number of lines drawn. The statement g.drawLine(x, y, x, y +
50); draws a vertical line which is 50 pixels long. Increasing the value
of x by 10 each time through the loop moves the next line 10 pixels to the
right.

   The first call to drawSticks() in the paint() method draws 12
lines with (25, 25) the top point of the left-most line. The second call to
  CHAPTER 3  Chapter Summary                                                                     139
                                                                                                     

/ DrawLineCanvas                      d e m o n s t r a t e s some g r a p h i c s  commands .
                                                                                    of 7 lines .
   I t draws a s e t of 12 v e r t i c a l l i n e s and a s e t

  /

import java . awt .  ;
import javax . swing . JFrame ;

public class DrawSticksCanvas extends Canvas

    /  d r a w S t i c k s ( g , x , y , num ) w i l l draw num v e r t i c a l l i n e

       segments . The l i n e segments are 10 p i x e l s a p a r t and

       50 p i x e l s long . The top endpoint of the l e f t most

       line segment is at the point (x , y ) .

       /

   public void drawSticks ( Graphics g , i n t x , i n t y , i n t num)
   { int k = 0;

          while ( k < num)
          { g . drawLine ( x , y , x , y + 5 0 ) ;

                  x = x + 10;
                 k = k + 1;
          } // w h i l e
   } // d r a w S t i c k s ( )

  public void paint ( Graphics g)
  { drawSticks (g , 25 , 25 , 12);

         g . setColor ( Color . cyan ) ;
         drawSticks (g , 25 , 125 , 7);
  } // p a i n t ( )

} // D r a w S t i c k s C a n v a s

                                                                                         

  Figure 3.19: A Swing Class with a method for drawing a set of sticks.

drawSticks() will draw 7 cyan sticks 100 pixels lower. Note that chang-
ing the color of g before passing it as an argument to drawSticks()
changes the drawing color.
An image of the DrawSticksCanvas as it appears in a window is shown
in Figure 3.20.

   As we have seen in this example, defining methods with parameters to
draw an object makes the code reusable and makes it possible to draw a
complex scene by calling a collection of simpler methods. It is a typical
use of the divide-and-conquer principle. The while-loop can be useful in
drawing almost any geometrically symmetric object.

Technical Terms                                                                                         Figure 3.20: The DrawSticksCan-
                                                                                                        vas as displayed in a Java win-
                                                                                                        dow.

                                                                                                        CHAPTER SUMMARY
                      140  CHAPTER 3  Methods: Communicating with Objects

                      accessor method    loop structure      repetition structure
                      class scope        method overloading  scope
                      formal parameter   method signature    selection
                      if statement       mutator method      side effect
                      if/else statement  multiway selection  while statement
                      inherit            override            while structure
                      local scope        polymorphism

                      Summary of Important Points

                       A formal parameter is a variable in a method declaration. It always con-
                         sists of a type followed by a variable identifier. An argument is a value
                         that is passed to a method via a formal parameter when the method is
                         invoked. A method's parameters constrain the type of information that
                         can be passed to a method.

                       When an argument of primitive type is passed to a method, it cannot
                         be modified within the method. When an argument of reference type
                         is passed to a method, the object it refers to can be modified within the
                         method.

                       Except for void methods, a method invocation or method call is an
                         expression which has a value of a certain type. For example,
                         nim.getSticks() returns a int value.

                       The signature of a method consists of its name, and the number, types,
                         and order of its formal parameters. A class may not contain more than
                         one method with the same signature.

                       A constructor is a method that is invoked when an object is created. If a
                         class does not contain a constructor method, the Java compiler supplies
                         a default constructor.

                       Restricting access to certain portions of a class is a form of informa-
                         tion hiding. Generally, instance variables are hidden by declaring them
                         private. The class's public methods make up its interface.

                       The if statement executes a statement only if its boolean condition is
                         true. The if-else statement executes one or the other of its statements
                         depending on the value of its boolean condition. Multiway selection al-
                         lows one and only one of several choices to be selected depending on
                         the value of its boolean condition.

                       The while statement is used for coding loop structures that repeatedly
                         execute a block of code while a boolean condition is satisfied.

SOLUTIONS TO          SOLUTION 3.1 A method declaration defines the method by specifying its name,
SELF-STUDY EXERCISES  qualifiers, return type, formal parameters, and its algorithm, thereby associating
                      a name with a segment of executable code. A method invocation calls or uses a
                      defined method.

                      SOLUTION 3.2 A formal parameter is a variable in the method declaration, whose
                      purpose is to store a value while the method is running. An argument is a value
                      that is passed to a method in place of a formal parameter.
CHAPTER 3  Solutions to Self-Study Exercises                        141

SOLUTION 3.3 The following code declares two instance variables for names of
players and defines a setName() method:

                                                                            

p r i v a t e S t r i n g nameOne = " P l a y e r One" ;
p r i v a t e S t r i n g nameTwo = " P l a y e r Two" ;

public void setNames ( S t r i n g name1 , S t r i n g name2 )

{ nameOne = name1 ;

       nameTwo = name2 ;

}

                                                                            

Of course, there are many other appropriate names for the variables and parame-
ters and other initial assignments.

SOLUTION 3.4 A method call that sets the names of the players of game1 is:

                                                                            

game1 . setNames ( "Xena" , " Yogi " ) ;
                                                                            

SOLUTION 3.5 A constructor cannot have a return type, such as void.

SOLUTION 3.6 One definition for the method is:

                                                                            

public OneRowNim( i n t s t i c k s )

{      nSticks = sticks ;

       player = 2;

}

                                                                            

SOLUTION 3.7 The following would be displayed on the screen:

                                                                            

   1

   20

   false                                                                    

SOLUTION 3.8 One definition for the method is:

                                                                            

  public int  getMoves ( )
              nMoves ;
  { return
                                                                            
  }


                                                                                 False isDone      True

  SOLUTION 3.9 One definition for the method is:                                                   return
                                                                                                   "Done"
                                                                                          return
                                                                                       "Not Done"
  public boolean playerOneIsNext ( )
  { r e t u r n ( p l a y e r == 1 ) ;                                      
  }


                                                                                 exit method       exit method

SOLUTION 3.10 See Figure 3.21.

                                                                                 Figure 3.21: Flowchart of the if-
                                                                                 else version of the getStatus()
                                                                                 method.
                                  142                   CHAPTER 3  Methods: Communicating with Objects

                                  SOLUTION 3.11

                                                                                                         

                                  i f ( isHeavy == t r u e )
                                          System . out . p r i n t l n ( "Heavy" ) ;

                                  else ; // E r r o r ( remove t h i s s e m i c o l o n )
                                          System . out . println ( "Light" ) ;

                                  i f ( isLong == t r u e )

                                        System . out . p r i n t l n ( "Long" )

                                  else  // E r r o r ( end l i n e above w i t h s e m i c o l o n )

                                        System . out . println ( "Short" ) ;                             

                                  SOLUTION 3.12

                                                                                                         

                                  public String getPlayerName ( )

                                  {     i f ( p l a y e r == 1 )

                                              r e t u r n "Ann" ;

                                        e l s e i f ( p l a y e r == 2 )

                                              return " Bill " ;

                                        e l s e i f ( p l a y e r == 3 )

                                              return "Cal" ;

                                        else

                                              return "Error" ;

                                  }

                                                                                                         

                                  SOLUTION 3.13 When passing an argument for a primitive type, a copy of the
                                  argument's value is passed. The actual argument cannot be changed inside the
                                  method. When passing a reference to an object, the object can be changed within
                                  the method.

                                  SOLUTION 3.14

                                                                                                         

                                  public i n t sumCubes ( i n t min , i n t max )

                                  {

                                        i n t num = min ;

                                        i n t sum = 0 ;

                                        while (num <= max ) { // W h i l e num <= max

                                        sum = sum + numnumnum ; // Add c u b e o f num t o sum

                                        num = num + 1 ;                   // Add 1 t o num

                                        } // w h i l e

                                        r e t u r n sum ;                 // R e t u r n t h e sum

                                  }

                                                                                                         

EXERCISES                         EXERCISE 3.1 Fill in the blanks in each of the following sentences:

Note: For programming exercises,  a. When two different methods have the same name, this is an example of
first draw a UML class diagram
describing all classes and their        .
inheritance relationships and/or
associations.                     b. Methods with the same name are distinguished by their            .

                                  c. A method that is invoked when an object is created is known as a

                                     method.
CHAPTER 3  Exercises                                                       143

d. A method whose purpose is to provide access to an object's instance variables

    is known as an    method.

e. A boolean value is an example of a          type.

f. A OneRowNim variable is an example of a              type.

g. A method's parameters have          scope.

h. A class's instance variables have   scope.

i. Generally, a class's instance variables should have          access.

j. The methods that make up an object's interface should have            access.

k. A method that returns no value should be declared            .

l. Java's if statement and if-else statement are both examples of           control

    structures.

m. An expression that evaluates to either true or false is known as a             .

n. In an if-else statement, an else clause matches           .

o. The ability to use a superclass method in a subclass is due to Java's

    mechanism.

p. The process of redefining a superclass method in a subclass is known as

    the method.

EXERCISE 3.2 Explain the difference between the following pairs of concepts:

a. Parameter and argument.
b. Method definition and method invocation.
c. Local scope and class scope.
d. Primitive type and reference type.
e. Access method and constructor method.

EXERCISE 3.3 Translate each of the following into Java code:

a. If b1 is true, then print "one"; otherwise, print "two".
b. If b1 is false and if b2 is true, then print "one"; otherwise, print "two".
c. If b1 is false and if b2 is true, then print "one"; otherwise, print "two", or print

    "three".

EXERCISE 3.4 Identify and fix the syntax errors in each of the following:

a.

                                                                                         

    i f ( isWalking == t r u e ) ;

          System . out . println ( "Walking" ) ;

    else

          System . out . p r i n t l n ( "Not walking " ) ;                              

b.

                                                                                         

    if ( isWalking )

          System . out . println ( "Walking" )

    else

          System . out . p r i n t l n ( "Not walking " ) ;                              
144             CHAPTER 3  Methods: Communicating with Objects

c.

                                                                            

    if ( isWalking )

          System . out . println ( "Walking" ) ;

    else

          System . out . p r i n t l n ( "Not walking" )                    

d.

                                                                            

    if ( isWalking = false )

          System . out . println ( "Walking" ) ;

    else

          System . out . p r i n t l n ( "Not walking" ) ;                  

EXERCISE 3.5 For each of the following, suppose that isWalking is true
and isTalking is false (first draw a flowchart for each statement and then
determine what would be printed by each statement):

a.

                                                                            

    i f ( isWalking == f a l s e )

          System . out . p r i n t l n ( "One" ) ;

          System . out . p r i n t l n ( "Two" ) ;                          

b.

                                                                            

    i f ( isWalking == t r u e )

          System . out . p r i n t l n ( "One" ) ;

          System . out . p r i n t l n ( "Two" ) ;                          

c.

                                                                            

    i f ( isWalking == f a l s e )
    {

          System . out . p r i n t l n ( "One" ) ;

          System . out . p r i n t l n ( "Two" ) ;

    }

                                                                            

d.

                                                                            

    i f ( isWalking == f a l s e )

          i f ( i s T a l k i n g == t r u e )

                System . out . p r i n t l n ( "One" ) ;

          else

                System . out . p r i n t l n ( "Two" ) ;

    else

          System . out . println ( "Three" ) ;                              
CHAPTER 3  Exercises                                                            145

EXERCISE 3.6 Show what the output would be if the following version of
main() were executed:

                                                                                 

public s t a t i c void main ( S t r i n g argv [ ] )
{

   System . out . p r i n t l n ( "main ( ) i s s t a r t i n g " ) ;

   OneRowNim game1 ;

   game1 = new OneRowNim ( 2 1 ) ;

   OneRowNim game2 ;

   game2 = new OneRowNim ( 8 ) ;

   game1 . t a k e S t i c k s ( 3 ) ;

   game2 . t a k e S t i c k s ( 2 ) ;

   game1 . t a k e S t i c k s ( 1 ) ;

   game1 . r e p o r t ( ) ;

   game2 . r e p o r t ( ) ;

   System . out . p r i n t l n ( "main ( ) i s f i n i s h e d " ) ;

}

                                                                                 

EXERCISE 3.7 Determine the output of the following program:

                                                                                 

public class Mystery
{

   public S t r i n g myMethod ( S t r i n g s )
   {

          return ("Hello" + s ) ;
   }

   public s t a t i c void main ( S t r i n g argv [ ] )
   {

          Mystery mystery = new Mystery ( ) ;
          System . out . p r i n t l n ( mystery . myMethod ( " d o l l y " ) ;
   }

}

                                                                                 

EXERCISE 3.8 Write a boolean method--a method that returns a boolean--
that takes an int parameter and converts the integers 0 and 1 into false and
true, respectively.

EXERCISE 3.9 Define an int method that takes a boolean parameter. If the
parameter's value is false, the method should return 0; otherwise, it should
return 1.

EXERCISE 3.10 Define a void method named hello that takes a single
boolean parameter. The method should print "Hello" if its parameter is true;
otherwise, it should print "Goodbye".

EXERCISE 3.11 Define a method named hello that takes a single boolean
parameter. The method should return "Hello" if its parameter is true; otherwise it
should return "Goodbye". Note the difference between this method and the one
in the previous exercise. This one returns a String. That one was a void method.

EXERCISE 3.12 Write a method named hello that takes a single String pa-
rameter. The method should return a String that consists of the word "Hello"
concatenated with the value of its parameter. For example, if you call this method
with the expression hello("dolly"), it should return "hello dolly". If you call
it with hello("young lovers wherever you are"), it should return "hello
young lovers wherever you are".
146  CHAPTER 3  Methods: Communicating with Objects

EXERCISE 3.13 Define a void method named day1 that prints "a partridge in a
pear tree".

EXERCISE 3.14 Write a Java application program called TwelveDays that
prints the Christmas carol "Twelve Days of Christmas." For this version, write a
void method named intro() that takes a single String parameter that gives the
day of the verse and prints the intro to the song. For example, intro("first")
should print, "On the first day of Christmas my true love gave to me". Then write
methods day1(), day2(), and so on, each of which prints its version of the verse.
Then write a main() method that calls the other methods to print the whole song.

EXERCISE 3.15 Define a void method named verse that takes two String
parameters and returns a verse of the Christmas carol "Twelve Days of Christ-
mas." For example, if you call this method with verse("first", "a
partridge in a pear tree"), it should return, "On the first day of Christ-
mas my true love gave to me, a partridge in a pear tree".

EXERCISE 3.16 Define a void method named permute, which takes three
String parameters and prints out all possible arrangements of the three strings.
For example, if you called permute("a", "b", "c"), it would produce the
following output: abc, acb, bac, bca, cab, cba, with each permutation on a separate
line.

EXERCISE 3.17 Design a method that can produce limericks given a bunch of
rhyming words. That is, create a limerick template that will take any five words
or phrases and produce a limerick. For example, if you call

                                                                                 

limerick ( "Jones" ,"stones" ,"rained" ,"pained" ,"bones" ) ;
                                                                                 

your method might print (something better than)

                                                                                 

There once a person named J o n e s

Who had a g r e a t l i k i n g f o r s t o n e s ,

But whenever i t rained ,

Jones ' e x p r e s s i o n was pained ,

Because stones weren ' t good for the bones .                                    


For each of the following exercises, write a complete Java application program:

EXERCISE 3.18 Define a class named Donor that has two instance variables,
the donor's name and rating, both of which are Strings. The name can
be any string, but the rating should be one of the following values: "high,"
"medium," or "none." Write the following methods for this class: a construc-
tor, Donor(String,String), that allows you to set both the donor's name and
rating; and access methods to set and get both the name and rating of a donor.

EXERCISE 3.19 Challenge. Define a CopyMonitor class that solves the fol-
lowing problem. A company needs a monitor program to keep track of when a
particular copy machine needs service. The device has two important (boolean)
variables: its toner level (too low or not) and whether it has printed more than
100,000 pages since its last servicing (it either has or has not). The servicing rule
that the company uses is that service is needed when either 100,000 pages have
been printed or the toner is too low. Your program should contain a method that
reports either "service needed" or "service not needed" based on the machine's
state. (Pretend that the machine has other methods that keep track of toner level
and page count.)
CHAPTER 3  Exercises                         147

EXERCISE 3.20 Challenge. Design and write an OldMacdonald class that
sings several verses of "Old MacDonald Had a Farm." Use methods to generalize
the verses. For example, write a method named eieio() to "sing" the "E I E I O"
part of the verse. Write another method with the signature hadAnX(String s),
which sings the "had a duck" part of the verse, and a method withA(String
sound) to sing the "with a quack quack here" part of the verse. Test your class by
writing a main() method.

ADDITIONAL EXERCISES

EXERCISE 3.21 Suppose you have an Object A, with public methods a(),
b(), and private method c(). And suppose you have a subclass of A named B
with methods named b(), c() and d(). Draw a UML diagram showing the rela-
tionship between these two classes. Explain the inheritance relationships between
them and identify those methods that would be considered polymorphic.

EXERCISE 3.22 Consider the definition of the class C. Define a subclass of C
named B that overrides method m1() so that it returns the difference between m
and n instead of their sum.

                                              

  public class C {
         private int m;
         private int n;
         public C( i n t mIn , i n t nIn ) {
               m = mIn ;
                n = nIn ;
         }

     public i n t m1 ( ) {
            r e t u r n m+n ;

     }

  }

                                              
148  CHAPTER 3  Methods: Communicating with Objects
Chapter 4

Input/Output: Designing
the User Interface

OBJECTIVES

After studying this chapter, you will
 Understand the importance of the user interface.
 Know how to use a simple command-line interface.
 Be able to program and use a simple Graphical User Interface (GUI).
 Understand the concept of event-driven programming.
 Know how to program and use a Java Swing program.

OUTLINE

4.1 Introduction
4.2 The User Interface
4.3 A Command-line Interface
4.4 A Graphical User Interface (GUI)
4.5 Case Study: The One Row Nim Game
4.6 From the Java Library: java.io.File and file input (Optional)

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              149
                   150  CHAPTER 4  Input/Output: Designing the User Interface

                   4.1 Introduction

                   One of the most important parts of learning a programming language is
                   learning how to program an application to accept input and produce out-
                   puts (I/O). Computers wouldn't be very useful if we could not give them
                   data to manipulate and compute, and if we were not able to read or un-
                   derstand the results that they produce. In general, a computer program's
                   input and output capabilities are known collectively as its user interface.

                      An input operation is any action that transfers data from the user to
                   the computer's main memory via one of the computer's input devices.
                   An output operation is any action that transfers data from the computer's
                   main memory to one of the computer's output devices.

                      In this chapter, we will introduce three simple user interfaces: a
                   command-line interface and two graphical user interfaces (GUIs). These
                   interfaces can be used interchangeably with the material in most of the
                   subsequent chapters. Indeed, one of the most important design princi-
                   ples that we emphasize in this chapter is that the user interface should be
                   designed to function independently of the computational task. In other
                   words, it should be possible to take an application, such as a computer
                   game, and design it so that it can be used with a variety of different user
                   interfaces.

User interface     4.2 The User Interface
Division of labor
                   The user interface is that part of the program that handles the input and
                   output interactions between the user and the program. As an interface,
                   it limits or constrains the manner in which the user can interact with the
                   program.

                      Computer programs are just one of the many things that require a user
                   interface. Virtually every device we use has one. For example, consider
                   again the difference between the user interface of a digital versus an ana-
                   log watch. On a digital watch, you have a display that tells you the time
                   to the exact hour, minute, and second. On an analog watch, one with a
                   sweep second hand, the time can never be displayed to the exact second.
                   Similarly, on a digital watch there are buttons that let you set the time to
                   the exact hour, minute, and second. On an analog watch, there is a small
                   wheel that allows you to set the time only approximately. Thus, the user
                   interface constrains the kinds of interactions that are possible between the
                   user and the device.

                      With regard to our Java programs, one way to divide up the labor is to
                   distinguish between the user interface and the computational functions.
                   The role of the user interface is to transmit data back and forth between the
                   user and the program. The role of the computational part of the program
                   is to perform some kind of computation, in the broad sense of that term.
                   The computation might be to play a game, or calculate a square root, or
                   monitor a hospital patient. Figure 4.1 provides a generic picture of the
                   relationship between the user interface and the computational object.

                      In this chapter we focus our attention on the user interface side of the
                   relationship shown in Figure 4.1. In subsequent chapters we will focus
                   more on the computational side of the relationship. What we desire is an
SECTION 4.3  A Command-Line Interface  151
                                                Figure 4.1: The user interface
                                                transmits data back and forth be-
                                                tween the user and the program's
                                                computational objects.

approach that lets us combine a computational object with any one of the
three different kinds of user interfaces.

 JAVA EFFECTIVE DESIGN The User Interface Module Separating
 the user interface from the computational object is a good way to
 divide up the labor in programs that perform I/O.

4.3 A Command-Line Interface

A command-line interface is perhaps the simplest, and most old-
fashioned, way to design the interaction between a user and a program.
According to this approach, user input is taken from the keyboard, and
the program's output is displayed on some kind of console (Fig. 4.2).

                                                                          Figure 4.2: A command-line user
                                                                          interface.

   The command-line approach might also be called console interface. In
the early days of computers, before we had graphics-based computer
monitors capable of displaying multiple windows, the console was the
entire computer display. For today's computers the console might be a
window provided by your programming environment, as in Figure 4.3.

   In Chapter 3 we described how to use the System.out.print()
and System.out.println() methods to output strings to the console.
That takes care of the output side of command-line interface. The more
challenging task is managing the input-side of the interface.
                                                 152  CHAPTER 4  Input/Output: Designing the User Interface
Figure 4.3: The Java console win-
dow.

Streams                              In Java, input and output is handled by objects that are called streams.
                                  You can think of a stream as a kind of pipe through which data flow
Figure 4.4:                       (Fig. 4.4). An input stream carries data from some kind of input device,
streams.                          such as a keyboard or network connection or a file, to the program's main
                                  memory. An output stream carries data from the program's memory to
                                  some kind of output device, such as a printer or a file.

                Input and output

Buffered input                       Each Java program has three standard streams available to it at startup:
                                  System.in, System.out, and System.err. System.in is a prede-
                                  fined input stream that is typically associated with the keyboard (Fig. 4.4).
                                  That is, it carries data from the keyboard to the program. System.out
                                  and System.err are both output streams typically associated with the
                                  console. They both carry data from the program to the console. The dif-
                                  ference is simply that System.out is used for normal program output
                                  and System.err is used to output error messages.

                                  4.3.1 Using a BufferedReader to Input Strings from the
                                           Keyboard

                                  We will use a BufferedReader object to handle data input from the
                                  keyboard. As its name implies, the BufferedReader class performs
                                  buffered input. A buffer is a portion of main memory where input is held
                                  until it is needed by the program. Using a buffer between the keyboard
                                  and the program allows you to use the Backspace key to delete a char-
                                  acter. When you hit the Enter key, any characters that you deleted will
                                  be ignored when the program retrieves characters from the input buffer.
                                  If the user's input were not buffered in this way, it would contain ev-
                                  ery keystroke, including the Backspaces, and then it would be up to the
                                  program to eliminate the characters that were supposed to be deleted.
SECTION 4.3  A Command-Line Interface  153
                                                Figure 4.5: The BufferedRead-
                                                er class.

   Figure 4.5 provides a UML diagram of the BufferedReader class and        
shows its relationship to other the classes that will be used for keyboard  
input . Note that along with InputStreamReader, BufferedReader
is one of several subclasses of the Reader class. As the diagram            
shows, BufferedReader has two important methods. Its constructor            
method takes a Reader parameter, which means that when we create a
BufferedReader we must provide it with a reference to some kind of           Keyboard input
Reader object. To perform keyboard input, we want to provide a refer-
ence to an object that can read System.in, the standard input stream.
As the figure shows, InputStreamReader has a constructor that allows
it to read an InputStream. Therefore, to construct a BufferedReader
that will read System.in we use the following statement:

 

    BufferedReader input = new BufferedReader
         (new InputStreamReader ( System . i n ) ) ;

 

In this statement we are actually creating two objects. We first create an
InputStreamReader, giving it a reference to System.in. We then pass
that object to a BufferedReader. The result is a cooperation between
two objects that enables us to do buffered reading of the keyboard.

   By creating a BufferedReader in this way, whenever we use its
readLine() method, it will read a line of characters from the keyboard.
For example, having created a BufferedReader named input, the fol-
lowing code segment will read one line of input and assign it to the
String variable named inputString.

 

    String inputString = input . readLine ( ) ;
 

When the program encounters the readLine() expression, it will wait
for the user to hit the Enter key. It will then input whatever the user
                 154  CHAPTER 4  Input/Output: Designing the User Interface

                 typed, minus any characters that were Backspaced over, into the String
                 variable.

                 JAVA LANGUAGE RULE Keyboard Input. The
                 BufferedReader.readLine() method allows the user to
                 backspace over errors during keyboard input.

                 4.3.2 Inputting Numbers from the Keyboard

Wrapper classes  As the previous section showed, we can use a BufferedReader object
                 to input Strings from the keyboard. In Java, all keyboard input is repre-
                 sented as Strings. However, what if we want to input numbers? The an-
                 swer is that we have to extract numbers from the input strings. To do this,
                 Java provides us two special classes, known as wrapper classes: Integer
                 and Double.

                    A wrapper class contains methods for converting primitive data into
                 objects and for converting data from one type to another. The Integer
                 class contains the parseInt() method, which extracts an int from its
                 String argument. For example, in the following usage, the string "55" is
                 converted into the number 55:

                                                                                                   

                 int m = Integer . parseInt ( "55" ) ;                                             
                 

                 Similarly, the Double class contains the parseDouble() method, which
                 extracts a double value from its parameter. In this example, the number
                 55.2 is extracted from the string "55.2":

                                                                                                   

                 double num = Double . parseDouble ( " 5 5 . 2 " ) ;
                                                                                                   

                 If we are writing a program that requires us to input numbers from
                 the keyboard, then assuming we have created a BufferedReader ob-
                 ject named input, we can use these methods in combination with the
                 readLine() method, to input and process numbers. For example, this
                 code segment calculates a runner's race pace:

                                                                                                   

                 S t r i n g i n p u t S t r i n g = new S t r i n g ( ) ;
                 System . out . p r i n t l n ( "How many t o t a l m i l e s did you run ? " ) ;
                 inputString = input . readLine ( ) ; // I n p u t a S t r i n g }
                 double miles = Double . parseDouble ( inputString ) ; // C o n v e r t
                 System . out . p r i n t l n ( "How many minutes did i t t a k e you ? " ) ;
                 inputString = input . readLine ( ) ; // I n p u t a n o t h e r S t r i n g
                 double minutes = Double . parseDouble ( inString ) ;

                 // C o n v e r t

                 System . out . p r i n t l n ( "Your average pace was " +

                                   minutes/miles + " minutes per mile" ) ;                         
SECTION 4.3  A Command-Line Interface             155

Notice how we included prompts in this example so that the user knows
what type of input is expected. Designing appropriate prompts is an
important aspect of designing a good user interface.

JAVA EFFECTIVE DESIGN Prompting. In a well-designed user
interface, prompts should be used to guide the user through the input
process.

4.3.3 Designing a Keyboard Reader Class

Now that we have introduced the library classes and methods that we
will use for command-line input, lets design a class to encapsulate these
functions. We want a class that will use a BufferedReader to read any
kind of data--strings, integers, or real numbers--from keyboard. We also
want this class to hide some of the messy details involved in performing
keyboard input.

                                                                                                     Figure 4.6: Design of the
                                                                                                     KeyboardReader class.

   Figure 4.6 presents the design of KeyboardReader class. Note that
instances of this class will use a BufferedReader object to perform
the actual keyboard input. That's why we need a private instance vari-
able of type BufferedReader. The constructor method will create a
BufferedReader, which will then be used whenever a read operation
is requested. Note that the KeyboardReader() has five public meth-
ods. The getKeyboardInput() method returns a String. This is the
method we will call when we just want to get the string that the user typed
from the keyboard. The getKeyboardInteger() method returns an
int value. This is the method we will call when we want an integer from
the keyboard. Similarly, the getKeyboardDouble() method returns a
double. This is the method we will call when we want to input a floating
point value from the keyboard. Finally, the prompt() and display()
methods will be used to perform two other important tasks of a user in-
terface: that of prompting the user and that of displaying the program's
output.

   The following code segment illustrates how we will use a Keyboard-
Reader object to input an integer:

                                                                             

KeyboardReader cmdline = new KeyboardReader ( ) ;

int m = cmdline . getKeyboardInteger ( ) ;                                   

                       156  CHAPTER 4  Input/Output: Designing the User Interface

Private helper method  All we need to do is create an instance of the KeyboardReader and ask
I/O exceptions         it to get an integer for us. This greatly simplifies the work we would have
                       to do when we want to perform keyboard input.

                          Note that Figure 4.6 lists a private method named readKeyboard()
                       in the KeyboardReader class. This is the method that does the actual
                       work of reading data from the keyboard. Because it is private, it can only
                       be called by the other methods in KeyboardReader. It cannot be called
                       by other classes. The reason we make it private is to hide it, and the messy
                       details of performing keyboard input, from other classes.

                          One of those messy details is the fact that whenever I/O is performed,
                       it is possible for things to go wrong. The possibility of errors occurring
                       applies to all forms of I/O, not just keyboard I/O. For example, when a
                       program is trying to read a file, the file might be missing. Or when trying
                       to download a web page, the Internet connection might malfunction.

                          Because these types of external errors are possible, Java requires that
                       whenever a program performs certain types of I/O, it must watch out
                       for certain kinds of error conditions, known as exceptions. Exceptions are
                       covered in Chapter 11, so we will not attempt to cover them here. Instead,
                       we will design the readKeyboard() method to take care of this detail
                       for us.

                        JAVA LANGUAGE RULE Exceptions. Java I/O methods require
                        that programs check for certain error conditions during input.

                          Figure 4.7 gives the full implementation (for now) of the Keyboard-
                       Reader class. Lets go through it line by line. The first thing to no-
                       tice is the use of the import statement. Recall that importing a Java
                       package enables us to refer to elements in the package by their short
                       names (BufferedReader), rather than by their fully qualified names
                       (java.io.BufferedReader).

                          Next notice how we create a BufferedReader object in the
                       KeyboardReader() constructor:

                                                                                                     

                       r e a d e r = new BufferedReader

                            (new InputStreamReader ( System . i n ) ) ;                              

                       The resulting reader object will persist as long as our KeyboardReader
                       object exists and can be used for all subsequent input operations.

                          Next notice the definition of the readKeyboard() method. It calls
                       the inherited readLine() method to input a line from the keyboard and
                       then it returns the line. Note, however, how the call to the readLine()
                       method is embedded in a try...catch block. This is one way to handle
                       the possibility that an exception might occur during the input operation.
                       Java requires that our program do something to address the possibility
                       of an I/O exception, and as we will learn in Chapter 11, there are other
                       designs that we might have used here. The primary advantage of doing
                       it this way is that we can hide this language detail from the rest of the
                       program. The rest of the program--and any other programs that use the
                       KeyboardReader class--will not have to worry about this exception is-
                       sue. They can just ask the KeyboardReader to get them a string or an
                       integer and it will deliver the goods.
   SECTION 4.3  A Command-Line Interface                          157
                                                                     

                                                                     
  import java . io .  ;

  public class KeyboardReader
  { private BufferedReader reader ;

         public KeyboardReader ( ) {
                r e a d e r = new BufferedReader
                      (new InputStreamReader ( System . i n ) ) ;

         }
         public String getKeyboardInput ()
         { return readKeyboard ( ) ;
         }
         public int getKeyboardInteger ()
         { return Integer . parseInt ( readKeyboard ( ) ) ;
         }
         public double getKeyboardDouble ( )
         { return Double . parseDouble ( readKeyboard ( ) ) ;
         }
         public void prompt ( String s )
         { System . out . print ( s ) ;
         }
         public void display ( String s )
         { System . out . print ( s ) ;
         }
         private String readKeyboard ( )
         { String line = "" ;

                try
                { line = reader . readLine ( ) ;
                } catch ( IOException e )
                { e . printStackTrace ();
                }
                return line ;
         }
  }


              Figure 4.7: Definition of the KeyboardReader class.

   Next, notice how the public input methods are defined. The
getKeyboardInput() method just returns the line that it gets by call-
ing readKeyboard(). The getKeyboardInteger() method also calls
readKeyboard(), but instead of just returning the line, it extracts an
integer from it and returns the integer. The getKeyboardDouble()
method works the same way.

   Finally, notice how the public output methods are defined. Both the
prompt() and display() methods take a single String parameter
and do exactly the same thing-they merely print their string. So why do
we have two methods when one will suffice? The answer is that these
methods encapsulate important and distinct user-interface functions--
prompting the user and displaying output--that just happen to be imple-
mented in exactly the same way in this case. As we will see when we de-
sign our GUI interface, we will use completely different objects to prompt
the user and display output. So, despite their similarities, it is important
158  CHAPTER 4  Input/Output: Designing the User Interface

that we distinguish the task of prompting the user from the more general
task of displaying output.

4.3.4 Designing a Command-Line Interface

Now that we have defined a special class for performing keyboard input,
we now show how it can be used as a user interface in cooperation with
the other objects that make up a program. As described in Figure 4.1,
the user interface will serve as an intermediary between the user and
some type of computational object. Although our command-line interface
should work with any application, no matter how complex, we begin with
a very simple computational problem. This will allow us to focus on the
user interface.

   Let's design a program that prompts the user for his or her name and
then says hello. Thus, the program's I/O should look like this:

                                                                              

     Hi , p l e a s e input your name here > Kim

     Hi Kim , n i c e t o meet you .                                          

   In the design we use there will be two primary objects involved. One
will serve as the user interface. This will be our KeyboardReader. A
second object will serve as the computational object. In this case it will
"compute" an appropriate greeting. It will serve contain the main()
method and will encapsulate the algorithm for this application. It will
use a KeyboardReader to handle its I/O needs.

   The main advantage of this division of labor is that it enables us to use
the KeyboardReader, as is, with virtually any Java application. More-
over, despite its simplicity, our computational object in this example can
serve as a template for future programs.

JAVA EFFECTIVE DESIGN Modularity. By designing the user
interface as a self-contained module, we can use it with just about any
application.

   Figure 4.8 provides the details the design we wish to implement. Note
that GreeterApp contains an instance variable for a KeyboardReader.
This will enable it to use the KeyboardReader whenever it needs to per-
form keyboard input. By giving GreeterApp a main() method, we al-
low it to be the main class for our application. Its run() method will con-
tain the algorithm that controls the application, and its greet() method
will handle the task of greeting the user.

   The full implementation of the GreeterApp class is shown in
Figure 4.9. It begins by declaring an instance variable for the
KeyboardReader, which is instantiated in the constructor method. This
gives GreeterApp a way to refer directly to the user interface whenever it
needs keyboard input. The run() method encapsulates the application's
algorithm. Notice how it uses the KeyboardReader to prompt the user,
to input the user's name, and then to display the greeting. Finally, the
main() method serves to create an instance of the computational object
and calls its run() method.
SECTION 4.3  A Command-Line Interface                                  159
                                                                                Figure 4.8: Using Keyboard-
                                                                                Reader as the user interface.

                                                                        

public class GreeterApp
{ private KeyboardReader reader ;

  public GreeterApp ( )

  { r e a d e r = new KeyboardReader ( ) ;

  } // G r e e t e r A p p ( )

  public void run ( )

  { S t r i n g name = "" ;

     r e a d e r . prompt ( " P l e a s e input your name here > " ) ;

     name = r e a d e r . getKeyboardInput ( ) ;

     r e a d e r . d i s p l a y ( g r e e t ( name ) + "\n" ) ;

  } // run ( )

  public S t r i n g g r e e t ( S t r i n g name )

  { r e t u r n "Hi " + name + " n i c e t o meet you . " ;

  } // g r e e t ( )

  public s t a t i c void main ( S t r i n g args [ ] )

  { GreeterApp app = new GreeterApp ( ) ;

     app . run ( ) ;

  }

} // G r e a t e r A p p

                                                                        

     Figure 4.9: Definition of the GreeterApp class.

   To re-cap, we have designed a simple command-line interface that can
be used, with minor changes, for virtually any programming task in sub-
sequent chapters. Before moving on, it may be helpful to touch on some
of the important object-oriented principles that went into our design.

     Divide-and-conquer: We see the usefulness of dividing a program
       into separate objects, one to handle the computations required by
       the application, and one to handle the user interface.

     Encapsulation: The classes we designed encapsulate just the in-
       formation and behavior that is necessary to perform their specific
       roles.

     Information hiding: We use a private method to hide certain messy
       implementation details from other parts of the program.

     Generality and Extensibility: We have developed a design that is
       general enough that it can be extended to other applications.
                          160  CHAPTER 4  Input/Output: Designing the User Interface

                          SELF-STUDY EXERCISES

                          EXERCISE 4.1 Java's Math class has a static method that will gener-
                          ate a random number between 0 and 0.99999999--that is, between 0 and
                          1, not including 1. By using simple arithmetic, we can generate random
                          numbers between any two values. For example, the following statement
                          assigns a random integer between 1 and 100 to the variable:

                                                                                         

                            secretNumber = 1 + ( i n t ) ( Math . random ( )  1 0 0 ) ;  

                          Given this statement, design and implement an application that will play
                          the following guessing game with the user. The computer generates a ran-
                          dom number between 1 and 100 and then lets the user guess the number,
                          telling the user when the guess is too high or too low. Note that for this
                          problem, the user will have to input integers at the keyboard.

Event-driven programming  4.4 A Graphical User Interface (GUI)

                          While command-line interfaces are useful, one of the great advantages of
                          the Java language is that its extensive class library makes it relatively easy
                          to develop applications that employ Graphical User Interfaces (GUIs).
                          GUIs have been around now for many years, since the production of the
                          Macintosh in the early 1980s. Today nearly all the personal computing
                          applications are GUI-based. Therefore, it is important that beginning pro-
                          grammers be able design and write programs that resemble, albeit on a
                          simpler scale, those programs that they use every day. Among other ben-
                          efits, developing the ability to write GUI programs, like the ones everyone
                          uses today, will make it easier for you to show off your work to others,
                          which might help motivate further interest in learning to program.

                             In this and subsequent sections, we will develop an extensible GUI
                          model that can be used with either a Java application or an applet. By
                          extensible we mean a model that can be easily adapted and used in a wide
                          variety of programs. GUI programming involves a computational model
                          known as event-driven programming, which means that GUI programs
                          react to events that are generated mostly by the user's interactions with
                          elements in the GUI. Therefore, we will have to learn how to use Java's
                          event model to handle simple events.

                             Given that this is our first look at some complex topics, we will keep
                          the discussion as simple as possible. This means we will delay discussion
                          of certain issues, which we take up in more depth in Chapter 13.

                          4.4.1 Java's GUI Components

                          The Java library comes with two separate but interrelated packages of GUI
                          components, the older java.awt package and the newer javax.swing
                          package. For the most part, the Swing classes supersede the AWT
                          classes. For example, the java.awt.Button class is superseded by the
                          javax.swing.JButton class, and the java.awt.TextField class is
                          superseded by the javax.swing.JTextField class. As these examples
                          show, the newer Swing components add an initial 'J' to the names of their
                          corresponding AWT counterparts.
SECTION 4.4  A Graphical User Interface (GUI)  161
                                                        Figure 4.10: Various GUI com-
                                                        ponents from the javax.swing
                                                        package. [Artwork: We need to
                                                        label the components.]

   Figure 4.10 illustrates how some of the main components appear in a        Model-view-controller (MVC) archi-
GUI interface. As shown there, a JLabel is simply a string of text dis-       tecture
played on the GUI, used here as a prompt. A JTextField is an input
element that can hold a single line of text. In this case, the user has in-   Swing portability
put his name. A JTextArea is an output component that can display
multiple lines of text. In this example, it displays a simple greeting. A
JButton is a labeled control element, which is an element that allows
the user to control the interaction with the program. In this example, the
user will be greeted by the name input into the JTextField, whenever
the JButton is clicked. As we will learn, clicking on the JButton causes
an event to occur, which leads the program to take the action of displaying
the greeting. Finally, all of these components are contained in a JFrame,
which is a top-level container. A container is a GUI component that can
contain other GUI components.

   The Swing classes are generally considered to be superior to their AWT
counterparts. For one thing, Swing components use a sophisticated object-
oriented design known as the model-view-controller (MVC) architecture,
which gives them much greater functionality than their AWT counter-
parts. For example, whereas an AWT Button can only have a string as its
label, a Swing JButton can use an image as a label. (See Chapter 13 for a
detailed discussion of the MVC architecture.)

   Second, Swing components are written entirely in Java which makes
them more portable and enables them to behave the same way regardless
of the operating system on which they are run. Because of their portability,
Swing components are considered lightweight. By contrast, AWT classes
use routines that are implemented in the underlying operating system and
are therefore not easily portable. Hence, they are considered heavyweight
components. Whereas a Swing JButton should look and act the same
way regardless of platform, an AWT Button would have a different im-
plementation, and hence a different look and feel, on a Macintosh and on
a Windows system. In this book, we will use the new Swing classes in our
programs.
                      162  CHAPTER 4  Input/Output: Designing the User Interface

                      4.4.2 Class Inheritance: Extending a Superclass

Inheritance           As you recall from Chapter 0, class inheritance is the mechanism by which
Functionality         a class of objects can acquire (inherit) the methods and variables of its su-
                      perclasses. Just as a horse, by membership in the class of horses, inherits
The isa relationship  those attributes and behaviors of a mammal, and, more generally, those of
Top-level container   an animal, a Java subclass inherits the variables and methods of its super-
                      classes. We sometimes lump together an object's attributes and behaviors
Specialization        and refer to them collectively as its functionality. So we say that an object
                      of a subclass inherits the functionality of all of its superclasses.

                         By the same token, just as a horse and a cow extend their mammalian
                      attributes and behaviors in their own special ways, a Java subclass ex-
                      tends the functionality of its superclasses in its own special way. Thus, a
                      subclass specializes its superclass.

                         In Chapter 3, we showed how all classes in the Java hierarchy inherit
                      the toString() method from the Object class. The lesson there was
                      that an object in a subclass can either use or override any public method
                      defined in any of its superclasses. In order to implement GUI programs,
                      we need to look at another way to employ inheritance. In particular, we
                      need to learn how to define a new class by extending an existing class.

                         We noted in Chapter 2 that unless a class is explicitly defined as a sub-
                      class of some other class it is considered implicitly to be a direct subclass
                      of Object. Thus, the GreeterApp class that we defined earlier in this
                      chapter is a subclass of Object. We can make the relationship between
                      GreeterApp and Object explicit by using the extends keyword when
                      we define the GreeterApp class:

                                                                                                     

                           public class GreeterApp extends Object { . . . }                          

                      Thus, the extends keyword is used to specify the subclass/superclass
                      relationships that hold in the Java class hierarchy. We sometimes refer to
                      the subclass/superclass relationship as the isa relationship, in the sense
                      that a horse isa mammal, and a mammal isa animal. Thus, the extends
                      keyword is used to define the isa relationship among the objects in the
                      Java class hierarchy.

                         A top-level container is a GUI container that cannot be added to an-
                      other container; it can only have components added to it. Figure 4.11 is a
                      class hierarchy that shows the relationships among some of the top-level
                      Swing and AWT classes. For example, the javax.swing.JFrame class,
                      which represents a top-level window, is a subclass of java.awt.Frame,
                      and the javax.swing.JPanel is a subclass of java.awt.Panel. We
                      can see from this figure that a JFrame isa Frame and an Frame isa Window
                      and a Window isa Container. These subclass/superclass relationships
                      are created in their respective class definitions by using the extends
                      keyword as follows:

                                                                                                     

                           public c l a s s JFrame extends Frame { . . . }

                           public c l a s s Frame extends Window { . . . }

                           public c l a s s Window extends Container { . . . }                       

                      As we will see in the next section, extending a class in this way enables us
SECTION 4.4  A Graphical User Interface (GUI)               163
                                                                     Figure 4.11: Top-level Swing and
         java.lang                                                   AWT classes. [NOTE: REDRAW
                     Object                                          JWindow is a subclass of Win-
                                                                     dow.]

java.awt                Frame                   javax.swing
        Component                                    JFrame

Container               Dialog                     JDialog
               Window                           JComponent
                 Panel

java.applet                                     JApplet
               Applet

to create a new class by specializing an existing class.                       Content pane

4.4.3 Top-level Windows

Referring again to Figure 4.11, notice that all of the Swing components are
subclasses of the AWT Container class. This means that Swing compo-
nents are Containers. They inherit the functionality of the Container
class. So Swing components can contain other GUI components. That is
why a JButton can contain an image.

   All GUI programs must be contained inside some kind of top-level
container. Swing provides three top-level container classes: JFrame,
JApplet and JDialog. For our basic GUI, we will use a JFrame as the
top-level window for stand alone applications.

   A JFrame encapsulates the basic functionality of a top-level window.
It has what is called a content pane, to which other Swing components,
such as buttons and text fields, can be added. Also, it comes with enough
built-in functionality to respond to certain basic commands, such as when
the user adjusts its size or closes it.

   Figure 4.12 shows a simple top-level window as it would be displayed
on the console. This window has a title ("My GUI"). It is 200 pixels wide,
150 pixels high, and its top-left corner is located at coordinates (100,150)
on the console screen. Like in other graphical systems, points on the Java
console always given as an ordered pair, (X, Y), with the horizontal coordi-
nate, X, listed first, followed by the vertical coordinate, Y. The horizontal
x-axis extends positively from left to right, and the vertical y-axis extends
positively from top to bottom.

   The class that created and displayed this window is shown in Fig-
ure 4.13. Note the use of the extends keyword to define SimpleGUI
as a subclass of JFrame. As a subclass, SimpleGUI inherits all of the
functionality of a JFrame (Fig. 4.14) . That is, it can contain other GUI
                                               164  CHAPTER 4  Input/Output: Designing the User Interface
Figure 4.12: A simple window.

                                                                                                           

import javax . swing .  ;

public class SimpleGUI extends JFrame
{

       public SimpleGUI ( String t i t l e )
       { setSize (200 ,150);

              setLocation (100 , 150);
              setTitle ( title );
              setVisible ( true ) ; // D i s p l a y s t h e JFrame
       } // SimpleGUI ( )

                                                    public s t a t i c void main ( S t r i n g args [ ] )

                                                    { new SimpleGUI ( "My GUI" ) ;

                                                    } // main ( )

} // SimpleGUI c l a s s

                                                                                                           

                                                    Figure 4.13: A top-level window with a title.

components. It knows how to resize and close itself, and so on. The rea-
son we want to define a subclass of JFrame, rather than just use a JFrame
instance, is because we want eventually to give our subclass additional
functionality that is specialized for our application.

 JAVA EFFECTIVE DESIGN Specialization. By creating a subclass of
 JFrame we can specialize its functionality for our application.

   Note how SimpleGUI's main() program creates an instance of
SimpleGUI by invoking its constructor. There is no need to use a vari-
able here because there are no further references to this object in this class.
However, simply constructing a SimpleGUI will not cause it to appear on
the Java console. For that to happen, it is necessary to give it a size and to
call its setVisible() method. This is done in the constructor method.

   The constructor method illustrates how to use some of the meth-
ods inherited from JFrame. Figure 4.14 shows some of the methods
that SimpleGUI inherits from JFrame. We use the setSize() and
                   SECTION 4.4  A Graphical User Interface (GUI)  165

mpleGUI is a sub-

.

                   setLocation() methods to set SimpleGUI's size and location. We use
                   the setTitle() method to set its title. And we use the setVisible()
                   method to cause it to appear on the console.

                   4.4.4 GUI Components for Input, Output, and Control

                   To enable our top-level window to serve as a user interface, it will be nec-
                   essary to give it some components. Figure 4.15 provides an overview of
                   some of the main Swing components. Generally, there are three types of
                   components, which correspond to the three main functions of a user in-
                   terface: input, output, and control. A JTextField would be an example
                   of an input component. The user can type text into the text field, which
                   can then be transmitted into the program. A JTextArea is an example
                   of an output component. The program can display text in the text area.
                   Control components enable the user to control the actions of the program.
                   A JButton would be an example of a control component. It can be asso-
                   ciated with an action that can be initiated whenever the user clicks it. We
                   might also consider a JLabel to be an output component, because we can
                   use it to prompt the user as to what type of actions to take.

                      Let's begin by creating a simple user interface, one that enables us to
                   perform basic input, output, and control operations with a minimum of
                   Swing components. This will allow us to demonstrate the basic principles
                   and techniques of user-interface design and will result in a GUI that can
                   be extended for more sophisticated applications. For this example, we
                   will limit our application to that of simply greeting the user, just as we
                   did in designing our command-line interface. That means that the user
                   will be prompted to input his or her name and the program will respond
                   by displaying a greeting (Fig. 4.10). We will call our GUI GreeterGUI, to
                   suggest its interdependence with the same Greeter computational object
                   that we used with the command-line interface.

                      For this simple application, our GUI will make use of the following
                   components:

                        A JTextField will be used to accept user input.
                                166               CHAPTER 4  Input/Output: Designing the User Interface

Figure 4.15: Swing components.

                                     java.lang    java.awt
                                          Object   Component

                                                               Container  JToggleButton   JCheckbox
                                                                            JButton      JRadioButton
                                javax.swing
                                          JComponent                      JMenuItem         JMenu

                                                       AbstractButton      JTextArea     JPasswordField
                                                            JList          JTextField

                                                       JOptionPane
                                                       JPopupMenu
                                                       JTextComponent
                                                        JMenuBar
                                                       JScrollPane

                                                           JLabel
                                                           JPanel

                                      A JTextArea will serve to display the program's output.

                                      A JButton will allow the user to request the greeting.

                                      A JLabel will serve as a prompt for the JTextField.

                                Figure 4.16 shows some of the constructors and public methods for the

                                JTextArea, JTextField, JButton, and JLabel components. The fol-

                                lowing code segments illustrate how to use these constructors to create

                                instances of these components:

                                                                                                                          

                                     // D e c l a r e i n s t a n c e v a r i a b l e s f o r t h e comp onent s

                                private JLabel prompt ;

                                private JTextField inField ;

                                private JTextArea display ;

                                private JButton goButton ;

                                     // I n s t a n t i a t e t h e c ompon ents

                                prompt = new J L a b e l ( " P l e a s e type your name here : " ) ;

                                i n F i e l d = new J T e x t F i e l d ( 1 0 ) ; // 1 0 c h a r s w i d e

                                d i s p l a y = new J T e x t A r e a ( 1 0 , 3 0 ) ; // 1 0 r o w s x 3 0 c o l u m n s

                                goButton = new J B u t t o n ( " C l i c k here f o r a g r e e t i n g ! " ) ;           
                                

                                For this example, we use some of the simpler constructors. Thus, we create
                                a JTextField with a size of 10. That means it can display 10 characters
                                of input. We create a JTextArea with 10 rows of text, each 30 characters
SECTION 4.4  A Graphical User Interface (GUI)  167
                                                        Figure 4.16: Public methods and
                                                        constructors for basic Swing com-
                                                        ponents.

wide. We create a JButton with a simple text prompt meant to inform
the user of how to use the button.

4.4.5 Adding GUI Components to a Top-Level Window

Now that we know how to create GUI components, the next task is to
add them to the top-level window. A JFrame is a top-level Container
(Fig. 4.11), but instead of adding the components directly to the JFrame
we have to add them to the JFrame's content pane, which is also a
Container.

 JAVA LANGUAGE RULE Content Pane. GUI Components cannot
 be added directly to a JFrame. They must be added to its content
 pane.

Java's Container class has several add() methods that can be used to         
insert components into the container:                                        

                                                                              Layout manager

    add ( Component comp ) // a d d c o m p t o e n d o f c o n t a i n e r
    add ( Component comp , i n t index ) // a d d c o m p a t i n d e x
    add ( S t r i n g region , Component comp ) add comp a t r e g i o n
 

The particular add() method to use depends on how we want to arrange
the components in the container. The layout of a container is controlled
by its default layout manager, an object associated with the container that
determines the sizing and the arrangement of its contained components.
For a content pane, the default layout manager is a BorderLayout. This
                                  168  CHAPTER 4  Input/Output: Designing the User Interface

Figure 4.17: Arrangement of com-  is an arrangement whereby components may be placed in the center of the
ponents in a border layout.       pane and along its north, south, east, and west borders (Fig. 4.17).

                                                                                           North

                                       West  Center                                        East

                                             South

                                     Components are added to a border layout by using the add(String
                                  region, Component comp) method, where the String parameter
                                  specifies either "North," "South," "East," "West," or "Center." For exam-
                                  ple, to add the JTextArea to the center of the JFrame we first create a
                                  reference to its content pane and we then add the component at its center:

                                                                                                                 

                                  Container contentPane = getContentPane ( ) ; // Get pane

                                  contentPane . add ( " Center " , d i s p l a y ) ; // Add J T e x t A r e a    
                                  

                                     One limitation of the border layout is that only one component can be
                                  added to each area. This is a problem for our example because we want
                                  our prompt JLabel to be located right before the JTextField. To get
                                  around this problem, we will create another container, a JPanel, and add
                                  the prompt, the text field, and the goButton to it. That way, all of the
                                  components involved in getting the user's input will be organized into
                                  one panel. We then add the entire panel to one of the areas on the content
                                  pane.

                                                                                                                 

                                  J P a n e l i n p u t P a n e l = new J P a n e l ( ) ;

                                  inputPanel . add ( prompt ) ; // Add J L a b e l t o p a n e l

                                  inputPanel . add ( i n F i e l d ) ; // Add J T e x t F i e l d t o p a n e l

                                  inputPanel . add ( goButton ) ; // Add J B u t t o n t o p a n e l

                                  contentPane . add ( " South " , inputPanel ) ; // Add t o J F r a m e          
                                  

                                  The default layout for a JPanel is FlowLayout, which means that com-
                                  ponents are added left to right with the last addition going at the end of
                                  the sequence. This is an appropriate layout for this JPanel because it will
                                  place the prompt just to the left of the input JTextField.

                                  JAVA EFFECTIVE DESIGN Encapsulation. JPanels can be used to
                                  group related components in a GUI.

                                  4.4.6 Controlling the GUI's Action

                                  Now that we know how to place all the components on the GUI, we need
                                  to design the GUI's controls. As mentioned earlier, GUIs use a form of
                                  event-driven programming. Anything that happens when you are using
SECTION 4.4  A Graphical User Interface (GUI)                              169
                                                                                     Figure 4.18: Java's event model.
                                                   Java Applet
                                  Handlers: actionPerformed() method

                                 Java Enabled Browser: Netscape, JVM
                                     Handlers: menu_event, scrollbar

                               Operating System: MacOS, Windows, Unix
                                Handlers: select_window, close_window

                                             Computer Hardware
                           Generate Events: mouse_clicks, diskette events,

                                     mouse_moves, keyboard_events

a computer--every keystroke and mouse movement--is classified as an              Event listener
event. As Figure 4.18 illustrates, events are generated by the computer's
hardware and filtered up through the operating system and the applica-          
tion programs. Events are handled by special objects called listeners. A        
listener is a specialist that monitors constantly for a certain type of event.
Some events, such as inserting a CD in the CD-ROM drive, are handled
by listeners in the operating system. Others, such as typing input into
a Web page or a Word document, are handled by listeners in a piece of
application software, such as a browser or a word processor.

   In an event-driven programming model, the program is controlled by
an event loop. That is, the program repeatedly listens for events, taking
some kind of action whenever an event is generated. In effect, we might
portray this event loop as follows:

 

      Repeat forever or u n t i l the program i s stopped
           Listen for events
           I f event-A occurs , handle i t with event-A-handler
           I f event-B occurs , handle i t with event-B-handler
             ...

 

The event loop listens constantly for the occurrence of events and then
calls the appropriate object to handle each event.

   Figure 4.19 shows some of the main types of events in the
java.awt.event package. In most cases, the names of the event classes
are suggestive of their roles. Thus, a MouseEvent occurs when the mouse
is moved. A KeyEvent occurs when the keyboard is used. The only event
that our program needs to listen for is an ActionEvent, the type of event
that occurs when the user clicks the JButton.

   When the user clicks the JButton, Java will create an ActionEvent
object. This object contains important information about the event, such
as the time that the event occurred and the object, such as a JButton,
that was the locus of the event. For our application, when the user
clicks the JButton, the program should input the user's name from the
JTextField and display a greeting, such as "Hi John nice to meet you"
                                   170  CHAPTER 4  Input/Output: Designing the User Interface

Figure 4.19: Java's event hierar-       java.lang
chy.                                               Object

                                        java.util
                                              EEvveennttOObbjjeecctt

                                        java.awt                      java.awt.event
                                               AAWWTTEEvveenntt

                                                                      ActionEvent

                                                                      AdjustmentEvent

                                                                      ComponentEvent

                                                                      ItemEvent        ContainerEvent
                                                                      TextEvent        FocusEvent

                                                                                                InputEvent

                                                                                       PaintEvent            KeyEvent
                                                                                       WindowEvent          MouseEvent

                                   in the JTextArea. That is, we want the program to execute the following
                                   code segment:

                                                                                                                        

                                        S t r i n g name = i n F i e l d . g e t T e x t ( ) ;

                                        d i s p l a y . append ( g r e e t e r . g r e e t ( name ) + "\n" ) ;          

java.sun.com/j2se/1.5.0/docs/api/  The first line uses the JTextField.getText() method to get the text
                                   that the user typed into the JTextField and stores it in a local vari-
                                   able, name. The second line passes the name to the greeter.greet()
                                   method and passes the result it gets back to the JTextArea.append()
                                   method. This will have the effect of displaying the text at the end of the
                                   JTextArea.

                                      In this example, we have used a couple of the standard public methods
                                   of the JTextField and JTextArea classes. For our simple GUI, the
                                   methods described in Figure 4.16 will be sufficient for our needs. How-
                                   ever, if you would like to see the other methods available for these and
                                   other Swing components, you should check Java's online API documen-
                                   tation.

                                   4.4.7 The ActionListener Interface

                                   Given that the code segment just described will do the task of greeting
                                   the user, where should we put that code segment in our program? We
                                   want that code segment to be invoked whenever the user clicks on the
                                   goButton. You know enough Java to understand that we should put that
                                   code in a Java method. However, we need a special method in this case,
                                   one that will be called automatically by Java whenever the user clicks that
SECTION 4.4  A Graphical User Interface (GUI)                       171

button. In other words, we need a special method that the button's listener       Java interface
knows how to call whenever the button is clicked.
                                                                                 
   Java solves this problem by letting us define a pre-selected method           
that can be associated with the goButton. The name of the method is
actionPerformed() and it is part of the ActionListener interface.
In this case, an interface is a special Java class that contains only methods
and constants (final variables). It cannot contain instance variables. (Be
careful to distinguish this kind of interface, a particular type of Java class,
form the more general kind of interface, whereby we say that a class's pub-
lic methods make up its interface to other objects.) Here's the definition of
the ActionListener interface:



public abstract interface ActionListener

     extends EventListener

{    public abstract void actionPerformed ( ActionEvent e ) ;

  }


This resembles a class definition, but the keyword interface replaces
the keyword class in the definition. Note also that we are declaring this
interface to be abstract. An abstract interface or abstract class is one
that contains one or more abstract methods. An abstract method is one
that consists entirely of its signature; it lacks an implementation--that is,
it does not have a method body. Note that the actionPerformed()
method in ActionListener places a semicolon where its body is sup-
posed to be.

JAVA LANGUAGE RULE Java Interface. A Java interface is like a
Java class except that it cannot contain instance variables.

JAVA LANGUAGE RULE Abstract Methods and Classes. An
abstract method is a method that lacks an implementation. It has no
method body.

   Declaring a method abstract means that we are leaving its imple-              Abstract method
mentation up to the class that implements it. This way, its implementation
can be tailored to a particular context, with its signature specifying gen-
erally what the method should do. Thus, actionPerformed() should
take an ActionEvent object as a parameter and perform some kind of
action.

   What this means, in effect, is that any class that implements the
actionPerformed() method can serve as a listener for ActionEvents.
Thus, to create a listener for our JButton, all we need to do is give an
implementation of the actionPerformed() method. For our program,
the action we want to take when the goButton is clicked, is to greet
the user by name. Thus, we want to set things up so that the follow-
172          CHAPTER 4  Input/Output: Designing the User Interface

ing actionPerformed() method is called whenever the goButton is
clicked:

                                                                                              

 public void actionPerformed ( ActionEvent e )
{ i f ( e . g e t S o u r c e ( ) == goButton )

     { S t r i n g name = i n F i e l d . g e t T e x t ( ) ;
                d i s p l a y . append ( g r e e t e r . g r e e t ( name ) + "\n" ) ;

     }

     }

                                                                                              

In other words, we place the code that we want executed when the button
is clicked in the body of the actionPerformed() method. Note that in
the if-statement we get the source of the action from the ActionEvent
object and check that it was the goButton.

   That explains what gets done when the button is clicked--namely,
the code in actionPerformed() will get executed. But it doesn't
explain how Java knows that it should call this method in the first
place. To set that up we must do two further things. We must place
the actionPerformed() method in our GreeterGUI class, and we
must tell Java that GreeterGUI will be the ActionListener for the
goButton.

   The following stripped-down version of the GreeterGUI class illus-
trates how we put it all together:

                                                                                              

 public c l a s s GreeterGUI extends Frame
                                                        implements ActionListener

{ ...
   public void buildGUI ( )
   { ...
         goButton = new J B u t t o n ( " C l i c k here f o r a g r e e t i n g ! " ) ;
         goButton . addActionListener ( this ) ;
         ...
   }

        ...
        public void actionPerformed ( ActionEvent e )
        { i f ( e . g e t S o u r c e ( ) == goButton )

               { S t r i n g name = i n F i e l d . g e t T e x t ( ) ;
                      d i s p l a y . append ( g r e e t e r . g r e e t ( name ) + "\n" ) ;

               }

        }

        ...

}

                                                                                              

First, we declare that GreeterGUI implements the ActionListener
interface in the class header. This means that the class must provide a
definition of the actionPerformed() method, which it does. It also
means that GreeterGUI isa ActionListener. So SimpleGUI is both a
JFrame and an ActionListener.
SECTION 4.4  A Graphical User Interface (GUI)  173

   Second, note how we use the addActionListener() method to as-
sociate the listener with the goButton:

                                                                               

goButton . addActionListener ( this )
                                                                               

   The this keyword is a self-reference--that is, it always refers to the
object in which it is used. It's like a person referring to himself by saying
"I". When used here, the this keyword refers to this GreeterGUI. In
other words, we are setting things up so that the GreeterGUI will serve
as the listener for action events on the goButton.

JAVA LANGUAGE RULE This Object. The this keyword always
refers to the object that uses it. It is like saying "I" or "me."
174     CHAPTER 4  Input/Output: Designing the User Interface

4.4.8 Connecting the GUI to the Computational Object

Figure 4.20 gives the complete source code for our GreeterGUI interface.
Because there is a lot going on here, it might be helpful to go through the
program carefully even though we have introduced most of its elements

                                                                                      

import javax . swing .  ;
import java . awt .  ;
import java . awt . event .  ;

public class GreeterGUI extends JFrame                         ActionListener
                                                  implements

{ private JTextArea display ;
   private JTextField inField ;
   private JButton goButton ;
   private Greeter greeter ;

   public GreeterGUI ( String t i t l e )

   { g r e e t e r = new G r e e t e r ( ) ;

     buildGUI ( ) ;

     setTitle ( title );

     pack ( ) ;

     setVisible ( true );

   } // G r e e t e r G U I ( )

   private void buildGUI ( )

   { Container contentPane = getContentPane ( ) ;

     contentPane . s e t L a y o u t (new BorderLayout ( ) ) ;

     d i s p l a y = new JTextArea ( 1 0 , 3 0 ) ;

     i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;

     goButton = new J B u t t o n ( " C l i c k here f o r a g r e e t i n g ! " ) ;

     goButton . addActionListener ( this ) ;

     J P a n e l i n p u t P a n e l = new J P a n e l ( ) ;

     i n p u t P a n e l . add (new J L a b e l ( " Input your name here : " ) ) ;

     inputPanel . add ( i n F i e l d ) ;

     inputPanel . add ( goButton ) ;

     contentPane . add ( " Center " , display ) ;

     contentPane . add ( " South " , inputPanel ) ;

   } // b u i l d G U I ( )

   public void actionPerformed ( ActionEvent e )

   { i f ( e . g e t S o u r c e ( ) == goButton )

     { S t r i n g name = i n F i e l d . g e t T e x t ( ) ;

        d i s p l a y . append ( g r e e t e r . g r e e t ( name ) + "\n" ) ;

     }

   } // a c t i o n P e r f o r m e d ( )

}

                                                                                      

        Figure 4.20: Definition of the GreeterGUI class.

already. That will help us put together all of the various concepts that we
have introduced.

   To begin with, note the several Java packages that must be included
in this program. The javax.swing package includes definitions for
all of the Swing components. The java.awt.event package includes
SECTION 4.4  A Graphical User Interface (GUI)  175

the ActionEvent class and the ActionListener interface, and the                 Extending a class
java.awt packages contain the Container class.                                  Implementing an interface
                                                                                The computational object
   Next note how the GreeterGUI class is defined as a subclass
of JFrame and as implementing the ActionListener interface.
GreeterGUI thereby inherits all of the functionality of a JFrame. Plus,
we are giving it additional functionality. One of its functions is to serve as
an ActionListener for its goButton. The ActionListener interface
consists entirely of the actionPerformed() method, which is defined
in the program. This method encapsulates the actions that will be taken
whenever the user clicks the goButton.

   The next elements of the program are its four instance variables, the
most important of which is the Greeter variable. This is the variable that
sets up the relationship between the GUI and the computational object. In
this case, because the variable is declared in the GUI, we say that the GUI
uses the computation object, as illustrated in Figure 4.8. This is slightly
different from the relationship we set up in the command-line interface,
in which the computational object uses the interface (Fig. 4.2).

   The other instance variables are for those GUI components that must
be referred to throughout the class. For example, note that the goButton,
inField, and display are instantiated in the buildGUI() method and
referenced again in the actionPerformed() method.

   The next element in the program is its constructor. It begins by creating
an instance of the Greeter computational object. It is important to do this
first in case we need information from the computational object in order
to build the GUI. In this case we don't need anything from Greeter, but
we will need such information in other programs.

   We've already discussed the fact that the constructor's role is to coor-
dinate the initialization of the GreeterGUI object. Thus, it invokes the
buildGUI() method, which takes care of the details of laying out the
GUI components. And, finally, it displays itself by calling the pack() and
setVisible() methods, which are inherited from JFrame. The pack()
method sizes the frame according to the sizes and layout of the compo-
nents it contains. The setVisible() method is what actually causes the
GUI to appear on the Java console.

   Finally, note the details of the buildGUI() method. We have dis-
cussed each of the individual statements already. Here we see the order
in which they are combined. Note that we can declare the contentPane
and inputPanel variables locally, because they are not used elsewhere
in the class.

SELF-STUDY EXERCISES

EXERCISE 4.2 There is a simple modification that we can make to
GreeterGUI. The JTextField can serve both as an input element and
as a control element for action events. An ActionEvent is generated
whenever the user presses the Return or Enter key in a JTextField so
that the JButton can be removed. Of course, it will be necessary to des-
ignate the inField as an ActionListener in order to take advantage
of this feature. Make the appropriate changes to the buildGUI() and
actionPerformed() methods so that the inField can function as both
a control and input element. Call the new class GreeterGUI2.
                               176  CHAPTER 4  Input/Output: Designing the User Interface

                               4.4.9 Using the GUI in a Java Application

                               As you know, a Java application is a stand alone program, one that can
                               be run on its own. We have designed our GUI so that it can easily be
                               used with a Java application. We saw in the previous section that the GUI
                               has a reference to the Greeter object, which is the computational object.
                               Therefore, all we need to get the program to run as an application is a
                               main() method.

                                  One way to use the GUI in an application is simply to create an in-
                               stance in a main() method. The main() method can be placed in the
                               GreeterGUI class itself or in a separate class. Here's an example with
                               the main in a separate class:

                                                                                                              

                               public class GreeterApplication
                               { public s t a t i c void main ( S t r i n g args [ ] )

                                    {

                                         new GreeterGUI ( " G r e e t e r " ) ;
                                    }

                               }

                                                                                                              

                               The main() method creates an instance of GreeterGUI, passing it a
                               string to use as its title. If you prefer, this same main() method can be
                               incorporated directly into the GreeterGUI class.

                               4.5 Case Study: The One Row Nim Game

Figure 4.21: A UML diagram of  In this section, we show how to develop alternative interfaces for our case
the OneRowNim class.           study game of One Row Nim that was developed in the two previous
                               chapters. As you recall, the One Row Nim game starts with, say, 21 sticks
                               on a table. Players take turns picking up 1, 2 or 3 sticks, and the player to
                               pick up the last stick loses. We wish to develop an application program so
                               that the user of the program can play this game against the computer, that
                               is, against the program.

                                  As in our other examples in this chapter, our design will divide this
                               problem into two primary objects: a computational object, in this case
                               OneRowNim, and a user interface object, for which we will use either a
                               KeyboardReader or a OneRowNimGUI. One goal of our design was to
                               develop the OneRowNim class so that it can be used, without changes,
                               with either a command-line interface or a GUI.

                                  Recall that we designed the OneRowNim class to maintain the state of
                               the game and to provide methods that enforce the rules of the game. Thus,
                               we know that after each legal move, the number of sticks will decline, until
                               it is 0 or less, which indicates that the game is over. Also, an instance of
                               OneRowNim keeps track of whose turn it is and can determine if the game
                               is over and who the winner is when the game is over. Finally, the game
                               ensures that players cannot cheat, either by taking too few or too many
                               sticks on one turn. Figure 4.23 shows the UML diagram of the OneRowNim
                               class as described at the end of the previous chapter.
SECTION 4.5  Case Study: The One Row Nim Game  177

4.5.1 A Command-line Interface to OneRowNim

Let's now focus on connecting a OneRowNim instance with a Keyboard-                    Loop algorithm
Reader instance, the command-line interface we developed at the begin-                
ning of this chapter. To do so requires no changes to KeyboardReader
(Fig. 4.6). Unlike in the greeter example, we will use a third object to              
serve as the main program. As shown in Figure 4.22, the OneRowNimApp                   Loop structure: Initializer, entry con-
class will contain the run() method that controls the game's progress.                 dition, updater
OneRowNimApp will use the KeyboardReader object to prompt the user,
to display the program's output, and to perform input from the keyboard.
It will use the OneRowNim object to keep track of the game.

   In fact, the main challenge for this part of our problem is designing the
run() method, which will use a loop algorithm to play the game. The
user and the computer will repeatedly take turns picking up sticks until
the game is over. The game is over when there are no more sticks to pick
up. Thus, we can use the game's state--the number of sticks left--as our
loop's entry condition. We will repeat the loop while there are more than
0 sticks remaining.

   The following pseudocode describes the remaining details of our al-
gorithm. We refer to the OneRowNim instance as the game object, and
we refer to the KeyboardReader instance as the reader object. We
use the notation game:get the number of sticks left to indicate
that we are sending a message to the game object.

 

      C r e a t e a game o b j e c t with 21 s t i c k s
      Create a reader object
      s t i c k s L e f t = game : g e t t h e number o f s t i c k s l e f t
      r e a d e r : d i s p l a y t h e r u l e s o f t h e game
      while ( game : t h e game i s not over )

             whoseMove = game : f i n d out whose turn i t i s
             i f ( whoseMove == user )

                    game : user chooses number o f s t i c k s t o t a k e
             else

                    game : computer chooses number o f s t i c k s t o t a k e
             s t i c k s L e f t = game : g e t t h e number o f s t i c k s l e f t
             reader : r e p o r t the number of s t i c k s l e f t

       // At t h i s p o i n t t h e game i s o v e r .

      i f game : t h e user i s t h e winner
                  reader : report that the user wins

      else
                 reader : report that the computer wins

 

In this algorithm, the initializations we perform consist of creating the
game and reader objects and initializing sticksLeft. We use a while
loop structure to control the game. The loop's entry condition is that the
'the game is not over'. This is a piece of information that comes directly
from the game object. As long as the game is not over, the body of the
loop will be executed. Note that in the loop's body, either the player or the
computer makes a move. Again, it is up to the game object to determine
whose move it is. Following the move we ask the game how many sticks
are left and we use the reader object to report this.

   Note that the loop structure has the three necessary elements. The ini-
                   178  CHAPTER 4  Input/Output: Designing the User Interface

Division of labor  tializer in this case is the creation of a OneRowNim object. We know that
                   this will cause the game to have 21 sticks and it will be the user's move.
                   The loop-entry condition is that the game is not over, which is based on
                   the fact that there are still sticks remaining to be picked up. But again, this
                   knowledge is kept by the game object. Finally, we have an updater that
                   consists of either the computer or the user picking up some sticks. This in
                   turn changes the value of sticksLeft on each iteration, moving us ever
                   closer to the condition that there are no sticks left, at which point the game
                   will be over.

                      Note that we have left out of this algorithm the details of the user's
                   moves and computer's moves. These are the kinds of actions that are
                   good to put into separate methods, where we can worry about checking
                   whether the user made a legal move and other such details.

                      Figure 4.22 provides the implementation of the OneRowNimApp appli-
                   cation. It uses a KeyboardReader as a command-line interface and a
                   OneRowNim instance as it computational object. Thus, it has private in-
                   stance variables for each of these objects, which are instantiated in the
                   constructor method. The algorithm we just described has been placed in
                   the run() method, which is called from main() after the application is
                   instantiated. The use of the boolean method gameOver() to control the
                   loop makes this code segment easier to understand. Also, it leaves it up
                   to the game object to determine when the game is over. From an object-
                   oriented design perspective, this is an appropriate division of responsibil-
                   ity. If you doubt this, imagine what could go wrong if this determination
                   was left up to the user interface. A user-interface programmer might end
                   up, mistakenly, implementing the wrong rule for the game being over. A
                   similar point applies to the getWinner() method. This determination
                   rests with the game, not the user interface. If left up to the user interface,
                   it is possible that a programming mistake could lead to the loss of the
                   game's integrity.

                      The run() method calls userMove() and computerMove() to per-
                   form the specific set of actions associated with each type of move.
                   The userMove() method uses the KeyboardReader() to prompt the
                   user and input his or her move. It then passes the user's choice to
                   game.takeSticks(). Note how it checks the return value to determine
                   whether the move was legal or not and provides an appropriate response
                   through the interface.

                      Finally, note how we use private methods to implement the actions as-
                   sociated with the user's and computer's moves. Because these private
                   methods are not part of the object's interface and because they can only
                   be used within the object themselves, they are in a sense secondary to the
                   object's public instance methods. We sometimes refer to them as helper
                   methods. This division of labor allows us to organize all of the details
                   associated with the moves into a single module. The computerMove()
                   method uses a temporary strategy of taking a single stick and passes
                   the number 1 to game.takeSticks(). Finally, computerMove() re-
                   ports its choice through the interface. After we have covered operators of
                   the int data type in the next chapter, we will be able to describe better
                   strategies for the computer to make a move.

                      This example shows how simple and straightforward it is to use our
                   KeyboardReader user interface. In fact, for this problem, our interface
SECTION 4.5  Case Study: The One Row Nim Game                179

                                                                                                     

public c l a s s OneRowNimApp
{ private KeyboardReader reader ;

   p r i v a t e OneRowNim game ;

  public OneRowNimApp ( )
  { r e a d e r = new KeyboardReader ( ) ;

     game = new OneRowNim ( 2 1 ) ;
  } // OneRowNim ( )

  public void run ( )
  { i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;

     r e a d e r . d i s p l a y ( " Let ' s play One Row Nim . You go f i r s t . \ n" ) ;
     reader . display ( "There are " + sticksLeft +

                                                                     " s t i c k s l e f t .\n" ) ;
     r e a d e r . d i s p l a y ( "You can p i c k up 1 , 2 , or 3 a t a time \n . " ) ;
     while ( game . gameOver ( ) == f a l s e )
     { i f ( game . g e t P l a y e r ( ) == 1 ) userMove ( ) ;

         else computerMove ( ) ;
         s t i c k s L e f t = game . g e t S t i c k s ( ) ;
         reader . display ( "There are " + sticksLeft +

                                                                   " s t i c k s l e f t .\n" ) ;
     } // w h i l e
     i f ( game . getWinner ( ) == 1 )

         r e a d e r . d i s p l a y ( "Game over . You win . Nice game . \ n" ) ;
     e l s e r e a d e r . d i s p l a y ( "Game over . I win . Nice game . \ n" ) ;
  } // run ( )

  private void userMove ( )
  { r e a d e r . prompt ( "Do you t a k e 1 , 2 , or 3 s t i c k s ? : " ) ;

     int userTakes = reader . getKeyboardInteger ( ) ;
     i f ( game . t a k e S t i c k s ( userTakes ) )
     { r e a d e r . d i s p l a y ( "You t a k e " + userTakes + " . \ n" ) ;
     } else
     { r e a d e r . d i s p l a y ( "You can ' t t a k e " + userTakes +

                                                                          " . Try again\n" ) ;
     } // e l s e
  } // userMove ( )

  private void computerMove ( )                   strategy .
  { game . takeAway ( 1 ) ; // T e m p o r a r y
                                                  ");
     reader . display ("I take 1 stick .
  } // computerMove ( )

  public s t a t i c void main ( S t r i n g args [ ] )

  { OneRowNimApp app = new OneRowNimApp ( ) ;

  app . run ( ) ;

  } // main ( )

} // OneRowNimApp

                                                                                                     

Figure 4.22: Definition of OneRowNimApp, a command-line interface to
the OneRowNim.
                   180       CHAPTER 4  Input/Output: Designing the User Interface

                   didn't require any changes. Although there might be occasions where we
                   will want to extend the functionality of KeyboardReader, it can be used
                   without changes for a wide variety of problems in subsequent chapters.

                   JAVA EFFECTIVE DESIGN Code Reuse. A well-designed user
                   interface can be used with many computational objects.

                   4.5.2 A GUI for OneRowNim

                   The first task is designing a GUI for the OneRowNim is to decide how to
                   use input, output, and control components to interact with the user. Fol-
                   lowing the design we used in the GUI for our greeter application, we can
                   use a JTextField for the user's input and a JTextArea for the game's
                   output. Thus, we will use the JTextArea to report on the progress of the
                   game and to display any error messages that arise. As in the greeter exam-
                   ple, we can use both the JTextField and JButton as control elements
                   and a JLabel as a prompt for the input text field. For the most part then,
                   the use of GUI components will remain the same as in our previous exam-
                   ple. This is as we would expect. The relationship between the user and
                   the interface are pretty similar in both this and the previous application.

                      In contrast, the relationship between the interface and the game are
                   quite different from what we saw in the greeter application. As in the
                   previous application, the GUI will still need a reference to its associated
                   computational object, in this case the game:

                                                                                                

                        p r i v a t e OneRowNim game ;

                        ...

                        game = new OneRowNim ( ) ;                                              

Java's event loop  The biggest difference between this GUI and the one we used with
                   the greeter application occurs in the details of the interaction between
                   the GUI and the game. These details are the responsibility of the
                   actionPerformed() method, whose actions depend on the actual
                   progress of the individual game.

                      Unlike in the command-line version, there is no need to use a loop con-
                   struct in the actionPerformed() method. Instead, because we are us-
                   ing event-driven programming here, we will rely on Java's event loop to
                   move the game from one turn to another.

                      As in the greeter example, the actionPerformed() method will be
                   called automatically whenever the JButton is clicked. It is the responsi-
                   bility of the GUI to ensure that it is the user's turn whenever this action
                   occurs. Therefore, we design actionPerformed() so that each time it
                   is called, it first performs the user's move and then, assuming the game
SECTION 4.5  Case Study: The One Row Nim Game                    181

is not over and an error did not occur on the user's move, it performs the
computer's move. Thus, the basic algorithm is as follows:

                                                                               

  Let t h e user move .

  I f game : game i s not over and computer turn

  l e t t h e computer move .

  Game : how many s t i c k s a r e l e f t .

  d i s p l a y : r e p o r t how many s t i c k s a r e l e f t

  I f game : game i s over

  Stop a c ce p t in g moves .

  Report the winner .                                                          

After the user's move, it is possible that the user picked up the last stick,
which means that the game would be over. In that case, the computer
would not get a move. Or, the user could have made an error. In that case
it would still be the user's move. These possibilities have to be considered
in the algorithm before the computer gets to move. As the pseudocode
shows, it is the OneRowNim object's responsibility to keep track of whether
the game is over and whose turn it is.

   Figure 4.23 shows the complete implementation of the OneRowNimGUI
class. In terms of its instance variables, constructor, and its buildGUI()
method, there are only a few minor differences between this GUI and
the GreeterGUI (Fig. 4.20). This GUI has instance variables for its
JTextField, JTextArea, and JButton, as well as one for OneRowNim
instance, its computational object. It needs to be able to refer to these
objects throughout the class. Hence we give them class scope.

   The constructor method plays the same role here as in the previous
GUI: It creates an instance of the computational object, builds the GUI's
layout, and then displays the interface on the console.

   All of the changes in the buildGUI() method have to do with
application-specific details, such as the text we use as the prompt and
the goButton's label. One new method we use here is the setText()
method. Unlike the append() method, which is used to add text to the
existing text in a JTextArea, the setText() method replaces the text in
a JTextArea or a JTextField.

   Next let's consider the private userMove() and computerMove()
methods. Their roles are very similar to the corresponding methods in
the command-line interface: They encapsulate the details involved in per-
forming the players' moves. The primary difference here is that for the
user move we input the user's choice from a JTextField rather than
from the keyboard. We use getText() to retrieve the user's input from
the JTextField and we use Integer.parseInt() to convert to an
int value:

                                                                               

int userTakes = Integer . parseInt ( inField . getText ( ) ) ;                 


Another difference is that we use a JTextField to display the program's
messages to the user.

   As we have noted, the main differences between this and the
GreeterGUI occur in the actionPerformed() method. Note
182              CHAPTER 4  Input/Output: Designing the User Interface

                                                                                                                

import javax . swing .  ;
import java . awt .  ;
import java . awt . event .  ;

public c l a s s OneRowNimGUI extends                   JFrame   implements  ActionListener
{ private JTextArea display ;

   private JTextField inField ;
   private JButton goButton ;
   p r i v a t e OneRowNim game ;

  public OneRowNimGUI( S t r i n g t i t l e )

  { game = new OneRowNim ( 2 1 ) ;

     buildGUI ( ) ;

     setTitle ( title );

     pack ( ) ;

     setVisible ( true );

  } // OneRowNimGUI ( )

  private void buildGUI ( )

  { Container contentPane = getContentPane ( ) ;

     contentPane . s e t L a y o u t (new BorderLayout ( ) ) ;

     d i s p l a y = new JTextArea ( 2 0 , 3 0 ) ;

     d i s p l a y . s e t T e x t ( " Let ' s play Take Away . There a r e " + game . g e t S t i c k s ( ) +

     " s t i c k s . \ n" + " P i c k up 1 , 2 , or 3 a t a time . \ n" + "You go f i r s t . \ n" ) ;

     i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;

     goButton = new J B u t t o n ( " Take S t i c k s " ) ;

     goButton . addActionListener ( this ) ;

     J P a n e l i n p u t P a n e l = new J P a n e l ( ) ;

     i n p u t P a n e l . add (new J L a b e l ( "How many s t i c k s do you t a k e : " ) ) ;

     inputPanel . add ( i n F i e l d ) ;

     inputPanel . add ( goButton ) ;

     contentPane . add ( " Center " , display ) ;

     contentPane . add ( " South " , inputPanel ) ;

  } // buildGUI

  private void userMove ( )

  { int userTakes = Integer . parseInt ( inField . getText ( ) ) ;

     i f ( game . t a k e S t i c k s ( userTakes ) )

     d i s p l a y . append ( "You t a k e " + userTakes + " . \ n" ) ;

     e l s e d i s p l a y . append ( "You can ' t t a k e " + userTakes + " . Try again \n" ) ;

  }// userMove ( )

  private void computerMove ( )

  { i f ( game . gameOver ( ) ) r e t u r n ;

     i f ( game . g e t P l a y e r ( ) == 2 )

     { game . t a k e S t i c k s ( 1 ) ; // Temporary s t r a t e g y

     display . append ( " I take one s t i c k . " ) ;

     } // i f

  } // computerMove ( )

  p r i v a t e void endGame ( )

  { goButton . s e t E n a b l e d ( f a l s e ) ; // D i s a b l e button and t e x t f i e l d

     inField . setEnabled ( false ) ;

     i f ( game . getWinner ( ) == 1 )

     d i s p l a y . append ( "Game over . You win . Nice game . \ n" ) ;

     e l s e d i s p l a y . append ( "Game over . I win . Nice game . \ n" ) ;

  } // endGame ( )

  public void actionPerformed ( ActionEvent e )

  { i f ( e . g e t S o u r c e ( ) == goButton )

     { userMove ( ) ;

     computerMove ( ) ;

     i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;

     display . append ( "There are " + s t i c k s L e f t + " s t i c k s l e f t .\n" ) ;

     i f ( game . gameOver ( ) ) endGame ( ) ;

     } // i f

  } // act ionPerf ormed ( )

} // OneRowNimGUI
                                                                                                                

                       Figure 4.23: The OneRowNimGUI class.
SECTION 5  File Input                                         183

there how we use OneRowNim's public methods, getPlayer(),
gameOver() and getWinner() to control the interaction with the user.

   One issue that differs substantially from the command-line interface is:
How do we handle the end of the game? Because we are using Java's built-
in event loop, the GUI will continue to respond to user's events, unless we
stop it from doing so. One way to do this is to disable the JButton and
the JTextField. By disabling a control element, we render it unable to
respond to events. To do this we use the setEnabled() method, passing
it the value false to, in effect, "turn off" that component:

                                                                             
                                                                             
  i f ( game . gameOver ( ) )            // End t h e game
  { goButton . setEnabled ( false ) ;                                         GUI input, output, and control

       inField . setEnabled ( false ) ;
        ...
  }


Although it doesn't apply in this situation, the setEnabled() method
can be used repeatedly in a GUI to turn components on and off as the
context of the interaction dictates.

   This example shows how simple and straightforward it can be to build
a GUI for just about any application. One main design issue is deciding
what kinds of input, output, and control elements to use. For most ap-
plications, we can use JTextField, JTextArea, JLabel, and JButton
as the GUI's basic elements. A second design issue concerns the develop-
ment of the actionPerformed() method, which must be designed in
an application-specific way. Here we apply what we've learned regard-
ing Java's event-programming model: We designate one or more of our
elements to serve as an ActionListener and we design algorithms to
handle the action events that occur on that element.

   Of course, for some applications we may need two JTextFields to
handle input. At some point, we also might want to introduce JMenus and
other advanced GUI elements. Some of these options will be introduced in
upcoming chapters. Others will be covered in Chapter 13, which provides
a more comprehensive view of Java's GUI capabilities.

JAVA EFFECTIVE DESIGN GUI Design A well-designed GUI
makes appropriate use of input, output, and control elements.

4.6 From the Java Library: java.io.File
      and File Input (Optional)

In addition to command-line and GUI user interfaces, there is one more
standard user interface, files. In this section we show how the Scanner
class, that was used in Chapter 2 for keyboard input, can also read input
from files. Reading input from a file is relevant to only certain types of
programming problems. It is hard to imagine how a file would be used
in playing the One Row Nim game but a file might very well be useful
                                       184  CHAPTER 4  Input/Output: Designing the User Interface

                                       to store a collection of riddles that could be read and displayed by a Java
                                       program. We will develop such a program later in this section.

                                          Java has two types of files, text files and binary files. A text file stores a
                                       sequence of characters and is the type of file created by standard text edi-
                                       tors like NotePad and WordPad on a Windows computer or SimpleText on a
                                       Macintosh. A binary file has a more general format that can store numbers
                                       and other data the way they are stored in the computer. In this section we
                                       will consider only text files. Binary files are considered in Chapter 11.

                                       4.6.1 File Input with the File and Scanner Classes

Figure 4.24: A UML class diagram       An instance of the java.io.File class stores information that a
of the File class with a partial list  Scanner object needs to create an input stream that is connected to the
of public methods                      sequence of characters in a text file. A partial list of the public methods
                                       of the File class is given in the UML class diagram in Figure 4.26. We
Figure 4.25: A UML class diagram       will need to use only the File() constructor in this section. The File
of the Scanner class with an ex-       instance created with the statement
panded list of public methods
                                                                                                                          

                                            F i l e t h e F i l e = new F i l e ( " r i d d l e s . t x t " ) ;           

                                       will obtain and store information about the "riddles.txt" file in the same
                                       directory as the java code being executed, if such a file exists. If no such
                                       file exists, the File object stores information needed to create such a file
                                       but does not create it. In Chapter 11, we will describe how other objects
                                       can use a file object to create a file in which to write data. If we wish to
                                       create a File object that describes a file in a directory other than the one
                                       containing the Java program, we must call the constructor with a string ar-
                                       gument that specifies the file's complete path name--that is, one that lists
                                       the sequence of directories containing the file. In any case, while we will
                                       not use it at this time, the exists() method of a File instance can be
                                       used to determine whether or not a file has been found with the specified
                                       name.

                                          In order to read data from a file with a Scanner object we will need
                                       to use methods that were not discussed in Chapter 2. An expanded list
                                       of methods of the Scanner class is given in Figure 4.27. Note the there
                                       is a Scanner() constructor with a File object as an argument. Unlike
                                       the other create() method that was used in Chapter 2, this create()
                                       throws an exception that must be handled. The following code will create
                                       a Scanner object that will be connected to an input stream that can read
                                       from a file:

                                                                                                                          

                                       try

                                       { F i l e t h e F i l e = new F i l e ( " r i d d l e s . t x t " ) ;

                                            f i l e S c a n = new Scanner ( t h e F i l e ) ;

                                            fileScan = fileScan . useDelimiter ( "\r\n" ) ;

                                       } catch ( IOException e )

                                       {    e . printStackTrace ();

                                       } // c a t c h ( )

                                                                                                                          

                                       We will discuss the try-catch commands when exceptions are covered
                                       in Chapter 10. Until then, the try-catch structures can be copied exactly
                                       as above, if you wish to use a Scanner object for file input. In the code
SECTION 6  File Input                                 185

above, the useDelimiter() method has been used to set the Scanner
object so that spaces can occur in strings that are read by the Scanner
object. For the definition of a class to read riddles from a file, the above
code belongs in a constructor method.

   After we create a Scanner object connected to a file, we can make a
call to nextInt(), nextDouble(), or next() method to read, respec-
tively, an integer, real number, or string from the file. Unlike the strategy
for using a Scanner object to get keyboard input, it is suggested that
you test to see if there is more data in a file before reading it. This can
be done with the hasNext(), hasNextInt(), and hasNextDouble()
methods. These methods return the value true if there are more data in
the file.

   The program in Figure 4.26 is the complete listing of a class that reads
riddles from a file and displays them. Note that, in the body of the method
readRiddles(), the statements:

                                                                               

String ques = null ;

String ans = null ;

Riddle theRiddle = null ;
                                                                               

make explicit the fact that variables that refer to objects are assigned null
as a value when they are declared. The statements:

                                                                               

if ( fileScan . hasNext ( ) )

   ques = fileScan . next ( ) ;

if ( fileScan . hasNext ( ) )

{ ans = fileScan . next ( ) ;

   t h e R i d d l e = new Riddle ( ques , ans ) ;

}

                                                                               

will read Strings into the variables ques and ans only if the file contains
lines of data for them. Otherwise the readRiddle() method will return
a null value. The main() method uses this fact to terminate a while
loop when it runs out of string data to assign to Riddle questions and
answers. There is a separate method, displayRiddle() using a sepa-
rate instance of Scanner attached to the keyboard to display the question
of a riddle before the answer.

   The contents of the "riddles.txt" file should be a list of riddles with
each question and answer on a separate line. For example The following
three riddles saved in a text file would form a good example to test the
RiddleFileReader class.

                                                                                  

   What i s b l a c k and white and red a l l over ?

   An embarrassed zebra

   What i s b l a c k and white and read a l l over ?

   A newspaper

   What o t h e r word can be made with t h e l e t t e r s o f ALGORITHM?

   LOGARITHM                                                                      
186       CHAPTER 4  Input/Output: Designing the User Interface

                                                                               

import java . io .  ;
import java . u t i l . Scanner ;
public class RiddleFileReader
{ private Scanner fileScan ; // For f i l e i n p u t

     private Scanner kbScan ; // F o r k e y b o a r d i n p u t

     public R i d d l e F i l e R e a d e r ( S t r i n g fName )

     { kbScan = new Scanner ( System . i n ) ;

     try

     { F i l e t h e F i l e = new F i l e ( fName ) ;

          f i l e S c a n = new Scanner ( t h e F i l e ) ;

          fileScan = fileScan . useDelimiter ( "\r\n" ) ;

     } catch ( IOException e )

     {    e . printStackTrace ();

     } // c a t c h ( )

     } // R i d d l e F i l e R e a d e r ( ) c o n s t r u c t o r

     public Riddle readRiddle ()

     { String ques = null ;

     String ans = null ;

     Riddle theRiddle = null ;

     if ( fileScan . hasNext ( ) )

          ques = fileScan . next ( ) ;

     if ( fileScan . hasNext ( ) )

     { ans = fileScan . next ( ) ;

          t h e R i d d l e = new Riddle ( ques , ans ) ;

     } // i f

     return theRiddle ;

     } // r e a d R i d d l e ( )

     public void displayRiddle ( Riddle aRiddle )

     { System . out . println ( aRiddle . getQuestion ( ) ) ;

     System . out . print ( " Input any l e t t e r to see answer : " ) ;

     String s t r = kbScan . next ( ) ; // I g n o r e KB i n p u t

     System . out . println ( aRiddle . getAnswer ( ) ) ;

     System . out . println ( ) ;

     } // d i s p l a y R i d d l e ( )

     public s t a t i c void main ( S t r i n g [ ] args )

     { RiddleFileReader rfr =

          new R i d d l e F i l e R e a d e r ( " r i d d l e s . t x t " ) ;

     Riddle riddle = rfr . readRiddle ( ) ;

     while ( riddle != null )

     { rfr . displayRiddle ( riddle );

          riddle = rfr . readRiddle ( ) ;

     } // w h i l e

     } // main ( )

} // R i d d l e F i l e R e a d e r c l a s s

                                                                               

Figure 4.26: A program which reads riddles from a file and displays them.

   When the main() method is executed, the user will see output in the
console window that looks like:

                                                                               

     What i s b l a c k and white and red a l l over ?
     Input any l e t t e r to see answer : X
     An embarrassed zebra

     What i s b l a c k and white and read a l l over ?

     Input any l e t t e r to see answer :                                     
CHAPTER 4  Chapter Summary             187

   Files are covered in depth in Chapter 11. Information on writing data
to a file and reading data from a file without using the Scanner class can
be found in that chapter.

SELF-STUDY EXERCISES

EXERCISE 4.3 Modify the RiddleFileReader class to create a pro-
gram NumberFileReaderthat opens a file named "numbers.txt" and re-
ports the sum of the squares of the integers in the file. Assume that the
file "numbers.txt" contains a list of integers in which each integer is on
a separate line. The program should print the sum of the squares in the
System.out console window. In this case, there is no need to have a
method to display the data being read or a Scanner object connected to
the keyboard. You will want a constructor method and a method that
reads the numbers and computes the sum of squares.

Technical Terms                                                                CHAPTER SUMMARY

abstract class      event loop          model-view-
abstract interface  graphical user         controller (MVC)
abstract method                            architecture
AWT                    interface (GUI)
binary file         helper method       output operation
buffer              inheritance         output stream
command-line        input operation     stream
                    input stream        Swing
   interface        interface           text file
container           layout manager      top-level container
control element     listener            user interface
event-driven                            wrapper class

   programming

Summary of Important Points

 An input operation is any action that transfers data from the user to the
   computer's main memory via one of the computer's input devices. An
   output operation is any action that transfers data from the computer's
   main memory to one of the computer's output devices.

 The user interface is that part of the program that handles the input
   and output interactions between the user and the program. As an in-
   terface, it limits or constrains the manner in which the user can interact
   with the program.

 In a command-line interface, user input is taken from the keyboard,
   and the program's output is displayed on some kind of console.

 A buffer is a portion of main memory where input is held until it is
   needed by the program. Using a buffer between the keyboard and the
   program allows you to use the Backspace key to delete a character.
188  CHAPTER 4  Input/Output: Designing the User Interface

 A wrapper class contains methods for converting primitive data into
  objects and for converting data from one type to another.

 Designing appropriate prompts is an important aspect of designing a
  good user interface.

 I/O operations must watch out for certain types of I/O exceptions.

 GUI programming involves a computational model known as event-
  driven programming, which means that GUI programs react to events
  that are generated mostly by the user's interactions with elements in
  the GUI.

 Java has two packages of GUIs, the older java.awt and the newer
  javax.swing.

 Swing components are based on the object-oriented model-view-
  controller (MVC) architecture.

 The extends keyword is used to specify subclass/superclass relation-
  ships in the Java class hierarchy.

 A top-level container is a GUI container that cannot be added to an-
  other container; it can only have components added to it. All GUI
  programs must be contained in a top-level container.

 There are generally three kinds of GUI components, corresponding to
  the three main functions of a user interface: input, output, and control.

 Events are handled by special objects called listeners. A listener is a
  specialist that listens constantly for a certain type of event.

 An interface is a special Java class that contains only methods and
  constants (final variables).
CHAPTER 4  Solutions to Self-Study Exercises                     189

  SOLUTION 4.1 The following modification of the GreeterApp class is an im-  SOLUTIONS TO
  plementation of the High Low Game:                                         SELF-STUDY EXERCISES

                                                                                  
  { private KeyboardReader reader ;
      private int secretNumber ;

  public HighLowApp ( )
  { r e a d e r = new KeyboardReader ( ) ;

     secretNumber = 1 + ( i n t ) ( Math . random ( )  1 0 0 ) ;
  } // HighLowApp ( ) c o n s t r u c t o r

  public void run ( )
  { int userGuess = -1;

     r e a d e r . d i s p l a y ( " Guess my s e c r e t number between 1 and 1 0 0 . " ) ;
     while ( userGuess != secretNumber )
     { reader . prompt ( " Please input your guess here > " ) ;

         userGuess = reader . getKeyboardInteger ( ) ;
         if ( userGuess > secretNumber )

             reader . d i s p l a y ( "Your guess was too high . " ) ;
         if ( userGuess < secretNumber )

             reader . d i s p l a y ( "Your guess was too low . " ) ;
     } // w h i l e
     reader . d i s p l a y ( " C o n g r a t u l a t i o n s . Your guess was c o r r e c t . " ) ;
  } // run ( )

  public s t a t i c void main ( S t r i n g args [ ] )

  { HighLowApp app = new HighLowApp ( ) ;

  app . run ( ) ;

  } // main ( )

}// HighLowApp

                                                                                                      
190     CHAPTER 4  Input/Output: Designing the User Interface

SOLUTION 4.2 The following modification of GreeterGUI eliminates the
JButton.

                                                                                

import java . awt .  ;
import java . awt . event .  ;

public class GreeterGUI2 extends JFrame
                                             implements ActionListener

{ private JTextArea display ;
   private JTextField inField ;
   private Greeter greeter ;

  public GreeterGUI2 ( String t i t l e )

  { g r e e t e r = new G r e e t e r ( ) ;

     buildGUI ( ) ;

     setTitle ( title );

     pack ( ) ;

     setVisible ( true );

  } // G r e e t e r G U I 2 ( )

  private void buildGUI ( )

  { Container contentPane = getContentPane ( ) ;

     contentPane . s e t L a y o u t (new BorderLayout ( ) ) ;

     d i s p l a y = new JTextArea ( 1 0 , 3 0 ) ;

     i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;

     inField . addActionListener ( this );

     J P a n e l i n p u t P a n e l = new J P a n e l ( ) ;

     i n p u t P a n e l . add (new

                 J L a b e l ( " Input your name and type e n t e r : " ) ) ;

     inputPanel . add ( i n F i e l d ) ;

     contentPane . add ( " Center " , display ) ;

     contentPane . add ( " South " , inputPanel ) ;

  } // b u i l d G U I ( )

  public void actionPerformed ( ActionEvent e )

  { i f ( e . g e t S o u r c e ( ) == i n F i e l d )

     { S t r i n g name = i n F i e l d . g e t T e x t ( ) ;

        d i s p l a y . append ( g r e e t e r . g r e e t ( name ) + "\n" ) ;

     }

  } // a c t i o n P e r f o r m e d ( )

} // G r e e t e r G U I 2

                                                                                
CHAPTER 4  Exercises                                                                191

SOLUTION 4.3 Java code that prints out the sum of the squares of a set of
integers read from a file named "numbers.txt":

                                                                                              

import java . u t i l . Scanner ;

public class NumberFileReader
{ private Scanner fileScan ; // For f i l e i n p u t

  public NumberFileReader ( S t r i n g fName )

  { try

         { F i l e t h e F i l e = new F i l e ( fName ) ;

                  f i l e S c a n = new Scanner ( t h e F i l e ) ;

         } catch ( IOException e )

         {        e . printStackTrace ();

         } // c a t c h ( )

  } // N u m b e r F i l e R e a d e r ( )

  public void readNumbers ( )

  { i n t num = 0 ;                         // To s t o r e i n t e g e r s r e a d

         i n t sum = 0 :                    // To s t o r e sum o f s q u a r e s

         while ( fileScan . hasNextInt ( ) )

         { num = f i l e S c a n . n e x t I n t ( ) ;

                  sum = sum + num  num ;

         } // w h i l e

         System . out . p r i n t l n ( "The sum o f s q u a r e s = " +             sum ) ;

  } // readNumbers ( )

  public s t a t i c void main ( S t r i n g [ ] args )

  { NumberFileReader nfr =

                  new NumberFileReader ( "numbers . t x t " ) ;

         nfr . readNumbers ( )

  } // main ( )

} // N u m b e r F i l e R e a d e r

                                                                                              

EXERCISE 4.1 Fill in the blanks in each of the following sentences:                              EXERCISES

a. An             is a Java program that can be embedded in a Web page.                          Note: For programming exercises,
                                                                                                 first draw a UML class diagram
b. A method that lacks a body is an             method.                                          describing all classes and their
                                                                                                 inheritance relationships and/or
c. An             is like a class except that it contains only instance methods, no              associations.

  instance variables.

d. In a Java class definition a class can               a class and                  an inter-

  face.

e. Classes and methods not defined in a program must be              from the Java

  class library.

f. A subclass of a class inherits that class's           instance variables and in-

  stance methods.

g. An object can refer to itself by using the           keyword.

h. The JButton, JTextField, and JComponent classes are defined in the

            package.

i. Java GUIs utilize a form of control known as             programming.
192              CHAPTER 4  Input/Output: Designing the User Interface

j. When the user clicks on a program's JButton, an                   will automatically

  be generated.

k. Two kinds of objects that generate ActionEvents are                            and

              .

l. JButtons, JTextFields, and JLabels are all subclasses of                    .

m. The JFrame class is a subclass of          .

n. If java class intends to handle ActionEvents, it must implement the

  interface.

o. When an applet is started, its             method is called automatically.

EXERCISE 4.2 Explain the difference between the following pairs of concepts:

a. Class and interface.
b. Extending a class and instantiating an object.
c. Defining a method and implementing a method.
d. A protected method and a public method.
e. A protected method and a private method.
f. An ActionEvent and an ActionListener() method.

EXERCISE 4.3 Draw a hierarchy chart to represent the following situation.
There are lots of languages in the world. English, French, Chinese, and Korean
are examples of natural languages. Java, C, and C++ are examples of formal lan-
guages. French and Italian are considered romance languages, while Greek and
Latin are considered classical languages.

EXERCISE 4.4 Arrange the Java library classes mentioned in the Chapter Sum-
mary into their proper hierarchy, using the Object class as the root of the hierar-
chy.

EXERCISE 4.5 Look up the documentation for the JButton class on Sun's Web
site:

                                                                                  

h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/a p i/
                                                                                  

List the signatures of all its constructors.

EXERCISE 4.6 Suppose we want to set the text in our program's JTextField.
What method should we use and where is this method defined? (Hint: Look up
the documentation for JTextField. If no appropriate method is defined there,
see if it is inherited from a superclass.)

EXERCISE 4.7 Does a JApplet have an init() method? Explain.

EXERCISE 4.8 Does a JApplet have an add() method? Explain.

EXERCISE 4.9 Does a JButton have an init() method? Explain.

EXERCISE 4.10 Does a JButton have an add() method? Explain.

EXERCISE 4.11 Suppose you type the URL for a "Hello, World!" applet into
your browser. Describe what happens--that is, describe the processing that takes
place in order for the applet to display "Hello, World!" in your browser.

EXERCISE 4.12 Suppose you have a program containing a JButton named
button. Describe what happens, in terms of Java's event handling model, when
the user clicks the button.

EXERCISE 4.13 Java's Object class contains a public method, toString(),
which returns a string that represents this object. Because every class is a subclass
of Object, the toString() method can be used by any object. Show how you
would invoke this method for a JButton object named button.
CHAPTER 4  Exercises                                                              193

EXERCISE 4.14 The JFrame that follows contains a semantic error in its
SomeFrame() constructor. The error will cause the actionPerformed()
method never to display "Clicked" even though the user clicks the button in the
JFrame. Why? (Hint: Think scope!)

                                                                                   

public c l a s s SomeFrame extends JFrame
                                           implements ActionListener

{

     // D e c l a r e i n s t a n c e v a r i a b l e s

   private JButton button ;

   public JFrame ( )                                                      me" ) ;
   {

          // I n s t a n t i a t e t h e i n s t a n c e v a r i a b l e

          J B u t t o n button = new J B u t t o n ( " C l i c k
          add ( button ) ;
          button . addActionListener ( this ) ;
   } // i n i t ( )

   public void actionPerformed ( ActionEvent e )

   {

      i f ( e . g e t S o u r c e ( ) == button )

      System . out . println ( "Clicked" ) ;

   } // a c t i o n P e r f o r m e d ( )

} // SomeFrame

                                                                                   

EXERCISE 4.15 What would be output by the following program?

                                                                                   

public c l a s s SomeFrame2 extends JFrame
{

   // D e c l a r e i n s t a n c e v a r i a b l e s

   private JButton button ;
   private JTextField field ;

   public SomeFrame ( )
   {

   // I n s t a n t i a t e i n s t a n c e v a r i a b l e s

      button = new J B u t t o n ( " C l i c k me" ) ;
      add ( button ) ;
       f i e l d = new J T e x t F i e l d ( " F i e l d me" ) ;
      add ( f i e l d ) ;
      System . out . println ( f i e l d . getText ( ) + button . getText ( ) ) ;
   } // i n i t ( )

   public s t a t i c void main ( S t r i n g [ ] args ) {
        SomeFrame2 frame = new SomeFrame2 ( ) ;
        frame . setSize (400 ,400);
        frame . setVisible ( true ) ;

   }

} // SomeFrame2

}

                                                                                   

EXERCISE 4.16 Design and implement a GUI that has a JButton, a
JTextField, and a JLabel and then uses the toString() method to display
each object's string representation.
194  CHAPTER 4  Input/Output: Designing the User Interface

EXERCISE 4.17 The JButton class inherits a setText(String s) from its
AbstractButton() superclass. Using that method, design and implement a
GUI that has a single button labeled initially, "The Doctor is out." Each time the
button is clicked, it should toggle its label to, "The Doctor is in" and vice versa.

EXERCISE 4.18 Design and implement a GUI that contains two JButtons, ini-
tially labeled, "Me first!" and "Me next!" Each time the user clicks either button,
the labels on both buttons should be exchanged. (Hint: You don't need an if-else
statement for this problem.)

EXERCISE 4.19 Modify the GUI in the previous exercise so that it contains three
JButtons, initially labeled "First," "Second," and "Third." Each time the user
clicks one of the buttons, the labels on the buttons should be rotated. Second
should get first's label, third should get second's, and first should get third's label.

EXERCISE 4.20 Design and implement a GUI that contains a JTextField and
two JButtons, initially labeled "Left" and "Right." Each time the user clicks a
button, display its label in the JTextField. A JButton()'s label can be gotten
with the getText() method.

EXERCISE 4.21 You can change the size of a JFrame by using the setSize(int
h, int v) method, where h and v give its horizontal and vertical dimensions
pixels. Write a GUI application that contains two JButtons, labeled "Big" and
"Small." Whenever the user clicks on small, set the JFrame's dimensions to 200
 100, and whenever the user clicks on big, set the dimensions to 300  200.

EXERCISE 4.22 Rewrite your solution to the previous exercise so that it uses a
single button whose label is toggled appropriately each time it is clicked. Obvi-
ously, when the JButton is labeled "Big," clicking it should give the JFrame its
big dimensions.

EXERCISE 4.23 Challenge: Design and write a Java GUI application that allows
the user to change the JFrame's background color to one of three choices, indi-
cated by buttons. Like all other Java Components, JFrame's have an associated
background color, which can be set by the following commands:

                                                            

setBackground ( Color . red ) ;

setBackground ( Color . yellow ) ;                          


The setBackground() method is defined in the Component class, and 13
primary colors--black, blue, cyan, darkGray, gray, green, lightGray,
magenta, orange, pink, red, white, yellow--are defined in the java.awt.Color
class.

ADDITIONAL EXERCISES

EXERCISE 4.24 Given the classes with the following headers

                                                            

public c l a s s Animal . . .

public c l a s s DomesticAnimal extends Animal . . .

public c l a s s FarmAnimal extends DomesticAnimal . . .

public class HousePet extends DomesticAnimal . . .

public c l a s s Cow extends FarmAnimal . . .

public c l a s s Goat extends FarmAnimal . . .

public c l a s s DairyCow extends Cow . . .
                                                            

draw a UML class diagram representing the hierarchy created by these
declarations.
CHAPTER 4  Exercises                    195

EXERCISE 4.25 Given the preceding hierarchy of classes, which of the following
are legal assignment statements?

                                         

DairyCow dc = new FarmAnimal ( ) ;

FarmAnimal f a = new Goat ( ) ;

Cow c1 = new DomesticAnimal ( ) ;

Cow c2 = new DairyCow ( ) ;

DomesticAnimal dom = new HousePet ( ) ;
                                         
196  CHAPTER 4  Input/Output: Designing the User Interface
Chapter 5

Java Data and Operators

OBJECTIVES

After studying this chapter, you will
 Understand the role that data play in effective program design.
 Be able to use all of Java's primitive types and their operators.
 Appreciate the importance of information hiding.
 Be able to use class constants and class methods.
 Know how to use Java's Math and NumberFormat classes.
 Be able to perform various kinds of data conversions.

OUTLINE

5.1 Introduction
5.2 Boolean Data and Operators

         Special Topic: Are We Computers?
5.3 Numeric Data and Operators
5.4 From the Java Library: java.lang.Math
5.5 Numeric Processing Examples
5.6 From the Java Library: java.text.NumberFormat
5.7 Character Data and Operators
5.8 Example: Character Conversions
5.9 Problem Solving = Representation + Action

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              197
                                                 198  CHAPTER 5  Java Data and Operators
Figure 5.1: Can the chess board be
tiled with dominoes?

5.1 Introduction

This chapter has two primary goals. One is to elaborate on Java's prim-
itive data types, which were first introduced in Chapter 1. We will cover
boolean, integer, character, and real number data types, including the var-
ious operations that you can perform on these types. We will provide ex-
amples, including several modifications of the OneRowNim class, to show
typical uses of the various data types.

   Our second goal is to illustrate the idea that programming is a matter of
choosing an appropriate way to represent a problem as well as choosing
an appropriate sequence of actions to solve the problem. Programming
is a form of problem solving that can be viewed as a two-part process:
representation and action.

   Representation means finding a way to look at the problem. This might
involve seeing the problem as closely related to a known problem or see-
ing that parts of the problem can be broken up into smaller problems
that you already know how to solve. In terms of programming prob-
lems, representation often means choosing the right kinds of objects and
structures.

   Action is the process of taking well-defined steps to solve a problem.
Given a particular way of representing the problem, what steps must we
take to arrive at its solution?

   Choosing an appropriate representation is often the key to solving a
problem. For example, consider this problem: Can a chess board, with
its top-left and bottom-right squares removed, be completely tiled by
dominoes that cover two squares at a time?

   One way to solve this problem might be to represent the chess board
and dominoes as shown in Figure 5.1. If we represent the board in this
way, then the actions needed to arrive at a solution involve searching for
a tiling that completely covers the board. In other words, we can try one
way of placing the dominoes on the board. If that doesn't work, we try an-
other way. And so on. This process will be very time consuming, because
there are millions of different ways of trying to tile the board.

   An alternative way to represent this problem comes from seeing that
the top-left and bottom-right squares of the board are both white. If you
remove them, you'll have a board with 62 squares, 32 black and 30 white.
Because each domino must cover one white and one black square, it is
SECTION 5.2  Boolean Data and Operators                       199

impossible to tile a board with an unequal number of black and white
squares.

   Thus, by representing the problem as the total number of black and
white squares, the actions required to solve it involve a very simple rea-
soning process. This representation makes it almost trivial to find the so-
lution. On the other hand, the brute force representation presented first--
trying all possible combinations--made it almost impossible to solve the
problem.

5.2 Boolean Data and Operators

As we learned in Chapter 1, the boolean type is one of Java's primitive        George Boole
types. For this type, there are only two possible values, true and false.      Conditional statement
The boolean type is derived from the work of British mathematician
George Boole, who in the 1850s, developed an algebra to process logical
expressions such as p and q. Such boolean expressions produce a value that is
either true or false. Every modern programming language provides some
means of representing boolean expressions.

   The boolean type has several important uses. As we saw in Chap-
ter 1, expressions of the form num == 7 and 5 < 7 have boolean val-
ues. Similarly, as we saw in Chapter 3, the boolean type is also used to
represent the condition in the if statement:

                 if (boolean expression)
                       statement;

For this reason, boolean expressions are also called conditions. Along these   Boolean flag
same lines, a boolean variable can be used as a flag or a signal to "remem-
ber" whether or not a certain condition holds. For example, in the follow-
ing code fragment, we use isDone to mark when a particular process is
completed:

                                                                               

boolean isDone = false ; // I n i t i a l i z e t h e f l a g

...              // Do some p r o c e s s i n g t a s k

isDone = true ;  // S e t f l a g when t h e t a s k done

...              // Do some o t h e r s t u f f

if ( isDone )    // Check i f f i n i s h e d t h e t a s k

...              // I f so , do s o m e t h i n g

else

  ...            // Or , do s o m e t h i n g e l s e

                                                                         

5.2.1 Boolean (or Logical) Operations                                          Data and operations

Like all the other simple data types, the boolean type consists of certain
data--the values true and false--and certain actions or operations that
can be performed on those data. For the boolean type there are four basic
operations: AND (signified by &&), OR (signified by ||), EXCLUSIVE-OR
(signified by ), and NOT (signified by !). These are defined in the truth
table shown in Table 5.1. A truth tables defines boolean operators by giving
their values in all possible situations. The first two columns of the table
give possible boolean values for two operands, o1 and o2. An operand is
a value used in an operation. Note that each row gives a different value
                 200                               CHAPTER 5  Java Data and Operators

                 assignment to the two operands, so that all possible assignments are repre-
                 sented. The remaining columns give the values that result for the various
                 operators given the assignment of values to o1 and o2.

                      TABLE 5.1 Truth-table definitions of the boolean operators:
                      AND (&&), OR (||), EXCLUSIVE-OR (), and NOT (!)

                      o1     o2     o1 && o2 o1 || o2 o1  o2 !o1

                      true   true   true           true   false  false
                      true   false  false          true   true   false
                      false  true   false          true   true   true
                      false  false  false          false  false  true

Binary operator     To see how to read this table, let's look at the AND operation, which is
Unary operator   defined in column 3. The AND operator is a binary operator--that is, it
                 requires two operands, o1 and o2. If both o1 and o2 are true, then (o1 &&
                 o2) is true (row1). If either o1 or o2 or both o1 and o2 are false, then the
                 expression (o1 && o2) is false (rows 2 and 3). The only case in which (o1
                 && o2) is true is when both o1 and o2 are true (row 4).

                    The boolean OR operation (column 4 of Table 5.1) is also a binary oper-
                 ation. If both o1 and o2 are false, then (o1 || o2) is false (row 4). If either o1
                 or o2 or both o1 and o2 are true, then the expression (o1 || o2) is true (rows
                 1-3). Thus, the only case in which (o1 || o2) is false is when both o1 and o2
                 are false.

                    The boolean EXCLUSIVE-OR operation (column 5 of Table 5.1) is a bi-
                 nary operation, which differs from the OR operator in that it is true when
                 either o1 or o2 is true (rows 2 and 3), but it is false when both o1 and o2 are
                 true (row 1).

                    The NOT operation (the last column of Table 5.1) is a unary operator--
                 it takes only one operand--and it simply reverses the truth value of its
                 operand. Thus, if o1 is true, !o1 is false, and vice versa.

                 5.2.2 Precedence and Associativity

                 In order to evaluate complex boolean expressions, it is necessary to un-
                 derstand the order in which boolean operations are carried out by the
                 computer. For example, what is the value of the following expression?

                                                                                                     

                 t r u e | | t r u e && f a l s e
                                                                                                     

                 The value of this expression depends on whether we evaluate the || first
                 or the && first. If we evaluate the || first, the expression's value will be
                 false; if we evaluate the && first, the expression's value will be true. In
                 the following example, we use parentheses to force one operation to be
                 done before the other:

                                                                                                     

                 EXPRESSION                        EVALUATION

                 ----------                        ----------

                 ( t r u e | | t r u e ) && f a l s e ==> t r u e && f a l s e ==> f a l s e

                 t r u e | | ( t r u e && f a l s e ) ==> t r u e | | f a l s e ==> t r u e          
                 
SECTION 5.2  Boolean Data and Operators                             201

As these evaluations show, we can use parentheses to force one operator       Parentheses supersede
or the other to be evaluated first. However, in Java, the && operator has
higher precedence than the || operator. Therefore, the second alternative
corresponds to the default interpretation that Java would apply to the ex-
pression that has no parentheses. In other words, given the expression
true || true && f alse, the AND operation would be evaluated before the
OR operation even though the OR operator occurs first (i.e., to the left) in
the unparenthesized expression.

  TABLE 5.2 Precedence order of the boolean operators

  Precedence Order     Operator                 Operation

              1        ()                       Parentheses

              2        !                        NOT

              3                                 EXCLUSIVE-OR

              4        &&                       AND

              5        ||                       OR

   As this example illustrates, the boolean operators have a built-in prece-
dence order which is used to determine how boolean expressions are to be
evaluated (Table 5.2). A simple method for evaluating an expression is to
parenthesize the expression and then evaluate it. For example, to evaluate
the complex expression

                                                                              

t r u e | | ! f a l s e ^ f a l s e && t r u e
                                                                              

we would first parenthesize it according to the precedence rules set out in
Table 5.2, which gives the following expression:

                                                                              

t r u e | | ( ( ( ! f a l s e ) ^ f a l s e ) && t r u e )
                                                                              

We can then evaluate this fully parenthesized expression, step by step,
starting at the innermost parentheses:

                                                                              

Step 1 . t r u e | | ( ( t r u e ^ f a l s e ) && t r u e )

Step 2 . t r u e | | ( t r u e && t r u e )

Step 3. true | | true

Step 4. true
                                                                              

JAVA PROGRAMMING TIP Parentheses. Parentheses can (and
should) be used to clarify any expression that appears ambiguous or
to override Java's default precedence rules.

   In addition to operator precedence, it is necessary to know about an
operator's associativity in order to evaluate boolean expressions of
the form (op1 || op2 || op3). Should this expression be evaluated as
202                             CHAPTER 5  Java Data and Operators

((op1 || op2) || op3) or as (op1 || (op2 || op3))? The binary boolean opera-
tors all associate from left to right. Thus, the expressions

                                                                                  

true ^ true ^ true // Same as : ( t r u e ^ t r u e ) ^ t r u e

t r u e && t r u e && t r u e // S a m e a s : ( t r u e && t r u e ) && t r u e

true | | true | | true // Same as : ( t r u e | | t r u e ) | | t r u e           


would be evaluated as follows:

                                                                                  

EXPRESSION                                EVALUATION

----------------                          -----------------

( t r u e ^ t r u e ) ^ t r u e ==> f a l s e ^ t r u e ==> t r u e

( t r u e && t r u e ) && t r u e ==> t r u e && t r u e ==> t r u e

( t r u e | | t r u e ) | | t r u e ==> t r u e | | t r u e ==> t r u e           


5.2.3 Short-Circuit Evaluation

Another important feature of the boolean operators is that they utilize a
form of evaluation known as short-circuit evaluation. In short-circuit eval-
uation, a boolean expression is evaluated from left to right, and the evalu-
ation is discontinued as soon as the expression's value can be determined,
regardless of whether it contains additional operators and operands. For
example, in the expression

                                                                                  

     expr1 && expr2                                                               

if expr1 is false, then the AND expression must be false, so expr2 need
not evaluated. Similarly, in the expression

                                                                                  

     expr1 | | expr2                                                              

if expr1 is true, then the OR expression must be true, so expr2 need not
evaluated.

   In addition to being a more efficient form of evaluating boolean ex-
pressions, short-circuit evaluation has some practical uses. For example,
we can use short-circuit evaluation to guard against null pointer excep-
tions. Recall from Chapter 2 that a null pointer exception results when
you try to use an uninstantiated reference variable--that is, a reference
variable that has not been assigned an object. For example, if we declare a
OneRowNim variable without instantiating it and then try to use it, a null
pointer exception will result:

                                                                                  

OneRowNim game ;      // U n i n s t a n t i a t e d R e f e r e n c e

i f ( ! game . gameOver ( ) ) // N u l l p o i n t e r e x c e p t i o n

     game . t a k e S t i c k s (num ) ;                                          
SECTION 5.2  Boolean Data and Operators                 203

In this code, a null pointer exception results when we use game in the
method call game.gameOver(). We can use short-circuit evaluation to
prevent the exception from occurring:

                                                                              

i f ( ( game ! = n u l l ) && ( ! game . gameOver ( ) )

  game . t a k e S t i c k s (num ) ;                                         

In this case, because game != null is false, neither method call involv-
ing game is made, thus avoiding the exception.

Special Topic: Are We Computers?

George Boole published his seminal work, An Investigation of the Laws
of Thought, in 1854. His achievement was in developing an algebra for
logic--that is, a purely abstract and symbolic system for representing the
laws of logic. Boole's was not the first attempt to explore the relationship
between the human mind and an abstract system of computation. Back in
1655, Thomas Hobbes had already claimed that all thought was computa-
tion.

   It is estimated that the human brain contains (1012 = 10,000,000,000,000)
neurons, and each neuron contains something like 10,000 dendrites, the
fibers that connect one neuron to another. Together, the neurons and den-
drites make up a web of enormous complexity. Since the 1840s it has been
known that the brain is primarily electrical, and by the 1940s scientists
had developed a pretty good model of the electrical interactions among
neurons. According to this model, neurons emit short bursts of electricity
along their axons, which function like output wires. The bursts leap over
the gap separating axons and dendrites, which function like the neurons'
input wires.

   In 1943, just before the first digital computers were developed, War-
ren McCulloch, a neurophysiologist, and Walter Pitts, a mathematician,
published a paper titled, "A Logical Calculus of the Ideas Imminent in
Nervous Activity." In this paper, they showed that all of the boolean
operators--AND, OR, NOT, and EXCLUSIVE-OR--could be represented
by the behavior of small sets of neurons. For example, they showed that
three neurons could be connected together in such a way that the third
neuron fired if and only if both of the other two neurons fired. This is
exactly analogous to the definition of the boolean AND operator.

   A few years later, when the first computers were built, many scientists
and philosophers were struck by the similarity between the logic elements
that made up the computer's circuits and the neuronal models that Mc-
Culloch and Pitts had developed.

   The area of neural networks is a branch of artificial intelligence (one
of the applied areas of computer science) and is based on this insight by
McCulloch and Pitts. Researchers in this exciting and rapidly advancing
field develop neural network models of various kinds of human thinking
and perception.
204                                    CHAPTER 5  Java Data and Operators

5.2.4  Using Booleans in OneRowNim

Now that we have introduced the boolean data type, let's use it to im-
prove the OneRowNim class, the latest version of which, from Chapter 3,
is given in Figure 3.16. Previously we used an int variable, player,
to represent who's turn it is. For a two-person game, such as One Row
Nim, a boolean variable is well suited for this purpose, because it can
toggle between true and false. For example, let's declare a variable,
onePlaysNext, and initialize it to true, to represent the fact that player
one will play first:

                                                                              

private boolean onePlaysNext = true ;
                                                                              

When onePlaysNext is true, it will be player one's turn. When it is
false, it will be player two's turn. Note that we are deliberately remaining
uncommitted as to whether one or the other player is the computer.

   Given this new variable, it is necessary to redefine the methods that
had previously used the player variable. The first method that needs
revision is the constructor:

                                                                              

public OneRowNim( i n t s t i c k s , i n t s t a r t e r )

{ nSticks = sticks ;

       onePlaysNext = ( s t a r t e r == 1 ) ;

} // OneRowNim ( ) c o n s t r u c t o r 3

                                                                              

In the constructor, the starter parameter is used with a value of 1 or 2 to
set which player goes first. Note how we use an assignment statement to
set onePlaysNext to true if starter equals 1; otherwise it is set to false.
The assignment statement first evaluates the expression on its right hand
side (starter == 1). Because this is a boolean expression, it will have
a value of true or false, which will be assigned to onePlaysNext. Thus,
the assignment statement is equivalent to the following if/else statement:

                                                                              

i f ( p l a y e r == 1 )

       onePlaysNext = true ;

else

       onePlaysNext = false ;

,                                                                             


The remaining changes are shown in Figure 5.2. There are only two in-
stance methods that need revision to accommodate the use of boolean
SECTION 5.3  Numeric Data and Operators                                 205

variables. The takeSticks() method contains two revisions. The first
uses the boolean OR operator to test whether a move is valid:

                                                                              

     public boolean t a k e S t i c k s ( i n t num)

     { i f (num < 1 | | num > 3 | | num > n S t i c k s )

             return false ;                           // E r r o r

       else                                           // V a l i d move

       { n S t i c k s = n S t i c k s - num ;

             onePlaysNext = ! onePlaysNext ;

             return true ;

       } // e l s e

     } // t a k e S t i c k s ( )

                                                                              

It also uses the boolean NOT operator to toggle the value of
onePlaysNext, to switch to the other player's turn:

                                                                              

     onePlaysNext = ! onePlaysNext ;                                          


Finally, the getPlayer() method now uses a if/else statement to return
either 1 or 2 depending on who's turn it is:

                                                                              

     public int getPlayer ()

     { if ( onePlaysNext )

             return 1;

       else return 2;

     } // g e t P l a y e r ( )

                                                                              

5.3 Numeric Data and Operators

Java has two kinds of numeric data: integers, which have no fractional
part, and real numbers or floating-point numbers, which contain a frac-
tional component. Java recognizes four different kinds of integers: byte,
short, int, and long, which are distinguished by the number of bits
used to represent them. A binary digit, or bit, is a 0 or a 1. (Recall that
computers read instructions as series of 0s and 1s.) Java has two different
kinds of real numbers, float and double, which are also distinguished
by the number of bits used to represent them. See Table 5.3.

TABLE 5.3 Java's numeric types

Type Bits                          Range of Values

byte   8                                    -128 to + 127
                                          -32768 to 32767
short 16                           -2147483648 to 2147483647
                                           -263 to 263 - 1
int    32

long   64

float  32                   -3.40292347E + 38 to + 3.40292347E + 38
             -1.79769313486231570E + 308 to + 1.79769313486231570E + 308
double 64
206                                CHAPTER 5  Java Data and Operators
                                                                                         

              OneRowNim
public class  int nSticks = 7;
              boolean onePlaysNext = true ;
{    private

     private

     public OneRowNim ( )

     {

     } // OneRowNim ( ) c o n s t r u c t o r 1

     public OneRowNim( i n t s t i c k s )

     { nSticks = sticks ;

     } // OneRowNim ( ) c o n s t r u c t o r 2

     public OneRowNim( i n t s t i c k s , i n t s t a r t e r )

     { nSticks = sticks ;

        onePlaysNext = ( s t a r t e r == 1 ) ;

     } // OneRowNim ( ) c o n s t r u c t o r 3

     public boolean t a k e S t i c k s ( i n t num)

     { i f (num < 1 | | num > 3 | | num > n S t i c k s )

              return false ;                          // E r r o r

        else                                          // V a l i d move

        { n S t i c k s = n S t i c k s - num ;

              onePlaysNext = ! onePlaysNext ;

              return true ;

        } // e l s e

     } // t a k e S t i c k s ( )

     public int getSticks ()

     { return nSticks ;

     } {\ color {cyan} // g e t S t i c k s ( ) }

     public int getPlayer ()

     { if ( onePlaysNext ) return 1;

        else return 2;

     } // g e t P l a y e r ( )

     public boolean gameOver ( )

     { r e t u r n ( n S t i c k s <= 0 ) ;

     } // gameOver ( )

     public int getWinner ( )

     { if ( nSticks < 1) return getPlayer ( ) ;

        else return 0; // game i s not over

     } // g e t W i n n e r ( )

     public void report ( )

     { System . out . p r i n t l n ( "Number o f s t i c k s l e f t : "

                                   + getSticks ());

        System . out . p r i n t l n ( "Next turn by player "

                                   + getPlayer ( ) ) ;

     } // r e p o r t ( )

} // OneRowNim c l a s s

                                                                           

Figure 5.2: The revised OneRowNim uses a boolean variable to keep track
of who's turn it is.

   The more bits a data type has, the more values it can represent. One bit
can represent two possible values, 1 and 0, which can be used to stand for
true and false, respectively. Two bits can represent four possible values:
00, 01, 10, and 11; three bits can represent eight possible values: 000, 001,
SECTION 5.3  Numeric Data and Operators  207

010, 100, 101, 110, 011, 111. And, in general, an n-bit quantity can represent  Integer data types
2n different values.

   As illustrated in Table 5.3, the various integer types represent posi-

tive or negative whole numbers. Perhaps the most commonly used in-

teger type in Java is the int type, which is represented in 32 bits. This
means that Java can represent 232 different int values, which range from
-2,147,483,648 to 2,147,483,647, that is, from -231 to (231 - 1). Similarly,
an 8-bit integer, a byte, can represent 28 or 256 different values, ranging
from -128 to +127. A 16-bit integer, a short, can represent 216 different

values, which range from -32768 to 32767. And a 64-bit integer, a long,
can represent whole number values ranging from -263 to 263 - 1.

   For floating-point numbers, a 32-bit float type can represent 232 dif-
ferent real numbers and a 64-bit double value can represent 264 different

real numbers.

JAVA EFFECTIVE DESIGN Platform Independence. In Java, a data
type's size (number of bits) is part of its definition and, therefore,
remains consistent across all platforms. In C and C++, the size of a
data type is dependent on the compiler.

   It is worth noting that just as model airplanes are representations of       Data types are abstractions
real airplanes, Java's numeric types are representations or models of the       Representation trade-offs
numbers we deal with in mathematics. In designing Java's data types,            Round-off error
various trade-offs have been made in order to come up with practical
implementations.

   One trade-off is that the set of integers is infinite, but Java's int type
can only represent a finite number of values. Similarly, Java cannot
represent the infinite number of values that occur between, say, 1.111 and
1.112. So, certain real numbers cannot be represented at all. For exam-
ple, because Java uses binary numbers to represent its numeric types, one
number that cannot be represented exactly is 110 . This inability to exactly
represent a value is known as round-off error. Being unable to represent
certain values can cause problems in a program. For example, it might be
difficult to represent dollars and cents accurately in a program.

   Another source of problems in dealing with numeric data is due to lim-
its in their precision. For example, a decimal number represented as a
double value can have a maximum of 17 significant digits, and a float
can have a maximum 8. A significant digit is one that contributes to
the number's value. If you tried to store values such as 12345.6789 or
0.123456789 in a float variable, they would be rounded off to 12345.679
and 0.12345679, respectively, causing a possible error.

JAVA DEBUGGING TIP Significant Digits. In using numeric data,
be sure the data type you choose has enough precision to represent the
values your program needs.

SELF-STUDY EXERCISES
                                   208                         CHAPTER 5  Java Data and Operators

Numeric operators                  5.3.1 Numeric Operations

Integer division gives an integer  The operations that can be done on numeric data include the standard
result                             algebraic operations: addition (+), subtraction (-), multiplication (*), division
Modular arithmetic                 (/), as well as the modulus (%) operator. Note that in Java, the multiplica-
                                   tion symbol is * and not the . The arithmetic operators are binary op-
                                   erators, meaning that they each take two operands. Table 5.4 compares

                                        TABLE 5.4 The standard arithmetic operators in Java

                                        Operation       Operator Java Algebra

                                        Addition        +      x+2 x+2

                                        Subtraction     -      m-2 m-2

                                        Multiplication  *      m * 2 2m or 2  m

                                        Division        /      x/y  xy  or  x
                                                                             y

                                        Modulus         %      x%y x modulo y (for integers x and y)

                                   expressions involving the Java operators with their standard algebraic
                                   counterparts.

                                      Although these operations should seem familiar, there are some im-
                                   portant differences between their use in algebra and their use in a Java
                                   program. Consider the following list of expressions:

                                                                                                                      

                                   3/2            ==> value 1       An i n t e g e r r e s u l t

                                   3 . 0 / 2 . 0 ==> value 1 . 5 A f l o a t i n g -p o i n t r e s u l t

                                   3 / 2 . 0 ==> value 1 . 5 A f l o a t i n g -p o i n t r e s u l t

                                   3 . 0 / 2 ==> value 1 . 5 A f l o a t i n g -p o i n t r e s u l t                 
                                   

                                   In each of these cases we are dividing the quantity 3 by the quantity 2.
                                   However, different results are obtained depending on the type of the
                                   operands involved. When both operands are integers, as in (3/2), the
                                   result must also be an integer. Hence, (3/2) has the value 1, an integer.
                                   Because integers cannot have a fractional part, the 0.5 is simply discarded.
                                   Integer division (/) always gives an integer result. Thus, the value of (6/2)
                                   is 3 and the value of (7/2) is also 3. Because 3.5 is not an integer, the result
                                   of dividing 7 by 2 cannot be 3.5.

                                   JAVA DEBUGGING TIP Integer Division. A common source of
                                   error among beginning programmers is forgetting that integer
                                   division always gives an integer result.

                                   On the other hand, when either operand is a real number, as in the last
                                   three cases, the result is a real number. Thus, while the same symbol (/)
                                   is used for dividing integers and real numbers, there are really two dif-
                                   ferent operations involved here: integer division and floating-point division.
                                   Using the same symbol (/) for different operations (integer division and
                                   real division) is known as operator overloading. It is similar to method
                                   overloading, which was discussed in Chapter 3.

                                      What if you want to keep the remainder of an integer division? Java
                                   provides the modulus operator (%), which takes two operands. The ex-
                                   pression (7 % 5) gives the remainder after dividing 7 by 5--2 in this case.
SECTION 5.3  Numeric Data and Operators             209

In general, the expression (m % n) (read m mod n) gives the remainder
after m is divided by n. Here are several examples:

                                                                               

7 % 5 ==> 7 mod 5 e q u a l s 2

5 % 7 ==> 5 mod 7 e q u a l s 5

-7 % 5 ==> -7 mod 5 e q u a l s -2

7 % -5 ==> 7 mod -5 e q u a l s 2
                                                                               

The best way to interpret these examples is to perform long division on
the operands keeping both the quotient and the remainder. For example,
when you do long division on -7  5, you get a quotient of -1 and a re-
mainder of -2. The quotient is the value of -7/5 and the remainder is the
value of -7%5. When you do long division on 7  -5, you get a quotient
of -1 and a remainder of 2. The quotient is the value of 7/ - 5 and the
remainder is the value of 7% - 5.

   We will encounter many practical uses for the modulus operator in our
programs. For a simple example, we use it when we want to determine
whether an integer is even or odd. Numbers that leave a 0 remainder
when divided by 2 are even:

                                                                               

i f (N % 2 == 0 )

  System . out . p r i n t l n (N + " i s even" ) ;                            

More generally, we could use the mod operator to define divisibility by 3,
4, 10, or by any number.

Numeric Promotion Rules                                                        Expressions have a type

Java is considered a strongly typed language because all expressions in
Java, such as (3/2), have a type associated with them. In cases where
one arithmetic operand is an integer and one is a floating-point num-
ber, Java promotes the integer into a floating-point value and performs a
floating-point operation.

   Promotion is a matter of converting one type to another type. For ex-
ample, in the expression (5 + 4.0), the value 5 must be promoted to 5.0
before floating-point addition can be performed on (5.0 + 4.0). Generally
speaking, automatic promotions such as these are allowed in Java when-
ever it is possible to perform the promotion without loss of information. Be-
cause an integer (5) does not have a fractional component, no information
will be lost in promoting it to a real number (5.0). On the other hand, you
cannot automatically convert a real number (5.4) to an integer (5) because
that might lead to loss of information. This leads to the following rule:

JAVA LANGUAGE RULE Integer Promotion. In an operation that
contains an integer and a floating-point operand, the integer is
promoted to a floating-point value before the operation is performed.

This rule is actually an instance of a more general rule, for whenever an
expression involves operands of different types, some operands must be
                        210                        CHAPTER 5  Java Data and Operators

                        converted before the expression can be evaluated. Consider the following
                        example:

                                                                                                        

                        byte n = 125;

                        short m = 32000;

                        n  m;                                                                           
                        

Promotion is automatic  In this case, (n * m) involves two different integer types, byte and short.
                        Before evaluating this expression Java must first promote the byte to a
                        short and carry out the operation as the multiplication of two shorts.
                        Conversion of short to byte would not be possible because there's no
                        way to represent the value 32000 as a byte.

                           It is important to note that this conversion rule applies regardless of
                        the actual values of the operands. In applying the rule, Java looks at the
                        operand's type, not its value. So even if m were assigned a value that
                        could be represented as a byte (for example, 100), the promotion would
                        still go from smaller to larger type. This leads to following the general
                        rule:

                        JAVA LANGUAGE RULE Type Promotion. In general, when two
                        different types are involved in an operation, the smaller type--the one
                        with fewer bits--is converted to the larger type before the operation is
                        performed. To do otherwise would risk losing information.

                        Table 5.5 summarizes the actual promotion rules used by Java in evaluat-
                        ing expressions involving mixed operands. Note that the last rule implies
                        that integer expressions involving byte or short or int are performed
                        as int. This explains why integer literals--such as 56 or -108--are rep-
                        resented as int types in Java.

                             TABLE 5.5 Java promotion rules for mixed arithmetic operators.
                             If two rules apply, choose the one that occurs first in this table.

                             If either operand is  The other is promoted to

                             double                double
                             float                 float
                             long                  long
                             byte or short         int

                        5.3.2 Operator Precedence

                        The built-in precedence order for arithmetic operators is shown in Ta-
                        ble 5.6. Parenthesized expressions have highest precedence and are evalu-
                        ated first. Next come the multiplication, division, and modulus operators,
                        followed by addition and subtraction. When we have an unparenthesized
                        expression that involves both multiplication and addition, the multiplica-
                        tion would be done first, even if it occurs to the right of the plus sign. Op-
SECTION 5.3  Numeric Data and Operators                    211

  TABLE 5.6 Precedence order of the arithmetic operators

  Precedence
     Order Operator Operation

  1         ()           Parentheses

  2         /%           Multiplication, Division, Modulus

  3         +-           Addition, Subtraction

erators at the same level in the precedence hierarchy are evaluated from
left to right. For example, consider the following expression:

                                                                                 

9 + 6-3  6 / 2                                                                   


In this case, the first operation to be applied will be the multiplication (*),
followed by division (/), followed by addition (+), and then finally the
subtraction (-). We can use parentheses to clarify the order of evaluation.
A parenthesized expression is evaluated outward from the innermost set
of parentheses:

                                                                                 

Step 1. ( (9 + 6) - ((3  6) / 2 ) )

Step 2. ( (9 + 6) - (18 / 2 ) )

Step 3. ( (9 + 6) - 9 )

Step 4. ( 15 - 9 )

Step 5. 6
                                                                                 

Parentheses can (and should) always be used to clarify the order of oper-
ations in an expression. For example, addition will be performed before
multiplication in the following expression:

                                                                                 

(a + b)  c
                                                                                 

Another reason to use parentheses is that Java's precedence and promo-
tion rules will sometimes lead to expressions that look fine but contain
subtle errors. For example, consider the following expressions:

                                                                                 

System . out . println (5/3/2.0); // 0 . 5

System . out . println ( 5 / ( 3 / 2 . 0 ) ) ; // 3 . 3 3                        


The first gives a result of 0.5, but the use of parentheses in the second
gives a result of 3.33. If the second is the expected interpretation, then the
parentheses here helped avoid a subtle semantic error.

JAVA PROGRAMMING TIP Parenthesize! To avoid subtle bugs
caused by Java's precedence and promotion rules, use parentheses to
specify the order of evaluation in an expression.

SELF-STUDY EXERCISE
                                212                                    CHAPTER 5  Java Data and Operators

                                5.3.3  Increment and Decrement Operators

                                Java provides a number of unary operators that are used to increment or
                                decrement an integer variable. For example, the expression k++ uses the
                                increment operator ++ to increment the value of the integer variable k. The
                                expression k++ is equivalent to the following Java statements:

                                                                                                                 

                                int k;

                                k = k + 1 ; // Add 1 t o k and a s s i g n t h e r e s u l t b a c k t o k       
                                

Preincrement and postincrement  The unary ++ operator applies to a single integer operand, in this case to
Precedence order                the variable k. It increments k's value by 1 and assigns the result back to k.
Predecrement and postdecrement  It may be used either as a preincrement or a postincrement operator. In the
                                expression k++, the operator follows the operand, indicating that it is being
                                used as a postincrement operator. This means that the increment operation
                                is done after the operand's value is used.

                                   Contrast that with the expression ++k in which the ++ operator precedes
                                its operand. In this case, it is used as a preincrement operator, which means
                                that the increment operation is done before the operand's value is used.

                                   When used in isolation, there is no practical difference between k++
                                and ++k. Both are equivalent to k = k + 1. However, when used in con-
                                junction with other operators, there is a significant difference between
                                preincrement and postincrement. For example, in the following code
                                segment,

                                                                                                                 

                                  int j = 0, k = 0;  // I n i t i a l l y b o t h j and k a r e 0
                                  j = ++k ;
                                                     // F i n a l v a l u e s o f b o t h j and k a r e 1

                                                                                                                    

                                the variable k is incremented before its value is assigned to j. After execu-
                                tion of the assignment statement, j will equal 1 and k will equal 1. The
                                sequence is equivalent to

                                                                                                                 

                                  int j = 0, k = 0;  // I n i t i a l l y b o t h j and k a r e 0
                                  k = k + 1;
                                  j = k;             // F i n a l v a l u e s o f b o t h j and k a r e 1
                                
                                                                                                                    

                                However, in the following example,

                                                                                                                 

                                int i = 0 , k = 0; // I n i t i a l l y both i and k a r e 0

                                  i = k++;           // F i n a l v a l u e o f i i s 0 and k i s 1
                                
                                                                                                                       

                                the variable k is incremented after its value is assigned to i. After execution
                                of the assignment statement, i will have the value 0 and k will have the
                                value 1. The preceding sequence is equivalent to

                                                                                                                 

                                int i = 0 , k = 0; // I n i t i a l l y both i and k a r e 0

                                i = k;

                                  k = k + 1;         // F i n a l v a l u e o f i i s 0 and k i s 1
                                
                                                                                                                    

                                In addition to the increment operator, Java also supplies the decrement op-
SECTION 5.3  Numeric Data and Operators                      213

erator --, which can also be used in the predecrement and postdecrement
forms. The expression -- k will first decrement k's value by 1 and then
use k in any expression in which it is embedded. The expression k-- will
use the current value of k in the expression in which k is contained and
then it will decrement k's value by 1. Table 5.7 summarizes the increment
and decrement operators. The unary increment and decrement operators
have higher precedence than any of the binary arithmetic operators.

          TABLE 5.7 Java's increment and decrement operators

  Expression               Operation      Interpretation

          j =++k           Preincrement   k = k + 1; j = k;
          j =k++           Postincrement  j = k; k = k + 1;
          j =--k           Predecrement   k = k - 1; j = k;
          j =k--           Postdecrement  j = k; k = k - 1;

JAVA LANGUAGE RULE Pre- and Postincrement/Decrement. If
an expression like ++k or --k occurs in an expression, k is
incremented or decremented before its value is used in the rest of the
expression. If an expression like k++ or k-- occurs in an expression, k
is incremented or decremented after its value is used in the rest of the
expression.

JAVA PROGRAMMING TIP Increment and Decrement
Operators. Because of their subtle behavior, be careful in how you use
the unary increment and decrement operators. They are most
appropriate and useful for incrementing and decrementing loop
variables, as we'll see later.

SELF-STUDY EXERCISE

5.3.4 Assignment Operators

In addition to the simple assignment operator (=), Java supplies a num-

ber of shortcut assignment operators that allow you to combine an arith-

metic operation and an assignment in one operation. These operations

can be used with either integer or floating-point operands. For example,

the += operator allows you to combine addition and assignment into one

expression. The statement

                                                                           

k += 3 ;
                                                                           

is equivalent to the statement

                                                                           

k = k + 3;                                                                 

                    214                              CHAPTER 5  Java Data and Operators

                    Similarly, the statement

                                                                                                     

                        r += 3 . 5 + 2 . 0  9 . 3 ;
                                                                                                     

                    is equivalent to

                                                                                                     

                        r = r + (3.5 + 2.0  9 . 3 ) ; // i . e . , r = r + 2 2 . 1 ;                 
                    

                    As these examples illustrate, when using the += operator, the expression
                    on its right-hand side is first evaluated and then added to the current value
                    of the variable on its left-hand side.

                       Table 5.8 lists the other assignment operators that can be used in com-
                    bination with the arithmetic operators. For each of these operations, the
                    interpretation is the same: Evaluate the expression on the right-hand side

                    TABLE 5.8 Java's assignment operators

                    Operator Operation                            Example Interpretation

                    =    Simple assignment                        m = n;  m = n;

                    +=   Addition then assignment                 m + = 3; m = m + 3;

                    -=   Subtraction then assignment              m - = 3; m = m - 3;

                    =    Multiplication then assignment           m  = 3; m = m  3;

                    /=   Division then assignment                 m / = 3; m = m/3;

                    %=   Remainder then assignment                m % = 3; m = m%3;

                    of the operator and then perform the arithmetic operation (such as addi-
                    tion or multiplication) to the current value of the variable on the left of the
                    operator.

                    SELF-STUDY EXERCISES

                    5.3.5 Relational Operators

                    There are several relational operations that can be performed on integers:
                    <, >, <=, >=, ==, and ! =. These correspond to the algebraic operators
                    <, >, , , =, and =. Each of these operators takes two operands (integer
                    or real) and returns a boolean result. They are defined in Table 5.9.

                         TABLE 5.9 Relational operators

                         Operator       Operation                 Java Expression

                         <              Less than                 5 < 10
                         >              Greater than              10 > 5
                         <=             Less than or equal to     5 <= 10
                         >=             Greater than or equal to  10 >= 5
                         ==             Equal to                  5 == 5
                         !=             Not equal to              5 != 4

Equals vs. assigns     Note that several of these relational operators require two symbols in
                    Java. Thus, the familiar equals sign (=) is replaced in Java by ==. This is so
                    the equality operator can be distinguished from the assignment operator.
SECTION 5.3  Numeric Data and Operators                               215

Also, less than or equal to (<=), greater than or equal to (>=), and not
equal to (!=) require two symbols, instead of the familiar , , and = from
algebra. In each case, the two symbols should be consecutive. It is an error
in Java for a space to appear between the < and = in <=.

JAVA DEBUGGING TIP Equality and Assignment. A common
semantic error among beginning programmers is to use the
assignment operator (=) when the equality operator (==) is intended.

   Among the relational operators, the inequalities (<, >, <=, and >=)
have higher precedence than the equality operators (== and ! =). In an
expression that involves both kinds of operators, the inequalities would be
evaluated first. Otherwise, the expression is evaluated from left to right.

   Taken as a group the relational operators have lower precedence than
the arithmetic operators. Therefore, in evaluating an expression that in-
volves both arithmetic and relational operators, the arithmetic operations
are done first. Table 5.10 includes all of the numeric operators introduced
so far.

            TABLE 5.10 Numeric operator precedence including relations

  Precedence                        Operation
     Order Operator

  1           ()                    Parentheses

  2           ++ --                 Increment, decrement

  3           /%                    Multiplication, division, modulus

  4           +-                    Addition, subtraction

  5           < > <= >= Relational operators

  6           == ! =                Equality operators

To take an example, let us evaluate the following complex expression:

                                                                              

9 + 6 <= 25  4 + 2                                                            


To clarify the implicit operator precedence, we first parenthesize the
expression

                                                                              

( 9 + 6 ) <= ( ( 2 5  4 ) + 2 )
                                                                              

and then evaluate it step by step:

                                                                              

Step 1 . ( 9 + 6 ) <= ( ( 2 5  4 ) + 2 )

Step 2 . ( 9 + 6 ) <= ( 100 + 2 )

Step 3 . 15 <= 102

Step 4. true                                                                  


The following expression is an example of an ill-formed expression:

                                                                              

9 + 6 <= 25  4 == 2                                                           

                                   216                    CHAPTER 5  Java Data and Operators

                                   That the expression is ill formed becomes obvious if we parenthesize it
                                   and then attempt to evaluate it:

                                                                                                                       

                                   Step 1 . ( ( 9 + 6 ) <= ( 25  4 ) ) == 2

                                   Step 2 . ( 15 <= 100 ) == 2

                                   Step 3 . t r u e == 2  // S y n t a x e r r o r r e s u l t s h e r e

                                                                                                                       

Strong typing                      The problem here is that the expression true == 2 is an attempt to com-
                                   pare an int and a boolean value, which can't be done. As with any other
                                   binary operator, the == operator requires that both of its operands be of
                                   the same type. This is another example of Java's strong type checking.

                                   SELF-STUDY EXERCISES

                                   5.4 From the Java Library java.lang.Math

java.sun.com/j2se/1.5.0/docs/api/   THE java.lang.Math class provides many common mathematical
                                   functions that will prove useful in performing numerical computations.
                                   As an element of the java.lang package, it is included implicitly in all
                                   Java programs. Table 5.11 lists some of the most commonly used Math
                                   class methods.

                                   TABLE 5.11 A selection of Math class methods

                                   Method                 Description                           Examples

                                   int abs(int x)         Absolute value of x                   if x >= 0 abs(x) is x
                                   long abs(long x)                                             if x < 0 abs(x) is -x
                                   float abs(float x)

                                   int ceil(double x)     Rounds x to the smallest              ceil(8.3) is 9
                                                          integer not less than x               ceil(-8.3) is -8

                                   int floor(double x)    Rounds x to the largest               floor (8.9) is 8
                                                          integer not greater than x            floor(-8.9) is -9

                                   double log(double x)   Natural logarithm of x                log (2.718282) is 1.0

                                   double pow(double x, double y) x raised to the y power (xy)  pow(3, 4 ) is 81.0
                                                                                                pow(16.0, 0.5) is 4.0

                                   double random()        Generates a random                    random() is 0.5551

                                                          number in the interval [0,1) random() is 0.8712

                                   long round(double x)   Rounds x to an integer                round(26.51) is 27
                                                                                                round (26.499) is 26

                                   double sqrt(double x)  Square root of x                      sqrt(4.0) is 2.0

                                      All Math methods are static class methods and are, therefore, in-
                                   voked through the class name. For example, we would calculate 24

                                   as Math.pow(2,4), which evaluates to 16. Similarly, we compute the

                                   square root of 225.0 as Math.sqrt(225.0), which evaluates to 15.0.
SECTION 5.5  Numeric Processing Examples                                217

   Indeed, Java's Math class cannot be instantiated and cannot be sub-
classed. Its basic definition is

                                                                                  

public f i n a l c l a s s Math  // F i n a l , can ' t s u b c l a s s

{ p r i v a t e Math ( ) {}      // P r i v a t e , can ' t i n v o k e

   ...

   public s t a t i c native double sqrt ( double a )

        throws ArithmeticException ;

}

                                                                                  

By declaring the Math class public final, we indicate that it can be
accessed (public) but it cannot be extended or subclassed (final). By
declaring its default constructor to be private, we prevent this class from
being instantiated. The idea of a class that cannot be subclassed and can-
not be instantiated may seem a little strange at first. The justification for it
here is that it provides a convenient and efficient way to introduce helpful
math functions into the Java language.

   Defining the Math class in this way makes it easy to use its methods,
because you don't have to create an instance of it. It is also a very efficient
design because its methods are static elements of the java.lang pack-
age. This means they are loaded into memory at the beginning of your
program's execution, and they persist in memory throughout your pro-
gram's lifetime. Because Math class methods do not have to be loaded into
memory each time they are invoked, their execution time will improve
dramatically.

JAVA EFFECTIVE DESIGN Static Methods. A method should be
declared static if it is intended to be used whether or not there is an
instance of its class.

5.5 Numeric Processing Examples

In this section we consider several numeric programming examples. They
are carefully chosen to illustrate different issues and concepts associated
with processing numeric data.

5.5.1 Example: Rounding to Two Decimal Places

As an example of how to use Math class methods, let's consider the prob-          Algorithm design
lem of rounding numbers. When dealing with applications that involve
monetary values--dollars and cents--it is often necessary to round a cal-
culated result to two decimal places. For example, suppose a program
computes the value of a certificate of deposit (CD) to be 75.19999. Be-
fore we output this result, we would want to round it to two decimal
places--to 75.20. The following algorithm can be used to accomplish this:

                                                                                  

1 . Multiply the number by 100 , giving 7 5 1 9 . 9 9 9 9 .

2 . Add 0 . 5 t o t h e number g i v i n g 7 5 2 0 . 4 9 9 9 .

3 . Drop the f r a c t i o n a l part giving 7520

4 . Divide the r e s u l t by 100 , giving 75.20                                  

                                   218                         CHAPTER 5  Java Data and Operators

                                   Step 3 of this algorithm can be done using the Math.floor(R) method,
                                   which rounds its real argument, R, to the largest integer not less than R
                                   (from Table 5.11). If the number to be rounded is stored in the double
                                   variable R, then the following expression will round R to two decimal
                                   places:

                                                                                                                  

                                   R = Math . f l o o r (R  1 0 0 . 0 + 0 . 5 ) / 1 0 0 . 0 ;                     
                                   

                                   Alternatively, we could use the Math.round() method (Table 5.11). This
                                   method rounds a floating-point value to the nearest integer. For exam-
                                   ple, Math.round(65.3333) rounds to 65 and Math.round(65.6666)
                                   rounds to 66. The following expression uses it to round to two decimal
                                   places:

                                                                                                                  

                                   R = Math . round ( 1 0 0 . 0  R) / 1 0 0 . 0 ;                                 
                                   

                                   Note that it is important here to divide by 100.0 and not by 100. Other-
                                   wise, the division will give an integer result and we'll lose the two decimal
                                   places.

                                   JAVA DEBUGGING TIP Division. Using the correct type of literal in
                                   division operations is necessary to ensure that you get the correct type
                                   of result.

                                   5.5.2 Example: Converting Fahrenheit to Celsius

                                   To illustrate some of the issues that arise in using numeric data, let's de-
                                   sign a program that performs temperature conversions from Fahrenheit to
                                   Celsius and vice versa.

What objects do we need?           Problem Decomposition

Figure 5.3: Interacting ob-        This problem requires two classes, a Temperature class and a
jects: The user interacts with     TemperatureUI class. The Temperature class will perform the temper-
the user interface (Tempera-       ature conversions, and TemperatureUI will serve as the user interface
tureUI), which interacts with the  (Fig. 5.3).
Temperature object.
                                        1: Convert 100C to F   2: result=celsToFahr(100)
                                                3: result=212

                                        User  : TemperatureUI                                  : Temperature

What data do we need?              Class Design: Temperature

                                   The purpose of the Temperature class is to perform the temperature con-
                                   versions. To convert a Celsius temperature to Fahrenheit or vice versa, it is
                                   not necessary to store the temperature value. Rather, a conversion method
                                   could take the Celsius (or Fahrenheit) temperature as a parameter, per-
                                   form the conversion, and return the result. Therefore, the Temperature
SECTION 5.5  Numeric Processing Examples                                   219

class does not need any instance variables. Note that in this respect the

Temperature class resembles the Math class. Unlike OneRowNim, which

stores the game's state--the number of sticks remaining and whose turn

it is--the Math and Temperature classes are stateless.

Thus, following the design of the Math class, the Temperature class                What methods do we need?

will have two public static methods: one to convert from Fahrenheit to

Celsius and one to convert from Celsius to Fahrenheit. Recall that static

methods are associated with the class rather than with its instances. There-

fore, we needn't instantiate a Temperature object to use these methods.

Instead, we can invoke the methods through the class itself.

The  methods  will   use  the  standard  conversion  formulas:  F  =  9  C  +  32
                                                                      5
and C = 59 (F - 32). Each of these methods should have a single parameter

to store the temperature value that is being converted.

Because we want to be able to handle temperatures such as 98.6, we

should use real-number data for the methods' parameters. Generally

speaking, because Java represents real literals such as 98.6 as doubles,

the double type is more widely used than float. Because doubles are

more widely used in Java, using double wherever a floating point value

is needed will cut down on the number of implicit data conversions that a

program would have to perform. Therefore, each of our conversion meth-

ods should take a double parameter and return a double result. These

considerations lead

JAVA PROGRAMMING TIP Numeric Types. Java uses the int type
for integer literals and double for real-number literals. When
possible, using int and double for numeric variables and parameters
reduces the number of implicit conversions a program would have to
perform.

                                                                                   F=C * 9/ 5+32
                                                                                   C=(F-32) * 5/ 9

Implementation: Temperature

The implementation of the Temperature class is shown in Figure 5.5.                                     Temperature
Note that because celsToFahr() uses the double value temp in its cal-
culation, it uses floating-point literals (9.0, 5.0, and 32.0) in its conversion      +Temperature()
expression. This helps to reduce the reliance on Java's built-in promo-               +fahrToCels(in fahr : double) : double
tion rules, which can lead to subtle errors. For example, to the design               +celsToFahr(in cels : double) : double
shown in Figure 5.4, suppose we had written what looks like an equivalent
expression using integer literals:                                                 쭲igure 5.4: The Temperature
                                                                                    class. Note that static elements are
 
                                                                                   쯷nderlined in UML. (NEEDS RE-
    return ( 9 / 5  temp + 3 2 ) ; // E r r o r : e q u a l s ( t e m p + 3 2 )     VISION)
                                                                                    Semantic error

Because 9 divided by 5 gives the integer result 1, this expression is always
equivalent to temp + 32, which is not the correct conversion formula.
This kind of subtle semantic error can be avoided if you avoid mixing
                     220                         CHAPTER 5  Java Data and Operators
                     types wherever possible.

                       JAVA PROGRAMMING TIP Don't Mix Types. You can reduce the
                       incidence of semantic errors caused by implicit type conversions if,
                       whenever possible, you explicitly change all the literals in an
                       expression to the same type.

Testing strategy     Testing and Debugging
Designing test data
                     The next question to be addressed is how should this program be tested?
                     As always, you should test the program in a stepwise fashion. As each
                     method is coded, you should test it both in isolation and in combination
                     with the other methods, if possible.

                        Also, you should develop appropriate test data. It is not enough to just
                     plug in any values. The values you use should test for certain potential
                     problems. For this program, the following tests are appropriate:

                      Test converting 0 degrees C to 32 degrees F.
                      Test converting 100 degrees C to 212 degrees F.
                      Test converting 212 degrees F to 100 degrees C.
                      Test converting 32 degrees F to 0 degrees C.

                     The first two tests use the celsToFahr() method to test the freezing
                     point and boiling point temperatures, two boundary values for this prob-
                     lem. A boundary value is a value at the beginning or end of the range of
                     values that a variable or calculation is meant to represent. The second pair
                     of tests performs similar checks with the fahrToCels() method. One

                                                                                             

                     public class Temperature
                     {

                       public Temperature ( ) {}

                       public s t a t i c double fahrToCels ( double temp )

                       {

                          return ( 5 . 0  ( temp - 3 2 . 0 ) / 9 . 0 ) ;

                       }

                       public s t a t i c double celsToFahr ( double temp )

                       {

                          return ( 9 . 0  temp / 5 . 0 + 3 2 . 0 ) ;

                       }

                     } // T e m p e r a t u r e

                                                                                             

                          Figure 5.5: The Temperature class.
SECTION 5.5  Numeric Processing Examples  221

advantage of using these particular values is that we know what results
the methods should return.

JAVA EFFECTIVE DESIGN Test Data. Developing appropriate test
data is an important part of program design. One type of test data
should check the boundaries of the particular calculations you are
making.

JAVA DEBUGGING TIP Test, Test, Test! The fact that your program
runs correctly on some data is no guarantee of its correctness. The
more testing, and the more careful the testing you do, the better.

The TemperatureUI Class

The purpose of the TemperatureUI class is to serve as a user interface--
that is, as an interface between the user and a Temperature object. It
will accept a Fahrenheit or Celsius temperature from the user, pass it to
one of the public methods of the Temperature object for conversion, and
display the result that is returned.

   As we discussed in Chapter 4, the user interface can take various forms,
ranging from a command-line interface to a graphical interface. Figure 5.6
shows a design for the user interface based on the command-line interface
developed in Chapter 4. The TemperatureUI uses a KeyboardReader
to handle interaction with the user and uses static methods in the
Temperature class to perform the temperature conversions.

                                                                             Figure 5.6: A command-line user
                                                                             interface.

SELF-STUDY EXERCISES
                                          222  CHAPTER 5  Java Data and Operators

                                          EXERCISE 5.1 Following the design in Figure 5.6, implement the
                                          TemperatureUI class and use it to test the methods in Temperature
                                          class. The run() method should use an input-process-output algorithm:
                                          Prompt the user for input, perform the necessary processing, and output
                                          the result. Note that because Temperature's conversion methods are
                                          class methods, you do not need to instantiate a Temperature object in
                                          this project. You can invoke the conversion methods directly through the
                                          Temperature class:

                                                                                                                                  

                                          double fahr = Temperature . celsToFahr ( 9 8 . 6 ) ;                                    
                                          

        Applet    Buttons                 EXERCISE 5.2 Following the design for the GUI developed in Chap-
                                          ter 4, implement a GUI to use for testing the Temperature class. The
                                          GUI should have the layout shown in Figure 5.7.

        Input Temperature >>              5.5.3 Example: Using Class Constants

Labels  45        F to C                  As we noted in Chapter 0, in addition to instance variables, which are
          C to F                          associated with instances (objects) of a class, Java also allows class vari-
                                          ables, which are associated with the class itself. One of the most common
        Conversion Result:    TextFields  uses of such variables is to define named constants to replace literal val-
                                          ues. A named constant is a variable that cannot be changed once it has
        45 C=113.0 F                      been given an initial value. In this section, we use our running example,
                                          OneRowNim, to illustrate using class constants.
Figure 5.7: Layout design of a GUI
that performs temperature con-               Recall that methods and variables that are associated with a class must
versions.                                 be declared with the static modifier. If a variable is declared static,
                                          there is exactly one copy of that variable created no matter how many
                                          times its class is instantiated. To turn a variable into a constant, it must be
                                          declared with the final modifier. Thus, the following would be exam-
                                          ples of a class constants, constant values that are associated with the class
                                          rather than with its instances:

                                                                                                                                  

                                            public s t a t i c f i n a l i n t PLAYER ONE = 1 ;

                                            public s t a t i c f i n a l i n t PLAYER TWO = 2 ;

                                            public s t a t i c f i n a l i n t MAX PICKUP = 3 ;

                                            public s t a t i c f i n a l i n t MAX STICKS = 7 ;
                                                                                                                                  

                                          The final modifier indicates that the value of a variable cannot be
                                          changed. When final is used in a variable declaration, the variable must
                                          be assigned an initial value. After a final variable is properly declared,
                                          it is a syntax error to attempt to try to change its value. For example, given
                                          the preceding declarations, the following assignment statement would
                                          cause a compiler error:

                                                                                                                                  

                                            PLAYER ONE = 5 ; / / S y n t a x e r r o r ; P L A Y E R O N E i s a c o n s t a n t  
                                          

                                          Note how we use uppercase letters and underscore characters ( ) in the
                                          names of constants. This is a convention that professional Java program-
                                          mers follow, and its purpose is to make it easy to distinguish the constants
SECTION 5.5  Numeric Processing Examples                      223

from the variables in a program. This makes the program easier to read
and understand.

JAVA PROGRAMMING TIP Readability. To make your programs
more readable, use uppercase font for constant identifiers.

   Another way that named constants improve the readability of a pro-          
gram is by replacing the reliance on literal values. For example, for the      
OneRowNim class, compare the following two if conditions:
                                                                                Readability
                                                                               
                                                                               
    i f (num < 1 | | num > 3 | | num > n S t i c k s ) . . .
    i f (num < 1 | | num > MAX PICKUP | | num > n S t i c k s ) . . .
 

Clearly, the second condition is easier to read and understand. In the first
condition, we have no good idea what the literal value 3 represents. In the
second, we know that MAX PICKUP represents the most sticks a player
can pick up.

   Thus, to make OneRowNim more readable, we should replace all occur-
rences of the literal value 3 with the constant MAX PICKUP. This same
principle would apply to some of the other literal values in the program.
Thus, instead of using 1 and 2 to represent the two players, we could use
PLAYER ONE and PLAYER TWO to make methods such as the following
easier to read and understand:

 

    public int getPlayer ()
    { if ( onePlaysNext )

                    r e t u r n PLAYER ONE ;
           e l s e r e t u r n PLAYER TWO ;
    } // g e t P l a y e r ( )
 

JAVA PROGRAMMING TIP Readability. To make your programs
more readable, use named constants instead of literal values.

Another advantage of named constants (over literals) is that their use         Maintainability
makes the program easier to modify and maintain. For example, suppose
that we decide to change OneRowNim so that the maximum number of
sticks that can be picked up is 4 instead of 3. If we used literal values, we
would have to change all occurrences of 4 that were used to represent the
224  CHAPTER 5  Java Data and Operators

maximum pick up. If we used a named constant, we need only change its
declaration to:

                                                                             

public s t a t i c f i n a l i n t MAX PICKUP = 4 ;                          


JAVA EFFECTIVE DESIGN Maintainability. Constants should be
used instead of literal values in a program. This will make the
program easier to modify and maintain.

   So far, all of the examples we have presented show why named con-
stants (but not necessarily class constants) are useful. Not all constants
are class constants. That is, not all constants are declared static. How-
ever, the idea of associating constants with a class makes good sense. In
addition to saving memory resources, by creating just a single copy of
the constant, constants such as MAX STICKS and PLAYER ONE make
more conceptual sense to associate with the class itself rather than with
any particular OneRowNim instance.

   Class constants are used extensively in the Java class library. For ex-
ample, as we saw in Chapter 2, Java's various built-in colors are rep-
resented as constants of the java.awt.Color class--Color.blue and
Color.red. Similarly, java.awt.Label uses int constants to specify
how a label's text should be aligned: Label.CENTER.

   Another advantage of class constants is that they can be used before
instances of the class exist. For example, a class constant (as opposed to
an instance constant) may be used during object instantiation:

                                                                             

OneRowNim game = new OneRowNim(OneRowNim . MAX STICKS ) ;
                                                                             

Note how we use the name of the class to refer to the class constant. Of
course, MAX STICKS has to be a public variable in order to be accessible
outside the class. To use MAX STICKS as a constructor argument it has
to be a class constant because at this point in the program there are no
instances of OneRowNim. A new version of OneRowNim that uses class
constants is shown in Figure 5.8.

   It is important to note that Java also allows class constants to
be referenced through an instance of the class. Thus, once we
have instantiated game, we can refer to MAX STICKS with either
OneRowNim.MAX STICKS or game.MAX STICKS.

SELF-STUDY EXERCISE

EXERCISE 5.3 Implement a command-line interface class named
KBTestOneRowNim, that uses our new version of OneRowNim. Make use
of the MAX STICKS and MAX PICKUP in the user interface.

5.5.4 OBJECT-ORIENTED DESIGN:
         Information Hiding

The fact that our new versions of OneRowNim--we've developed two new
versions in this chapter--are backward compatible with the previous version
SECTION 5.5  Numeric Processing Examples                                      225

                                                                               

public c l a s s OneRowNim     i n t PLAYER ONE = 1 ;
{ public static final          i n t PLAYER TWO = 2 ;
                               i n t MAX PICKUP = 3 ;
       public static final     i n t MAX STICKS = 1 1 ;
       public static final     boolean GAME OVER = f a l s e ;
       public static final
       public static final

  p r i v a t e i n t n S t i c k s = MAX STICKS ;
  private boolean onePlaysNext = true ;

  public OneRowNim ( )

  {

  } // OneRowNim ( ) c o n s t r u c t o r 1

  public OneRowNim( i n t s t i c k s )

  { nSticks = sticks ;

  } // OneRowNim ( ) c o n s t r u c t o r 2

  public OneRowNim( i n t s t i c k s , i n t s t a r t e r )

  { nSticks = sticks ;

     onePlaysNext = ( s t a r t e r == PLAYER ONE ) ;

  } // OneRowNim ( ) c o n s t r u c t o r 3

  public boolean t a k e S t i c k s ( i n t num)

  { i f (num < 1 | | num > MAX PICKUP | | num > n S t i c k s )

           return false ;                           // E r r o r

     else                                           // V a l i d move

     { n S t i c k s = n S t i c k s - num ;

           onePlaysNext = ! onePlaysNext ;

           return true ;

     } // e l s e

  }// t a k e S t i c k s ( )

  public int getSticks ()

  { return nSticks ;

  } // g e t S t i c k s ( )

  public int getPlayer ()

  { if ( onePlaysNext )

           r e t u r n PLAYER ONE ;

     e l s e r e t u r n PLAYER TWO ;

  } // g e t P l a y e r ( )

  public boolean gameOver ( )

  { r e t u r n ( n S t i c k s <= 0 ) ;

  } // gameOver ( )

  public int getWinner ( )

  { if ( nSticks < 1)

           return getPlayer ( ) ;

     else return 0;                       // Game i s n o t o v e r

  } // g e t W i n n e r ( )

  public String report ()

  { r e t u r n ( "Number o f s t i c k s l e f t : " + g e t S t i c k s ( )

     + "\nNext turn by player " + getPlayer ( ) + "\n" ) ;

  } // r e p o r t ( )

} // OneRowNim c l a s s

                                                                               

  Figure 5.8: This version of OneRowNim uses named constants.
                                 226  CHAPTER 5  Java Data and Operators

Preserving the public interface  is due in large part to the way we have divided up its public and private
Information hiding               elements. Because the new versions still present the same public interface,
                                 programs that use the OneRowNim class, such as the OneRowNimApp from
                                 Chapter 4 (Fig. 4.24), can continue to use the class without changing a
                                 single line of their own code. To confirm this, see the Self-Study Exercise
                                 at the end of this section.

                                    Although we have made significant changes to the underlying rep-
                                 resentation of OneRowNim, the implementation details--its data and
                                 algorithms--are hidden from other objects. As long as OneRowNim's pub-
                                 lic interface remains compatible with the old version, changes to its pri-
                                 vate elements won't cause any inconvenience to those objects that were
                                 dependent on the old version. This ability to change the underlying im-
                                 plementation without affecting the outward functionality of a class is one
                                 of the great benefits of the information hiding principle.

                                 JAVA EFFECTIVE DESIGN Information Hiding. In designing a
                                 class, other objects should be given access just to the information they
                                 need and nothing more.

                                    The lesson to be learned here is that the public parts of a class should
                                 be restricted to just those parts that must be accessible to other objects.
                                 Everything else should be private. Things work better, in Java program-
                                 ming and in the real world, when objects are designed with the principle
                                 of information hiding in mind.

                                 SELF-STUDY EXERCISE

                                 EXERCISE 5.4 To confirm that our new version of OneRowNim still
                                 works correctly with the user interfaces we developed in Chapter 4, com-
                                 pile and run it with OneRowNimApp (Fig. 4.24).

                                 5.5.5 Example: A Winning Algorithm for One Row Nim

                                 Now that we have access to numeric data types and operators, lets de-
                                 velop an algorithm that can win the One Row Nim game. Recall that
                                 in Chapter 4 we left things such that when the computer moves, it al-
                                 ways takes 1 stick. Let's replace that strategy with a more sophisticated
                                 approach.

                                    If you have played One Row Nim, you have probably noticed that in
                                 a game with 21 sticks, you can always win the game if you leave your
                                 opponent with 1, 5, 9, 13, 17, or 21 sticks. This is obvious for the case of 1
                                 stick. For the case where you leave your opponent 5 sticks, no matter what
                                 the opponent does, you can make a move that leaves the other player with
                                 1 stick. For example, if your opponent takes 1 stick, you can take 3; if your
                                 opponent takes 2, you can take 2; and, if your opponent takes 3, you can
                                 take 1. In any case, you can win the game by making the right move, if
                                 you have left your opponent with 5 sticks. The same arguments apply for
                                 the other values: 9, 13, 17, and 21.
SECTION 5.5  Numeric Processing Examples     227

   What relationship is common to the numbers in this set? Notice that
if you take the remainder after dividing each of these numbers by 4 you
always get 1:

                                                                              

  1 % 4 == 1

  5 % 4 == 1

  9 % 4 == 1

  13 % 4 == 1

  17 % 4 == 1

  21 % 4 == 1                                                                 

Thus, we can base our winning strategy on the goal of leaving the oppo-
nent with a number of sticks, N, such that N % 4 equals 1.

   To determine how many sticks to take in order to leave the opponent
with N, we need to use a little algebra. Let's suppose that sticksLeft
represents the number of sticks left before our turn. The first thing we
have to acknowledge is that if sticksLeft % 4 == 1, then we have been left
with 1, 5, 9, 13, and so on, sticks, so we cannot force a win. In that case,
it doesn't matter how many sticks we pick up. Our opponent should win
the game.

   So, let's suppose that sticksLeft % 4 != 1, and let M be the number of
sticks to pickup in order to leave our opponent with N, such that N % 4 ==
1. Then we have the following two equations:

                                                                              

s t i c k s L e f t - M == N

N % 4 == 1                                                                    


We can combine these into a single equation, which can be simplified as
follows:

                                                                              

( s t i c k s L e f t - M) % 4 == 1
                                                                              

If sticksLeft - M leaves a remainder of 1 when divided by 4, that means that
sticksLeft - M is equal some integer quotient, Q times 4 plus 1:

                                                                              

( s t i c k s L e f t - M) == (Q  4 ) + 1                                     


By adding M to both sides and subtracting 1 from both sides of this equa-
tion, we get:

                                                                              

  ( s t i c k s L e f t - 1 ) == (Q  4 ) + M                                  

This equation is saying that (sticksLeft - 1) % 4 == M. That is, that when
you divide sticksLeft-1 by 4, you will get a remainder of M, which is the
number of sticks you should pick up. Thus, to decide how many sticks to
take, we want to compute:

                                                                              

M == ( s t i c k s L e f t -1) % 4                                            

228                    CHAPTER 5  Java Data and Operators

To verify this, let's look at some examples:

                                                                                                  

     sticksLeft        ( s t i c k s L e f t -1) % 4  sticksLeft

        Before                                        After

     ----------------------------------------------------

         9             (9 -1) % 4 == 0                I l l e g a l Move
         8             (8 -1) % 4 == 3                5
         7             (7 -1) % 4 == 2                5
         6             (6 -1) % 4 == 1                5
         5             (5 -1) % 4 == 0                I l l e g a l Move

                                                                                    

The examples in this table show that when we use (sticksLeft-1 % 4) to
calculate our move, we always leave our opponent with a losing situation.
Note that when sticksLeft equals 9 or 5, we can't apply this strategy
because it would lead to an illegal move.

   Let's now convert this algorithm into Java code. In addition to incor-
porating our winning strategy, this move() method makes use of two
important Math class methods:

                                                                                                  

public i n t move ( )

{ i n t s t i c k s L e f t = nim . g e t S t i c k s ( ) ; // G e t n u m b e r o f s t i c k s

     i f ( s t i c k s L e f t % ( nim . MAX PICKUP + 1 ) ! = 1 ) // I f w i n n a b l e

        r e t u r n ( s t i c k s L e f t - 1 ) % ( nim . MAX PICKUP + 1 ) ;

     else {                                   // E l s e p i c k random

        i n t maxPickup = Math . min ( nim . MAX PICKUP, s t i c k s L e f t ) ;

        r et ur n 1 + ( i n t ) ( Math . random ( )  maxPickup ) ;

     }

}

                                                                                                  

The move() method will return an int representing the best move pos-
sible. It begins by getting the number of sticks left from the OneRowNim
object, which is referred to as nim in this case. It then checks whether it
can win by computing (sticksLeft-1) % 4. However, note that rather than
use the literal value 4, we use the named constant MAX PICKUP, which is
accessible through the nim object. This is an especially good use for the
class constant because it makes our algorithm completely general - that is,
our winning strategy will continue to work even if the game is changed
so that the maximum pickup is 5 or 6. The then clause computes and re-
turns (sticksLeft-1) % nim.MAX PICKUP+1, but here again it uses the class
constant.

   The else clause would be used when it is not possible to make a winning
move. In this case we want to choose a random number of sticks between
1 and some maximum number. The maximum number depends on how
many sticks are left. If there are more than 3 sticks left, then the most we
can pick up is 3, so we want a random number between 1 and 3. However,
if there are 2 sticks left, then the most we can pick up is 2 and we want a
random number between 1 and 2. Note how we use the Math.min()
method to decide the maximum number of sticks that can be picked up:

                                                                                                  

i n t maxPickup = Math . min ( nim . MAX PICKUP, s t i c k s L e f t ) ;                          

SECTION 5.6  From the Java Libraryjava.text.NumberFormat 229

The min() method returns the minimum value between its two argu-
ments.

   Finally, note how we use the Math.random() method to calculate a
random number between 1 and the maximum:

                                                                              

1 + ( i n t ) ( Math . random ( )  maxPickup ) ;                              

The random() method returns a real number between 0 and 0.999999 -
that is, a real number between 0 and 1 but not including 1:

                                                                              

0 <= Math . random ( ) < 1 . 0                                                

If we multiply Math.random() times 2, the result would be a value be-
tween 0 and 1.9999999. Similarly, if we multiplied it by 3, the result would
be a value between 0 and 2.9999999. In order to use the random value, we
have to convert it into an integer, which is done by using the (int) cast
operator:

                                                                              

  ( i n t ) ( Math . random ( )  maxPickup ) ;                                

Recall that when a double is cast into an int, Java just throws away the
fractional part. Therefore, this expression will give us a value between 0
and maxPickup-1. If maxPickup is 3, this will give a value between 0
and 2, whereas we want a random value between 1 and 3. To achieve this
desired value, we merely add 1 to the result. Thus, using the expression

                                                                              

  1 + ( i n t ) ( Math . random ( )  maxPickup )                              

gives us a random number between 1 and maxPickup, where
maxPickup is either 1, 2, or 3, depending on the situation of the game
at that point.

SELF-STUDY EXERCISE                                                           Figure 5.9: The NimPlayer class.

EXERCISE 5.5 Implement a class named NimPlayer that incorporates
the move() method designed in this section. The class should implement
the design shown in Figure 5.9. That is, in addition to the move() method,
it should have an instance variable, nim, which will serve as a reference to
the OneRowNim game. Its constructor method should take a OneRowNim
parameter, allowing the NimPlayer to be given a reference when it is
instantiated.

EXERCISE 5.6 Modify OneRowNim's command-line interface to play
One Row Nim between the user and the computer, where the NimPlayer
implemented in the previous exercise represents the computer.

5.6 From the Java Library                                                        java.sun.com/j2se/1.5.0/docs/api/
      java.text.NumberFormat
                                                                                  NumberFormat
 ALTHOUGH the Math.round() method is useful for rounding num-

                                                                              +getInstance() : NumberFormat
                                                                              +getCurrencyInstance() : NumberFormat
                                                                              +getPercentInstance() : NumberFormat
                                                                              +format(in n : double) : String
                                                                              +format(in n : long) : String
230  CHAPTER 5  Java Data and Operators

bers, it is not suitable for business applications. Even for rounded values,
Java will drop trailing zeroes. So a value such as $10,000.00 would be
output as $10000.0. This wouldn't be acceptable for a business report.

   Fortunately, Java supplies the java.text.NumberFormat class pre-
cisely for the task of representing numbers as dollar amounts, percentages,
and other formats (Fig. 5.10).

   The NumberFormat class is an abstract class, which means that
it cannot be directly instantiated. Instead, you would use its static
getInstance() methods to create an instance that can then be used for
the desired formatting tasks.

   Once a NumberFormat instance has been created, its format()
method can be used to put a number into a particular format. The
setMaximumFractionDigits() and setMaximumIntegerDigits()
methods can be used to control the number of digits before and after the
decimal point.

   For example, the following statements can be used to format a decimal
number as a currency string in dollars and cents:

                                                                                                                             

NumberFormat d o l l a r s = NumberFormat . getCurrencyInstance ( ) ;

System . out . println ( dollars . format ( 1 0 9 6 2 . 5 5 5 ) ) ;                                                          


These statements would cause the value 10962.555 to be shown as
$10,962.56. Similarly, the statements,

                                                                                                                             

NumberFormat percent = NumberFormat . g e t P e r c e n t I n s t a n c e ( ) ;

percent . setMaximumFractionDigits ( 2 ) ;

System . out . println ( percent . format ( 6 . 5 5 ) ) ;                                                                    


would display the value 6.55 as 6.55%. The utility of the Math and
NumberFormat classes illustrates the following principle:

JAVA EFFECTIVE DESIGN Code Reuse. Often the best way to solve
a programming task is to find the appropriate methods in the Java
class library.

                                       SELF-STUDY EXERCISE

                                                EXERCISE 5.7 A Certificate of Deposit (CD) is an investment instru-
                                               ment that accumulates interest at a given rate for an initial principal over
                                               a fixed number of years. The formula for compounding interest is shown
                                               in Table 5.11. It assumes that interest is compounded annually. For daily
                                               compounding, the annual rate must be divided by 365, and the com-
                                               pounding period must be multiplied by 365, giving: a = p(1 + r/365)365n.
                                               Implement a BankCD class that calculates the maturity value of a CD. Fig-
                                               ure 5.11 gives the design of the class. It should have three instance vari-
                                               ables for the CD's principal, rate, and years. Its constructor method sets
                                               the initial values of these variables when a BankCD is instantiated. Its
                                               two public methods calculate the maturity value using yearly and daily

Figure 5.11: The BankCD class.
SECTION 5.7  Character Data and Operators                231

compounding interest, respectively. Use the Math.pow() method to cal-
culate maturity values. For example, the following expression calculates
maturity value with annual compounding:

                                                          

p r i n c i p a l  Math . pow( 1 + r a t e , y e a r s )
                                                          

  TABLE 5.12 Formula for calculating compound interest

  a = p(1 + r)n where

   a is the CD's value at the end of the nth year
   p is the principal or original investment amount
   r is the annual interest rate
   n is the number of years or the compounding period

EXERCISE 5.8 Design a command-line user interface to the BankCD
class that lets the user input principal, interest rate, and years, and re-
ports the CD's maturity value with both yearly and daily compounding.
Use NumberFormat objects to display percentages and dollar figures in
an appropriate format. The program's output should look something like
the following (user's inputs are in cyan):

************************ OUTPUT ********************
Compare daily and annual compounding for a Bank CD.

 Input CD initial principal, e.g. 1000.55 > 2500
 Input CD interest rate, e.g. 6.5 > 7.8
 Input the number of years to maturity, e.g., 10.5 > 5
For Principal = $2,500.00 Rate= 7.8% Years= 5.0
 The maturity value compounded yearly is $3,639.43
 The maturity value compounded daily is: $3,692.30
************************ OUTPUT ********************

5.7 Character Data and Operators

Another primitive data type in Java is the character type, char. A char-                    Unicode
acter in Java is represented by a 16-bit unsigned integer. This means that
a total of 216 or 65536 different Unicode characters can be represented,                   
corresponding to the integer values 0 to 65535. The Unicode character set                  
is an international standard that has been developed to enable computer
languages to represent characters in a wide variety of languages, not just
English. Detailed information about this encoding can be obtained at

 

    h t t p : //www. unicode . org/
 

   It is customary in programming languages to use unsigned integers to
represent characters. This means that all the digits (0, . . . , 9), alphabetic let-
ters (a, . . . , z, A, . . . , Z), punctuation symbols (such as . ; , " `' ! -), and non-
printing control characters (LINE FEED, ESCAPE, CARRIAGE RETURN,
. . .) that make up the computer's character set are represented in the com-
puter's memory by integers. A more traditional set of characters is the
232                                  CHAPTER 5  Java Data and Operators

ASCII (American Standard Code for Information Interchange) character set.        ASCII cod
ASCII is based on a 7-bit code and, therefore, defines 27 or 128 different
characters, corresponding to the integer values 0 to 127. In order to make
Unicode backward compatible with ASCII systems, the first 128 Unicode
characters are identical to the ASCII characters. Thus, in both the ASCII
and Unicode encoding, the printable characters have the integer values
shown in Table 5.13.

TABLE 5.13 ASCII codes for selected characters

                                                        

Code  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
Char  SP ! " # $ % & ' ( )  + , - . /

Code  48 49 50 51 52 53 54 55 56 57
Char  0123456789

Code  58 59 60 61 62 63 64
Char  : ; <=> ? @

Code  65 66 67 68 69 70 71 72 73 74 75 76 77
Char  A B CD E F GH I J K LM

Code  78 79 80 81 82 83 84 85 86 87 88 89 90
Char  NO P Q R S T U VWX Y Z

Code  91 92 93 94 95 96
Char
      [\] ^           `

Code  97 98 99 100 101 102 103 104 105 106 107 108 109
Char  abcd e f g h i j k l m

Code  110 111 112 113 114 115 116 117 118 119 120 121 122
Char  n o p q r s t u vwx y z

Code 123 124 125 126

Char { | } ~                                            

5.7.1 Character to Integer Conversions

Is `A' a character or an integer? The fact that character data are stored
as integers in the computer's memory can cause some confusion about
whether a given piece of data is a character or an integer. In other words,
when is a character, for example `A', treated as the integer (65) instead of
as the character `A'? The rule in Java is that a character literal--`a' or `A'
or `0' or `?'--is always treated as a character, unless we explicitly tell Java
to treat it as an integer. So if we display a literal's value

                                                                                 

  System . out . println ( 'a ' ) ;
                                                                                 
SECTION 5.7  Character Data and Operators                                     233

the letter `a' will be displayed. Similarly, if we assign `a' to a char variable
and then display the variable's value,

                                                                                    
                                                                                    
  char ch = 'a ' ;                            // D i s p l a y s ' a '              
  System . out . println ( ch ) ;                                                   

                                                                                    
the letter `a' will be shown. If, on the other hand, we wish to output a            
character's integer value, we must use an explicit cast operator as follows:
                                                                                     The cast operator

                                                                                    
  System . out . println ( ( int ) ' a ' ) ;  // D i s p l a y s 97                 

                                                                                     Implicit type conversion
A cast operation, such as (int), converts one type of data ('a') into an-
other (97). This is known as a type conversion. Similarly, if we wish to             Widening conversion
store a character's integer value in a variable, we can cast the char into an       
int as follows:                                                                     



  int k = ( int ) 'a ' ;           // C o n v e r t s ' a ' t o 97
  System . out . println (k ) ;    // D i s p l a y s 97


As these examples show, a cast is a type conversion operator. Java al-
lows a wide variety of both explicit and implicit type conversions. Cer-
tain conversions (for example, promotions) take place when methods are
invoked, when assignment statements are executed, when expressions are
evaluated, and so on.

   Type conversion in Java is governed by several rules and exceptions. In
some cases Java allows the programmer to make implicit cast conversions.
For example, in the following assignment a char is converted to an int
even though no explicit cast operator is used:



  char ch ;
  int k;
  k = ch ; // c o n v e r t a c h a r i n t o an i n t


Java permits this conversion because no information will be lost. A char-
acter char is represented in 16 bits whereas an int is represented in 32
bits. This is like trying to put a small object into a large box. Space will be
left over, but the object will fit inside without being damaged. Similarly,
storing a 16-bit char in a 32-bit int will leave the extra 16 bits unused.
This widening primitive conversion changes one primitive type (char) into
a wider one (int), where a type's width is the number of bits used in its
representation.

   On the other hand, trying to assign an int value to a char variable
leads to a syntax error:



  char ch ;  // S y n t a x e r r o r : can ' t a s s i g n i n t t o c h a r
  int k;
  ch = k ;


Trying to assign a 32-bit int to 16-bit char is like trying to fit a big object
into an undersized box. The object won't fit unless we shrink it in some
                      234                            CHAPTER 5  Java Data and Operators

                      way. Java will allow us to assign an int value to a char variable, but only
                      if we perform an explicit cast on it:

                                                                                                        

                      ch = ( char ) k ; // E x p l i c i t c a s t o f i n t k i n t o c h a r ch       
                      

Narrowing conversion  The (char) cast operation performs a careful "shrinking" of the int by
                      lopping off the last 16 bits of the int. This can be done without loss of
                      information provided that k's value is in the range 0 to 65535--that is, in
                      the range of values that fit into a char variable. This narrowing primitive
                      conversion changes a wider type (32-bit int) to a narrower type (16-bit
                      char). Because of the potential here for information loss, it is up to the
                      programmer to determine that the cast can be performed safely.

                      JAVA LANGUAGE RULE Type Conversion. Java permits implicit
                      type conversions from a narrower type to a wider type. A cast operator
                      must be used when converting a wider type into a narrower type.

                      The cast operator can be used with any primitive type. It applies to the
                      variable or expression that immediately follows it. Thus, parentheses
                      must be used to cast the expression m + n into a char:

                                                                                                        

                      char ch = ( char ) (m + n ) ;
                                                                                                        

                      The following statement would cause a syntax error because the cast
                      operator would only be applied to m:

                                                                                                        

                      c h a r ch = ( c h a r )m + n ; // E r r o r : r i g h t s i d e i s a n i n t
                                                                                                        

                      In the expression on the right-hand side, the character produced by
                      (char)m will be promoted to an int because it is part of an integer oper-
                      ation whose result will still be an int. Therefore, it cannot be assigned to
                      a char without an explicit cast.

                      SELF-STUDY EXERCISE

                      5.7.2 Lexical Ordering

                      The order in which the characters of a character set are arranged, their
                      lexical order, is an important feature of the character set. It especially
                      comes into play for such tasks as arranging strings in alphabetical order.

                         Although the actual integer values assigned to the individual char-
                      acters by ASCII and UNICODE encoding seem somewhat arbitrary, the
                      characters are, in fact, arranged in a particular order. For example, note
                      that various sequences of digits, '0'. . .'9', and letters, 'a'. . .'z' and
                      'A'. . .'Z', are represented by sequences of integers (Table 5.11). This
                      makes it possible to represent the lexical order of the characters in terms of
                      the less than relationship among integers. The fact that `a' comes before `f'
                      in alphabetical order is represented by the fact that 97 (the integer code for
                      `a') is less than 102 (the integer code for `f'). Similarly, the digit `5' comes
                      before the digit `9' in an alphabetical sequence because 53 (the integer code
                      for `5') is less than 57 (the integer code for `9').
SECTION 5.8  Example: Character Conversions              235

   This ordering relationship extends throughout the character set. Thus,
it is also the case that `A' comes before `a' in the lexical ordering because 65
(the integer code for `A') is less than 97 (the integer code for `a'). Similarly,
the character `[' comes before `}' because its integer code (91) is less than
125, the integer code for `}'.

5.7.3 Relational Operators

Given the lexical ordering of the char type, the following relational oper-        char relations
ators can be defined: <, >, <=, >=, ==, !=. Given any two characters, ch1
and ch2, the expression ch1 < ch2 is true if and only if the integer value
of ch1 is less than the integer value of ch2. In this case we say that ch1
precedes ch2 in lexical order. Similarly, the expression ch1 > ch2 is true if
and only if the integer value of ch1 is greater than the integer value of ch2.
In this case we say that ch1 follows ch2. And so on for the other relational
operators. This means that we can perform comparison operations on any
two character operands (Table 5.14).

  TABLE 5.14 Relational operations on characters

  Operation             Operator Java    True Expression

  Precedes              <   ch1 < ch2            a<b
                            ch1 > ch2            c>a
  Follows               >   ch1 <= ch2           a <= a
                            ch2 >= ch1           a >= a
  Precedes or equals <=     ch1 == ch2           a == a
                            ch1 ! = ch2          a != b
  Follows or equals >=

  Equal to              ==

  Not equal to          !=

5.8 Example: Character Conversions

Another interesting implication of representing the characters as integers          Lowercase to uppercase
is that we can represent various character operations in terms of inte-
ger operations. For example, suppose we want to capitalize a lower-                
case letter. Table 5.13 shows that the entire sequence of lowercase let-           
ters ('a' ... 'z') is displaced by 32 from the sequence of uppercase
letters ('A' ... 'Z'), so we can convert any lowercase letter into its
corresponding uppercase letter by subtracting 32 from its integer value,
provided we perform an explicit cast on the result. When we perform the
cast (char) ('a' - 32 ), the resulting value is 'A', as the following
example shows:



  ( char )( 'a ' - 32)                 ==> 'A '

                        236                        CHAPTER 5  Java Data and Operators

                        Recall that in evaluating 'a' - 32 Java will promote `a' to an int and
                        then perform the subtraction. Thus, a step-by-step evaluation of the ex-
                        pression would go as follows:

                                                                                                            

                        Step 1. ( char ) ( ( int ) 'a ' - 32) // Promote ' a ' to i n t

                        Step 2. ( char )(97 - 32)       // S u b t r a c t

                        Step 3. ( char ) (65)           // C a s t r e s u l t t o a c h a r

                          Step 4 . 'A '                 // R e s u l t s i n 'A '
                        
                                                                                                        

Uppercase to lowercase  Similarly, we can convert an uppercase letter into the corresponding low-
Type error              ercase letter by simply adding 32 to its integer code and casting the result
                        back to a char:

                                                                                                            

                        ( char )( ' J ' + 32)           ==> ' j '                                           
                        

                        We can group these ideas into a method that performs conversion from
                        lowercase to uppercase:

                                                                                                            

                        char toUpperCase ( char ch ) {

                             i f ( ( ch >= ' a ' ) && ( ch <= ' z ' ) )

                             return ch - 32 ; // E r r o r : c a n ' t r e t u r n an i n t

                             return ch ;

                        }

                                                                                                            

                        This method takes a single char parameter and returns a char value. It
                        begins by checking if ch is a lowercase letter--that is, if ch falls between
                        `a' and `z' inclusive. If so, it returns the result of subtracting 32 from ch. If
                        not, it returns ch unchanged. However, the method contains a syntax error
                        that becomes apparent if we trace through its steps. If we invoke it with
                        the expression toUpperCase('b'), then since `b' is between `a' and `z',
                        the method will return `b' - 32. Because the integer value of `b' is 98, it
                        will return 98 - 32 or 66, which is the integer code for the character `B'.
                        However, the method is supposed to return a char, so this last statement
                        will generate the following syntax error:

                                                                                                            

                        I n c o m p a t i b l e type f o r r e t u r n . An e x p l i c i t c a s t needed

                        to convert int to char .

                        >> r e t u r n ch - 32 ;

                        >> ^                                                                                
                        

                        In order to avoid this error, the result must be converted back to char
                        before it can be returned:

                                                                                                            

                        char toUpperCase ( char ch ) {

                             i f ( ( ch >= ' a ' ) && ( ch <= ' z ' ) )

                             return ( char ) ( ch - 3 2 ) ; // E x p l i c i t c a s t

                             return ch ;

                        }

                                                                                                            
SECTION 5.9  Problem Solving = Representation + Action  237

Another common type of conversion is to convert a digit to its correspond-         Digit to integer
ing integer value. For example, we convert the character `9' to the integer       
9 by making use of the fact that the digit `9' is 9 characters beyond the digit   
`0' in the lexical order. Therefore, subtracting `0' from `9' gives integer 9 as  
a result:
                                                                                  


  ( ' 9 ' - ' 0 ' ) ==> ( 5 7 - 4 8 ) ==> 9


More generally, the expression ch- `0' will convert any digit, ch, to its
integer value. We can encapsulate these ideas into a method that converts
any digit into its corresponding integer value:



  int digitToInteger ( char ch )        {
      i f ( ( ch >= ' 0 ' ) && ( ch <=  '9 ' ))
         return ch - '0 ' ;
     r e t u r n -1 ;

  }


This method takes a single char parameter and returns an int. It first
checks that ch is a valid digit, and if so, it subtracts the character `0' from
it. If not, the method just returns -1, which indicates that the method
received an invalid input parameter. Obviously, when an object invokes
this method, it should first make sure that the value it passes is in fact a
digit.

   The Java application program shown in Figure 5.12 illustrates sev-
eral of the ideas discussed in this section. Note that both the
digitToInteger() and toUpperCase() are declared static. This al-
lows us to call them directly from the (static) main() method, as useful
and justifiable shortcut if, as in this case, we are just testing the methods.

5.9 Problem Solving = Representation + Action

As you have seen in this chapter, designing classes involves a careful in-
terplay between representation (data) and action (methods). Our several
modifications to the OneRowNim class illustrate that the data used to rep-
resent an object's state can either complicate or simplify the design of the
methods needed to solve a problem.

   We hope that it is becoming clear to you that in writing object-oriented
programs, choosing an appropriate data representation is just as impor-
tant as choosing the correct algorithm. The concept of an object allows us
to encapsulate representation and action into a single entity. It is a very
natural way to approach problem solving.

   If you look closely enough at any problem, you will find this close re-
lationship between representation and action. For example, compare the
task of performing multiplication using Arabic numerals--65 * 12 = 380--
and the same task using Roman numerals--LXV * XII = DCCLXXX. It's
doubtful that our science and technology would be where they are today
                 238                             CHAPTER 5  Java Data and Operators

                                                                                          

                 public class Test {

                      public s t a t i c void main ( S t r i n g argv [ ] ) {

                         char ch = 'a ' ;                 // L o c a l v a r i a b l e s

                         int k = ( int ) 'b ' ;

                         System . out . println ( ch ) ;

                         System . out . println (k ) ;

                         ch = ( char )k ;                 // C a s t needed h e r e

                         System . out . println ( ch ) ;

                         System . out . println ( toUpperCase ( 'a ' ) ) ;

                         System . out . println ( toUpperCase ( ch ) ) ;

                         System . out . println ( digitToInteger ( '7 ' ) ) ;

                      }

                      public s t a t i c char toUpperCase ( char ch ) {
                             i f ( ( ch >= ' a ' ) && ( ch <= ' z ' ) )
                                    return ( char ) ( ch - 3 2 ) ;
                             return ch ;

                      }

                      public s t a t i c int digitToInteger ( char ch ) {
                             i f ( ( ch >= ' 0 ' ) && ( ch <= ' 9 ' ) )
                                    return ch - '0 ' ;
                             r e t u r n -1 ;

                      }

                 } // T e s t

                                                                                          

                 Figure 5.12: A Java program illustrating character conversions. When run,
                 the program will generate the following outputs, one per line: a, 98, b, A,
                 B, 7.

                 if our civilization had to rely forever on the Roman way of representing
                 numbers!

                  JAVA EFFECTIVE DESIGN Representation and
                  Action. Representation (data) and action (methods) are equally
                  important parts of the problem-solving process.

CHAPTER SUMMARY  Technical Terms

                 action                    named constant        short-circuit
                 binary operator           operand                  evaluation
                 binary digit (bit)        operator overloading
                 boundary value            precedence order      type conversion
                 cast operation            promotion             unary operator
                 class constant            round off error       Unicode
                 input-process-output                            representation

                 Summary of Important Points
CHAPTER 5  Chapter Summary                                  239

 The way we approach a problem can often help or hinder us in our
  ability to solve it. Choosing an appropriate representation for a problem
  is often the key to solving it.

 In order to evaluate complex expressions, it is necessary to understand
  the precedence order and associativity of the operators involved. Paren-
  theses can always be used to override an operator's built-in precedence.

 Java provides several types of integer data, including the 8-bit byte,
  16-bit short, 32-bit int, and 64-bit long types. Unless otherwise
  specified, integer literals are represented as int data in a Java program.

 Java provides two types of floating-point data, the 32-bit float type
  and the 64-bit double type. Unless otherwise specified, floating-point
  literals are represented as double data.

 In general, if a data type uses n bits in its representation, then it can
  represent 2n different values.

 The fact that Java's primitive types are defined in terms of a specific
  number of bits is one way that Java promotes platform independence.

 It is necessary to distinguish integer operations from floating-point op-
  erations even though the same symbols are used. For example, (7/2) is
  3, while (7.0/2) is 3.0.

 In revising a class that is used by other classes it is important to pre-
  serve as much of the class's interface as possible.

 In Java, character data are based on the Unicode character set, which
  provides 216 = 65,536 different character codes. To provide backward
  compatibility with the ASCII code, the first 128 characters are the ASCII
  coded characters.

 Java operators are evaluated according to the precedence hierarchy
  shown in Table 5.15. The lower the precedence number, the earlier an
  operator is evaluated. So the operators at the top of the table are evalu-
  ated before operators that occur below them in the table. Operators at
  the same precedence level are evaluated according to their association,
  either left to right (L to R) or right to left (R to L).

TABLE 5.15 Java operator precedence and associativity table

Order Operator  Operation                                    Association

0 ()            Parentheses                                  L to R
                                                             R to L
1 ++ -- .       Postincrement, postdecrement,
                                                             R to L
                dotOperator                                  L to R

2 ++ -- + - !   Preincrement, predecrement                   L to R
                                                             L to R
                Unary plus, unary minus,                     L to R
                                                             L to R
                boolean NOT                                  L to R
                                                             L to R
3 (type) new    Type cast, object instantiation              R to L

4 */%           Multiplication, division, modulus

5 +-+           Addition, subtraction, string

                concatenation

6 < > <= >=     Relational operators

7 == !=         Equality operators

8               Boolean XOR

9 &&            Boolean AND

10 ||           Boolean OR

11 = += -= *= /= %= Assignment operators
                                                 240  CHAPTER 5  Java Data and Operators

EXERCISES

Note: For programming exercises,
first draw a UML class diagram
describing all classes and their
inheritance relationships and/or
associations.
Chapter 6

Control Structures

OBJECTIVES

After studying this chapter, you will
 Be able to solve problems involving repetition.
 Understand the differences among various loop structures.
 Know the principles used to design effective loops.
 Improve your algorithm design skills.
 Understand the goals and principles of structured programming.

OUTLINE

6.1 Introduction
6.2 Flow of Control: Repetition Structures
6.3 Counting Loops
6.4 Example: Car Loan
6.5 Graphics Example: Drawing a Checkerboard
6.6 Conditional Loops
6.7 Example: Computing Averages
6.8 Example: Data Validation
6.9 Principles of Loop Design
6.10 The switch Multiway Selection Structure
6.11 Object-Oriented Design: Structured Programming

         Special Topic: What Can Be Computed?
          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              241
242                           CHAPTER 6  Control Structures

6.1 Introduction

As we learned in Chapter 3, a control structure is a language element that
changes the flow of control of a program. Thus far, we have used the if
and if/else statements to select between two or more alternate paths in
a program. We have used the while-loop structure to repeat statements.
And we have used method-call-and-return to invoke methods that carry
out certain well-defined tasks in a program.

   In this chapter we will extend our repertoire of control structures. We
will introduce the for and do-while statements, both of which are used in
programs that require calculations to be repeated. We will also introduce
the switch statement, which will give us another way, in addition to
if/else, to select from among several alternate paths in a program.

   We begin by introducing the idea of a counting loop, which is used for
repetitive tasks when you know beforehand exactly how many repetitions
are necessary. This type of loop is most often implemented using a for
statement.

   We then distinguish two kinds of conditional loops, which are used for
performing repetitive tasks where the number of repetitions depends on
some kind of non-counting condition. These kinds of loops are usually
implemented using Java's while and do-while statements. We give ex-
amples of several kinds of loop bounds and use them to identify several
useful principles of loop design. Finally, we introduce some of the key
principles of the structured programming approach, a disciplined design
approach that preceded the object-oriented approach.

6.2 Flow of Control: Repetition Structures

As we saw in Chapter 3, a repetition structure is a control structure that
repeats a statement or sequence of statements. Many programming tasks
require a repetition structure. Consider some examples.

 You're working for the National Security Agency trying to decipher se-
  cret messages intercepted from foreign spies, and you want to count the
  number of times a certain letter, "a," occurs in a document containing
  N characters. In this case, you would want to employ something like
  the following (pseudocode) algorithm:

                                                                            

initialize totalAs to 0

for each character in the document

  i f the character i s an ' a '

  add 1 to t o t a l A s

return totalAs as the result                                                


 You're working for a caterer who wants to number the invitations to a
  client's wedding, so you need to print the numbers between 1 and 5000
SECTION 6.3  Counting Loops                               243

on the invitation cards (it's a big wedding)! In this case, you want to go
through each number, 1 to 5000, and simply print it out:

                                                                             

f o r each number , N, from 1 to 5000

  p r i n t N on the i n v i t a t i o n card                                

 You are helping the forest service in Alaska to track the number of black
  bear sightings, and you want to compute the average number of sight-
  ings per month. Suppose the user enters each month's count at the
  keyboard, and uses a special number, say, 9999, to signify the end of
  the sequence. However, 9999 should not be figured into the average.
  This example differs a bit from the preceding ones, because here you
  don't know exactly how many numbers the user will input:

                                                                             

i n i t i a l i z e sumOfBears to 0

i n i t i a l i z e numOfMonths t o 0

repeat the following steps

  read a number from the keyboard

  i f t h e number i s NOT 9999

  add i t to the sumOfBears

  add 1 t o numOfMonths

u n t i l the number read i s 9999

d i v i d e sumOfBears by numOfMonths g i v i n g average

return average as the result
                                                                             

  We repeat the process of reading numbers and adding them to a run-
  ning total "until the number read is 9999."
 Student records are stored in a file and you want to calculate Erika
  Wilson's current GPA. Here we need to perform a repetitive process--
  searching through the file for Erika Wilson's record--but again we
  don't know exactly how many times to repeat the process:

                                                                             

repeat the following steps

  read a record from the f i l e

until Erika Wilson ' s record is read

compute E r i k a Wilson ' s GPA

return gpa as the r e s u l t                                                


As these examples suggest, two types of loops are used: counting loops
and non-counting loops. Counting loops are used whenever you know
in advance exactly how many times an action must be performed. Non-
counting loops are used when the number of repetitions depends on
some condition--for example, the number of data items input from the
keyboard or the input of a particular record from a file.

6.3 Counting Loops

A counting loop, or counter-controlled loop, is a loop in which you know
beforehand how many times it will be repeated. Among the preceding
examples, the first two are counting loops.
               244                CHAPTER 6  Control Structures

                  Because you know the exact number of times the loop repeats before-
               hand, a counting loop can be made dependent on the value of a counter.
               For example, if you want to print the word "Hello" 100 times, you can use
               the following while structure:

                                                                                                   

               int k = 0;

               while (k < 100) {

                    System . out . println ( "Hello" ) ;

                    k++;

               }

                                                                                                   

Zero indexing  In this case, the counter is the variable k, which counts from 0 through
Loop counter   99--that is, it counts 100 times. Note that we start counting from 0 instead
               of 1. Counting from 0 is known as zero indexing and it is a common
               programming convention for counting loops. Although it doesn't really
               make any practical difference in this case, later on we will use loops to
               process structures, such as strings and arrays, which use zero indexing. It
               will be easier to process these structures if our loop counter also starts at 0.

                  The variable k in this example is called a counter variable or loop counter.
               Although it is certainly possible to name the counter variable anything we
               like, it is customary to use single letters like i, j, and k as loop counters. The
               fundamental feature of a counting loop is that we must know beforehand
               exactly how many iterations the loop will take.

               JAVA EFFECTIVE DESIGN Loop Design. A counting loop can be
               used whenever you know exactly how many times a process must be
               repeated.

               Although we can use a while-structure to code a counting loop, Java's
               for statement is ideally suited for this purpose. For example, the follow-
               ing for statement will also print the word "Hello" 100 times:

                                                                                                   

                    for ( int k = 0; k < 100; k++)

                    System . out . println ( "Hello" ) ;                                           

               In fact, this for statement is equivalent to the preceding while structure.
                  The for statement has the following syntax:

               JAVA LANGUAGE RULE For Statement. The for statement has the
               following syntax:

                                       for ( initializer ; loop entry condition ; updater )

                                                                 for loop body ;

               The for statement begins with the keyword for, which is followed by a
               parenthesized list of three expressions separated by semicolons: an ini-
               tializer, a loop entry condition, and an updater. Following the paren-
               thesized list is the for loop body, which is either a single statement or a
               sequence of statements contained in curly brackets, {. . . }.
SECTION 6.3  Counting Loops                                245
                                                                    Figure 6.1: Flowchart of the for
Initializer                     k=0                                 statement.

                   Updater                         k++

    Loop     True   Statement   k<100        True
    entry          (loop body)                       println("Hello")
 condition
                                False
False

6.3.1 The For Structure

Figure 6.1 shows how the for statement works. It might be useful to
compare this flowchart with the flowchart for the the while structure
(Fig. 6.2), which was introduced in Chapter 3. You see that it has exactly
the same structure. First, the initializer is evaluated. Thus, the initializer
sets the integer variable k to 0. Then the loop entry condition, which must
be a boolean expression, is evaluated. If it is true, the body of the loop is
executed; if it is false, the body of the loop is skipped and control passes to
the next statement following the for statement. The updater is evaluated
after the loop body is executed. After completion of the updater, the loop
entry condition is reevaluated and the loop body is either executed again
or not, depending on the truth value of the loop entry condition. This
process is repeated until the loop entry condition becomes false.

             While Statement                 While Structure                     Figure 6.2: Flowchart of the
                                                                                 while statement and while
                                                                                 structure.

                                Initializer

                                                   Updater

 Condition True    Statement
False
                                    Loop     True   Statement
                                    entry          (loop body)
                                 condition

                                False
                     246                           CHAPTER 6  Control Structures

                     Tracing the order in which the for loop components are evaluated

                     gives this sequence:

                                                                                                     

                          evaluate initializer

                          e v a l u a t e loop e n t r y c o n d i t i o n ==> True

                          execute for loop body ;

                          evaluate updater

                          e v a l u a t e loop e n t r y c o n d i t i o n ==> True

                          execute for loop body ;

                          evaluate updater

                          e v a l u a t e loop e n t r y c o n d i t i o n ==> True

                          execute for loop body ;

                          evaluate updater

                          .

                          .

                          .

                          e v a l u a t e loop e n t r y c o n d i t i o n ==> F a l s e             

Loop variable scope  As this trace shows, the loop entry condition controls entry to the body
Loop bound           of the loop and will, therefore, be the last thing done before the loop
                     terminates.

                        We have followed the standard convention of declaring the counter
                     variable in the header of the for statement. This restricts the variable's
                     scope to the for statement itself. It would be a syntax error to use k outside
                     the scope of the for loop, as in this example:

                                                                                                     

                     for ( int k = 0; k < 100; k++)
                        System . out . println ( "Hello" ) ;

                             // S y n t a x e r r o r , k u n d e c l a r e d

                     System . out . println ( "k = " + k ) ;
                                                                                                     

                     For some problems, it might be necessary to use the loop variable out-

                     side the scope of the for statement, in which case the variable should be

                     declared before the for statement. For example, if we want to print the

                     value of the loop variable, k, after the loop completes, we have to declare

                     it before the loop:

                                                                                                     

                     int k = 0;             // D e c l a r e t h e l o o p v a r i a b l e h e r e

                     for (k = 0; k < 100; k++)

                             System . out . println ( "Hello" ) ;

                     System . out . println ( "k = " + k ) ; // To u s e i t h e r e
                                                                                                     

                     In this example, the loop will exit when k becomes 100, so "k = 100" will
                     be printed.

                     6.3.2 Loop Bounds

                     A counting loop starts at some initial value and counts 0 or more itera-
                     tions. A loop bound is a value that controls how many times a loop is
                     repeated. A loop will repeat until its loop bound is reached. In a count-
                     ing loop, the loop entry condition should be a boolean expression that tests
                     whether the loop's bound has been reached. Similarly, in a counting loop,
                     the updater should modify the loop counter so that it makes progress to-
SECTION 6.3  Counting Loops                                             247

ward reaching its bound. Counting loops often increment or decrement              
their counter by 1, depending on whether the loop is counting forward
or backward. The following method contains a countdown loop, which                
prints 10 9 8 7 6 5 4 3 2 1 BLASTOFF. In this case, progress to-                   Unit indexing
ward the loop bound is made by decrementing the loop counter:

 

    public void countdown ( ) {
           f o r ( i n t k = 1 0 ; k > 0 ; k--)
                  System . out . print (k + " " ) ;
           System . out . p r i n t l n ( "BLASTOFF" ) ;

    } // countdown ( )
 

Note in this case that we are using unit indexing instead of zero indexing,
because countdowns repeat, or iterate, from 10 down to 1, not from 10
down to 0.

6.3.3 Infinite Loops

If the loop bound is never reached, the loop entry condition will never            Infinite loop
become false and the loop will repeat forever. This is known as an infinite       
loop. Can you see why each of the following for statements will result in
an infinite loop?



f o r ( i n t k = 0 ; k < 1 0 0 ; k--)       // I n f i n i t e l o o p
       System . out . println ( "Hello" ) ;

for ( int k = 1; k != 100; k+=2)             // I n f i n i t e l o o p
       System . out . println ( "Hello" ) ;

  for ( int k = 98; k < 100; k = k / 2) //     Infinite  loop
         System . out . println ( "Hello" ) ;
                                                                                  
                                                                                   Stuck in a loop

In the first example, k starts out at 0 and is decremented on each itera-
tion, taking on values -1, -2, -3, and so on, so k will never reach its loop
bound.

   In the second example, k starts out at 1 and is incremented by 2 on each
iteration, taking on the values 3, 5, 7, and so on. Because all these values
are odd, k will never equal 100. A much safer loop bound in this case
would be k <= 100.

   In the third example, k starts out at 98 and is halved on each iteration,
taking on the values 49, 24, 12, 6, 3, 1, 0, 0, and so on, forever. Thus, it too
will be stuck in an infinite loop.

   Encountering an unintended infinite loop when developing a program
can be very frustrating. If the program is stuck in a loop that gener-
ates output, it will be obvious that it is looping, but if no output is be-
ing generated, the computer will appear to "freeze," no longer respond-
ing to your keyboard or mouse commands. Some programming envi-
ronments allow you to break out of a looping program by typing a spe-
cial keyboard command such as CONTROL-C or CTRL-ALT-DELETE or
CONTROL-APPLE-ESCAPE, but if that doesn't work you will have to re-
boot the computer, possibly causing a loss of data. The best way to avoid
248                                   CHAPTER 6  Control Structures

infinite loops is to determine that the loop's updater expression will cause
the loop to eventually reach its bound.

JAVA EFFECTIVE DESIGN Loop Design. To guard against infinite
loops, make sure that the loop bound will eventually be reached.

6.3.4 Loop Indentation

Note how indentation is used to distinguish the loop body from both the
heading and from the statement that follows the loop:

                                                                              

f o r ( i n t k = 1 0 ; k > 0 ; k--)           // Loop h e a d i n g

     System . out . print ( k + " " ) ; // I n d e n t t h e body

System . out . p r i n t l n ( "BLASTOFF" ) // A f t e r t h e l o o p
                                                                              

Indenting the loop body is a stylistic convention intended to make the
code more readable. However, the indentation itself has no effect on how
the code is interpreted by Java. Each of the following code segments
would still produce the same countdown:

                                                                              

f o r ( i n t k = 1 0 ; k > 0 ; k--)
System . out . print (k + " " ) ;
System . out . p r i n t l n ( "BLASTOFF" ) ;

f o r ( i n t k = 1 0 ; k > 0 ; k--) System . out . p r i n t ( k +" " ) ;
System . out . p r i n t l n ( "BLASTOFF" ) ;

for

( i n t k = 1 0 ; k > 0 ; k--)

System . out . print (k + " " ) ;

System . out . p r i n t l n ( "BLASTOFF" ) ;                                 


In each case the statement, System.out.println("BLASTOFF"), is
not part of the for loop body and is executed only once when the loop
terminates.

JAVA PROGRAMMING TIP Loop Indentation. To make loops more
readable, indent the loop body to set it off from the heading and to
highlight which statement(s) will be repeated.

 JAVA DEBUGGING TIP Loop Indentation. Loop indentation has no
 effect on how Java interprets the loop. The loop body is determined
 entirely by the syntax of the for statement.

Note that up to this point the loop body has consisted of a single state-
ment, such as a println() statement. But the loop body may con-
sist of any Java statement, including an if or if-else statement or a
compound statement, which contains a sequence of statements enclosed
SECTION 6.3  Counting Loops                                                        249

within braces. Consider the following examples. The first example prints
the sequence 0, 5, 10, 15, . . . 95. Its loop body consists of a single if
statement:

                                                                                         

for ( int k = 0; k < 100; k++)// P r i n t 0 5 1 0 . . . 9 5

   i f ( k % 5 == 0 ) / / L o o p b o d y : s i n g l e i f s t a t e m e n t

   System . out . p r i n t l n ( "k= " + k ) ;                                          

The next example prints the lowercase letters of the alphabet. In this case,
the loop counter is of type char, and it counts the letters of the alphabet.
The loop body consists of a single print() statement:

                                                                                         

  for ( char k = 'a ' ;    k <=  ' z ' ; k++) // P r i n t ' a ' ' b ' . . . ' z '
     System . out . print  (k +
                                 " ");    // Loop body :  single               print ()

                                                                                         

The next example prints the sequence 5, 10, 15, . . . 50, but it uses several
statements within the loop body:

                                                                                         

f o r ( i n t k = 1 ; k <= 1 0 ; k++) { // P r i n t 5 1 0 1 5 . . . 5 0

   int m = k  5;                                 // B e g i n body

   System . out . p r i n t (m + " " ) ;

}                                                // End body

                                                                                         

In this example, the scope of the local variable m, declared within the loop
body, is limited to the loop body and cannot be used outside of that scope.

JAVA LANGUAGE RULE Loop Body. The body of a for statement
consists of the statement that immediately follows the for loop
heading. This statement can be either a simple statement or a
compound statement--a sequence of statements enclosed within
braces, {. . . }.

Although braces are not required when the body of a for loop consists
of a single statement, some coding styles recommend that braces should
always be used for the body of a loop statement. For example, it is always
correct to code the for loop as

                                                                                         

f o r ( i n t k = 1 ; k <= 1 0 ; k++) { // P r i n t 1 2 . . . 1 0

   System . out . print (k + " " ) ;      // B e g i n body

}                                         // End body

                                                                                         
250                                 CHAPTER 6  Control Structures

Another advantage of this coding style is that you can easily place addi-
tional statements in the loop body by placing them within the braces.

   JAVA DEBUGGING TIP Missing Braces. A common programming
   error for novices is to forget to use braces to group the statements they
   intend to put in the loop body. When braces are not used only the first
   statement after the loop heading will be iterated.

SELF-STUDY EXERCISES

EXERCISE 6.1 Identify the syntax error in the following for loop
statements.

a.                                                                            

     for ( int k = 5 , k < 100 , k++)

     System . out . println (k ) ;                                            

b.                                                                            

     for ( int k = 0 ; k < 12 ; k--;)

     System . out . println (k ) ;                                            

EXERCISE 6.2 Identify those statements that result in infinite loops.

a.                                                                            

     for ( int k = 0; k < 100; k = k )

     System . out . println (k ) ;                                            

b.                                                                            

     f o r ( i n t k = 1 ; k == 1 0 0 ; k = k + 2 )

     System . out . println (k ) ;                                            

c.                                                                            

     f o r ( i n t k = 1 ; k >= 1 0 0 ; k = k - 2 )

     System . out . println (k ) ;                                            

EXERCISE 6.3 Suppose you're helping your little sister learn to count
by fours. Write a for loop that prints the following sequence of numbers:
1, 5, 9, 13, 17, 21, 25.

EXERCISE 6.4 What value will j have when the following loop
terminates?

                                                                              

for ( int i = 0; i < 10; i ++) {

     int j ;

     j = j + 1;

}

                                                                              
   SECTION 6.3  Counting Loops                            251

6.3.5 Nested Loops

A nested loop is a structure in which one loop is contained inside the body
of another loop, such as when a for loop body contains a for loop. For
example, suppose you are working for Giant Auto Industries, and your
boss wants you to print a table for buyers to figure the cost of buying mul-
tiple quantities of a certain part. The cost of individual parts ranges from
$1 to $9. The cost of N items is simply the unit price times the quantity.
Thus, you'll want to print something like the following table of numbers,
where the prices per unit are listed in the top row, and the prices for 2, 3
and 4 units are listed in subsequent rows:

                                                                              

   123456789

   2 4 6 8 10 12 14 16 18

   3 6 9 12 15 18 21 24 27

   4 8 12 16 20 24 28 32 36                                                   

To produce this multiplication table, we could use the following nested
for loops:

                                                                                             

1 f o r ( i n t row = 1 ; row <= 4 ; row++) { // F o r e a c h o f 4 r o w s

2     f o r ( i n t c o l = 1 ; c o l <= 9 ; c o l ++) // F o r e a c h o f 9 c o l u m n s

3      System . out . p r i n t ( c o l  row + "\ t " ) ;  // P r i n t number

4 System . out . println ( ) ;   // S t a r t a new row

5 } // f o r row                                                                             
   

Note how indenting is used here to distinguish the levels of nesting and to   Inner and outer loop
make the code more readable. In this example, the outer loop controls the     Algorithm design
number of rows in the table, hence, our choice of row as its loop counter.
The println() statement is executed after the inner loop is done iterating,
which allows us to print a new row on each iteration of the outer loop. The
inner loop prints the nine values in each row by printing the expression
col*row. Obviously, the value of this expression depends on both loop
variables.

   Let's dissect this example a bit. How many times is the for statement
in line 2 executed? The inner loop is executed once for each iteration of
the outer loop. Thus, it is executed four times, which is the same number
of times that line 4 is executed. How many times is the statement on line
3 executed? The body of the inner loop is executed 36 times--9 times for
each execution of line 2.

   Sometimes it is useful to use the loop variable of the outer loop as the
bound for the inner loop. For example, consider the following pattern:

                                                                              

   #####

   ####

   ###

   ##

   #                                                                          
252                                   CHAPTER 6  Control Structures

Note that the number of # symbols in each row varies inversely with the
row number. In row 1, we have five symbols; in row 2 we have four; and
so on down to row 5, where we have one #.

   To produce this kind of two-dimensional pattern, we need two coun-
ters: one to count the row number, and one to count the number of #
symbols in each row. Because we have to print each row's symbols before
moving on to the next row, the outer loop will count row numbers, and
the inner loop will count the symbols in each row. But note that the inner
loop's bound will depend on the row number. Thus, in row 1 we want
five symbols; in row 2 we want four symbols; and so on. If we let row be
the row number, then in each row we want to print 6 - row symbols. The
following table shows the relationship we want:

       Row         Bound (6-row)      Number of Symbols

           1       6-1                5
           2       6-2                4
           3       6-3                3
           4       6-4                2
           5       6-5                1

If we let j be the counter for the inner loop, then j will be bound by the
expression 6 - row. This leads to the following nested loop structure:

                                                                               

   f o r ( i n t row = 1 ; row <= 5 ; row++) { // F o r e a c h r o w

     f o r ( i n t j = 1 ; j <= 6 - row ; j ++) // P r i n t t h e r o w

     System . out . print ( '# ' ) ;

     System . out . println ( ) ;     // S t a r t a new l i n e

   } // f o r row

                                                                               

Note that the bound of the inner loop varies according to the value of row,
the loop counter for the outer loop.

SELF-STUDY EXERCISE

EXERCISE 6.5 As the engineer hired to design ski jumps, write a nested
for loop to print the following pattern:

                                                                          

#

##

###

####

#####
                                                                          

6.4 Example: Car Loan

Recall the self-study exercise from Chapter 5 that calculated the value of a
bank CD (a) given its initial principle (p), interest rate (r), and number of
years (n), using the formula a = p(1 + r)n. This section explains how to use
SECTION 6.4  Example: Car Loan                                       253

the same formula to calculate the cost of a car loan for different interest
rates over various time periods.

Problem Description

For example, suppose you are planning on buying a car that costs $20,000.
You find that you can get a car loan ranging anywhere from 8 to 11 percent,
and you can have the loan for periods as short as two years and as long as
eight years. Let's use our loop constructs to create a table to show what the
car will actually cost you, including financing. In this case, a will represent
the total cost of the car, including the financing, and p will represent the
price tag on the car ($20,000):

                                                                                       

  8%                       9%    10%                             11%

Year 2 $23 ,469.81 $23 ,943.82 $24 ,427.39 $24 ,920.71

Year 3 $25 ,424.31 $26 ,198.42 $26 ,996.07 $27 ,817.98

Year 4 $27 ,541.59 $28 ,665.32 $29 ,834.86 $31 ,052.09

Year 5 $29 ,835.19 $31 ,364.50 $32 ,972.17 $34 ,662.19

Year 6 $32 ,319.79 $34 ,317.85 $36 ,439.38 $38 ,692.00

Year 7 $35 ,011.30 $37 ,549.30 $40 ,271.19 $43 ,190.31

Year 8 $37 ,926.96 $41 ,085.02 $44 ,505.94 $48 ,211.60
                                                                                       

Algorithm Design

The key element in this program is the nested for loop that generates the               Nested loop design
table. Because the table contains seven rows, the outer loop should iterate            
seven times, through the values 2, 3, . . . 8:                                         
                                                                                       

                                                                                       
  f o r ( i n t y e a r s = 2 ; y e a r s <= 8 ; y e a r s ++)
                                                                                       
                                                                                       
The inner loop should iterate through each of the interest rates, 8 through
11:



  for ( int years =        2 ; y e a r s <= 8 ; y e a r s ++) {
       for ( int rate      = 8 ; r a t e <= 1 1 ; r a t e ++) {
       } // f o r r a t e

  } // f o r y e a r s


The financing calculation should be placed in the body of the inner loop
together with a statement to print one cell (not row) of the table. Suppose
the variable we use for a in the formula is carPriceWithLoan, and the
variable we use for the actual price of the car is carPrice. Then our inner
loop body is



  carPriceWithLoan = carPrice 
           Math . pow( 1 + r a t e / 1 0 0 . 0 / 3 6 5 . 0 , y e a r s  3 6 5 . 0 ) ;

  System . out . print ( dollars . format ( carPriceWithLoan ) +"\ t " ) ;


Note that the rate is divided by both 100.0 (to make it a percentage) and by
365.0 (for daily compounding), and the year is multiplied by 365.0 before
these values are passed to the Math.pow() method. It is important here
                                  254             CHAPTER 6  Control Structures

                                  to use 100.0 and not 100 so that the resulting value is a double and not
                                  the int 0.

                                  Implementation

Formatting output                 The program must also contain statements to print the row and column
                                  headings. Printing the row headings should be done within the outer
                                  loop, because it must be done for each row. Printing the column head-
                                  ings should be done before the outer loop is entered. Finally, our program
                                  should contain code to format the dollar and cents values properly. For
                                  this we use the java.text.NumberFormat class that was described in
                                  Chapter 5. The complete program is shown in Figure 6.3.

                                                                                                                                                                  

                   import j a v a . t e x t . NumberFormat ; // F o r f o r m a t t i n g $ n n . dd o r n%

                   public class CarLoan {
                      public s t a t i c void main ( S t r i n g args [ ] ) {
                          double carPrice = 20000; // Car ' s a c t u a l p r i c e
                          double carPriceWithLoan ; // T o t a l c o s t o f t h e c a r p l u s f i n a n c i n g

                                                                                                                              // Number f o r m a t t i n g code

                          NumberFormat d o l l a r s = NumberFormat . getCurrencyInstance ( ) ;
                          NumberFormat percent = NumberFormat . g e t P e r c e n t I n s t a n c e ( ) ;
                          percent . setMaximumFractionDigits ( 2 ) ;

                                                                                                                         // P r i n t t h e t a b l e

                          f o r ( i n t r a t e = 8 ; r a t e <= 1 1 ; r a t e ++) // P r i n t t h e c o l u m n h e a d i n g
                             System . out . print ( "\ t " + percent . format ( rate /100.0) + "\ t " ) ;

                          System . out . println ( ) ;

                   f o r ( i n t y e a r s = 2 ; y e a r s <= 8 ; y e a r s ++) { // F o r y e a r s 2 t h r o u g h 8

                   System . out . print ( "Year " + years + "\ t " ) ; // P r i n t row h e a d i n g

                   f o r ( i n t r a t e = 8 ; r a t e <= 1 1 ; r a t e ++) { // C a l c a n d p r i n t CD v a l u e

                   carPriceWithLoan = carPrice 

                                         Math . pow( 1 + r a t e / 1 0 0 . 0 / 3 6 5 . 0 , y e a r s  3 6 5 . 0 ) ;

                   System . out . print ( dollars . format ( carPriceWithLoan ) + "\ t " ) ;

                   } // f o r r a t e

                   System . out . println ( ) ;   // S t a r t a new row

                   } // f o r y e a r s

                   } // main ( )

                   } // CarLoan

                                                                                                                                                                  

                                                 Figure 6.3: The CarLoan application.
SECTION 6.5  Graphics Example: Drawing a Checkerboard    255

6.5 Graphics Example: Drawing a Checkerboard

In this section we will combine some of the graphics methods we have
learned with the nested for-loop structure to draw a checkerboard with
checkers on it (Fig. 6.4). For this example, we will just concentrate on
drawing the checkerboard. We will not worry about providing a full
checkerboard representation, of the sort we would need if we were writing
a program to play the game of checkers. So, our design will not involve in-
stance variables for whose turn it is, how many checkers each player has,
where the checkers are located on the board, and other elements of the
game's state. Still, our visible representation of the board should be de-
signed so that it will eventually be useful when we do develop a checkers
game in Chapter 8.

Problem Description and Specification                                        Figure 6.4: A checkerboard with
                                                                             checkers.
The specification for this problem is to develop a program that will draw a
checkerboard and place upon it the checkers in their appropriate starting
positions. As with many of our programs, our design will involve two
classes, one which defines the user interface and the other which repre-
sents the computational object. For this problem, the computational object
will be defined in the CheckerBoard class. The details of its design are
described in the next section.

   Because the purpose of this example is to focus on how we
use loops and drawing methods, we will employ a very simple
JFrame interface, whose implementation is given in Figure 6.5. As
shown there, the program simply creates a CheckerBoard instance

                                                          

import java . awt .  ;
import javax . swing .  ;

public class CheckerBoardFrame extends JFrame {
     private CheckerBoard theBoard ;

  public CheckerBoardFrame ( ) {
         theBoard = new CheckerBoard ( ) ;

  }

  public void paint ( Graphics g) {
         super . paint (g ) ;
         theBoard . draw ( g ) ;

  } // p a i n t ( )

  public s t a t i c void main ( S t r i n g [ ] args ){

     CheckerBoardFrame c = new CheckerBoardFrame ( ) ;

     c . setSize (500 ,500);

     c . setVisible ( true );

  }

} // C h e c k e r B o a r d F r a m e

                                                          

     Figure 6.5: The CheckerBoardFrame class.

in its CheckerBoardFrame() constructor, and then invokes the
CheckerBoard's draw method in its paint() method. The reason we
                     256                         CHAPTER 6  Control Structures

                     invoke the draw() method in paint() is because we need to have ac-
                     cess to the JFrame's Graphics context, which is passed as an argument
                     to the draw() method. Recall that the main() method is invoked when
                     CheckerBoardFrame is run,and then the paint() methods are invoked
                     automatically by calling the setVisible(true) method in main().
                     Thus, the action taken by this program is simply to draw a visual rep-
                     resentation of the checkerboard.

                     Class Design: CheckerBoard

                     Because the program will invoke its draw() method, this method must

                     be part of the CheckerBoard's interface. Hence, it must be declared

                     public. The task of drawing a checkerboard involves two distinct sub-

                     tasks: (1) drawing the board itself, which will involve drawing a square

                     with smaller squares of alternating colors; and, (2) drawing the check-

                     ers on the checkerboard. A good design for the draw() method would

                     be simply to invoke helper methods that encapsulate these two subtasks.

                     This is good method design because it results in relatively small methods,

                     each of which performs a very well-defined task. Let's call these methods

                     drawBoard() and drawCheckers(), respectively. Their signatures are

                     shown in Figure 6.6, which summarizes the design of the CheckerBoard

                     class.

                     Before gettinginto the details of the drawBoard and drawCheckers()

                     methods, we must first discuss CheckerBoard's several instance vari-

                     ables. The first two variables LEFT X and UPPER Y, give the absolute po-

                     sition of the upper left corner of the checkerboard on the JFrame's drawing

                     panel. The SQ SIDE variable gives the size of the checkerboard's individ-

                     ual squares. N ROWS and N COLS give the number of rows and columns

                     in the checkerboard (typically, 8 by 8). All of these variables are integers.

                     The final four variables, SQ COLOR1, SQ COLOR2, CHECKER COLOR1, and

Figure 6.6: Design of the CHECKER COLOR2, specify the colors of the checkerboard and the check-

CheckerBoard class.  ers.

                     Note that the names of all the instance variables are written in upper-

                     case letters. This is to identify them as symbolic constants--that is, as fi-

                     nal variables whose values do not chage once they are initialized. Because

                     their actual values are not important, we do not show them in the UML

                     diagram and we won't discuss them here. Recall that the advantage of

                     defining class constants, rather than sprinkling literal values throughout

                     the program, is that they make it easy to modify the program if we decide

                     to change the size, location, or color of the checkerboard.

                     Method Design

                     Returning now to the design of CheckerBoard's instance methods, the
                     complete definition of the CheckerBoard class is given in Figure 6.7.
                     Note how simple its draw() method is. As we noted earlier, in order
                     to using Java's drawing commands, it is necessary to have a reference to a
                     Graphics object. This is passed to the draw() method when the draw()
                     method is invoked in the program. Because the draw() method delegates
                     the details of the drawing algorithm to its helper methods, drawBoard()
                     and drawCheckers(), it has to pass them a reference to the Graphics
                     object.

                        The drawBoard() method uses a nested for loop to draw an 8  8
                     array of rectangles of alternating colors. The loop variables, row and col,
   SECTION 6.5  Graphics Example: Drawing a Checkerboard             257
                                                                               

  import java . awt .  ;

public class CheckerBoard {

                       // D e f a u l t v a l u e s f o r a s t a n d a r d c h e c k e r b o a r d

  private f i n a l i n t LEFT X = 1 0 ;                     // P o s i t i o n o f l e f t

  p r i v a t e f i n a l i n t UPPER Y = 1 0 ;                       // upper c o r n e r

  private f i n a l int SQ SIDE = 4 0 ;                      // S i z e o f e a c h s q u a r e

  p r i v a t e f i n a l i n t N ROWS = 8 ;                 // C h e c k e r b o a r d rows

  p r i v a t e f i n a l i n t N COLS = 8 ;      // C h e c k e r b o a r d columns

  p r i v a t e f i n a l Color SQ COLOR1 = Color . l i g h t G r a y ; // C o l o r s

  p r i v a t e f i n a l Color SQ COLOR2 = Color . gray ; // o f s q u a r e s

  p r i v a t e f i n a l Color CHECKER COLOR1 = Color . white ; // a n d

  p r i v a t e f i n a l Color CHECKER COLOR2 = Color . b l a c k ; // c h e c k e r s

  private void drawBoard ( Graphics g ) {

  f o r ( i n t row = 0 ; row < N ROWS; row++)

// For e a c h row

  f o r ( i n t c o l = 0 ; c o l < N COLS ; c o l ++) { // F o r e a c h s q u a r e

              i f ( ( row + c o l ) % 2 == 0 )

// A l t e r n a t e c o l o r s

              g . s e t C o l o r (SQ COLOR1 ) ;

// L i g h t

              else

              g . s e t C o l o r (SQ COLOR2 ) ;

// or dark

              g . f i l l R e c t ( LEFT X+ c o l SQ SIDE ,

                       UPPER Y+rowSQ SIDE , SQ SIDE , SQ SIDE ) ;

  } // f o r

  } // drawBoard ( )

  private void drawCheckers ( Graphics g ) { // P l a c e c h e c k e r s

  f o r ( i n t row = 0 ; row < N ROWS; row++) // F o r e a c h r o w

  f o r ( i n t c o l = 0 ; c o l < N COLS ; c o l ++) // F o r e a c h s q u a r e

              i f ( ( row + c o l )%2 == 1 ) { // O n e p l a y e r h a s t o p 3 r o w s

              i f ( row < 3 ) {

                       g . s e t C o l o r (CHECKER COLOR1 ) ;

                       g . f i l l O v a l ( LEFT X+ c o l SQ SIDE ,

                              UPPER Y+rowSQ SIDE , SQ SIDE -2 ,SQ SIDE - 2 ) ;

              }// i f

              i f ( row >= N ROWS - 3 ) { // O t h e r h a s b o t t o m 3 r o w s

                       g . s e t C o l o r (CHECKER COLOR2 ) ;

                       g . f i l l O v a l ( LEFT X+ c o l SQ SIDE ,

                                   UPPER Y+rowSQ SIDE , SQ SIDE -2 ,SQ SIDE - 2 ) ;

              }// i f

              }// i f

  }// d r a w C h e c k e r s ( )

  public void draw ( Graphics g ) { // Draw b o a r d a n d c h e c k e r s

  drawBoard ( g ) ;

  drawCheckers (g ) ;

  }// draw ( )

} // C h e c k e r B o a r d

                                                                                                     

                       Figure 6.7: The CheckerBoard class.
                                    258  CHAPTER 6  Control Structures

   |0123                            both range from 0 to 7. The expression used to determine alternating
-----------------                   colors tests whether the sum of the row and column subscripts is even:
0|0123                              ((row + col)%2 == 0). If their sum is even, we use one color; if odd, we
1|1234                              use the other color.
2|2345
3|3456                                 As the table in the margin shows for a 4  4 board, the sum of a board's
                                    row and column subscripts alternates between even and odd values.
                                    Thus, in row 2 column 3, the sum of the subscripts is 5.

                                       To switch from one color to the other, we use the Graphics
                                    setColor() method to alternate between the two colors designated for
                                    the checkerboard, SQ COLOR1 and SQ COLOR2. We then use the following
                                    method call to draw the colored squares:

                                                                                                                  

                                    g . f i l l R e c t ( LEFT X+ c o l SQ SIDE , UPPER Y+rowSQ SIDE ,

                                         SQ SIDE , SQ SIDE ) ;                                                    

                                    Note how we use the loop variables, row col, together with the constants
                                    specifying the top left corner of the board (UPPER Y and LEFT X) and the
                                    size of the squares (SQ SIDE) to calculate the location and size of each
                                    square. The calculation here is illustrated in Figure 6.8. The first two pa-
                                    rameters in fillRect(left,top,width,height) specify the coordi-
                                    nates for the rectangle's top-left corner. These are calculated as a func-
                                    tion of the rectangle's row and column position within the checkerboard
                                    and the rectangle's width and height, which are equal for the squares of a
                                    checkerboard.

Figure 6.8: Calculating the loca-
tions of the checkerboard squares.

                                       The drawCheckers() method also uses a nested for loop to trace
                                    through the checkerboard's rows and columns. In this case, however, we
                                    draw checkers on just the dark-colored squares--that is, those that sat-
                                    isfy the expression (row + col)%2 == 1)--on the first three rows of each
SECTION 6.6  Conditional Loops                                              259

player's side of the board. So, each player's checkers initially are located
in the first three rows and last three rows of the checker board:

                                                                                  

i f ( ( row + c o l )%2 == 1 ) { // O n e p l a y e r h a s t o p 3 r o w s

      i f ( row < 3 ) {

           g . s e t C o l o r (CHECKER COLOR1 ) ;

           g . f i l l O v a l ( LEFT X+ c o l SQ SIDE ,

            UPPER Y+rowSQ SIDE , SQ SIDE -2 ,SQ SIDE - 2 ) ;

  }// i f

      i f ( row >= N ROWS - 3 ) { // O t h e r h a s b o t t o m 3 r o w s

           g . s e t C o l o r (CHECKER COLOR2 ) ;

           g . f i l l O v a l ( LEFT X+ c o l SQ SIDE ,

            UPPER Y+rowSQ SIDE , SQ SIDE -2 ,SQ SIDE - 2 ) ;

  }// i f

}// i f

                                                                                  

Because the checkers are circles, we use the fillOval() method to draw
them. Note that the parameters for fillOval(left, top, width,
height) are identical to those for fillRect(). The parameters spec-
ify an enclosing rectangle in which the oval is inscribed. In this case, of
course, the enclosing rectangle is a square, which causes fillOval() to
draw a circle.

   Our design of the CheckerBoard class illustrates an important princi-
ple of method design. First, rather than placing all of the commands for
drawing the checkerboard and the checkers into one method, we broke
up this larger task into distinct subtasks. This resulted in small methods,
each of which has a well defined purpose.

JAVA EFFECTIVE DESIGN Method Decomposition. Methods
should be designed to have a clear focus. If you find a method
becoming too long, you should break its algorithm into subtasks and
define a separate method for each subtask.

6.6 Conditional Loops

Unlike the problems in the previous sections, not all loops can be coded as
counting loops. Here's a problem that can't be solved by a counting loop.

   Mathematicians, especially number theorists, have found that certain
operations on numbers lead to interesting sequences. For example, the
3N+1 problem is a conjecture in number theory, which says that if N is any
positive integer, then the sequence generated by the following rules will
always terminate at 1.

                                                                                  

Case        Operation
----        ---------

N i s odd   N= 3 N+ 1

N i s even  N=N/ 2                                                                

                260                                 CHAPTER 6  Control Structures

Sentinel bound  In other words, start with any positive integer, N. If N is odd, multiply
                it by 3 and add 1. If N is even, divide it by 2. In either case, assign the
                result back to N. The conjecture states that N will eventually equal 1. For
                example, if N is initially 26, then the sequence generated is 26, 13, 40, 20,
                10, 5, 16, 8, 4, 2, 1.

                   The 3N+1 problem is an example of a noncounting loop. Because for
                any given N we don't know how long the 3N+1 sequence will be, we
                need a loop that terminates when the loop variable reaches a certain value,
                called a sentinel value--when N equals 1. This is an example of a loop that
                is terminated by a sentinel bound. With the exception of infinite loops, all
                loops are bounded by some condition, which is why they are sometimes
                referred to as conditional loop structures. The count and sentinel bounds
                are just special cases of the conditional loop structure.

                6.6.1 The While Structure, Revisited

                Consider the following pseudocode algorithm for the 3N+1 problem:

                                                                                               

                Algorithm f o r computing t h e 3N+1 sequence
                       While N i s not equal to 1 , do : {
                              Print N.
                              I f N i s even , divide i t by 2 .
                              I f N i s odd , mu lt ip ly N by 3 and add 1 .
                       }

                     Print N                                                                   

                In this structure, the body of the loop prints N and then updates N's value,
                using the 3N+1 rules. Suppose N equals 5 when this code segment begins.
                It will print the following sequence: 5, 16, 8, 4, 2, 1. Note that the loop
                body is entered as long as N is not equal to 1. So the loop entry condition
                in this case is N != 1. Conversely, the loop will terminate when N equals
                1. Also note that in this code segment the loop bound is tested before the
                body of the loop is executed.

                   We can implement this algorithm using Java's while statement, whose
                flowchart is shown in Figure 6.2:

                                                                                               

                while (N != 1 ) {                   // While N n o t e q u a l t o 1

                     System . out . p r i n t (N + " " ) ; // P r i n t N

                     i f (N % 2 == 0 )              // I f N i s even

                           N = N / 2;               // d i v i d e i t by 2

                     else                           // I f N i s odd

                           N = 3  N + 1;            // m u l t i p l y by 3 and add 1

                }

                System . out . p r i n t l n (N) ;  // P r i n t N

                                                                                               

                Recall that unlike the for statement, the while statement does not con-
                tain syntax for the initializer and the updater. These must be coded sepa-
                rately. As we pointed out in Chapter 3, the while structure (as opposed to
SECTION 6.6  Conditional Loops                                             261

the while statement) is a segment of code built by the programmer that
satisfies the following design principle:

JAVA EFFECTIVE DESIGN Loop Structure. A properly designed
loop structure must include an initializer, a loop-entry condition, and an
updater. The updater should guarantee that the loop-entry condition
will eventually become false, thereby causing the loop to terminate.

The while structure has the following form:

                                                                                 

InitializerStatements ;            // I n i t i a l i z e r

while ( loop entry condition ) { // Bound t e s t

    Statements ;                   // Loop body

    UpdaterStatements ;            // U p d a t e r

}

                                                                                 

As its form suggests, the while structure is designed so that on some
conditions the loop body will never be executed. Because it tests for the
loop bound before the loop body, it is possible that the loop body is never
executed. We might say that it is designed to perform 0 or more iterations.

   For example, going back to the 3N+1 problem, what if N equals 1 ini-
tially? In that case, the loop body will be skipped, because the loop entry
condition is false to begin with. No iterations will be performed, and the
algorithm will simply print the value 1.

   The while structure would be an appropriate control structure for the
following type of problem:

                                                                                 

write the problems on the assignment sh eet // I n i t i a l i z e r

while ther e are problems on the sheet               // Bound t e s t

    do a problem                                     // Loop body

         cross i t off the assignment sheet                  // U p d a t e r

                                                                                 

It is possible that the assignment sheet contains no homework problems
to begin with. In that case, there's no work for the body of the loop to do
and it should be skipped.

SELF-STUDY EXERCISES

EXERCISE 6.6 Identify the syntax error in the following while struc-
tures:

a.                                                                               

int k = 5;

while (k < 100) {

    System . out . println (k ) ;

    k++

}

                                                                                 
                     262                                     CHAPTER 6  Control Structures
                                                                                                             
                     b.
                                                                                                             
                         int k = 0;
                         while (k < 12 ; ) {

                              System . out . println (k ) ;
                              k++;
                         }
                      

                     EXERCISE 6.7 Determine the output and/or identify the error in each
                     of the following while structures:

                     a.                                                                              

                     int k = 0;

                     while (k < 100)

                         System . out . println (k ) ;                                               

                     b.                                                                              

                     while (k < 100) {

                         System . out . println (k ) ;

                         k++;

                     }

                                                                                                     

Problem description  EXERCISE 6.8 Your younger sister is now learning how to count by
Algorithm design     sixes. Write a while loop that prints the following sequence of numbers:
                     0, 6, 12, 18, 24, 30, 36.

                     EXERCISE 6.9 Here's another number theory problem. Start with any
                     positive integer, N. If N is even, divide it by 2. If N is odd, subtract 1 and
                     then divide it by 2. This will generate a sequence that is guaranteed to
                     terminate at 0. For example, if N is initially 15, then you get the sequence:
                     15, 7, 3, 1, 0. Write a method that implements this sequence using a while
                     statement.

                     6.6.2 The Do-While Structure

                     Here's another problem that can't be solved with a counting loop. Your
                     father has been fretting about the bare spots on the front lawn and is con-
                     sidering hiring the ChemSure Lawn Service to fertilize. However, your
                     scientifically minded younger sister wants to reassure him that at the rate
                     the grass is dying, there will be enough to last through the summer. Using
                     techniques she learned in biology, your sister estimates that the grass is
                     dying at the rate of 2 percent per day. How many weeks will it take for
                     half the lawn to disappear?

                        One way to solve this problem would be to keep subtracting 2 percent
                     from the current amount of grass until the amount dipped below 50 per-
SECTION 6.6  Conditional Loops                                                    263

cent, all the while counting the number of iterations required. Consider
the following pseudocode algorithm:

                                                                                        
                                                                                        
  Algorithm for calculating grass loss
         I n i t i a l i z e amtGrass to 100.0                                           Limit bound
         I n i t i a l i z e nDays to 0                                                 
         Repeat the following statements                                                
                amtGrass -= amtGrass  0 . 0 2 ;
                ++nDays ;
         As long as amtGrass > 5 0 . 0
         P r i n t nDays / 7



We begin by initializing amtGrass to 100.0, representing 100 percent.
And we initialize our counter, nDays to 0. Then we repeatedly subtract 2
percent of the amount and increment the counter until the amount drops
below 50 percent. In other words, in this case, we repeat the loop body
as long as the amount of grass remains above 50 percent of the original.
When the loop finishes, we report the number of weeks it took by dividing
the number of days by 7.

   The loop bound in this case is known as a limit bound. The loop will
terminate when a certain limit has been reached--in this case, when the
amount of grass dips below 50 percent of the original amount. Note that
in this case the loop bound is tested after the loop body. This is appropri-
ate for this problem, because we know in advance that the loop will iter-
ate at least once. We can implement this algorithm using Java's do-while
statement:



public int losingGrass ( double perCentGrass ) {

  double amtGrass = 1 0 0 . 0 ; // I n i t i a l i z e amount g r a s s

  i n t nDays = 0 ;               // I n i t i a l i z e day c o u n t e r

  do {                                           // R e p e a t

  amtGrass -= amtGrass  LOSSRATE ; // U p d a t e a m o u n t

  ++nDays ;                       //  Increment the counter

  } while ( amtGrass > perCentGrass ) ;

                                  // As l o n g as enough g r a s s r e m a i n s

  return nDays / 7 ;              // R e t u r n t h e number o f weeks

  } // l o s i n g G r a s s ( )


The do-while statement is a loop statement in which the loop entry con-
dition occurs after the loop body. It has the following general form:

JAVA LANGUAGE RULE Do-while Statement. The do-while
statement has the following syntax:

                           do
                                           loop body

                        while ( loop entry condition ) ;

Note, again, that unlike the for statement, the do-while statement does
not contain syntax for the initializer and the updater. These must be coded
separately.
                                                 264  Do-While Statement              CHAPTER 6  Control Structures
Figure 6.9: Flowchart of the
do-while statement and                                                                 Do-While Structure
do-while structure.

                                                                Statement                 Initializer1

                                                                Condition True            Initializer2
                                                               False                      Statement
                                                                                           Updater

                                                                                              Loop              True
                                                                                              entry
                                                                                           condition

                                                                                          False

   To further highlight the difference between a loop statement and a loop
structure, the do-while structure takes the following form:

                                                                                                                             

InitializerStatements1 ;                                                              // I n i t i a l i z e r

do {                                                                                  // B e g i n n i n g o f l o o p body

                                                      InitializerStatements2 ; // Another i n i t i a l i z e r

                                                      Statements ;                    //  Loop body

                                                      UpdaterStatements               //  Updater

} while ( loop entry condition ) ; // Bound t e s t                                                                          


Note that initializer statements may be placed before the loop body, at the
beginning of the loop body, or in both places, depending on the particular
problem. Like the other loop structures, updater statements occur within
the body of the loop. A flowchart of the do-while structure is shown in
Figure 6.9.

   The do-while structure would be an appropriate control structure for
the following type of problem:

                                                                                                                             

do

                                                      d i a l the d e s i r e d telephone number // I n i t i a l i z e r

                                                      i f you get a busy s i g n a l

                                                      hang up                             // U p d a t e r

while there i s a busy signal                                                             // Bound t e s t

                                                                                                                             
SECTION 6.6  Conditional Loops      265

In this case, you want to perform the actions in the body of the loop at
least once and possibly more than once (if you continue to receive a busy
signal).

JAVA EFFECTIVE DESIGN Do-While Loops. The do-while loop is
designed for solving problems in which at least one iteration must
occur.

JAVA EFFECTIVE DESIGN While versus Do-While Structures. For
problems where a noncounting loop is required, the while loop
structure is more general and, therefore, preferable to the do-while
structure. Use do-while only when at least one iteration must occur.

SELF-STUDY EXERCISES

EXERCISE 6.10 Identify the syntax error in the following do-while
structures:

a.                                                                              

int k = 0;

do while ( k < 1 0 0 )

{     System . out . println (k ) ;

      k++

}

                                                                                

b.                                                                              

int k = 0;

do {

      System . out . println (k ) ;

      k++;

} while (k < 12)                                                                


EXERCISE 6.11 Your sister has moved on to counting by sevens. Write
a do-while loop that prints the following sequence of numbers: 1, 8, 15,
22, 29, 36, 43.

EXERCISE 6.12 As the owner of Pizza Heaven, every night at the close
of business you quickly enter the price of every pizza ordered that day.
You take the data from the servers' receipts. Pizzas cost $8, $10, or (the
Heavenly Special) $15. You enter the data without dollar signs, and use
99 to indicate you're finished for the day. Write a Java method to input
and validate a single pizza data item. If an incorrect price is entered, the
program should print an error message and prompt for corrected input.
Correct input is used to compute a daily total.

EXERCISE 6.13 Because the pizza prices in the previous exercise are
fixed, change the method so you can save time on keyboarding. Instead of
entering the price, you'll enter codes of 1, 2, or 3 (corresponding to the $8,
$10, and $15 pizzas), and 0 to indicate that you're finished. Validate that
the data value entered is correct and then convert it to the corresponding
price before returning it.
                                      266                             CHAPTER 6  Control Structures

                                      6.7 Example: Computing Averages

Algorithm design: what kind of loop?  Suppose you want to compute the average of your exam grades in a
Algorithm design                      course. Grades, represented as real numbers, will be input from the key-
Priming read                          board using our KeyboardReader class. To signify the end of the list,
Initialization step                   we will use a sentinel value--9999 or -1 or some other value that won't
                                      be confused with a legitimate grade. Because we do not know exactly
                                      how many grades will be entered, we will use a noncounting loop in this
                                      algorithm. Because there could be no grades to average, we will use a
                                      while structure so it is possible to skip the loop entirely in the case that
                                      there are no grades to average.

                                         The algorithm should add each grade to a running total, keeping track
                                      of the number of grades entered. Thus, this algorithm requires two vari-
                                      ables: one to keep track of the running total and the other to keep track
                                      of the count. Both should be initialized to 0. After the last grade has been
                                      entered, the total should be divided by the count to give the average. In
                                      pseudocode, the algorithm for this problem is as follows:

                                                                                                                    

                                      initialize runningTotal to 0         // I n i t i a l i z e

                                      i n i t i a l i z e count to 0

                                      prompt and read the f i r s t grade  // P r i m i n g r e a d

                                      while the grade entered i s not 9999 {// S e n t i n e l t e s t

                                           add i t to the runningTotal

                                           add 1 to the count

                                           prompt and read the next grade // U p d a t e

                                      }

                                      if ( count > 0)                 // Guard a g a i n s t d i v i d e by 0

                                           divide runningTotal by count

                                      output the average as the result                                              
                                      

                                      Note that in this problem our loop variable, grade, is read before the
                                      loop test is made. This is known as a priming read. It is necessary in this
                                      case, because the loop test depends on the value that is read. Within the
                                      loop's body, the updater reads the next value for grade. This is a standard
                                      convention for coding while structures that involve input, as this prob-
                                      lem does. Note also that we must make sure that count is not 0 before
                                      we attempt to compute the average because dividing by 0 would cause a
                                      divide-by-zero error.

                                         Translating the pseudocode algorithm into Java raises several issues.
                                      Suppose we store each grade that is input in a double variable named
                                      grade. The loop will terminate when grade equals 9999, so its entry con-
                                      dition will be (grade != 9999). Because this condition uses grade, it
                                      is crucial that the grade variable be initialized before the bound test is
                                      made. This requires a priming read. By reading the first value of grade
                                      before the loop entry condition is tested, ensures that the loop will be
                                      skipped if the user happens to enter the sentinel (9999) on the very first
                                      prompt. In addition to reading the first exam score, we must initialize
                                      the variables used for the running total and the counter. Thus, for our
                                      initialization step, we get the following code:
SECTION 6.7  Example: Computing Averages                                            267

                                                                                          

  double runningTotal = 0;                                                                
  int count = 0;                                                                           Updater step
  reader . prompt ( " Input a grade ( e . g . , 8 5 . 3 ) " +
                                                                                          
             " or 9999 t o i n d i c a t e t h e end o f t h e l i s t >> " ) ;
  double grade =                                                                          
                                                                                           Modularity
           reader . getKeyboardDouble ( ) ; // P r i m i n g i n p u t
                                                                                          

Within the body of the loop we must add the grade to the running total                    
and increment the counter. Since these variables are not tested in the loop
entry condition, they will not affect the loop control. Our loop updater
in this case must read the next grade. Placing the updater statement at
the end of the loop body will ensure that the loop terminates immediately
after the user enters the sentinel value:



while ( grade != 9999) {              // Loop t e s t : s e n t i n e l

  r u n n i n g T o t a l += grade ;

  count ++;

  reader . prompt ( " Input a grade ( e . g . , 8 5 . 3 ) " +

  " or 9999 t o i n d i c a t e t h e end o f t h e l i s t >> " ) ;

  grade = reader . getKeyboardDouble ( ) ; // Update : i n p u t

  } // w h i l e


You can see that it is somewhat redundant to repeat the same statements
needed to do the initializating and the updating of the grade variable. A
better design would be to encapsulate these into a method and then call
the method both before and within the loop. The method should take care
of prompting the user, reading the input, converting it to double, and
returning the input value. The method doesn't require a parameter:



p r i v a t e double promptAndRead ( ) {
   reader . prompt ( " Input a grade ( e . g . , 8 5 . 3 ) " +
        " or 9999 t o i n d i c a t e t h e end o f t h e l i s t >> " ) ;
   double grade = reader . getKeyboardDouble ( ) ;

                                                               // Confirm i n p u t

     System . out . p r i n t l n ( "You input " + grade + "\n" ) ;
     return grade ;
  }


Note that we have declared this as a private method. It will be used
to help us perform our task but won't be available to other objects. Such
private methods are frequently called helper methods.

   This is a much more modular design. In addition to cutting down on
redundancy in our code, it makes the program easier to maintain. For
example, there is only one statement to change if we decide to change the
                      268                                      CHAPTER 6  Control Structures

                      prompt message. It also makes the program easier to debug. Input errors
                      are now localized to the promptAndRead() method.

                      JAVA EFFECTIVE DESIGN Modularity. Encapsulating code in a
                      method is a good way to avoid redundancy in a program.

                      JAVA DEBUGGING TIP Localization. Encapsulating code in a
                      method removes the need to have the same code at several locations in
                      a program. By localizing the code in this way, you make it easier to
                      modify and debug.

                      Another advantage of encapsulating the input task in a separate method
                      is that it simplifies the task of calculating the average. This task should
                      also be organized into a separate method:

                                                                                                      

                      public double inputAndAverageGrades ( ) {

                           double runningTotal = 0;

                           int count = 0;

                           double grade = promptAndRead ( ) ; // P r i m i n g i n i t i a l i z e r

                           while ( grade != 9999) {            // Loop t e s t : s e n t i n e l

                           r u n n i n g T o t a l += grade ;

                           count ++;

                           grade = promptAndRead ( ) ; // U p d a t e : g e t n e x t g r a d e

                           } // w h i l e

                           if ( count > 0)  // Guard a g a i n s t d i v i d e -by - z e r o

                           return runningTotal / count ; // R e t u r n t h e a v e r a g e

                           else

                           return 0;        // S p e c i a l ( e r r o r ) r e t u r n v a l u e

                      }

                                                                                                      

Method decomposition  Note that we have declared this as a public method. This will be the
                      method you call to calculate your course average.

                         Because we have decomposed the problem into its subtasks, each sub-
                      task is short and simple, making it easier to read and understand. As
                      we saw in the checkerboard example, the use of small, clearly-focused
                      methods is a desireable aspect of designing a program.

                         The complete Average.java application is shown in Figure 6.10. Its
                      overall design is similar to application programs we designed in previous
                      chapters. The only instance variable it uses is the KeyboardReader vari-
                      able. The other variables are declared locally, within the methods. In this
                      case, declaring them locally makes the algorithms easier to read.

                         One final point about this program is to note the care taken in the design
                      of the user interface to explain the program to the user, to prompt the user
            SECTION 6.7  Example: Computing Averages                                          269
                                                                                                 


import java . io .  ;

public class Average {                                             // C o n s o l e I /O

   p r i v a t e KeyboardReader r e a d e r = new KeyboardReader ( ) ;

   p r i v a t e double promptAndRead ( ) {

      reader . prompt ( " Input a grade ( e . g . , 8 5 . 3 ) " +

            " or 9999 t o i n d i c a t e t h e end o f t h e l i s t >> " ) ;

      double grade = reader . getKeyboardDouble ( ) ;

      System . out . p r i n t l n ( "You i n p u t " + grade + "\n" ) ; // C o n f i r m i n p u t

      return grade ;

   }

   public double inputAndAverageGrades ( ) {

      double runningTotal = 0;

      int count = 0;

      double grade = promptAndRead ( ) ; // I n i t i a l i z e : p r i m i n g i n p u t

      while ( grade != 9999) {               // Loop t e s t : s e n t i n e l

      r u n n i n g T o t a l += grade ;

      count ++;

      grade = promptAndRead ( ) ;            // Update : g e t n e x t g r a d e

      } // w h i l e

      if ( count > 0)           // Guard a g a i n s t d i v i d e -by - z e r o

      return runningTotal / count ; // R e t u r n t h e a v e r a g e

      else

      return 0;                 // S p e c i a l ( e r r o r ) r e t u r n v a l u e

}

  public s t a t i c void main ( S t r i n g argv [ ] ) {

      System . out . p r i n t l n ( " This program c a l c u l a t e s average grade . " ) ;

      Average avg = new Average ( ) ;

      double average = avg . inputAndAverageGrades ( ) ;

      i f ( average == 0 )                                         // E r r o r c h e c k

      System . out . p r i n t l n ( "You didn ' t e n t e r any grades . " ) ;

      else

      System . out . p r i n t l n ( "Your average i s " + average ) ;

} // main ( )

} // Average

                                                                                                     

            Figure 6.10: A program to compute average grade using a while struc-
            ture.

            before a value is input, and to confirm the user's input after the program
            has read it.

            JAVA EFFECTIVE DESIGN User Interface. Whenever you ask a
            user for input, the user should know why you are asking and what you
            are asking for. Prompts should be used for this purpose. It is also a
            good idea to confirm that the program has received the correct input.
                                   270                              CHAPTER 6  Control Structures

                                   6.8 Example: Data Validation

Algorithm design                   One frequent programming task is data validation. This task can take dif-
                                   ferent forms depending on the nature of the program. One use for data
User inputs        Output error    validation occurs when accepting input from the user.
    data               message
                                      In the program in the preceding section, suppose the user types -10 by
     Is it        No               mistake when asked to input an exam grade. Obviously this is not a valid
  correct?                         exam grade and should not be added to the running total. How should a
                                   program handle this task?
 Yes
  Process                             Because it is possible that the user may take one or more attempts to
                                   correct an input problem, we should use a do-while structure for this
    data                           problem. The program should first input a number from the user. The
                                   number should then be checked for validity. If it is valid, the loop should
                                   exit and the program should continue computing the before getting the
                                   input average grade. If it is not valid, the program should print an error
                                   message and input the number again. A flowchart for this algorithm is
                                   shown in Figure 6.11.

                                      For example, suppose only numbers between 0 and 100 are considered
                                   valid. The data validation algorithm would be as follows:

                                                                                                                 

                                   do                                                          input
                                    Get the next grade // I n i t i a l i z e : p r i m i n g
                                     i f the grade < 0 or grade > 100 and grade                != 9999
                                        p r i n t an e r r o r message // E r r o r c a s e

                                        // S e n t i n e l t e s t

                                   while the grade < 0 or grade > 100 and grade != 9999
                                                                                                                 

Figure 6.11: Do-while is a good    Note here that initialization and updating of the loop variable are per-
structure for the data validation  formed by the same statement. This is acceptable because we must up-
algorithm.                         date the value of grade on each iteration before checking its validity. Note
                                   also that for this problem the loop-entry condition is also used in the if
                                   statement to check for an error. This allows us to print an appropriate
                                   error message if the user makes an input error.

                                      Let's incorporate this data validation algorithm into the promptAnd-
                                   Read() method that we designed in the previous section (Fig. 6.10). The
                                   revised method will handle and validate all input and return a number
                                   between 0 and 100 to the calling method. To reflect its expanded pur-
                                   pose, we will change the method's name to getAndValidateGrade(),
                                   and incorporate it into a revised application, which we name Validate
                                   (Fig. 6.12).

                                   6.9 Principles of Loop Design

                                   Before moving on, it will be useful to summarize the main principles
                                   involved in correctly constructing a loop.

                                    A counting loop can be used whenever you know in advance exactly
                                      how many iterations are needed. Java's for statement is an appropriate
                                      structure for coding a counting loop.
                      SECTION 6.9  Principles of Loop Design                                                    271

                                                                                                                 

mport java . io .  ;

public class Validate {                                    // C o n s o l e        input

  p r i v a t e KeyboardReader r e a d e r = new KeyboardReader ( ) ;

  private double getAndValidateGrade ( ) {

     double grade = 0;

     do {

     reader . prompt ( " Input a grade ( e . g . , 8 5 . 3 ) " +

                           " or 9999 t o i n d i c a t e t h e end o f t h e l i s t >> " ) ;

     grade = reader . getKeyboardDouble ( ) ;

     i f ( ( grade ! = 9 9 9 9 ) && ( ( grade < 0 ) | | ( grade > 1 0 0 ) ) ) // I f e r r o r

           System . out . p r i n t l n ( " Error : grade must be between 0 and 100 \n" ) ;

     else

           System . out . p r i n t l n ( "You input " + grade + "\n" ) ;

/ Confirm input

     } while ( ( grade ! = 9 9 9 9 ) && ( ( grade < 0 ) | | ( grade > 1 0 0 ) ) ) ;

     return grade ;

  }

  public double inputAndAverageGrades ( ) {

     double runningTotal = 0;

     int count = 0;

     double grade = getAndValidateGrade ( ) ; // I n i t i a l i z e : p r i m i n g i n p u t

     while ( grade != 9999) {                              // Loop t e s t : s e n t i n e l

     r u n n i n g T o t a l += grade ;

     count ++;

     grade = getAndValidateGrade ( ) ;                     // Update : g e t n e x t g r a d e

     } // w h i l e

     if ( count > 0)                                       // Guard a g a i n s t d i v i d e -by - z e r o
           return runningTotal / count ;                   // R e t u r n t h e a v e r a g e

     else                                                  // S p e c i a l ( e r r o r ) r e t u r n v a l u e
           return 0;

  }

  public s t a t i c void main ( S t r i n g argv [ ] ) {

     System . out . p r i n t l n ( " This program c a l c u l a t e s average grade . " ) ; // E x p l a i n

     Average avg = new Average ( ) ;

     double average = avg . inputAndAverageGrades ( ) ;

     i f ( average == 0 )                                  // E r r o r c h e c k

     System . out . p r i n t l n ( "You didn ' t e n t e r any grades . " ) ;

     else

     System . out . p r i n t l n ( "Your average i s " + average ) ;

  } // main ( )

  // V a l i d a t e

                                                                                                                 

                      Figure 6.12: A program to compute average grade using a while struc-
                      ture. This version validates the user's input.
272                     CHAPTER 6  Control Structures

 A while structure should be used when the problem suggests that the
  loop body may be skipped entirely. Java's while statement is specially
  designed for the while structure.

 A do-while structure should be used only when a loop requires one or
  more iterations. Java's do-while statement is specially designed for the
  do-while structure.

 The loop variable is used to specify the loop-entry condition. It must be
  initialized to an appropriate initial value, and it must be updated on
  each iteration of the loop.

 A loop's bound may be a count, a sentinel, or, more generally, a conditional
  bound. It must be correctly specified in the loop-entry expression, and
  progress toward the bound must be made in the updater.

 An infinite loop may result if the initializer, loop-entry expression, or
  updater expression is not correctly specified.

The loop types are also summarized in Table 6.1.

TABLE 6.1 A summary of the design decisions required when coding a loop

Use                 If                                  Java Statement

Counting loop       Number of iterations known in advance for

While structure     Number of iterations not known      while
                    Loop may not be entered at all

Do-while structure  Number of iterations not known      do-while
                    Loop must be entered at least once

SELF-STUDY EXERCISE

EXERCISE 6.14 For each of the following problems, decide whether
a counting loop structure, a while structure, or a do-while structure
should be used, and write a pseudocode algorithm.

   Print the names of all visitors to your Web site.

   Validate that a number input by the user is positive.

   Change all the backslashes (\) in a Windows Web page address to the
      slashes (/) used in a Unix Web page address.

   Find the car with the best miles-per-gallon ratio among the cars in
      the Consumer Reports database.
SECTION 6.10  The switch Multiway Selection Structure  273

6.10 The switch Multiway Selection Structure

Another selection structure to add to our repertoire is the switch/break       
structure. It is meant to provide a shorthand way of coding the following      
type of multiway selection structure:                                          

                                                                               
                                                                                Integral expression
    i f ( i n t e g r a l V a r == i n t e g r a l V a l u e 1 )

                 // some s t a t e m e n t s

    e l s e i f ( i n t e g r a l V a r == i n t e g r a l V a l u e 2 )

                 // some s t a t e m e n t s

    e l s e i f ( i n t e g r a l V a r == i n t e g r a l V a l u e 3 )

                 // some s t a t e m e n t s

    else // some s t a t e m e n t s
 

Note that each of the conditions in this case involves the equality of an
integral variable and an integral value. This type of structure occurs so
frequently in programs that most languages contain statements specially
designed to handle it. In Java, we use a combination of the switch and
break statements to implement multiway selection.

   The switch is designed to select one of several actions depending on
the value of some integral expression:

 

    switch ( integralExpression )
    { case integralValue1 :

                     // some s t a t e m e n t s

         case integralValue2 :

                     // some s t a t e m e n t s

         case integralValue3 :

                     // some s t a t e m e n t s

         default :
                some s t at e m en t s

    }
 

The integralExpression must evaluate to a primitive integral value of type
byte, short, int, char, or boolean. It may not be a long, float,
double, or a class type. The integralValues must be literals or final vari-
ables. They serve as labels in the one or more case clauses that make up
the switch statement body. The default clause is optional, but it is a
good idea to include it.

   A switch statement is executed according to the following rules:

Rule 1. The integralExpression is evaluated.

Rule 2. Control passes to the statements following the case label whose
    value equals the integralExpression or, if no cases apply, to the default
    clause.

Rule 3. Beginning at the selected label or at the default, all of the state-
    ments up to the end of the switch are executed.
274                              CHAPTER 6  Control Structures

Consider the following example:

                                                                             

int m = 2;

switch (m)

{ case 1:

      System . out . print ( " m = 1" ) ;

     case 2:

      System . out . print ( " m = 2" ) ;

     case 3:

      System . out . print ( " m = 3" ) ;

     default :

      System . out . print ( " default case " ) ;

}

                                                                             

In this case, because m equals 2, the following output would be produced:

                                                                             

     m = 2 m = 3 default case
                                                                             

Obviously, this output does not match the following if-else multiway
selection structure, which would output, simply, m = 2:

                                                                             

int m = 2;

i f (m == 1 )

      System . out . print ( " m = 1" ) ;

e l s e i f (m == 2 )

      System . out . print ( " m = 2" ) ;

e l s e i f (m == 3 )

      System . out . print ( " m = 3" ) ;

else

      System . out . print ( " default case " ) ;                            

The reason for this disparity is that the switch executes all statements
following the label that matches the value of the integralExpression (see
again Rule 3 on the previous page).

   In order to use the switch as a multiway selection, you must force it to
break out of the case clause after executing that clause's statements:

                                                                             

int m = 2;

switch (m)

{ case 1:

      System . out . print ( " m = 1" ) ;

      break ;

     case 2:

      System . out . print ( " m = 2" ) ;

      break ;

     case 3:

      System . out . print ( " m = 3" ) ;

      break ;

     default :

      System . out . print ( " default case " ) ;

}

                                                                             
SECTION 6.10  The switch Multiway Selection Structure  275

In this example, the break statement causes control to pass to the end
of the switch, with the effect being that one and only one case will be
executed within the switch. Thus, the output of this code segment will
be simply m = 2, matching exactly the behavior of the multiway if-else
selection structure (Fig. 6.13).

                                                                         Figure 6.13: Flowchart of the mul-
                                                                         tiway switch structure. Note that
                                                                         because of the break statement,
                                                                         one and only one case is executed.

               F                F                 F
case1             case2            case n

T                 T                T

statement1        statement2       statement n

break             break            break

JAVA PROGRAMMING TIP Multiway Selection. A typical use for
the switch statement is to use it together with break to code a
multiway selection structure.

JAVA LANGUAGE RULE break. The break statement transfers
control out of its enclosing block, where a block is any sequence of
statements contained within curly brackets { and }.

JAVA DEBUGGING TIP Switch without break. A common error in
coding the switch-based multiway selection is forgetting to put a
break statement at the end of each clause. This may cause more than
one case to be executed.
276                      CHAPTER 6  Control Structures

SELF-STUDY EXERCISES

EXERCISE 6.15 Identify any errors in the following switch structures
(if there is no error, specify the output):

                                                          

(a) int k = 0;

     switch (k)

     case 0:

        System . out . println ( "zero" ) ;

        break ;

     case 1:

        System . out . println ( "one" ) ;

        break ;

     default :

        System . out . println ( " default " ) ;

        break ;                                           

                                                          

(b) int k = 0;

     switch (k + 1)

     { case 0:

                System . out . println ( "zero" ) ;

                break ;

        case 1:

                System . out . println ( "one" ) ;

                break ;

        default :

                System . out . println ( " default " ) ;

                break ;

     }

                                                          
                                                          

(c) int k = 6;

     switch (k / 3.0)

     { case 2:

                System . out . println ( "zero" ) ;

                break ;

        case 3:

                System . out . println ( "one" ) ;

                break ;

        default :

                System . out . println ( " default " ) ;

                break ;

     }

                                                          

EXERCISE 6.16 Flavors of ice cream are represented as integers where
0 is vanilla, 1 is chocolate, and 2 is strawberry. Write a switch statement
that checks an integer variable flavor and prints out the name of the ice
cream flavor or prints "Error" in the default case.

EXERCISE 6.17 Modify your solution to the previous exercise to use
constants (final variables) to represent the ice cream flavors.
SECTION 6.11  OBJECT-ORIENTED DESIGN:Structured Programming 277

6.11 OBJECT-ORIENTED DESIGN:
        Structured Programming

Structured programming is the practice of writing programs that are built up  Spaghetti code
from a small set of predefined control structures. As an overall approach
to programming, structured programming has largely been superseded            Figure 6.14: Flowcharts of the four
by the object-oriented approach. Nevertheless, its design principles are      types of control structures. Each
still relevant to the design of the algorithms and methods that make up a     small rectangle represents a single
program's objects.                                                            executable statement.

   The principles of structured programming seem so obvious today that
it may be difficult to appreciate their importance. In the 1960s and 1970s,
one of the main controls used in programs was the infamous go to state-
ment, which could be used to transfer control of a program to any arbi-
trary location within it, and from there to any other arbitrary location,
and so on. This led to incredibly complex and ill-formed programs--so
called "spaghetti code"--that were almost impossible to understand and
modify.

   Structured programming evolved in reaction to the unstructured soft-
ware development practices of the 1960s, which were fraught with budget
overruns, costly delays, and failed products. One of the classic research
results of that era was a 1966 paper by Boehm and Jacopini that showed
that any program using go to's could be represented by an equivalent pro-
gram that used a sequence of two types of controls: if/else and while
structures. Another influential paper by Edgar Dikjstra ("GoTo Statement
Considered Harmful") pointed out the various ways in which the go to
statement could lead to impossibly complex programs.

   The Pascal language, introduced by Nicklaus Wirth in 1971, was de-
signed to promote structured programming techniques and became the
language of choice within academic institutions because of its suitability
as a teaching language. In Pascal, the go to was replaced with the four
structures that control the flow of execution in a program (Fig. 6.14):

Sequence               Selection if/else

                       False  True

Repetition while loop  Method call and return
                       method1 method2
           True
     False

 Sequence--The statements in a program are executed in sequential or-
  der unless their flow is interrupted by one of the following control
  structures.
                          278               CHAPTER 6  Control Structures

                           Selection--The if, if/else, and switch statements are branching
                            statements that allow choice through the forking of the control path
                            into two or more alternatives.

                           Repetition--The for, while, and do-while statements are looping
                            statements that allow the program to repeat a sequence of statements.

                           Method Call--Invoking a method transfers control temporarily to a
                            named method. Control returns to the point of invocation when the
                            method is completed.

                          No matter how large or small a program you write, its flow of control can
                          be constructed as a combination of these four basic types of structures.

                          Preconditions and Postconditions

                          The Java language supplies us with a good collection of control structures,
                          and Java's syntax constrains the way we can use them. One of the fea-
                          tures of the four control structures is that each has a single entry point
                          and exit (Fig. 6.14). This is an extremely important property. To grasp its
                          importance, consider the following debugging problem:

                                                                                                                 

                          k = 0;            // 1 . U n s t r u c t u r e d code

                          System . out . p r i n t l n ( "k= " + k ) ; // 2 . k s h o u l d e q u a l 0 h e r e

                          goto label1 ;     // 3 .

                          label2 :

                          System . out . p r i n t l n ( "k= " + k ) ; // 4 . k s h o u l d e q u a l 1 h e r e
                                                                                                                 

                          In this example a goto statement is used to jump to label1, a label that
                          marks a section of code somewhere else in the program. Suppose we're
                          trying to determine how k has acquired an erroneous value and that its
                          value is correct in line 2 of this sequence. Given the go to statement on
                          line 3, there's no guarantee that control will ever return to the println()
                          statement on line 4. Thus, in unstructured code it is very difficult to nar-
                          row the scope of an error to a fixed segment of code. Because the go to
                          statement can transfer control anywhere in the program, with no guar-
                          antee of return, any segment of code can have multiple entry points and
                          multiple exits.

                             Now contrast the unstructured code with the following well-structured
                          code:

                                                                                                                 

                          k = 0;            // 1 . S t r u c t u r e d code

                          System . out . p r i n t l n ( "k= " + k ) ; // 2 . k s h o u l d e q u a l 0 h e r e

                          someMethod ( ) ;  // 3 .

                          System . out . p r i n t l n ( "k= " + k ) ; // 4 . k s h o u l d e q u a l 1 h e r e  
                          

Debugging with println()  In this case, we can be certain that control will eventually return to line 4.
                          If k's value is erroneous on line 4, we can trace through someMethod() to
                          find the error. Because any segment of a structured program has a single
                          entry and exit, we can use a pair of println() statements in this way to
                          converge on the location of the program bug.

                             An important implication of the single-entry/single-exit property is
                          that we can use preconditions and postconditions to help us design and
                          debug our code. The previous example provided a simple example: The
SECTION 11  OOD: Structured Programming                                                      279

precondition is that k should equal 0 on line 2, and the postcondition is that
k should equal 1 on line 4. Figure 6.15 shows some additional examples.

                                                                                             

   int k = 0; // P r e c o n d i t i o n : k == 0

   k = 5;              // A s s i g n m e n t t o k

   // P o s t c o n d i t i o n : k == 5

                                                                                              
                                                                                             

   int k = 0;                  // P r e c o n d i t i o n : k == 0

   while (k < 100) {           // While l o o p

         k = 2  k + 2;

   }

   // P o s t c o n d i t i o n : k >= 1 0 0

                                                                                              
                                                                                             

   /

       factorial (n ):

         factorial (n) is 1 if n is 0

         f a c t o r i a l ( n ) i s n  n -1  n -2  . . .  1 i f n > 0

       P r e c o n d i t i o n : n >= 0

       Postcondition :

       factorial (n) = 1 if n = 0

                               = n  n -1  n -2  . . .  1 i f n > 0

      /

   public int factorial ( int n) {

         i f ( n == 0 )

           return 1;

         else {

           int f = 1;                         // I n i t a t e m p o r a r y v a r i a b l e

           f o r ( i n t k = n ; k >= 1 ; k--) // F o r n down t o 1

                 f = f  k;                     //    Accumulate the product

           return f ;                                // R e t u r n t h e f a c t o r i a l

         } // e l s e

   } // f a c t o r i a l ( )

                                                                                              

        Figure 6.15: Using pre- and postconditions to document code.

   In the first example, we use pre- and postconditions to define the se-
mantics of an assignment statement. No matter what value k has before
the assignment, the execution of the assignment (k = 5) will make the
postcondition (k == 5) true.

   In the second example, the postcondition follows from the semantics of
the while loop. Because the loop-entry condition is k < 100, when the
loop exits the postcondition (k >= 100) must be true.

   The third example shows how pre- and postconditions can be used to
design and document methods. The factorial(n) is defined for n  0 as
follows:

                                                                                                   

   f a c t o r i a l ( n ) i s 1 , i f n == 0

   f a c t o r i a l ( n ) i s n  n-1  n-2  . . .  1 , i f n > 0
                                                                                                   
  280                                        CHAPTER 6  Control Structures

  In other words, the factorial of N is defined as the cumulative product of
  multiplying 1 times 2, times 3, and so on up to N. For example, if N is 5,
  then factorial(5) is 1 * 2 * 3 * 4 * 5 = 120.

     Note how the factorial computation is done in the method. The variable
  f, which is used to accumulate the product, is initialized to 1. Then on each
  iteration of the for loop, f is multiplied by k and the product is assigned
  back to f. This is similar to the way we accumulate a sum, except in this
  case we are accumulating a product.

     The precondition on the factorial() method represents the condi-
  tion that must be true in order for the method to work correctly. Factorial
  is undefined for n < 0, so it is important that n be greater than or equal
  to 0 whenever this method is called. Given that the precondition holds,
  the postcondition gives a precise specification of what must be true when
  the method is finished.

  Design: Defensive Programming

  The pre- and postconditions for a method can be used to design de-

  fensive code--that is, code that guards against errors. For exam-

  ple, what action should factorial() take if its precondition fails to
  hold? In Java, the best way to handle this situation is to throw an

  IllegalArgumentException, as the following example illustrates:

                                                                                                      

  public int factorial ( int n) {

       if (n < 0)                                       // P r e c o n d i t i o n f a i l u r e

          throw new I l l e g a l A r g u m e n t E x c e p t i o n ( " F a c t o r i a l : "+ n ) ;

       i f ( n == 0 )

          return 1;

       else {

          int f = 1;              // I n i t a t e m p o r a r y v a r i a b l e

          f o r ( i n t k = n ; k >= 1 ; k--) // F o r n down t o 1

          f = f  k;               //                    Accumulate the product

          return f ;                                    // R e t u r n t h e f a c t o r i a l

       }

  } // f a c t o r i a l ( )

                                                                                                      

  An exception is an erroneous condition (an error) that arises during

  the running of a program. An Exception is an object that encap-

  sulates information about the erroneous condition. A program can
  throw an Exception, thereby stopping the program, when an er-

  roneous condition is detected. In this example, we create a new
  IllegalArgumentException that would report the illegal value of n

  with something like the following error message:

                                                                                                      

Exception in thread "main" java . lang . IllegalArgumentException :

          F a c t o r i a l : -1

  a t Test . f a c t o r i a l ( Param . j a v a : 5 )

  a t Test . main ( Param . j a v a : 1 8 )                                                           

  You have undoubtedly already encountered thrown exceptions during
  program development. Java has an extensive hierarchy of Exceptions,
  which we will cover in some depth in Chapter 11. For now, however, we
  just note how to use the IllegalArgumentException. As its name
SECTION 11  OOD: Structured Programming                                           281

implies, an IllegalArgumentException is used when an argument in
a method call is not legal.

   Rather than continuing the program with an erroreous data value,
throwing an exception causes the program to stop and print an error mes-
sage. Determining whether an argument is legal or illegal is an impor-
tant use of the method's preconditions. The failure of the precondition
in factorial() points to a problem elsewhere in the program, because
it is doubtful that the program deliberately passed a negative value to
factorial(). The discovery of this error should lead to modifications
in that part of the program where factorial() was invoked--perhaps
to some validation of the user's input:

                                                                                        

i n t num = I n t e g e r . p a r s e I n t ( t e x t I n . g e t T e x t ( ) ) ;

i f (num >= 0 )  // I f f a c t o r i a l ( ) p r e c o n d i t i o n v a l i d

      factNum = f a c t o r i a l (num ) ; // C o m p u t e f a c t o r i a l

else

      System . out . println ( " Error " ) ; // R e p o r t i n p u t e r r o r }       

This would be the traditional way to handle this kind of error.

Using Pre- and Postconditions

The use of preconditions and postconditions in the ways we've described
can help improve a program's design at several distinct stages of its
development:

 Design stage: Using pre- and postconditions in design helps to clarify
  the design and provides a precise measure of correctness.

 Implementation and testing stage: Test data can be designed to demon-
  strate that the preconditions and postconditions hold for any method
  or code segment.

 Documentation stage: Using pre- and postconditions to document the
  program makes the program more readable and easier to modify and
  maintain.

 Debugging stage: Using the pre- and postconditions provides precise
  criteria that can be used to isolate and locate bugs. A method is incor-
  rect if its precondition is true and its postcondition is false. A method
  is improperly invoked if its precondition is false.

Like other programming skills and techniques, learning how to use pre-
and postconditions effectively requires practice. One way to develop these
skills is to incorporate pre- and postconditions into the documentation of
the methods you write for laboratories and programming exercises. Ap-
pendix A provides guidelines on how to incorporate pre- and postcondi-
tions into your program's documentation. However, it would be a mistake
to get in the habit of leaving the identification of pre- and postconditions
to the documentation stage. The method's documentation, including its
pre- and postconditions, should be developed during the design stage and
should play a role in all aspects of program development.

Effective Program Design

What we're really saying here is that using pre- and postconditions forces
you to analyze your program's logic. It is not enough to know that a single
282  CHAPTER 6  Control Structures

isolated statement within a program works correctly at the present time.
You have to ask yourself: Will it continue to work if you change some
other part of the program? Will other parts of the program continue to
work if you revise it? No matter how clever you are, it is not possible to
keep an entire model of a good-sized program in your head at one time.
It is always necessary to focus on a few essential details and leave aside
certain others. Ideally, what you hope is that the details you've left aside
for the moment aren't the cause of the current bug you're trying to fix.
Using pre- and postconditions can help you determine the correctness of
the details you choose to set aside.

JAVA EFFECTIVE DESIGN Pre- and Postconditions. Pre- and
postconditions are an effective way of analyzing the logic of your
program's loops and methods. They should be identified at the
earliest stages of design and development. They should play a role in
the testing and debugging of the program. Finally, they should be
included, in a systematic way, in the program's documentation.

 JAVA PROGRAMMING TIP Develop your program's
 documentation at the same time that you develop its code and include
 the pre- and postconditions in the documentation.

As the programs you write become longer and more complex, the chances
that they contain serious errors increase dramatically. There's no real way
to avoid this complexity. The only hope is to try to manage it. In addi-
tion to analyzing your program's structure, another important aspect of
program design is the attempt to reduce its complexity.

 JAVA EFFECTIVE DESIGN Reducing Complexity. Design your
 programs with an aim toward reducing their complexity.

Perhaps the best way to reduce complexity is to build your programs us-
ing a small collection of standard structures and techniques. The basic
control structures (Fig. 6.14) help reduce the potential complexity of a pro-
gram by constraining the kinds of branching and looping structures that
can be built. The control structures help to manage the complexity of your
SECTION 11  OOD: Structured Programming                  283

program's algorithms. In the same way, the following practices can help
reduce and manage the complexity in a program.

  JAVA PROGRAMMING TIP Standard Techniques. Acquire and use
  standard programming techniques for standard programming
  problems. For example, using a temporary variable to swap the values
  of two variables is a standard technique.

  JAVA PROGRAMMING TIP Encapsulation. Use methods wherever
  appropriate in your own code to encapsulate important sections of
  code and thereby reduce complexity.

  JAVA PROGRAMMING TIP Code Reuse. Instead of reinventing the
  wheel, use library classes and methods whenever possible. These have
  been carefully designed by experienced programmers. Library code
  has been subjected to extensive testing.

SELF-STUDY EXERCISES

EXERCISE 6.18 Identify the pre- and postconditions on j and k where

indicated in the following code segment:

                                                                     

int j = 0; k = 5;

do {

      i f ( k % 5 == 0 ) {

                            // P r e c o n d i t i o n

         j += k ;

         k--;

      }

      else k = k ;

} while ( j <= k ) ;

                            // P o s t c o n d i t i o n

                                                                     

EXERCISE 6.19 Identify the pre- and postconditions for the following
method, which computes xn for n  0:

                                                                     

public double power ( double x , i n t n ) {

      double pow = 1 ;

      f o r ( i n t k = 1 ; k <= n ; k++)

         pow = pow  x ;

      r e t u r n pow ;

} // power ( )

                                                                     
284  CHAPTER 6  Control Structures

Special Topic: What Can Be Computed?

Did you ever wonder whether there are problems that cannot be solved by
a computer, no matter what kind of control structures are used? Well, back
in 1939, in his seminal paper titled "On Computable Numbers," Alan Tur-
ing proved that indeed there are an infinite number of unsolvable prob-
lems. Prior to this, mathematicians and logicians thought all problems
could be solved. So Turing's proof was quite a blow!

   To help him prove this point, Turing defined an abstract computer,
which has come to be known as a Turing machine. A Turing machine
has an alphabet of symbols; a read/write head; an infinitely long tape
on which the read/write head can write symbols, and from which it can
also read symbols; and a control unit, which controls the movement and
action of the read/write head. Note that the Turing machine elements
correspond to key components of a real computer--although Turing in-
vented this concept a decade before the first computers were developed.
The read/write head corresponds to a computer's central processing unit
(CPU). The tape corresponds to the computer's memory. And the control
unit corresponds to the computer program.

   A Turing machine represents a purely abstract concept of computa-
tion. It represents the pure idea of an algorithmic solution to a problem.
Equipped with this concept, Turing was able to prove that there are un-
solvable problems--that is, problems for which no algorithm can arrive at
a solution.

   One such problem is the halting problem. This problem asks whether an
algorithm can be devised to determine whether an arbitrary program will
eventually halt. If there were such an algorithm, it could be used to detect
programs that contain infinite loops, a service that might be really helpful
in an introductory computing lab, among other places! But, alas, there can
be no such algorithm.

   Here's an outline of a proof that shows that the halting problem is un-
solvable. (This particular version of the proof was suggested by J. Glenn
Brookshear in Computer Science: An Overview, Benjamin-Cummings, 1985.)

   Suppose you had a program, P, that solves the halting problem. That is,
whenever P is given a self-halting program, it sets a variable isTerminating
to true, and otherwise it sets isTerminating to false. Now let's create a new
version of P, named P , which is identical to P except that right after where
P sets isTerminating to true or false, P contains the following loop:

                                                                                                            

  while ( i s T e r m i n a t i n g == t r u e ) ;  // I n f i n i t e i f i s T e r m i n a t i n g  true

                                                                                                            

In other words, if the input to P is a self-terminating program, then P
will enter an infinite loop and it won't terminate. Otherwise, if a non-
self-terminating program is input to P , P will skip the loop and will
terminate.

   Now what if we give a representation of P to itself. Will it halt? The
answer generates a contradiction: If P is a self-terminating program, then
when it is input to itself, it will not terminate. And if P is not self-
terminating, when it is input to itself, it will terminate. Because our as-
sumption that P solves the halting problem has led to a contradiction, we
CHAPTER 6  Chapter Summary                                285

have to conclude that it wasn't a very good assumption in the first place.
Therefore, there is no program that can solve the halting problem.

   The topic of computability is a fundamental part of the computer sci-
ence curriculum, usually taught in a sophomore- or junior-level theory of
computation course.

Technical Terms                                                                CHAPTER SUMMARY

conditional loop    loop bound            sentinel bound
counting loop       loop entry condition  unit indexing
do-while statement  nested loop           updater
infinite loop       postcondition         while statement
initializer         precondition          zero indexing
limit bound         priming read
loop body           repetition structure

Summary of Important Points                                                    TABLE 6.2 A summary
                                                                               of various loop bounds
 A repetition structure is a control structure that allows a statement or
   sequence of statements to be repeated.                                      Bound     Example

 All loop structures involve three elements--an initializer, a loop entry     Counting  k < 100
   condition or a loop boundary condition, and an updater.                     Sentinel  input != 9999
                                                                               Flag      done != true
 When designing a loop, it is important to analyze the loop structure to      Limit     amount < 0.5
   make sure that the loop bound will eventually be satisfied.

 The for statement has the following syntax:
   for ( initializer ; loop entry condition ; updater )
           for loop body ;

 The while statement takes the following form:
     while ( loop entry condition )
           loop body ;

 The do-while statement has the following general form:

     do

           loop body ;
     while ( loop entry condition ) ;
 When designing a loop, it is important to analyze the loop structure to
   make sure that the loop bound will eventually be satisified. Table 6.2
   summarizes the types of loop bounds that we have identified.
 Structured programming is the practice of writing programs that are
   built up from a small set of predefined control structures--the sequence,
   selection, repetition, and method-call structures. An important feature of
   these structures is that each has a single entry and exit.
 A precondition is a condition that must be true before a certain code
   segment executes. A postcondition is a condition that must be true when
   a certain code segment is finished. Preconditions and postconditions
   should be used in the design, coding, documentation, and debugging
   of algorithms and methods.
                      286                                         CHAPTER 6  Control Structures

SOLUTIONS TO          SOLUTION 6.1 Identify the syntax error in the following for loop statements:
SELF-STUDY EXERCISES   a. Commas are used instead of semicolons in the header.

                                                                                                                   

                           for ( int k = 5; k < 100; k++)

                                  System . out . println (k ) ;                                                    

                         b. There shouldn't be 3 semicolons in the header

                                                                                                                   

                           f o r ( i n t k = 0 ; k < 12 ; k--)

                                  System . out . println (k ) ;                                                    

                      SOLUTION 6.2 Identify those statements that result in infinite loops:
                       a. Infinite loop because k is never incremented.
                       b. Infinite loop because k is always odd and thus never equal to 100.

                      SOLUTION 6.3 Your sister is learning to count by fours. Write a for loop that
                      prints the following sequence of numbers: 1, 5, 9, 13, 17, 21, 25.

                                                                                                 

                      f o r ( i n t k = 1 ; k <= 2 5 ; k = k +4)

                           System . out . print (k + " " ) ;                                     

                      SOLUTION 6.4 What value will j have when the following loop terminates? An-
                      swer: j will be undefined when the loop terminates. It is a local variable whose
                      scope is limited to the loop body.

                                                                                                 

                      for ( int i = 0; i < 10; i ++)

                      {

                         int j ;

                         j = j + 1;

                      }                                                                          
                      

                        SOLUTION 6.5  Write a nested for loop to print the following geometric pat-
                        tern:                                                                                   

                      

                        #
                        ##
                        ###
                        ####
                        #####

                      f o r ( i n t row = 1 ; row <= 5 ; row++) { // For each row

                         f o r ( i n t c o l = 1 ; c o l <= row ; c o l ++) // Columns per row

                           System . out . print ( '# ' ) ;

                         System . out . println ( ) ;             // New l i n e

                      } // row
                                                                                                 

                      SOLUTION 6.6 Identify the syntax error in the following while structures:
CHAPTER 6  Solutions to Self-Study Exercises                                     287

a.  

        int k = 5;

        while (k < 100) {

           System . out . println (k ) ;

           k++                            << Missing semicolon

        }
                                                                                       

b.  

        int k = 0;

        while (k < 12;) {                 << E x t r a semicolon

           System . out . println (k ) ;

           k++;

        }
                                                                                       

SOLUTION 6.7 Determine the output and/or identify the error in each of the
following while structures.

a.  

        int k = 0;

        while (k < 100)

           System . out . p r i n t l n ( k ) ; << Missing updater i n loop body       

        Output: infinite loop prints 0 0 0 0 0...

b.  

        while (k < 100) {                 << Missing i n i t i a l i z e r

           System . out . println (k ) ;

           k++;

        }
                                                                                       

        Output: unpredictable since k's initial value is not known

SOLUTION 6.8 Your younger sister is now learning how to count by sixes. Write
a while loop that prints the following sequence of numbers: 0, 6, 12, 18, 24, 30, 36.

                                                                                  

  int k = 0;                              // I n i t i a l i z e r

  while ( k <= 3 6 ) {                    // Loop-e n t r y c o n d i t i o n

           System . out . println (k ) ;

           k += 6 ;                       // Updater

  }                                                                               

SOLUTION 6.9 If N is even, divide it by 2. If N is odd, subtract 1 and then
divide it by 2. This will generate a sequence that is guaranteed to terminate at 0.
For example, if N is initially 15, then you get the sequence 15, 7, 3, 1, 0. Write a
method that implements this sequence using a while statement.

                                                                                  

public s t a t i c void sub1Div2 ( i n t N) {

     while (N != 0 ) {

           System . out . p r i n t (N + " " ) ;

           i f (N % 2 == 0 )

                 N = N / 2;

           else

                 N = (N - 1 ) / 2 ;

     }

     System . out . println ( N ) ;

} // sub1Div2 ( )
                                                                                  

SOLUTION 6.10 Identify the syntax error in the following do-while structures:
288                                                       CHAPTER 6  Control Structures

a.  

      int k = 0;

      do while ( k < 1 0 0 ) << Misplaced c o n d i t i o n

      {

            System . out . println (k ) ;

            k++;

      }                 << Belongs here
                                                                                                  

b.  

      int k = 0;

      do {

            System . out . println (k ) ;

            k++;

      } while ( k < 1 2 ) << Missing semicolon                                                    
     

SOLUTION 6.11 Your sister has moved on to counting by sevens. Write a
do-while loop that prints the following sequence of numbers: 1, 8, 15, 22, 29,
36, 43.

                                                                                               

n = 1;                                                    // I n i t i a l i z e r

do {

      System . out . print (n + " " ) ;

      n += 7 ;                                            // Updater

} while ( n <= 4 3 ) ;                                    // Loop e n t r y c o n d i t i o n  


SOLUTION 6.12 Write a method to input and validate pizza sales.

                                                                                               

public i n t g e t A n d V a l i d a t e P i z z a P r i c e ( ) {// Uses KeyboardReader

  int pizza = 0;

  do {

      reader . prompt ( " Input a pizza price ( 8 , 10 , or 15) " ) ;

      r e a d e r . prompt ( " or 99 t o end t h e l i s t >> " ) ;

      pizza = reader . getKeyboardInteger ( ) ;

      i f ( ( p i z z a ! = 9 9 ) && ( p i z z a ! = 8 ) && ( p i z z a ! = 1 0 ) &&

                        ( pizza != 15))

        System . out . p r i n t l n ( " Error : you ' ve entered an "

         + " i n v a l i d pizza p r i c e \n" ) ;        // E r r o r in pu t

      else                                                // OK in pu t

            System . out . p r i n t l n ( "You in pu t " + p i z z a + "\n" ) ;

  } while ( ( p i z z a ! = 9 9 ) && ( p i z z a ! = 8 ) &&

                        ( p i z z a ! = 1 0 ) && ( p i z z a ! = 1 5 ) ) ;

  return pizza ;

} // g e t A n d V a l i d a t e P i z z a P r i c e ( )
                                                                                               
CHAPTER 6  Solutions to Self-Study Exercises                                              289

SOLUTION 6.13 Write a method to input and validate pizza sales using the
numbers 1, 2, and 3 to represent pizzas at different price levels.

                                                                                           

public i n t g e t A n d V a l i d a t e P i z z a P r i c e ( ) { // Uses KeyboardReader

  int pizza = 0;

  do {

  reader . prompt ( " Input a 1 ,2 or 3 to i n d i c a t e pizza "

              + " price ( 1( $8 ) , 2( $10 ) , or 3( $15 ) ) " ) ;

  r e a d e r . prompt ( " or 0 t o end t h e l i s t >> " ) ;

  pizza = reader . getKeyboardInteger ( ) ;

  i f ( ( p i z z a < 0 ) | | ( p i z z a > 3 ) ) // E r r o r check

        System . out . p r i n t l n ( " Error : you ' ve entered an "

                                                          + " i n v a l i d value\n" ) ;

  else                                                    // OK in pu t

        System . out . p r i n t l n ( "You in pu t " + p i z z a + "\n" ) ;

  } while ( ( pizza < 0) | | ( pizza > 3) ) ;

  i f ( p i z z a == 1 )

  return 8;

  e l s e i f ( p i z z a == 2 )

  return 10;

  e l s e i f ( p i z z a == 3 )

  return 15;

  else

  return 0;

} // g e t A n d V a l i d a t e P i z z a P r i c e ( )                                   


SOLUTION 6.14 For each of the following problems, decide whether a counting
loop structure, a while structure, or a do-while structure should be used, and
write a pseudocode algorithm.
 Printing the names of all the visitors to a Web site could use a counting loop

    because the exact number of visitors is known.

                                                                                                

  f o r each name i n t h e v i s i t o r ' s l o g

        p r i n t t h e name                                                                    

 Validating that a user has entered a positive number requires a do-while
    structure in which you repeatedly read a number and validate it.

                                                                                                

  do

        read a number

        i f number i s i n v a l i d , p r i n t e r r o r message

  while number i s i n v a l i d
                                                                                                

 Changing all the backslashes (\) in a Windows Web page address, to the slashes
    (/) used in a Unix Web page address.

                                                                                                

  f o r each c h a r a c t e r i n t h e Web page address

        if i t is a backslash replace i t with slash                                            

 Finding the largest in a list of numbers requires a while loop to guard against
    an empty list.

                                                                                                

  i n i t i a l i z e maxMPG t o s m a l l e s t p o s s i b l e number

  while t h e r e are more c a r s in the database

        i f c u r r e n t c a r ' s MPG i s g r e a t e r than maxMPG

        r e p l a c e maxMPG with i t                                                           

SOLUTION 6.15 Identify any errors in the following switch structures (if there
is no error, specify the output):
290                                                  CHAPTER 6  Control Structures

   a.  

       int k = 0;

       switch ( k ) // Syntax e r r o r : missing b r a c e s

       case 0:

                System . out . println ( "zero" ) ;

                break ;

       case 1:

                System . out . println ( "one" ) ;

                break ;

       default :

                System . out . println ( " default " ) ;

                break ;                                                              

   b.  

       int k = 0;

       switch (k + 1)

       {

                case 0:

                   System . out . println ( "zero" ) ;

                   break ;

                case 1:

                   System . out . p r i n t l n ( "one" ) ; // Output "one"

                   break ;

                default :

                   System . out . println ( " default " ) ;

                   break ;

       }                                                                             

   c.  

       int k = 6;

       switch ( k / 3 . 0 ) // Syntax e r r o r : not an i n t e g r a l value

       {

                case 2:

                   System . out . println ( "zero" ) ;

                   break ;

                case 3:

                   System . out . println ( "one" ) ;

                   break ;

                default :

                   System . out . println ( " default " ) ;

                   break ;

       }                                                                             

SOLUTION 6.16 A switch statement to print ice cream flavors:

                                                                                

switch ( flavor )

{

     case 1:

       System . out . println ( " Vanilla " ) ;

       break ;

     case 2:

       System . out . println ( "Chocolate" ) ;

       break ;

     case 3:

       System . out . println ( "Strawberry" ) ;

       break ;

     default :

       System . out . println ( " Error " ) ;

}
                                                                                
   CHAPTER 6  Exercises                                                   291

SOLUTION 6.17

                                                                           

public f i n a l i n t VANILLA = 0 ,

                            CHOCOLATE = 1 ,

                            STRAWBERRY = 2 ;

switch ( flavor )

{

      c a s e VANILLA :

         System . out . println ( " Vanilla " ) ;

         break ;

      c a s e CHOCOLATE:

         System . out . println ( "Chocolate" ) ;

         break ;

      c a s e STRAWBERRY :

         System . out . println ( "Strawberry" ) ;

         break ;

      default :

         System . out . println ( " Error " ) ;

}                                                                          


SOLUTION 6.18 Identify the pre- and postconditions on j and k where indicated
in the following code segment:

                                                                           

int j = 0; k = 5;

do {

      i f ( k % 5 == 0 ) {

                            // P r e c o n d i t i o n : j <= k

         j += k ;

         k--;

      }

      e l s e k = k ;

} while ( j <= k ) ;

                            // P o s t c o n d i t i o n : j > k           

SOLUTION 6.19 Identify the pre- and postconditions for the following method,
which computes xn for n >= 0.

                                                                           

   // P r e c o n d i t i o n : N >= 0

   // P o s t c o n d i t i o n : power ( x , n ) == x t o t h e n

   public double power ( double x , i n t n ) {

         double pow = 1 ;

         f o r ( i n t k = 1 ; k <= n ; k++)

         pow = pow  x ;

         r e t u r n pow ;

   } // power ( )
                                                                           

EXERCISE 6.1 Explain the difference between the following pairs of terms:       EXERCISES

a. Counting loop and conditional loop.                                          Note: For programming exercises,
b. For statement and while statement.                                           first draw a UML class diagram
c. While statement and do-while statement.                                      describing all classes and their
d. Zero indexing and unit indexing.                                             inheritance relationships and/or
e. Sentinel bound and limit bound.                                              associations.
f. Counting bound and flag bound.
g. Loop initializer and updater.
h. Named constant and literal.
i. Compound statement and null statement.

EXERCISE 6.2 Fill in the blank.
292                                 CHAPTER 6  Control Structures

a. The process of reading a data item before entering a loop is known as a  .

b. A loop that does nothing except iterate is an example of        .

c. A loop that contains no body is an example of a           statement.

d. A loop whose entry condition is stated as (k < 100 || k >= 0) would be an

   example of an             loop.

e. A loop that should iterate until the user types in a special value should use a

       bound.

f. A loop that should iterate until its variable goes from 5 to 100 should use a

       bound.

g. A loop that should iterate until the difference between two values is less than

   0.005 is an example of a         bound.

EXERCISE 6.3 Identify the syntax errors in each of the following:

a. for (int k = 0; k  100; k++) System.out.println(k)
b. for (int k = 0; k  100; k++); System.out.println(k);
c. int k = 0 while k  100 System.out.println(k); k++;
d. int k = 0; do System.out.println(k); k++; while k  100 ;

EXERCISE 6.4 Determine the output and/or identify the error in each of the
following code segments:

a. for (int k = 1; k == 100; k += 2) System.out.println(k);
b. int k = 0; while (k  100) System.out.println(k); k++;
c. for (int k = 0; k  100; k++) ; System.out.println(k);

EXERCISE 6.5 Write pseudocode algorithms for the following activities, paying
particular attention to the initializer, updater, and boundary condition in each case.

a. a softball game
b. a five-question quiz
c. looking up a name in the phone book

EXERCISE 6.6 Identify the pre- and postconditions for each of the statements
that follow. Assume that all variables are int and have been properly declared.

a. int result = x / y;
b. int result = x
c. int x = 95; do x /= 2; while(x = 0);

EXERCISE 6.7 Write three different loops--a for loop, a while loop, and a
do-while loop--to print all the multiples of 10, including 0, up to and including
1,000.

EXERCISE 6.8 Write three different loops--a for loop, a while loop, and a
do-while loop--to print the following sequence of numbers: 45, 36, 27, 18, 9, 0,
-9, -18, -27, -36, -45.

EXERCISE 6.9 Write three different loops--a for loop, a while loop, and a
do-while loop--to print the following ski-jump design:

                                                                            

#

##

###

####

#####

######

#######
                                                                            
CHAPTER 6  Exercises                                                     293

EXERCISE 6.10 The Straight Downhill Ski Lodge in Gravel Crest, Vermont, gets
lots of college students on breaks. The lodge likes to keep track of repeat visitors.
Straight Downhill's database includes an integer variable, visit, which gives the
number of times a guest has stayed at the lodge (1 or more). Write the pseudocode
to catch those visitors who have stayed at the lodge at least twice and to send them
a special promotional package (pseudocode = send promo). (Note: The largest
number of stays recorded is eight. The number nine is used as an end-of-data
flag.)

EXERCISE 6.11 Modify your pseudocode in the previous exercise. In addition
to every guest who has stayed at least twice at the lodge receiving a promotional
package, any guest with three or more stays should also get a $40 coupon good for
lodging, lifts, or food.

EXERCISE 6.12 Write a method that is passed a single parameter, N, and dis-
plays all the even numbers from 1 to N.

EXERCISE 6.13 Write a method that is passed a single parameter, N, that prints
all the odd numbers from 1 to N.

EXERCISE 6.14 Write a method that is passed a single parameter, N, that prints
all the numbers divisible by 10 from N down to 1.

EXERCISE 6.15 Write a method that is passed two parameters--a char Ch and
an int N--and prints a string of N Chs.

EXERCISE 6.16 Write a method that uses a nested for loop to print the follow-
ing multiplication table:

                                                                          

  123456789

11

224

3369

4 4 8 12 16

5 5 10 15 20 25

6 6 12 18 24 30 36

7 7 14 21 28 35 42 48

8 8 16 24 32 40 48 56 64

9 9 18 27 36 45 54 63 72 81                                               


EXERCISE 6.17 Write a method that uses nested for loops to print the patterns
that follow. Your method should use the following statement to print the patterns:
System.out.print('#').

                                                                          

  ########                     ######## ######## ########
      #######
          ######               #######  #            #                 #
             #####
                 ####          ######      #      #                 #
                    ###
                        ##     #####          ##                 #
                            #
                               ####           ##              #

                               ###         #      #        #

                               ##       #            #  #

                               #        ######## ########                 

EXERCISE 6.18 Write a program that asks the user for the number of rows and
the number of columns in a box of asterisks. Then use nested loops to generate the
box.
294     CHAPTER 6  Control Structures

EXERCISE 6.19 Write a Java application that lets the user input a sequence of
consecutive numbers. In other words, the program should let the user keep en-
tering numbers as long as the current number is one greater than the previous
number.

EXERCISE 6.20 Write a Java application that lets the user input a sequence of
integers terminated by any negative value. The program should then report the
largest and smallest values that were entered.

EXERCISE 6.21 How many guesses does it take to guess a secret number be-
tween 1 and N? For example, I'm thinking of a number between 1 and 100. I'll
tell you whether your guess is too high or too low. Obviously, an intelligent first
guess would be 50. If that's too low, an intelligent second guess would be 75. And
so on. If we continue to divide the range in half, we'll eventually get down to one
number. Because you can divide 100 seven times (50, 25, 12, 6, 3, 1, 0), it will take
at most seven guesses to guess a number between 1 and 100. Write a Java Swing
program that lets the user input a positive integer, N, and then reports how many
guesses it would take to guess a number between 1 and N.

EXERCISE 6.22 Suppose you determine that the fire extinguisher in your
kitchen loses X percent of its foam every day. How long before it drops below
a certain threshold (Y percent), at which point it is no longer serviceable? Write a
Java Swing program that lets the user input the values X and Y and then reports
how many weeks the fire extinguisher will last.

EXERCISE 6.23 Leibnitz's method for computing  is based on the following
convergent series:

      = 1 - 1 + 1 - 1 + 렁
     4  357

How many iterations does it take to compute  to a value between 3.141 and 3.142
using this series? Write a Java program to find out.

EXERCISE 6.24 Newton's method for calculating the square root of N starts by
making a (nonzero) guess at the square root. It then uses the original guess to
calculate a new guess, according to the following formula:

                                       

guess = (( N / guess ) + guess ) / 2;  


No matter how wild the original guess is, if we repeat this calculation, the algo-
rithm will eventually find the square root. Write a square root method based on
this algorithm. Then write a program to determine how many guesses are required
to find the square roots of different numbers. Uses Math.sqrt() to determine
when to terminate the guessing.

EXERCISE 6.25 Your employer is developing encryption software and wants
you to develop a Java Swing Program that will display all of the primes less than
N, where N is a number to be entered by the user. In addition to displaying the
primes themselves, provide a count of how many there are.

EXERCISE 6.26 Your little sister asks you to help her with her multiplication
and you decide to write a Java application that tests her skills. The program will
let her input a starting number, such as 5. It will generate multiplication problems
ranging from from 5  1 to 5  12. For each problem she will be prompted to enter
the correct answer. The program should check her answer and should not let
her advance to the next question until the correct answer is given to the current
question.
CHAPTER 6  Exercises  295

EXERCISE 6.27 Write an application that prompts the user for four values and
draws corresponding bar graphs using an ASCII character. For example, if the
user entered 15, 12, 9, and 4, the program would draw

                       









                       

EXERCISE 6.28 Revise the application in the previous problem so that the bar
charts are displayed vertically. For example, if the user inputs 5, 2, 3, and 4, the
program should display

                       



  

   

   

   

-------------

                       

EXERCISE 6.29 The Fibonacci sequence (named after the Italian mathematician
Leonardo of Pisa, ca. 1200) consists of the numbers 0, 1, 1, 2, 3, 5, 8, 13, . . . in which
each number (except for the first two) is the sum of the two preceding numbers.
Write a method fibonacci(N) that prints the first N Fibonacci numbers.

EXERCISE 6.30 The Nuclear Regulatory Agency wants you to write a program
that will help determine how long certain radioactive substances will take to de-
cay. The program should let the user input two values: a string giving the sub-
stance's name and its half-life in years. (A substance's half-life is the number of
years required for the disintegration of half of its atoms.) The program should re-
port how many years it will take before there is less than 2 percent of the original
number of atoms remaining.

EXERCISE 6.31 Modify the CarLoan program so that it calculates a user's car
payments for loans of different interest rates and different loan periods. Let the
user input the amount of the loan. Have the program output a table of monthly
payment schedules.

The next chapter also contains a number of loop exercises.
296  CHAPTER 6  Control Structures
Chapter 7

Strings and String
Processing

OBJECTIVES

After studying this chapter, you will
 Be more familiar with Java Strings.
 Know how to solve problems that involve manipulating strings.
 Be able to use loops in designing string-processing algorithms.

OUTLINE

7.1 Introduction
7.2 String Basics
7.3 Finding Things Within a String
7.4 Example: Keyword Search
7.5 From the Java Library: StringBuffer
7.6 Retrieving Parts of Strings
7.7 Example: Processing Names and Passwords
7.8 Processing Each Character in a String
7.9 Comparing Strings
7.10 From the Java Library: StringTokenizer
7.11 Handling Text in a Graphics Context (Optional)

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              297
                                                  298               CHAPTER 7  Strings and String Processing

                                                  7.1 Introduction

                       Object                     You have already had an introduction to Strings in the early chapters
                                                  of this text. In Chapter 2, we introduced the String data type and
                       String                     showed how to create String objects and use String methods, such
                                                  as length(), concat(), and equals().
-value
-count                                               We have seen Strings used for GUI I/O operations when used
+String()                                         Strings as the contents of JTextFields and other text components, as
+String(in s : String)                            the values of JLabels, as the labels for JButtons, and so on. Strings
+length() :int                                    are also used extensively in command-line interfaces.
+valueOf(in n : int) : String
+concat(in s : String) : String                      Another important task that Strings are used for are as a standard
+valueOf(in d : double) : String                  way of presenting or displaying information about objects. As we saw
+charAt(in n : int) : char                        in Chapter 2, one of the key conventions of the Java class hierarchy is
+equals(in o : Object) : boolean                  that every class inherits the Object.toString() method, which can
+indexOf(in ch : int) : int                       be used to provide a string representation of any object. For example,
+indexOf(in ch : int, in start : int) : int       Integer.toString() converts an int to a String, so that it can be
+indexOf(in s : String) : int                     used in JTextFields or JLabels.
+indexOf(in s : String, in start : int) : int
+substring(in strt : int) : String                   Programmers often have to work with strings. Think of some of the
+substring(in strt : int, in end : int) : String  tasks performed by a typical word processor, such as cut, paste, copy, and
                                                  insert. When you cut and paste text from one part of the document to
Figure  7.1:           The                        another, the program has to move one string of text, the cut, from one
                      class.                      location in the document and insert it in another.
java.lang.String
                                                     Strings are also important because they are our first look at a data struc-
                                                  ture. A data structure is a collection of data that is organized (structured)
                                                  in some way. A string is a collection of character (char) data. Strings are
                                                  important data structures in a programming language, and they are used
                                                  to represent a wide variety of data.

                                                     The main purpose of this chapter is to provide a detailed discussion of
                                                  Java's string-related classes, including the String, StringBuffer, and
                                                  StringTokenizer classes. These are the important classes for writing
                                                  string-processing applications. Our goal is to introduce the important
                                                  String methods and illustrate common string-processing algorithms.
                                                  We will review how to create strings from scratch and from other data
                                                  types. We will learn how to find characters and substrings inside bigger
                                                  strings. We will learn how to take strings apart and how to rearrange their
                                                  parts. Finally, we will learn how to apply these string-processing skills in
                                                  a program that plays the game of Hang Man.

Are strings objects?                              7.2 String Basics

                                                  Before we cover the new material on Strings, let's first review what
                                                  we know about this topic. In Java, Strings are considered full-fledged
                                                  objects. A String object is a sequence of the characters that make up
                                                  the string, plus the methods that are used to manipulate the string. The
                                                  java.lang.String class (Fig. 7.1) is a direct subclass of Object, and it
                                                  contains many public methods that can be used to perform useful opera-
                                                  tions on strings (such as concatenation). We will discuss a selection of the
SECTION 7.2  String Basics                                               299

more commonly used methods, but for a full listing and description of the
String methods see

                                                                               

h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/a p i/
                                                                               

Like other object variables, String variables serve as references to their
respective objects. However, unlike other Java objects, Strings have cer-
tain characteristics in common with the primitive data types. For example,
as we have already seen, Java allows for literal strings. A string literal is
a sequence of zero or more characters contained in double quotes, such as
"Socrates" and "" (the empty string). Java allows us to perform operations
on literal strings, such as concatenation. As we have already seen, the
expression "Hello" + "world" results in the string "Helloworld".
Java also allows us to use string literals to initialize String variables
with an assignment statement. These exceptional features greatly simplify
the use of Strings in our programs. Given how much we use Strings,
incorporating these features into Java seems like a good design decision.

7.2.1 Constructing Strings

To create String objects, the String class provides many constructors,

including the following:

                                                                               

public String ( ) ;          // C r e a t e s an empty s t r i n g

  // Copy c o n s t r u c t o r : C r e a t e s a copy o f a s t r i n g

public String ( String initial value ) ;
                                                                               

When we create an object using the first constructor, as in                    

                                                                                  name : String

    S t r i n g name = new S t r i n g ( ) ;                                     value=""
 
                                                                                  count=0
Java will create a String object and make name the reference to it. Fig-
ure 7.2 shows a hypothetical representation of a String object. In addi-       Figure 7.2:  An empty
tion to storing the sequence of characters that make up the string, Java
also stores an integer value representing the number of characters in the      string is a String object
string. We have chosen to represent these two elements as the private in-
stance variables, value, for the sequence of characters, and count for the     with value "" and count 0.
number of characters. In fact, we don't know exactly how Java stores the
sequence of characters. That information is hidden. As Figure 7.2 illus-       
trates, when we use the default constructor, the value of the is the empty
string and its count is 0.

   The second constructor is the copy constructor for the String class. A
copy constructor is a constructor that makes a duplicate, sometimes called
a clone, of an object. Many Java classes have copy constructors. Consider
the following statements:

 

S t r i n g s1 = new S t r i n g ( " Hello " ) ; ) ;

S t r i n g s2 = new S t r i n g ( s1 ) ;                                      


These two statements would result in two distinct String objects, both
storing the word "Hello".
                                     300         CHAPTER 7  Strings and String Processing

       "Socrates" : String              Note that in the first of the preceding statements, we used the literal
                                     string "Hello" in the constructor. When Java encounters a new literal
       value="Socrates"              string in a program, it constructs an object for it. For example, if your
       count=8                       program contained the literal "Socrates," Java would create an object for
                                     it and treat the literal itself as a reference to the object (Fig. 7.3).
Figure 7.3:    The lit-
eral String    "Socrates."              We often use a string literal to assign a value to a String variable:

                                                                                                                               

                                     String s ;  // The v a l u e o f s i s i n i t i a l l y n u l l

                                     s = " Socrates " ; // s now r e f e r s t o " S o c r a t e s " o b j e c t               
                                     

"Socrates"             : String      In this case, the reference variable s is initially null--that is, it has no
     name2     value="Socrates"      referent, no object, to refer to. However, after the assignment statement, s
     name3     count=8               would refer to the literal object "Socrates," which is depicted in Figure 7.3.
                                     Given these two statements, we still have only one object, the String
           ""            : String    object containing the word "Socrates.". But now we have two references
                    value=""         to it: the literal string "Socrates," and the reference variable s.
     name1          count=0
                                        Assignment statements can also be used as initializers when declaring
                                     a String variable:

                                                                                                                               

                                     S t r i n g name1 = " " ; // R e f e r e n c e t o t h e e m p t y s t r i n g

Figure 7.4: The variables name1,     S t r i n g name2 = " S o c r a t e s " ; // R e f e r e n c e s t o " S o c r a t e s "
name2, and name3 serve as refer-
ences to the literal String objects  S t r i n g name3 = " S o c r a t e s " ;                                                 
"Socrates" and "".                   

name4                    : String    In this example, Java does not construct new String objects. Instead, as
name6               value=""         Figure 7.4 shows, it simply makes the variables name1, name2, and name3
                    count=0          serve as references to the same objects that are referred to by the literal
name5                                strings "" and "Socrates." This is a direct consequence of Java's policy of
                       : String      creating only one object to serve as the referent of a literal string, no mat-
               value="Socrates"      ter how many occurrences there are of that literal in the program. Thus,
               count=8               these declarations result in no new objects, just new references to existing
                                     objects. The justification for this policy is that it saves lots of memory in
                                     our programs. Instead of creating a String object for each occurrence
                                     of the literal "Socrates," Java creates one object and lets all occurrences of
                                     "Socrates" refer to that object.

                                        Finally, consider the following declarations, which do invoke the
                                     String constructors:

                                                                                                                               

                                     S t r i n g name4 = new S t r i n g ( ) ;  // C r e a t e s an o b j e c t

Figure 7.5: Together with the        S t r i n g name5 = new S t r i n g ( " S o c r a t e s " ) ;
objects in Figure 7.4, there are
now four different String            S t r i n g name6 = name4 ;                                                               
objects with eight different         
references to them, includ-
ing the literals "Socrates"          In this case, as shown in Figure 7.5, Java creates two new objects and
and "".                              sets name4 to refer to the first and name5 to refer to the second. It gives
                                     name4 the empty string as its value, and it gives name5 "Socrates" as its
                                     value. But these two objects must be distinguished from the objects corre-
  SECTION 7.2  String Basics                                             301

  sponding to the literals ("" and "Socrates") themselves. The declaration of
  name6 just creates a second reference to the object referred to by name4.

  JAVA LANGUAGE RULE Strings. Java Strings are full-fledged
  objects, but they have some properties in common with primitive
  types. They can have literal values and they can be used in assignment
  statements.

  JAVA LANGUAGE RULE String Declaration and
  Instantiation. Unless a String() constructor is called explicitly, no
  new String object is created when declaring a String variable and
  assigning it an initial value.

  7.2.2 Concatenating Strings                                                     

  Another way to build a String object is to concatenate two other strings.       
  Recall from Chapter 2 that there are two ways to perform string concate-         String concatenation
  nation in Java: We can use the concat() method or the concatenation              Operator overloading
  operator, +.

   

      String lastName = "Onassis" ;
      String jackie =

           new S t r i n g ( " J a c q u e l i n e " + "Kennedy " + lastName ) ;
      System . out . println ( " Jacqueline " . concat ( lastName ) ) ;
   

  The second of these statements uses the concatenation operator, +, to create
  the String "Jacqueline Kennedy Onassis." The third statement uses the
  String method, concat(), to print "JacquelineOnassis."
  Using the + symbol as the string concatenation operator is another ex-
  ample of operator overloading--using the same operator for two or more
  different operations--which we encountered in Chapter 5.

  JAVA LANGUAGE RULE String Concatenation. When surrounded
  on either side by a String, the + symbol is used as a binary
  concatenation operator. It has the effect of joining two strings together
  to form a single string.

  Note that primitive types are automatically promoted to Strings when
  they are mixed with concatenation operators. Thus, the statement

                                                                                  

  System . out . p r i n t l n ( "The sum o f 5 and 5 = "+ ( 5 + 5 ) ) ;          
  

  will print the string "The sum of 5 and 5 = 10." Note that the integer
  addition--(5 + 5)--is performed first, before the integer result is converted
  into a String. If we had left off the parentheses around the addition oper-
  ation, the second plus sign would also be interpreted as a concatenation
  operator. Thus,

                                                                                  

System . out . p r i n t l n ( "The concatenation of 5 and 5 = " + 5 + 5 ) ;      

                                    302                      CHAPTER 7  Strings and String Processing

                                    would print "The concatenation of 5 and 5 = 55."

                                    SELF-STUDY EXERCISES

                                    EXERCISE 7.1 What will be printed by each of the following segments
                                    of code?

                                    a. String s1 = "silly"; System.out.println(s1);
                                    b. String s2 = s1; System.out.println(s2);
                                    c. String s3 = new String (s1 + " stuff");

                                              System.out.println(s3);

                                    EXERCISE 7.2 Write a String declaration that satisfies each of the
                                    following descriptions:

                                    a. Initialize a String variable, str1, to the empty string.
                                    b. Instantiate a String object, str2, and initialize it to the word stop.
                                    c. Initialize a String variable, str, to the concatenation of str1 and str2.

                                    EXERCISE 7.3 Evaluate the following expressions:

                                                                                                                             

                                    int M = 5, N = 10;

                                      String s1 = "51" , s2 = "75" ;                                               
                                                                                      c. s1 + s2

                                    a. M + N               b. M + s1

                                    EXERCISE 7.4 Draw a picture, similar to Figure 7.5, showing the ob-
                                    jects and references that are created by the following declarations:

                                                                                                                             

                                    String s1 , s2 = "Hello" , s3 = "Hello" ;

                                    String s4 = "hello" ;

                                    S t r i n g s5 = new S t r i n g ( " Hello " ) ;

                                    String s6 = s5 ;

                                    String s7 = s3 ;
                                                                                                                             

                                    7.2.3 Indexing Strings

                                    Programmers often need to take strings apart or put them together or re-

                                    arrange them. Just think of the many word-processing tasks, such as cut

                                    and paste, that involve such operations. To help simplify such operations,

String length                       it is useful to know how many characters a string contains and to number,
                                    or index, the characters that make up the string.
                       Indexes
                 01234567              The number of characters in a string is called its length. The String
                 Soc r a t e s
                                    instance method, length(), returns an integer that gives the String's

                                    length. For example, consider the following String declarations and the

                                    corresponding values of the length() method for each case:

                                                                                                                             

                                      String string1 = "" ;                           s t r i n g 1 . l e n g t h ( ) ==> 0

                                      String string2 = "Hello" ;                      s t r i n g 2 . l e n g t h ( ) ==> 5

                                      S t r i n g s t r i n g 3 = "World" ;           s t r i n g 3 . l e n g t h ( ) ==> 5

                                      String string4 = string2 + " "

                                             + string3 ;                              s t r i n g 4 . l e n g t h ( ) ==> 11
                                                                                                                                   

                                       The position of a particular character in a string is called its string in-
                                    dex. All Strings in Java are zero indexed--that is, the index of the first

Figure 7.6: The string "Socrates"
has eight characters, indexed from
0 to 7. This is an example of zero
indexing.
SECTION 7.2  String Basics                                                         303

character is zero. (Remember, zero indexing is contrasted with unit index-
ing, in which we start counting at 1.) For example, in "Socrates," the letter
S occurs at index 0, the letter o occurs at index 1, r occurs at index 3, and so
on. Thus, the String "Socrates" contains eight characters indexed from
0 to 7 (Fig. 7.6). Zero indexing is customary in programming languages.
We will see other examples of this when we talk about arrays and vectors.

JAVA LANGUAGE RULE String Indexing. Strings are indexed
starting at 0. The first character in a string is at position 0.

JAVA DEBUGGING TIP Zero Versus Unit Indexing. Syntax and
semantic errors will result if you forget that strings are zero indexed.
In a string of N characters, the first character occurs at index 0 and the
last at index N - 1. This is different from the String.length()
method, which gives the number of characters in the string, counting
from 1.

7.2.4 Converting Data to Strings

The String.valueOf() method is a class method that is used to con-

vert a value of some primitive type into a String object. For example,

the expression, String.valueOf(128) converts its int argument to

the String "128."

There are different versions of valueOf(), each of which has the fol-

lowing type of signature:

                                                                                         

s t a t i c public S t r i n g valueOf ( Type ) ;
                                                                                         

where Type stands for any primitive data type, including boolean,

char, int, double, and so on.

The valueOf() method is most useful for initializing Strings. Be-

cause valueOf() is a class method, it can be used as follows to instantiate

new String objects:

                                                                                         

S t r i n g number = S t r i n g . valueOf ( 1 2 8 ) ; // C r e a t e s " 1 2 8 "

String truth = String . valueOf ( true ) ; // C r e a t e s " t r u e "

String bee = String . valueOf ( 'B ' ) ;                // C r e a t e s " B "

S t r i n g pi = S t r i n g . valueOf ( Math . PI ) ;

// C r e a t e s " 3 . 1 4 1 5 9 "

                                                                                         

We have already seen that Java automatically promotes primitive type

values to String where necessary, so why do we need the valueOf()

methods? For example, we can initialize a String to "3.14159" as follows:

                                                                                         

S t r i n g p i = new S t r i n g ( " "+Math . PI ) ; // C r e a t e s " 3 . 1 4 "       


In this case, because it is part of a concatenation expression, the value of
Math.PI will automatically be promoted to a String value. The point
             304                    CHAPTER 7  Strings and String Processing

Readability  of the valueOf() method is twofold. First, it may be the method that the
             Java compiler relies on to perform string promotions such as this one. Sec-
             ond, using it in a program--even when it is not completely necessary--
             makes the promotion operation explicit rather than leaving it implicit.
             This helps to make the code more readable. (Also, see Exercise 7.9.)

             SELF-STUDY EXERCISES

             EXERCISE 7.5 Evaluate each of the following expressions:

             a. String.valueOf (45)                 c. String.valueOf ('X')

             b. String.valueOf (128 - 7)

             EXERCISE 7.6 Write an expression to satisfy each of the following
             descriptions:

             a. Convert the integer value 100 to the string "100".
             b. Convert the character 'V' to the string "V".
             c. Initialize a new String object to X times Y.

             7.3 Finding Things Within a String

             Programmers often have to find the location of a particular character
             or substring in a string. For example, user names and passwords are
             sometimes stored in a single string in which the name and password
             are separated from each other by a special character, such as a colon
             (username:password). In order to get the name or password from such
             a string, it is convenient to have methods that will search the string and
             report the index of the colon character.

                The indexOf() and lastIndexOf() methods are instance methods
             that can be used to find the index position of a character or a substring
             within a String. There are several versions of each:

                                                                                          

             public int indexOf ( int character ) ;
             public int indexOf ( int character , int startingIndex ) ;
             public int indexOf ( String string ) ;
             public int indexOf ( String string , int startingIndex ) ;

             public int lastIndexOf ( int character ) ;

             public int lastIndexOf ( int character , int startingIndex ) ;

             public int lastIndexOf ( String string ) ;

             public int lastIndexOf ( String string , int startingIndex ) ;               
             

             The indexOf() method searches from left to right within a String for
             either a character or a substring. The lastIndexOf() method searches
             from right to left for a character or substring. To illustrate, suppose we
             have declared the following Strings:

                                                                                          

             String string1 = "" ;

             String string2 = "Hello" ;

             S t r i n g s t r i n g 3 = "World" ;

             String string4 = string2 + " " + string3 ;                                   
             
  SECTION 7.3  Finding Things Within a String               305

  Recalling that Strings are indexed starting at 0, searching for o in the
  various strings gives the following results:

                                                                                                      

    s t r i n g 1 . indexOf ( ' o ' ) ==> -1  s t r i n g 1 . l a s t I n d e x O f ( ' o ' ) ==> -1
    s t r i n g 2 . indexOf ( ' o ' ) ==> 4   s t r i n g 2 . l a s t I n d e x O f ( ' o ' ) ==>
    4
    s t r i n g 3 . indexOf ( ' o ' ) ==> 1   s t r i n g 3 . l a s t I n d e x O f ( ' o ' ) ==>
    1
    s t r i n g 4 . indexOf ( ' o ' ) ==> 4   s t r i n g 4 . l a s t I n d e x O f ( ' o ' ) ==>
    7                                                                                             
  

  Because string1 is the empty string, "", it does not contain the let-           Sentinel return value
  ter o. Therefore, indexOf() returns -1, a value that cannot be a valid
  index for a String. This convention is followed in indexOf() and                                      Indexes
  lastIndexOf(). Because string2 and string3 each contain only one                              0 1 2 3 4 5 6 7 8 9 10
  occurrence of the letter o, both indexOf() and lastIndexOf() return                          H e l l o Wo r l d
  the same value when used on these Strings. Because string4 contains
  two occurrences of o, indexOf() and lastIndexOf() return different              Figure 7.7: The indexing of the
  values in this case. As Figure 7.7 shows, the first o in "Hello, World!"        "Hello, World!" string.
  occurs at index 4, the value returned by indexOf(). The second o occurs
  at index 7, which is the value returned by lastIndexOf().

     By default, the single-parameter versions of indexOf() and last-
  IndexOf() start their searches at their respective (left or right) ends of
  the string. The two-parameter versions of these methods allow you to
  specify both the direction and starting point of the search. The second
  parameter specifies the starting index. Consider these examples:

                                                                                  

  string4 . indexOf ( 'o ' , 5)               ==> 7

  s t r i n g 4 . l a s t I n d e x O f ( ' o ' , 5 ) ==> 4                       
  

  If we start searching in both cases at index 5, then indexOf() will miss
  the o that occurs at index 4. The first o it finds will be the one at index 7.
  Similarly, lastIndexOf() will miss the o that occurs at index 7 and will
  find the o that occurs at index 4.

     The indexOf() and lastIndexOf() methods can also be used to
  find substrings:

                                                                                  

  s t r i n g 1 . indexOf ( " or " ) ==> -1  s t r i n g 1 . l a s t I n d e x O f ( " or " ) ==> -1
  s t r i n g 2 . indexOf ( " or " ) ==> -1  s t r i n g 2 . l a s t I n d e x O f ( " or " ) ==> -1
  s t r i n g 3 . indexOf ( " or " ) ==> 1   s t r i n g 3 . l a s t I n d e x O f ( " or " ) ==> 1
  s t r i n g 4 . indexOf ( " or " ) ==> 7   s t r i n g 4 . l a s t I n d e x O f ( " or " ) ==> 7

                                                                                                   

  The substring "or" does not occur in either string1 or string2. It does
  occur beginning at location 1 in string3 and beginning at location 7 in
  string4. For this collection of examples, it doesn't matter whether we
  search from left to right or right to left.

  SELF-STUDY EXERCISES

  EXERCISE 7.7 Suppose the String variable s has been initialized to
  "mom." Evaluate each of the following expressions:
                  306                   CHAPTER 7  Strings and String Processing

                  a. s.indexOf("m"); b. s.indexOf("o"); c. s.indexOf("M");

                  EXERCISE 7.8 Evaluate the expressions given the String declaration

                  String s1 = "Java, Java,        Java";

                  a. s1.length()                    g. s1.indexOf('a', 5)
                  b. String.valueOf(s1.length())    h. s1.lastIndexOf('a', 5)
                  c. s1.indexOf('a')                i. s1.indexOf("av", s1.length() - 10)
                  d. s1.lastIndexOf('a')            j. s1.lastIndexOf("av",
                  e. s1.indexOf("av")
                  f. s1.lastIndexOf("av")                s1.length() - 4)

                                                    k. s1.indexOf("a", s1.indexOf("va"))

                  EXERCISE 7.9 Evaluate the following expression:

                                                                                                 

                    String tricky = "abcdefg01234567" ;

                    tricky . indexOf ( String . valueOf ( tricky . indexOf ( "c" ) ) ) ;         

                  7.4 Example: Keyword Search

Method design     One of the most widely used Web browser functions is the search utility.
Algorithm design  You probably know how it works. You type in a keyword and click on a
                  button, and it returns with a list of Web pages that contain the keyword.

                     Suppose you were writing a browser in Java. How would you imple-
                  ment this function? Of course, we don't know yet how to read files or
                  Web pages, and we won't cover that until Chapter 11. But, for now, we
                  can write a method that will search a string for all occurrences of a given
                  keyword. That's at least part of the task that the browser's search engine
                  would have to do.

                     So we want a method, keywordSearch(), that takes two String pa-
                  rameters, one for the string that's being searched, and the other repre-
                  senting the keyword. Let's have the method return a String that lists
                  the number of keyword occurrences, followed by the index of each occur-
                  rence. For example, if we asked this method to find all occurrences of is in
                  "This is a test," it should return the string "2: 2 5" because there are two
                  occurrences of is, one starting at index 2 and the other at index 5 in the
                  string.

                     The algorithm for this method will require a loop, because we want
                  to know the location of every occurrence of the keyword in the string.
                  One way to do this would be to use the indexOf() method to search for
                  the location of substrings in the string. If it finds the keyword at index
                  N, it should record that location and then continue searching for more
                  occurrences starting at index N + 1 in the string. It should continue in this
                  way until there are no more occurrences.

                                                                                                 

                    Suppose S i s our s t r i n g and K i s the keyword .

                    I n i t i a l i z e a counter v a r i a b l e and r e s u l t s t r i n g .

                    Set Ptr to the indexOf ( ) the f i r s t occurrence of K in S .

                    While ( Ptr != -1)

                       Increment the counter

                       Insert Ptr into the result string

                       Set Ptr to the next l o c a t i o n of the keyword in S

                    Insert the count into the result string

                    Return the result string as a String                                         
                  
SECTION 7.4  Example: Keyword Search                                                307

As this pseudocode shows, the algorithm uses a while loop with a sentinel                 Implementation

bound. The algorithm terminates when the indexOf() method returns a

-1, indicating that there are no more occurrences of the keyword in the

string.

  Translating the pseudocode into Java gives us the method shown in Fig-

ure 7.8. Note how string concatenation is used to build the resultStr.

Each time an occurrence is found, its location (ptr) is concatenated to

the right-hand side of the resultStr. When the loop terminates, the

number of occurrences (count) is concatenated to the left-hand side of

the resultStr.

                                                                                     

/ 

   Pre : s and keyword are any S t r i n g s

   Post : keywordSearch () returns a String containing the

   number of o c c u r r e n c e s of keyword in s , followed

   by the s t a r t i n g l o c a t i o n of each o c c u r r e n c e

  /

public S t r i n g keywordSearch ( S t r i n g s , S t r i n g keyword ) {
   String resultStr = "" ;
   int count = 0;
   i n t ptr = s . indexOf ( keyword ) ;
   while ( ptr != -1) {
      ++count ;
       resultStr = resultStr + ptr + " " ;
       p t r = s . indexOf ( keyword , p t r + 1 ) ; // N e x t o c c u r r e n c e
   }

  resultStr = count + " : " + resultStr ; // I n s e r t t h e c o u n t
  return resultStr ;

// R e t u r n as a S t r i n g

} // k e y w o r d S e a r c h ( )

                                                                                     

         Figure 7.8: The keywordSearch() method.

Testing and Debugging                                                                     What test data do we need?

What test data should we use for the keywordSearch() method? One
important consideration in this case is to test that the method works for
all possible locations of the keyword within the string. Thus, the method
should be tested on strings that contain keyword occurrences at the begin-
ning, middle, and end of the string. We should also test the method with
a string that doesn't contain the keyword. Such tests will help verify that
the loop will terminate properly in all cases. Given these considerations,
Table 7.1 shows the tests that were made. As you can see from these re-
sults, the method did produce the expected outcomes. While these tests
do not guarantee its correctness, they provide considerable evidence that
the algorithm works correctly.

  JAVA EFFECTIVE DESIGN Test Data. In designing test data to
  check the correctness of a string searching algorithm, it's important to
  use data that test all possible outcomes.
                                       308             CHAPTER 7  Strings and String Processing

                                       TABLE 7.1 Testing the keywordSearch() method.

                                       Test Performed                                  Expected Result

                                       keywordSearch("this is a test","is")            2: 2 5
                                       keywordSearch("able was i ere i saw elba","a")  4: 0 6 18 24
                                       keywordSearch("this is a test","taste")         0:

                        7.5 From the Java Library: java.lang.StringBuffer

java.sun.com/j2se/1.5.0/docs/api/ ONE PROBLEM with the keywordSearch() method is that it is not
                                   very efficient because a String in Java is a read-only object. This means
                                   that once it has been instantiated, a String cannot be changed. You
                                   cannot insert new characters or delete existing characters from it.

                                       JAVA LANGUAGE RULE Strings Are Immutable. Once
                                       instantiated, a Java String cannot be altered in any way.

                                       Given this fact, how is it possible that the resultStr in the keyword-
                                       Search() ends up with the correct value? he answer is that every time
                                       we assign a new value to resultStr, Java has to create a new String
                                       object. Figure 7.9 illustrates the process. Thus, given the statement

                                                                                                                     

resultStr=resultStr+ptr+" "            resultStr = resultStr + ptr + " " ;
                                                                                                                     

    : String         : String          Java will evaluate the right-hand side, which creates a new String object
                                       whose value would be the concatenation of the right-hand-side elements,
value=" "        value="4 "            resultStr + ptr + " " (Fig. 7.9a). It would then assign the new ob-
count=0          count=2               ject as the new referent of resultStr (Fig. 7.9b). This turns the previous
                                       referent of resultStr into an orphan object--that is, into an object that
(a) Before assignment                  no longer has any references to it. Java will eventually dispose of these
                                       orphaned objects, removing them from memory in a process known as
                 resultStr             garbage collection. However, creating and disposing of objects is a task
                                       that consumes the computer's time.
(Orphan object)
                                          The fact that this assignment statement occurs within a loop means
    : String         : String          that several new objects are created and later garbage collected. Because
                                       object creation is a relatively time-consuming and memory-consuming
value=""         value="4 "            operation, this algorithm is somewhat wasteful of Java's resources.
count=0          count=2
                                          Of course, except for the inefficiency of doing it this way, no real harm
(b) After assignment                   is done by this algorithm used in the keywordSearch() method. Java's
                                       garbage collector will automatically reclaim the memory used by the or-
Figure 7.9: Evaluating resultStr
= resultStr + ptr + " "
creates an orphan object that must be
garbage collected.
SECTION 7.5  From the Java Library: java.lang.StringBuffer             309

phaned object. However, this algorithm does consume more of Java's
resources than other algorithms we might use.

JAVA LANGUAGE RULE Automatic Garbage Collection. An
object that has no reference to it can no longer be used in a program.
Therefore, Java will automatically get rid of it. This is known as
garbage collection.

A more efficient way to write the keywordSearch() method would                                                                 Choosing the appropriate data
make use of a StringBuffer to store and construct the resultStr.                                                               structure
Like the String class, the java.lang.StringBuffer class also rep-
resents a string of characters. However, unlike the String class, a
StringBuffer can be modified, and it can grow and shrink in length
as necessary. As Figure 7.10 shows, the StringBuffer class contains
several of the same kind of methods as the String class, for exam-
ple, charAt() and length(). But it also contains methods that allow
characters and other types of data to be inserted into a string, such as
append(), insert(), and setCharAt(). Most string-processing algo-
rithms use StringBuffers instead of Strings as their preferred data
structure.

JAVA PROGRAMMING TIP StringBuffer. A StringBuffer
should be used instead of a String for any task that involves
modifying a string.

The StringBuffer class provides several methods that are useful for                                                            
string processing. The constructor method, StringBuffer(String),
makes it easy to convert a String into a StringBuffer. Similarly, once                                                                                  Object
you are done processing the buffer, the toString() method makes it
easy to convert a StringBuffer back into a String.                                                                                             +toString() : String

   The typical way to use a StringBuffer is shown in the following                                                                                  StringBuffer
revised version of the keywordSearch() method:
                                                                                                                                     +StringBuffer()
                                                                                                                                     +StringBuffer(in s : String)
                                                                                                                                     +append(in data : <type>)
    public S t r i n g keywordSearch ( S t r i n g s , S t r i n g keyword ) {                                                       +charAt(in n : int) : char
                                                                                                                                     +insert(in n : int, in data : <type>)
                                                                                       // C r e a t e S t r i n g B u f f e r        +length() : int

        S t r i n g B u f f e r r e s u l t S t r = new S t r i n g B u f f e r ( ) ;                                           +setCharAt(in n : int, in ch : char)
        int count = 0;
        i n t ptr = s . indexOf ( keyword ) ;                                                                                        +toString() : String
       while ( ptr != -1) {
                                                                                                                               Figure  7.10:                  The
           ++count ;
           r e s u l t S t r . append ( ptr + " " ) ; // Append t o b u f f e r
           ptr = s . indexOf ( keyword , ptr + 1 ) ;
       }
        resultStr . insert (0 , count + " : " ) ;
        return resultStr . toString ( ) ; // Convert b u f f e r to S t r i n g
    } // k e y w o r d S e a r c h ( )
 

We declare resultStr as a StringBuffer instead of a String. Then,
instead of concatenating the ptr and reassigning the resultStr, we
append() the ptr to the resultStr for each occurrence of a keyword.
Similarly, after the loop exits, we insert() the count at the front (index

                                                                                                                               java.lang.StringBuffer

                                                                                                                               class.
                       310                  CHAPTER 7  Strings and String Processing

Strings are immutable  0) of the resultStr. Finally, we convert resultStr into a String by
                       using the toString() method before returning the method's result.

                          One advantage of the StringBuffer class is that there are several
                       versions of its insert() and append() methods. These make it pos-
                       sible to insert any type of data--int, double, Object, and so on--into a
                       StringBuffer. The method itself takes care of converting the data into
                       a string for us.

                          To summarize, String objects in Java are immutable. So when a
                       String is "modified," this really means that a new String object is cre-
                       ated and the old String object must be garbage collected. This is some-
                       what inefficient, especially if done repeatedly within a loop. To avoid
                       these inefficiencies, use a StringBuffer instead of a String in such
                       contexts.

                       7.6 Retrieving Parts of Strings

                       Programmers often need to retrieve an individual character or a part of a
                       string from a string, as, for example, in a word processing program when
                       a part of a string is copied or deleted. In this section we look at methods
                       that help us with these kinds of tasks.

                          The charAt(int index) method is a String instance method that
                       can be used to retrieve the character stored at a certain index. The several
                       varieties of the substring() method can be used to retrieve a substring
                       of characters from a String. These methods are defined as follows:

                                                                                                     

                       public char charAt ( int index )

                       public String substring ( int startIndex )

                       public String substring ( int startIndex , int endIndex )                     
                       

                       The charAt() method returns the character located at the index supplied
                       as its parameter. Thus, str.charAt(0) retrieves the first character in
                       str, while str.charAt(str.length()-1) retrieves the last character.

                          The substring() methods work in a similar way, except that you
                       need to specify both the starting and the ending index of the sub-
                       string you wish to retrieve. The first version of substring(int
                       startIndex) takes a single parameter and returns a String consisting
                       of all the characters beginning with startIndex and continuing up to
                       the end of the String. For example, if the str is "HelloWorld", then
                       str.substring(5) would return "World" and str.substring(3)
                       would return "loWorld":

                                                                                                     

                       String str = "HelloWorld" ;

                       str . substring (5)          ==> "World"

                       str . substring (3)          ==> " loWorld "
                                                                                                     

                       The substring(int, int) version requires that you specify both the
                       starting and ending index of the substring. The second index always
SECTION 7.6  Retrieving Parts of Strings                                                  311

points to the character that is one beyond the last character in the String
you want to retrieve. For example,

                                                                                                
                                                                                                
   // INDEX : 0123456789                   ==> "Wo"
    String str = "HelloWorld" ;            ==> " Hello "                                        
    str . substring (5 ,7)                 ==> "World"                                          
    str . substring (0 ,5)
    str . substring (5 , str . length ())                                                        Delimited strings
                                                                                                
                                                                                                
Note here that when we want to retrieve "Wo" from str, we specify its
substring as indexes 5 and 7; the 7 points to the character just beyond                         
"Wo." Similarly, substring(0,5), picks out the first five characters                            
("Hello"). In the third example, the length() method specifies the sub-
string beginning at index 5 and extending to the end of the string. This is
equivalent to str.substring(5):



   // INDEX : 0123456789                   ==> "World"
    String str = "HelloWorld" ;            ==> "World"
    str . substring (5 , str . length ())
    str . substring (5)


The fact that the second parameter in substring() refers to the char-
acter one beyond the desired substring may seem a bit confusing at first,
but it is actually a very useful way to designate a substring. For example,
many string-processing problems have to do with retrieving substrings
from a delimited string, which is a string that contains special characters
that separate the string into certain substrings. For example, consider the
string "substring1:substring2," in which the delimiter is the colon, ':'.
The following code retrieves the substring preceding the delimiter:



String str = "substring1 : substring2" ;

int n = str . indexOf ( ' : ' ) ;

  str . substring (0 ,n)                   ==> " s u b s t r i n g 1 "


Thus, by making the second index of substring() refer to the char-
acter one beyond the last character in the desired substring, we can use
indexOf() and substring() together to process delimited strings.
Note that it is not necessary to use a temporary variable n to store the
index of the delimiter, because the two method calls can be nested:



  String str = "substring1 : substring2" ;
  s t r . s u b s t r i n g ( 0 , s t r . indexOf ( ' : ' ) ) ==> " s u b s t r i n g 1 "


JAVA DEBUGGING TIP substring(int p1, int p2). Don't
forget that the second parameter in the substring() methods refers
to the character just past the last character in the substring.

SELF-STUDY EXERCISES
                  312                            CHAPTER 7  Strings and String Processing

                  EXERCISE 7.10 Given the String declaration

                                                                                         

                  String s = "abcdefghijklmnopqrstuvwxyz" ;
                                                                                         

                  evaluate each of the following expressions:

                  a. s.substring(20)                             d. s.substring(23, 25)

                  b. s.substring(1, 5)                           e. s.substring(s.indexOf('x'))

                  c. s.substring(23)

                  EXERCISE 7.11 Given the preceding declaration of s, evaluate each of
                  the following expressions:

                  a. s.substring(20, s.length())
                  b. s.substring(s.indexOf('b'), s.indexOf('f'))
                  c. s.substring(s.indexOf("xy"))
                  d. s.substring(s.indexOf(s.charAt(23)))
                  e. s.substring(s.length() - 3)

                  7.7 Example: Processing Names and Passwords

                  Many computer systems store user names and passwords as delimited
                  strings, such as

                                                                                                

                    smith : bg1s5xxx

                    mccarthy :2 ffo900ssi

                    cho : biff4534ddee4w
                                                                                                

Algorithm design  Obviously, if the system is going to process passwords, it needs some way
                  to take apart these name-password pairs.

                     Let's write methods to help perform this task. The first method will
                  be passed a name-password pair and will return the name. The second
                  method will be passed a name-password pair and will return the pass-
                  word. In both cases, the method takes a single String parameter and
                  returns a String result:

                                                                                                

                    S t r i n g getName ( S t r i n g s t r ) ;

                    String getPassword ( String str ) ;
                                                                                                

                  To solve this problem we can make use of two String methods. We use
                  the indexOf() method to find the location of the delimiter--which is the
                  colon, ":"--in the name-password pair and then we use substring() to
                  take the substring occurring before or after the delimiter. It may be easier
                  to see this if we take a particular example:

                                                                                                

                       INDEX :                1                  2

                       INDEX : 012345678901234567890

                                jones : b34rdffg12               // ( 1 )

                                cho : rtf546                     // ( 2 )

                                                                                                

                  In the first case, the delimiter occurs at index position 5 in the string.
                  Therefore, to take the name substring, we would use substring(0,5).
SECTION 7.8  Processing Each Character in a String                      313

To take the password substring, we would use substring(6). Of
course, in the general case, we would use variables to indicate the position
of the delimiter, as in the following methods:

                                                                                     

public s t a t i c S t r i n g getName ( S t r i n g s t r ) {
   int posColon = s t r . indexOf ( ' : ' ) ; // F i n d t h e d e l i m i t e r
   String result = s t r . substring (0 , posColon ) ; // Get name
   return result ;

}

public static String getPassword ( String str ) {

   int posColon = s t r . indexOf ( ' : ' ) ; // F i n d t h e d e l i m i t e r

   String result = s t r . substring ( posColon + 1 ) ; // Get passwd

   return result ;

}

                                                                                     

Note in both of these cases we have used local variables, posColon and
result, to store the intermediate results of the computation--that is, the
index of the ":" and the name or password substring.

   An alternative way to code these operations would be to use nested
method calls to reduce the code to a single line:

                                                                                  

return str . substring (0 , str . indexOf ( ' : ' ) ) ;                           


In this line, the result of str.indexOf(':') is passed immediately as
the second argument to str.substring(). This version dispenses with
the need for additional variables. And the result in this case is not unrea-
sonably complicated. But whenever you are faced with a trade-off of this
sort--nesting versus additional variables--you should opt for the style
that will be easier to read and understand.

JAVA EFFECTIVE DESIGN Nested Method Calls. Nested method
calls are fine as long as there are not too many levels of nesting. The
goal should be to produce code that is easy to read and understand.

7.8 Processing Each Character in a String

Many string-processing applications require you to process each character         Counting loop algorithm
in a string. For example, to encrypt the string "hello" into "jgnnq", we
have to go through each letter of the string and change each character to
its substitute.

   These types of algorithms usually involve a counting loop bounded by
the length of the string. Recall that the length() method determines
the number of characters in a String and that strings are zero indexed.
This means that the first character is at index 0, and the last character is
at index length()-1. For example, to print each character in a string on
                  314  CHAPTER 7  Strings and String Processing

                  a separate line, we would step through the string from its first to its last

                  character and print each character::

                                                                                                                

                  // P r e c o n d i t i o n : s t r i s n o t n u l l

                  // P o s t c o n d i t i o n : t h e l e t t e r s i n s t r w i l l have been p r i n t e d

                  public void printLetters ( String str ) {

                       for ( int k = 0; k < s t r . length ( ) ; k++)// F o r e a c h c h a r

                       System . out . println ( s t r . charAt ( k ) ) ; // P r i n t i t

                  }

                                                                                                                

Counting bound    Note that our loop bound is k < str.length(), since the index of
Off-by-one error  the last character of any String is length()-1. Note also the use of
                  str.charAt(k) to retrieve the kth character in str on each iteration of
Method design     the loop.
Algorithm design
                     Note the use of pre- and postconditions in the method's comment
                  block. The precondition states that str has been properly initialized--
                  that is, it is not null. The postcondition merely states the expected
                  behavior of the method.

                  7.8.1 Off-by-One Error

                  A frequent error in coding counter-controlled loops is known as the off-
                  by-one error, which can occur in many different ways. For example, if
                  we had coded the loop boundary condition as k <= str.length(),
                  this would cause an off-by-one error, because the last character
                  in str is at location length()-1. This would lead to a Java
                  IndexOutOfBoundsException, which would be reported as soon as
                  the program executed this statement.

                     The only way to avoid off-by-one errors is to check your loop bounds
                  whenever you code a loop. Always make sure you have the loop counter's
                  initial and final values correct.

                  JAVA DEBUGGING TIP Off-by-One Errors. Loops should be
                  carefully checked to make sure they don't commit an off-by-one error.
                  During program testing, develop data that tests the loop variable's
                  initial and final values.

                  7.8.2 Example: Counting Characters

                  As another example of an algorithm that processes each character in a
                  string, consider the problem of computing the frequency of the letters in
                  a given document. Certain text analysis programs, such as programs that
                  analyze encrypted data and spam filters, perform this type of function.

                     The countChar() method will count the number of occurrences of
                  any particular character in a String (Fig. 7.11). This method takes two
                  parameters: a String parameter that stores the string being searched and
                  a char parameter that stores the character being counted.

                     Begin by initializing the local variable, counter, to 0. As in the pre-
                  vious example, the for loop here will iterate through each character of
                  the String--from 0 to length()-1. On each iteration a check is made
                  to see if the character in the kth position (str.charAt(k)) is the char-
                  acter being counted. If so, counter is incremented. The method ends
   SECTION 7.8  Processing Each Character in a String                                         315
                                                                                                 

// P r e c o n d i t i o n : N e i t h e r s t r nor ch a r e n u l l                            

// P o s t c o n d i t i o n : c o u n t c h a r ( ) == t h e number o f ch i n s t r

public int countChar ( String str , char ch ) {

     int counter = 0;                    // I n i t i a l i z e a c o u n t e r

     for ( int k = 0; k < s t r . length ( ) ; k++)// F o r e a c h c h a r

     i f ( s t r . charAt ( k ) == ch )        // I f i t ' s a ch

        counter ++;                            //                                    count it

     return counter ;                    // R e t u r n t h e r e s u l t

  }


Figure 7.11: A method to count the occurrence of a particular character in
a string.

by returning counter, which, when the method completes, will store an
integer representing the number of ch's in str.

7.8.3 Example: Reversing a String

Another interesting method that processes each character in a string is the                     Algorithm design
reverse() method. This is a method that reverses the letters in a string.                      
For example, the reverse of "java" is "avaj".

   The algorithm for the reverse() method should use a simple count-
ing loop to reverse the letters in its String parameter. In this case, how-
ever, we can process the string from right to left, beginning at its last char-
acter and ending with its first character. That way we can just append
each character, left to right, in the result string:

 

     /

      Pre : s i s any non n u l l s t r i n g

      Post : s is returned in reverse order

     /

     public String reverse ( String s ) {
            S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;
            f o r ( i n t k = s . l e n g t h ( ) - 1 ; k >= 0 ; k--) {
                   r e s u l t . append ( s . charAt ( k ) ) ;
            } // f o r

        return result . toString ( ) ;

     } // r e v e r s e ( )

                                                                                               

Note that as in the other string-manipulation algorithms--for exam-
ple, keywordSearch()--we should us a StringBuffer to store the
method's result. Thus we declare the result StringBuffer at the be-
ginning of the method and convert it back into a String at the end of the
method.

     JAVA PROGRAMMING TIP Changing Each Character in a
     String. Algorithms that require you to alter a string should use a
     StringBuffer to store the result.
                  316                           CHAPTER 7  Strings and String Processing

                  7.8.4 Example: Capitalizing the First Letter

                  Another string manipulation method is the capitalize() method,

Algorithm design  which returns a String whose initial letter is capitalized but whose

                  other letters are lowercase - for example, "Hello". We use the static

                  toUpperCase() and toLowerCase() methods from the Character

                  class to convert individual letters. We could also have used the methods

                  of the same name that we wrote in Section 5.8. The algorithm converts

                  the first letter to upper case and then loops through the remaining letters

                  converting each to lowercase:

                                                                                                       

                  /

                        Pre : s i s any non n u l l s t r i n g

                        Post : s is returned with only i t s f i r s t l e t t e r capitalized

                       /

                  public String capitalize ( String s ) {

                       i f ( s . l e n g t h ( ) == 0 )  // S p e c i a l c a s e : empty s t r i n g

                          return s ;

                       S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;

                       r e s u l t . append ( Character . toUpperCase ( s . charAt ( 0 ) ) ) ;

                                                         // C o n v e r t t h e f i r s t l e t t e r

                       for ( int k = 1; k < s . length ( ) ; k++) { // And t h e r e s t
                          r e s u l t . append ( Character . toLowerCase ( s . charAt ( k ) ) ) ;

                       } // f o r

                       return result . toString ( ) ;

                  } // c a p i t a l i z e ( )

                                                                                                       

                  SELF-STUDY EXERCISES

                  EXERCISE 7.12 Write a Java program to test the methods described in
                  this section. Organize the methods themselves into a single class, named
                  StringProcessor, and design a second class to serve as the user inter-
                  face. Because these methods are similar to the utility methods of the Math
                  class, it would be useful to declare them static. The user interface should
                  prompt the user to input a string and should then print out the result of
                  passing that string to each of the methods we developed.

                  EXERCISE 7.13 Add a method to the StringProcessor class that
                  will remove all blanks from a string. It should take a String parameter
                  and should return a String result.

                  7.8.5 Miscellaneous String Methods

                  In addition to the several String class methods we have discussed--
                  valueOf(), equals(), indexOf(), lastIndexOf(), charAt(),
                  substring()--Table 7.2 shows some of the other useful methods in the
                  String class. Note that because of what we said about the read-only na-
                  ture of Strings, methods such as toUpperCase(), toLowerCase(),
                  and trim() do not change their string. Instead they produce a new
        SECTION 7.9  Comparing Strings                                 317

ome useful String methods applied to the literal string "Perfection."

ture                                 Example

dsWith(String suffix)                "Perfection".endsWith("tion")  true
artsWith(String prefix)              "Perfection".startsWith("Per")  true
artsWith(String prefix, int offset)  "Perfection".startsWith("fect",3)  true
pperCase()                           "Perfection".toUpperCase()  "PERFECTION"
owerCase()                           "Perfection".toLowerCase()  "perfection"
m()                                  "Perfection".trim()  "Perfection"

        string. If you want to use one of these methods to convert a string, you
        must reassign its result back to the original string:

                                                                                        

        S t r i n g s = new S t r i n g ( " h e l l o world " ) ;

        s = s . toUpperCase ( ) ; // s now e q u a l s " HELLO WORLD "                  
        

        7.9 Comparing Strings

        Comparing strings is another important task. For example, when a word           H precedes h
        processor performs a search and replace operation, it needs to identify
        strings in the text that match the target string.

           Strings are compared according to their lexicographic order--that is, the
        order of their characters. For the letters of the alphabet, lexicographic or-
        der just means alphabetical order. Thus, a comes before b and d comes
        after c. The string "hello" comes before "jello" because h comes before j in
        the alphabet.

           For Java and other programming languages, the definition of lexico-
        graphic order is extended to cover all the characters that make up the
        character set. We know, for example, that in Java's Unicode character set
        the uppercase letters come before the lowercase letters (Table 5.13). So, the
        letter H comes before the letter h and the letter Z comes before the letter a.

           Lexicographic order can be extended to include strings of characters.
        Thus, "Hello" precedes "hello" in lexicographic order because its first let-
        ter, H, precedes the first letter, h, in "hello." Similarly, the string "Zero"
        comes before "aardvark," because Z comes before a. To determine lexico-
        graphic order for strings, we must perform a character-by-character com-
        parison, starting at the first character and proceeding left to right. As an
        example, the following strings are arranged in lexicographic order:

                                                                                        

      "" " ! " " 0 " "A" "Andy" "Z" " Zero " "a" "an" "and" "andy" " candy " " zero "
                                                                                        
                       318                           CHAPTER 7  Strings and String Processing

                       We can define lexicographic order for strings as follows:

                         JAVA LANGUAGE RULE Lexicographic Order. For strings s1 and
                         s2, s1 precedes s2 in lexicographic order if its first character precedes
                         the first character of s2. If their first characters are equal, then s1
                         precedes s2 if its second character precedes the second character of s2;
                         and so on. An empty string is handled as a special case, preceding all
                         other strings.

                       Perhaps a more precise way to define lexicographic order is to define a
                       Java method:

                                                                                                                            

                         public boolean precedes ( String s1 , String s2 ) {

                                                                                      // P i c k s h o r t e r l e n g t h

                            i n t minlen = Math . min ( s1 . l e n g t h ( ) , s2 . l e n g t h ( ) ) ;

                                                          // For e a c h c h a r i n s h o r t e r  string }
                                                                                                    chars unequal
                            for ( int k=0; k < minlen ; k++) {
                               if ( s1 . charAt (k) != s2 . charAt (k )) // I f

                                       // r e t u r n t r u e i f s1 ' s c h a r p r e c e d e s s2 ' s

                                   return s1 . charAt (k) < s2 . charAt (k ) ;
                            }

                            // I f a l l c h a r a c t e r s so f a r a r e e q u a l

                            // t h e n s1 < s2 i f i t i s s h o r t e r t h a n s2

                            return s1 . length () < s2 . length ( ) ;

                         } // p r e c e d e s ( ) }

                                                                                                                            

Algorithm: Loop bound  This method does a character-by-character comparison of the two strings,
                       proceeding left to right, starting at the first character in both strings.
                       Its for loop uses a counting bound, which starts at k equal to zero
                       and counts up to the length of the shorter string. This is an impor-
                       tant point in designing this algorithm. If you don't stop iterating when
                       you get past the last character in a string, your program will generate a
                       StringIndexOutOfBounds exception. To prevent this error, we need to
                       use the shorter length as the loop bound.

                          Note that the loop will terminate early if it finds that the respective
                       characters from s1 and s2 are unequal. In that case, s1 precedes s2 if s1's kth
                       character precedes s2's. If the loop terminates normally, that means that
                       all the characters compared were equal. In that case, the shorter string
                       precedes the longer. For example, if the two strings were "alpha" and
                       "alphabet," then the method would return true, because "alpha" is shorter
                       than "alphabet."

                       SELF-STUDY EXERCISES

                       EXERCISE 7.14 Arrange the following strings in lexicographic order:

                                                                                                                            

                       zero bath bin alpha Alpha Zero Zeroes a A z Z                                                        
                       

                       EXERCISE 7.15 Modify the precedes() method so that it will also
                       return true when s1 and s2 are equal--for example, when s1 and s2 are
                       both "hello".
SECTION 7.9  Comparing Strings                          319

7.9.1 Object Identity Versus Object Equality

Java provides several methods for comparing Strings:

                                                                                

  public  boolean equals ( Object anObject ) ; // O v e r r i d e s O b j e c t . e q u a l s ( )
  public  boolean equalsIgnoreCase ( String anotherString ) ;
  public  int compareTo ( String anotherString ) ;

                                                                                              

The first comparison method, equals(), overrides the Object.equals()

method. Two Strings are equal if they have the exact same letters in the

exact same order. Thus, for the following declarations,                         Equality vs. identity

                                                                                

  String s1 = "hello" ;                                                          Venus            The morning star
  String s2 = "Hello" ;


s1.equals(s2) is false, but s1.equals("hello") is true.                         Figure 7.12: Venus is the morning
   You have to be careful when using Java's equals() method. Accord-            star, so "Venus" and "the morn-
                                                                                ing star" are two references to the
ing to the default definition of equals(), defined in the Object class,         same object.
"equals" means "identical." Two Objects are equal only if their names
are references to the same object.

   This is like the old story of the morning star and the evening star,
which were thought to be different objects before it was discovered that
both were just the planet Venus. After the discovery, it was clear that
"the morning star" and "the evening star" and "Venus" were just three
different references to one and the same object (Fig. 7.12).

   We can create an analogous situation in Java by using the following
JButton definitions:

                                                                                

    J B u t t o n b1 = new Button ( "a " ) ;                                       b1              b2 b3 (References)
    J B u t t o n b2 = new Button ( "a " ) ;
    JButton b3 = b2 ;                                                           쯠                 a (Labeled buttons)
 
                                                                                JButton b1=new JButton("a");
Given these three declarations, b1.equals(b2) and b1.equals(b3)                 JButton b2=new JButton("a");
would be false, but b2.equals(b3) would be true because b2 and b3               JButton b3=b2;
are just two names for the same object (Fig. 7.13). So, in this case, "equals"
really means "identical."                                                       Figure 7.13: For most objects,
                                                                                equality means identity. JBut-
   Moreover, in Java, when it is used to compare two objects, the               tons b2 and b3 are identical (and,
equality operator (==) is interpreted in the same way as the default            hence, equal), but JButtons b1 and
Object.equals() method. So, it really means object identity. Thus,              b2 are not identical (and, hence,
b1 == b2 would be false, because b1 and b2 are different objects, but           unequal).
b2 == b3 would be true because b2 and b3 refer to the same object.

   These points are illustrated in the program shown in Figure 7.14. This
program uses methods isEquals() and isIdentical() to perform
 320                                   CHAPTER 7  Strings and String Processing

          java . awt .  ;
  import

public class TestEquals {                      ("a" ) ;
   s t a t i c Button b1 = new Button          ( "b" ) ;
   s t a t i c Button b2 = new Button
   s t a t i c Button b3 = b2 ;

private s t a t i c void isEqual ( Object o1 ,            Object o2 )        {
   i f ( o1 . equals ( o2 ) )                             " equals "
       System . out . println ( o1 . toString ( ) +       " does NOT         + o2 . toString ( ) ) ;
   else
       System . out . println ( o1 . toString ( ) +                          equal " +
                                                                                o2 . toString ( ) ) ;
} // i s E q u a l ( )

private s t a t i c void i sI d en t ic a l ( Object      o1 , Object o2 ) {
   i f ( o1 == o2 )
       System . out . println ( o1 . toString ( ) +       " is identical to " +
                                                                                 o2 . toString ( ) ) ;
   else
       System . out . println ( o1 . toString ( ) +       " i s NOT i d e n t i c a l t o " +
                                                                                 o2 . toString ( ) ) ;
} // i s I d e n t i c a l ( )

public static      void                main ( S t r i n g argv [ ] ) {
   isEqual ( b1 ,  b2 ) ;
   isEqual ( b1 ,  b3 ) ;                                // n o t e q u a l
   isEqual ( b2 ,  b3 ) ;                                // n o t e q u a l
                                                         // e q u a l

         i s I d e n t i c a l ( b1 ,  b2 ) ;  // n o t i d e n t i c a l
         i s I d e n t i c a l ( b1 ,  b3 ) ;  // n o t i d e n t i c a l
         i s I d e n t i c a l ( b2 ,  b3 ) ;  // i d e n t i c a l
     } // main ( )

  } // T e s t E q u a l s


Figure 7.14: The TestEquals program tests Java's default equals()
method, which is defined in the Object class.

the comparisons and print the results. This program will produce the
following output:

 

    java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label=a ]
         does NOT equal j a v a . awt . Button [ button1 , 0 , 0 , 0 x0 , i n v a l i d , l a b e l =b ]

    java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label=a ]
         does NOT equal j a v a . awt . Button [ button1 , 0 , 0 , 0 x0 , i n v a l i d , l a b e l =b ]

    jav a . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , la be l=b ]
         equals java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , label=b ]

    java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label=a ]
         i s NOT i d e n t i c a l t o j a v a . awt . Button [ button1 , 0 , 0 , 0 x0 , i n v a l i d , l a b e l

    java . awt . Button [ button0 , 0 , 0 , 0 x0 , invalid , label=a ]
         i s NOT i d e n t i c a l t o j a v a . awt . Button [ button1 , 0 , 0 , 0 x0 , i n v a l i d , l a b e l

    jav a . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , la be l=b ]
         i s i d e n t i c a l to java . awt . Button [ button1 , 0 , 0 , 0 x0 , invalid , label=b ]

 
                     SECTION 7.9  Comparing Strings                                                       321

                     7.9.2 String Identity Versus String Equality

                     In comparing Java Strings, we must be careful to distinguish between
                     object identity and string equality. Thus, consider the following declara-
                     tions, which create the situation shown in Figure 7.15.

r String objects,      "hello" s5 s6       s1 s4                             s2    "Hello"
dentity are differ-
nct (nonidentical)     : String            : String                      : String  : String
are equal if they
                       value="hello" value="hello" value="hello" value="Hello"
 string value. So
 s5, and s6 are        count=5           count=5                count=5            count=5
1 and s4 are iden-
 strings s5 and s6.    String s1=new String ("hello");                                                 s3
                       String s2=new String ("hello");                             : String

                       String s3=new String ("Hello");                             value="Hello"
                       String s4=s1;                                               count=5
                       String s5="hello";

                       String s6="hello";

                                                                                                                     

                       S t r i n g s1 = new S t r i n g ( " h e l l o " ) ;                                           Equality vs. identity
                                                                                                                     
                       S t r i n g s2 = new S t r i n g ( " h e l l o " ) ;                                          
                                                                                                                     
                       S t r i n g s3 = new S t r i n g ( " Hello " ) ;                                              
                                                                                                                     
                       String s4 = s1 ;                         // s 1 and s 4 a r e now i d e n t i c a l

                       String s5 = "hello" ;

                       String s6 = "hello" ;
                     

                     Given these declarations, we would get the following results if we com-
                     pare the equality of the Strings:

                     

                       s1 . e q u a l s ( s2 ) ==> t r u e s1 . e q u a l s I g n o r e C a s e ( s3 )  ==> t r u e
                       s1 . e q u a l s ( s3 ) ==> f a l s e s1 . e q u a l s ( s5 )                    ==> t r u e
                       s1 . e q u a l s ( s4 ) ==> t r u e s1 . e q u a l s ( s6 )                      ==> t r u e
                     

                     and the following results if we compare their identity:

                     

                       s1 == s2  ==> f a l s e                           s1 == s3 ==> f a l s e
                       s1 == s4  ==> t r u e                             s1 == s5 ==> f a l s e
                       s5 == s6  ==> t r u e
                     

                     The only true identities among these Strings are s1 and s4, and s5 and s6.
                     In the case of s5 and s6, both are just references to the literal string, "hello",
                     as we described in Section 7.2. The program in Figure 7.16 illustrates these
                     points.

                     SELF-STUDY EXERCISES

                     EXERCISE 7.16 Given the String declarations,

                                                                                                           

                     String s1 = "java" , s2 = "java" , s3 = "Java" ;

                     S t r i n g s4 = new S t r i n g ( s2 ) ;

                     S t r i n g s5 = new S t r i n g ( " j a v a " ) ;
                                                                                                           

                     evaluate the following expressions:
322                                       CHAPTER 7  Strings and String Processing


  import java . awt .  ;

public class TestStringEquals {

s t a t i c S t r i n g s 1 = new S t r i n g ( " h e l l o " ) ; // s 1 a n d s 2 a r e e q u a l , n o t

s t a t i c S t r i n g s2 = new S t r i n g ( " h e l l o " ) ;

s t a t i c S t r i n g s 3 = new S t r i n g ( " H e l l o " ) ; // s 1 a n d s 3 a r e n o t e q u a l

static String s4 = s1 ;                                             // s1 and s4 a r e i d e n t i c a l

static String s5 = "hello" ;                                        // s1 and s5 a r e n o t i d e n t i c

static String s6 = "hello" ;                                        // s5 and s6 a r e i d e n t i c a l

private s t a t i c void testEqual ( String str1 , String str2 ) {
   if ( str1 . equals ( str2 ))
       System . out . println ( str1 + " equals " + str2 ) ;
   else
       System . out . println ( str1 + " does not equal " + str2 ) ;

} // t e s t E q u a l ( )

private s t a t i c void t e s t I d e n t i c a l ( String str1 , String str2 ) {
   i f ( s t r 1 == s t r 2 )
       System . out . println ( str1 + " i s id en ti ca l to " + str2 ) ;
   else
       System . out . println ( str1 + " i s not id en ti ca l to " + str2 ) ;

} // t e s t I d e n t i c a l ( )

public s t a t i c void main ( S t r i n g            argv [ ] ) {

        testEqual ( s1 , s2 ) ;                   //  equal
                                                      not equal
        testEqual ( s1 , s3 ) ;                   //  equal
                                                      equal
        testEqual ( s1 , s4 ) ;                   //  equal

        testEqual ( s1 , s5 ) ;                   //

        testEqual ( s5 , s6 ) ;                   //

        t e s t I d e n t i c a l ( s1 ,  s2 ) ;  // n o t i d e n t i c a l
        t e s t I d e n t i c a l ( s1 ,  s3 ) ;  // n o t i d e n t i c a l
        t e s t I d e n t i c a l ( s1 ,  s4 ) ;  // i d e n t i c a l
        t e s t I d e n t i c a l ( s1 ,  s5 ) ;  // n o t i d e n t i c a l
        t e s t I d e n t i c a l ( s5 ,  s6 ) ;  // i d e n t i c a l

     }  // main ( )
  }//
        TestStringEquals

        ------Program Output-----
        hello equals hello
        hello does not equal Hello
        hello equals hello
        hello equals hello
        hello equals hello
        hello is not identical to hello
        hello is not identical to Hello
        hello is identical to hello
        hello is not identical to hello
        hello is identical to hello

Figure 7.16: Program illustrating the difference between string equality
and identity.
SECTION 7.10  From the Java Library: java.util.StringTokenizer 323

a. s1 == s2       d. s1.equals(s3)          g. s2 == s4
b. s1.equals(s2)  e. s2 == s3               h. s1 == s5
c. s1 == s3       f. s2.equals(s4)          i. s4 == s5

EXERCISE 7.17 Why are the variables in TestStringEquals de-
clared static?

EXERCISE 7.18 Given the following declarations,

                                                                       

String s1 = "abcdefghijklmnopqrstuvwxyz" ;

String s2 = " hello world" ;
                                                                       

write Java expressions to carry out each of the following operations:

a. Swap the front and back half of s1 giving a new string.
b. Swap "world" and "hello" in s2 giving a new string.
c. Combine parts of s1 and s2 to create a new string "hello abc".

7.10 From the Java Library:
        java.util.StringTokenizer

ONE OF THE most widespread string-processing tasks is that of breaking                                       java.sun.com/j2se/1.5.0/docs/api/
up a string into its components, or tokens. For example, when processing
a sentence, you may need to break the sentence into its constituent words,                           Object
which are considered the sentence tokens. When processing a name-
password string, such as "boyd:14irXp", you may need to break it into                                        쳃nterface
a name and a password. Tokens are separated from each other by one or
more characters which is known as delimiters. Thus, for a sentence, white                                   Enumeration
space, including blank spaces, tabs, and line feeds, serve as the delimiters.
For the password example, the colon character serves as a delimiter.                                 +hasMoreElements() : boolean

   Java's java.util.StringTokenizer class is specially designed for                                  +nextElement() : String
breaking strings into their tokens (Fig. 7.17). When instantiated with
a String parameter, a StringTokenizer breaks the string into to-                                  
kens, using white space as delimiters. For example, if we instantiated a
StringTokenizer as in the code                                                                               StringTokenizer

                                                                                                  +StringTokenizer(in s : String)

    StringTokenizer sTokenizer                                                                      +StringTokenizer(in s : String, in d : String)
       = new S t r i n g T o k e n i z e r ( " This i s an E n g l i s h s e n t e n c e . " ) ;    +countTokens() : int
                                                                                                    +hasMoreTokens() : boolean
                                                                                                    +nextToken() : String
                                                                                                    +nextToken(in delim : String) : String
it would break the string into the following tokens, which would be stored                          +hasMoreElements() : boolean
internally in the StringTokenizer in the order shown:
                                                                                                  +nextElement() : String
 

    This
    is
    an
    English
    sentence .
 

Note that the period is part of the last token ("sentence."). This is because
punctuation marks are not considered delimiters by default.

                                                                                                  Figure     7.17:                 The

                                                                                                  java.util.StringTokenizer

                                                                                                  class.
                                        324                           CHAPTER 7  Strings and String Processing

                                           If you wanted to include punctuation symbols as delimiters, you could
                                        use the second StringTokenizer() constructor, which takes a second
                                        String parameter (Fig. 7.17). The second parameter specifies a string of
                                        those characters that should be used as delimiters. For example, in the
                                        instantiation,

                                                                                                                                                     

                                        StringTokenizer sTokenizer

                                               = new S t r i n g T o k e n i z e r ( " This i s an E n g l i s h s e n t e n c e . " ,

                                                                      "\b\ t \n , ; . ! " ) ;                                                        

                                        various punctuation symbols (periods, commas, and so on) are included
                                        among the delimiters. Note that escape sequences (\b\t\n) are used to
                                        specify blanks, tabs, and newlines.

                                           The hasMoreTokens() and nextToken() methods can be used to
                                        process a delimited string, one token at a time. The first method returns
                                        true as long as more tokens remain; the second gets the next token in the
                                        list. For example, here's a code segment that will break a standard URL
                                        string into its constituent parts:

                                                                                                                                                     

                                        S t r i n g u r l = " http :// java . t r i n c o l l . edu/~ j j j /index . html" ;

                                        S t r i n g T o k e n i z e r s T o k e n i z e r = new S t r i n g T o k e n i z e r ( u r l , " : / " ) ;

                                        while ( sTokenizer . hasMoreTokens ( ) ) {

                                               System . out . println ( sTokenizer . nextToken ( ) ) ;

                                        }

                                                                                                                                                     

                                        This code segment will produce the following output:

                                                                                                                                                     

                                        http

                                        java . t r i n c o l l . edu

                                        ~ jjj

                                        index . html
                                                                                                                                                     

                                        The only delimiters used in this case were the ":" and "/" symbols. And
                                        note that nextToken() does not return the empty string between ":"
                                        and "/" as a token.

                      Graphics          7.11 Handling Text in a Graphics Context
                                                (Optional)
   +getFont() : Font
   +getFontMetrics() : FontMetrics      In order to create attractive GUIs, it is often necessary to be able to select
   +setFont(in f : Font)                and control the font that is used. Even a simple drawing task, such as
   +setFontMetrics(in f : FontMetrics)  being able to center a message in a panel, requires that we know the font's
                                        dimensions and be able to manipulate them. In this section, we learn how
Figure 7.18: Methods to access the      to work with Java's fonts and font control methods.
Font and FontMetrics objects
associated with each Graphics              Each graphics context has an associated Font and FontMetrics ob-
context.                                ject, and the Graphics class (Fig. 7.18) provides several methods to ac-
                                        cess them. A FontMetrics is an object that encapsulates important
                                        data about a font, such as its height and width. Java assigns a default
                                        font to each Graphics object. For example, this is the font used by the
SECTION 11  Handling Text in a Graphics Context                        325

drawString() method, which we used in our very first Java programs
back in Chapter 1. The particular font used is system dependent, but to
override the default one can simply invoke the setFont() method:

                                                                                 

g . s e t F o n t (new Font ( "TimesRoman" , Font . ITALIC , 1 2 ) ) ;           


In this case, the Font() constructor is used to specify a 12-point, itali-
cized, TimesRoman font. Once the font is set, it will be used in all subse-
quent drawings.

7.11.1 The Font and FontMetrics Classes                                               Font

The Font class (Fig. 7.19) provides a platform-independent representa-                +BOLD : int
tion of an individual font. A font is distinguished by its name, size,                +ITALIC : int
and style, and the Font class includes protected instance variables for               +PLAIN : int
these properties, as well as a constructor method that allows these three             # name : String
characteristics to be specified.                                                      # size : int
                                                                                      # style : int
   In order to understand how fonts work, it is necessary to distinguish              +Font(in s : String, in sty : int, in sz : int)
between a character, which is a symbol that represents a certain letter or
digit, and a glyph, which is a shape used to display the character. When                Figure 7.19: The Font class.
you display a string, such as "Hello", Java maps each individual charac-
ter into a corresponding shape, as defined by the particular font that is
selected.

   Java distinguishes between physical and logical fonts. A physical font is
an actual font library that contains the data and tables needed to associate
the correct glyph with a given character. Generally speaking, a given plat-
form (host computer plus operating system) will have a collection of such
fonts available on it.

   A logical font is one of five font families that are supported by the Java
runtime environment. These include Serif, SansSerif, Monospaced, Dia-
log, and DialogInput. Java also supports the following font styles: PLAIN,
BOLD, ITALIC, and BOLD+ITALIC. Whereas the physical fonts are plat-
form dependent, the logical fonts and styles are platform independent.
When used in a program, they are mapped to real fonts available on the
host system. If the host system does not have an exact match for the speci-
fied font, it will supply a substitute. For example, if you specify a 48-point,
italic, Monospaced font,

                                                                                 

Font myFont = new Font ( "Monospaced" , Font . ITALIC , 4 8 ) ;
                                                                                 

the system may map this to a 24-point, italic Courier font, if that is the
largest fixed-spaced font available.

   The Font() constructor is designed to work with any set of arguments.
Thus, if you supply the name of a font that is not available, the system
will supply a default font as a substitute. For example, on my system,
specifying a nonexistent font named Random,

                                                                                 

g . s e t F o n t (new Font ( "Random" , Font . ITALIC , 1 2 ) ) ;

g . drawString ( " Hello , World ! ! ( random , i t a l i c , 1 2 ) " , 30 , 4 5 ) ;
                                                                                 
                                     326                  CHAPTER 7  Strings and String Processing

                                     produces the same font used as the mapping for a font named Dialog.

                                     JAVA EFFECTIVE DESIGN Font Portability. The fact that Font()
                                     will produce a font for virtually any set of arguments is important in
                                     ensuring that a Java program will run on any platform. This is another
                                     example of how Java has been designed for portability.

                                        The Component.setFont() method can be used to assign a specific
                                     font to a button or window or other graphics component. All AWT and
                                     JFC components have an associated font, which can be accessed using the
                                     Component.setFont() and Component.getFont() methods. For
                                     example, the following code could be used to override a Button's font:

                                                                                                                     

                                     Button b = new Button ( " Label " ) ;

                                     b . s e t F o n t (new Font ( " Times " , Font . ITALIC , 1 4 ) ) ;
                                                                                                                     

                                     If 14-point, italic, Times font is not available on the host system, a substi-
                                     tute will be supplied.

                                     7.11.2 Font Metrics

Problem statement                    To illustrate how to use the FontMetrics class, let's write a "Hello,
                                     World!" application that centers its message both horizontally and ver-
        Advance                      tically in its window. The message should be centered regardless of the
                                     size of the application window. Thus, we will have to position the text
Height       ~     Leading           relative to the window size, which is something we learned in positioning
        fontspecs  Baseline          geometric shapes. The message should also be centered no matter what
                                     font is used. This will require us to know certain characteristics of the font
                   Descent           itself, such as the height and width of its characters, whether the charac-
                                     ters have a fixed or variable width, and so on. In order to get access to
Figure 7.20: An illustration of the  these properties, we will use the FontMetrics class.
various font measurements.
                                        Figure 7.20 illustrates the various properties that are associated with
                                     a font. The baseline of a font refers to the line on which the bottom of
                                     most characters occurs. When drawing a string, the x- and y-coordinates
                                     determine the baseline of the string's first character. Thus, in

                                                                                                                     

                                     g . drawString ( " Hello , World ! " , 10 , 4 0 ) ;                             
                                     

            FontMetrics              the bottom left of the H in "Hello, World!" would be located at (10, 40).
                                        All characters ascend some distance above the baseline. This is known
# font : Font
                                     as the character's ascent. Some characters, such as y, may extend below
# FontMetrics(in font : Font)        the baseline, into what's known as the descent. Each font has a maximum
+charWidth(in ch : int) : int        descent. Similarly, some characters, such as accent characters, may extend
+charWidth(in ch : char) : int       above the maximum ascent into a space known as the leading.
+getAscent() : int
+getDescent() : int                     The height of a font is defined as the sum (in pixels) of the ascent, de-
+getFont() : Font                    scent, and leading values. The height is a property of the font itself rather
+getHeight() : int                   than of any individual character. Except for fixed-width fonts, in which
+getLeading() : int                  the width of all characters is the same, the characters that make up a font
+getMaxAdvance() : int               have varying widths. The width of an individual character is known as its
+getMaxDescent() : int               advance.
+stringWidth() : int
                                        The FontMetrics class (Fig. 7.21) provides methods for accessing a

Figure 7.21: The FontMetrics
class.
SECTION 11  Handling Text in a Graphics Context  327

font's properties. These can be useful to control the layout of text on a
GUI. For example, when drawing multiple lines of text, the getHeight()
method is useful for determining how much space should be left between
lines. When drawing character by character, the charWidth() method
can be used to determine how much space must be left between charac-
ters. Alternatively, the stringWidth() method can be used to determine
the number of pixels required to draw the entire string.

7.11.3 Example: Centering a Line of Text

Given this background, let's take on the task of centering a message in an      Algorithm design: Generality
application window. In order for this application to work for any font, we
must take care not to base its design on characteristics of the particular      
font that we happen to be using. To underscore this point, let's design         
it to work for a font named Random, which, as we noted earlier, will
be mapped to some font by the system on which the application is run.                                  Dimension
In other words, we will let the system pick a font for this application's
message. An interesting experiment would be to run the application on             +height : int
different platforms to see what fonts are chosen.                                 +width : int

   The only method we need for this application is the paint() method.          +Dimension()
Let's begin by setting the font used by the graphics context to a random
font. To get the characteristics of this font, we create a FontMetrics            +Dimension(in d : Dimension)
object and get the font metrics for the font we just created:                     +Dimension(in width : int, in height : int)
                                                                                  +equals(in o : Object) : boolean
                                                                                  +getSize() : Dimension

    g . s e t F o n t (new Font ( "Random" , Font . BOLD, 2 4 ) ) ;             +setSize(in d : Dimension)
    FontMetrics metrics = g. getFontMetrics ( ) ;
                                                                                  +setSize(in width : int, in height : int)
                                                                                  +toString() : String
The next step is to determine the JFrame's dimensions using the
getSize() method. This method returns an object of type Dimension.              Figure 7.22:  The Dimension
The java.awt.Dimension class (Fig. 7.22) represents the size (width             class.
and height) of a GUI component. A Dimension makes it possible to ma-
nipulate an object's width and height as a single entity. Note that the
height and width variables are defined as public, which is an excep-
tion from the usual convention of defining instances variables as private
or protected. The justification for this exception is probably to simplify
the syntax of referring to an object's width and height. For example, the
following syntax can be used to refer to a component's dimensions:

 

    Dimension d = new Dimension ( 1 0 0 , 5 0 ) ;
    System . out . println ( "width = " + d . width +

                                      " height = " + d. height );
 

Note the redundancy built into the Dimension class. For example, in
addition to being able to set a Dimension's instance variables directly,
public access methods are provided. Also, by defining more than one ver-
sion of some access methods, the class achieves a higher level of flexibility.
The same can be said for providing several different constructors, includ-
ing a copy constructor. Finally, note how it overrides the equals() and
                 328               CHAPTER 7  Strings and String Processing

                 toString() methods. These are all examples of good object-oriented
                 design.

                 JAVA EFFECTIVE DESIGN Redundancy. Redundancy is often a
                 desirable characteristic of object design. It makes the object easier to
                 use and more widely applicable.

Centering text      The Dimension object is used to calculate the x- and y-coordinates for
                 the string. In order to center the string horizontally, we need to know
                 its width, which is supplied by the metrics object. If the JFrame is
                 d.width pixels wide, then the following expression subtracts the width
                 of the string from the width of the JFrame and then divides the leftover
                 space in half:

                                                                                             

                                   // C a l c u l a t e c o o r d i n a t e s

                 int x = (d . width - metrics . stringWidth ( s t r ) ) / 2;                 
                 

                 Similarly, the following expression adds the height of the string to the
                 height of the JFrame and divides the leftover space in half:

                                                                                             

                 int y = (d. height + metrics . getHeight ( ) ) / 2;                         
                 

                 Taken together, these calculations give the coordinates for the lower left
                 pixel of the first character in "Hello, World!!" The only remaining task
                 is to draw the string (Fig. 7.23). Because the paint() method is called
                 automatically whenever the JFrame is resized, this application, whose
                 output is shown in Figure 7.24, will re-center its message whenever it is
                 resized by the user.

                 JAVA PROGRAMMING TIP Generality. By using a component's
                 size and font as the determining factors, you can center text on
                 virtually any component. These values are available via the
                 component's getFont() and getSize() methods.

CHAPTER SUMMARY  Technical Terms

                 ascent            garbage collection   string
                 baseline          glyph                string index
                 concatenation     lexicographic order  string literal
                 copy constructor  logical font         token
                 data structure    off-by-one error     unit indexed
                 delimited string  orphan object        zero indexed
                 delimiter         physical font
                 empty string      read only
   CHAPTER 7  Chapter Summary                                                       329
                                                                                              

  import java . awt .  ;
  import javax . swing .  ;

public class CenterText extends JFrame {                                                           font

                                     // P r i n t h e l l o world ! i n c e n t e r o f f r a m e

public void paint ( Graphics g) {
   S t r i n g s t r = " Hello , World ! " ;
   g . s e t F o n t ( new Font ( "Random" , Font . PLAIN , 2 4 ) ) ; // Random
   FontMetrics metrics = g . getFontMetrics ( ) ; //

And i t s m e t r i c s

   Dimension d = getSize ( ) ;           // Get t h e f r a m e ' s s i z e

   // C l e a r t h e f r a m e

   g . setColor ( getBackground ( ) ) ;

   g . f i l l R e c t (0 ,0 ,d . width , d . height ) ;

   g . setColor ( Color . black ) ;

                                         // C a l c u l a t e c o o r d i n a t e s

   int x = (d . width - metrics . stringWidth ( s t r ) ) / 2;

   int y = (d. height + metrics . getHeight ( ) ) / 2;

   g . drawString ( str , x , y ) ;                       // Draw t h e s t r i n g
} // p a i n t ( )

public s t a t i c void main ( S t r i n g args [ ] ) {

   C en t erText c t = new CenterText ( ) ;

   ct . setSize (400 ,400);

   ct . setVisible ( true );

}

} // C e n t e r T e x t

                                                                                                          

   Figure 7.23: The CenterText application.

                       Summary of Important Points

                             A String literal is a sequence of 0 or more characters enclosed within
                               double quotation marks. A String object is a sequence of 0 or more
                               characters, plus a variety of class and instance methods and variables.

                             A String object is created automatically by Java the first time it en-
                               counters a literal string, such as "Socrates," in a program. Subsequent
                               occurrences of the literal do not cause additional objects to be instan-
                               tiated. Instead, every occurrence of the literal "Socrates" refers to the
                               initial object.

 CenterText ap-
 its message cen-
how its window is
                      330                     CHAPTER 7  Strings and String Processing

                       A String object is created whenever the new operator is used
                        in conjunction with a String() constructor--for example, new
                        String("hello").

                       The String concatenation operator is the overloaded + symbol; it is
                        used to combine two Strings into a single String: "hello" + "world"
                        ==> "helloworld".

                       Strings are indexed starting at 0. The indexOf() and lastIndex-
                        Of() methods are used for finding the first or last occurrence of a char-
                        acter or substring within a String. The valueOf() methods con-
                        vert a nonstring into a String. The length() method determines
                        the number of characters in a String. The charAt() method re-
                        turns the single character at a particular index position. The vari-
                        ous substring() methods return the substring at particular index
                        positions in a String.

                       The overloaded equals() method returns true if two Strings con-
                        tain the same exact sequence of characters. The == operator, when used
                        on Strings, returns true if two references designate the same String
                        object.

                       String objects are immutable. They cannot be modified.
                       A StringBuffer is a string object that can be modified using meth-

                        ods such as insert() and append().
                       A StringTokenizer is an object that can be used to break a String

                        into a collection of tokens separated by delimiters. The whitespace
                        characters--tabs, blanks, and newlines--are the default delimiters.
                       The FontMetrics class is used to obtain the specific dimensions of
                        the the various Fonts. It is useful when you wish to center text. Fonts
                        are inherently platform dependent. For maximum portability, it is best
                        to use default fonts.

SOLUTIONS TO          SOLUTION 7.1  a. silly         b. silly  c. silly stuff
SELF-STUDY EXERCISES
                      SOLUTION 7.2

                      a. String str1 = "";

                      b. String str2 = new String("stop");

                      c. String str3 = str1 + str2;

                      SOLUTION 7.3  a. 15            b. "551"  c. "5175"

                      SOLUTION 7.4 See Figure 7.25.

                      SOLUTION 7.5  a. "45"          b. "121"  c. "X"

                      SOLUTION 7.6

                      a. String.valueOf(100)

                      b. String.valueOf('V');

                      c. String s = new String(String.valueOf(X * Y));

                      SOLUTION 7.7  a. 0             b. 1      c. -1
                     CHAPTER 7  Solutions to Self-Study Exercises                                      331

nswer to Exercise                 s2             "hello" s4                         s5 s6     s1
 is null because it    "Hello" s3 s7
stantiated and has

ed a literal value.                    : String   : String                          : String

                                                                                              null

                       value="Hello" value="hello" value="Hello"

                       count=5                   count=5                   count=5

                       String s1, s2="Hello", s3="Hello";
                       String s4="hello";
                       String s5=new String ("Hello");
                       String s6=s5;
                       String s7=s3;

                     SOLUTION 7.8      b. "16"                             f. 13              j. 7
                      a. 16            c. 1                                g. 7               k. 3
                                       d. 15                               h. 3
                                       e. 1                                i. 7

                     SOLUTION 7.9 Evaluate the following expression:

                                                                                                        

                     String tricky = "abcdefg01234567" ;

                     tricky . indexOf ( String . valueOf ( tricky . indexOf ( "c" ) ) ) ;

                     tricky . indexOf ( String . valueOf ( 2 ) ) ;

                     tricky . indexOf ( "2" ) ;

                       Answer : 9      a. "uvwxyz"                         c. "xyz"                               
                                                                                              e. "xyz"

                       SOLUTION 7.10

                                       b. "bcde"                           d. "xy"

                     SOLUTION 7.11 a. "uvwxyz" c. "xyz"                                       e. "xyz"

                                       b. "bcde"                           d. "xyz"

                     SOLUTION 7.12 A class to test the string methods.

                                                                                                             

                     public class StringProcessorTest {

                       public s t a t i c void main ( S t r i n g [ ] args ) {

                       KeyboardReader kb = new KeyboardReader ( ) ;

                       kb . prompt ( " Input a S t r i n g or - stop - to quit : " ) ;

                       S t r i n g s t r = kb . getKeyboardInput ( ) ;

                       while ( ! str . equals ( "stop" )){

                       kb . display ( " Testing p r i n t L e t t e r s ( ) \ n" ) ;

                       StringProcessor . printLetters ( str );

                       kb . display ( " t e s t i n g countChars ( ) \ n" ) ;

                       kb . display ( " Total occurences of e = " ) ;

                       kb . display ( StringProcesso r . countChar ( s t r , ' e ' ) + "\n" ) ;

                       kb . display ( " Testing reverse ( ) \ n" ) ;

                       kb . display ( StringProcesso r . reverse ( s t r )+ "\n" ) ;

                       kb . display ( " Testing c a p i t a l i z e ( ) \ n" ) ;

                       kb . display ( StringProcesso r . c a p i t a l i z e ( s t r ) + "\n\n" ) ;

                       kb . prompt ( " Input a S t r i n g or - stop - to quit : " ) ;

                       s t r = kb . getKeyboardInput ( ) ;

                       } // w h i l e

                       } // main ( )

                     } // S t r i n g P r o c e s s o r T e s t c l a s s

                                                                                                             
                                  332                         CHAPTER 7  Strings and String Processing

                                  SOLUTION 7.13 Method to remove all blanks from a string:

                                                                                                                                

                                    // Pre : s i s a non n u l l s t r i n g

                                    // P o s t : s i s r e t u r n e d w i th a l l i t s b l a n k s removed

                                    public String removeBlanks ( String s ) {

                                       S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;

                                       for ( int k = 0; k < s . length ( ) ; k++)

                                          if ( s . charAt (k) != ' ' )        // I f t h i s i s n o t a b l a n k

                                          r e s u l t . append ( s . charAt ( k ) ) ; //

                                  append i t to r e s u l t

                                       return result . toString ( ) ;

                                  }

                                                                                                                                

                                  SOLUTION 7.14 A Alpha Z Zero Zeroes a alpha bath bin z zero

                                  SOLUTION 7.15 To modify precedes so that it also returns true when its two

                                  string arguments are equal, just change the operator in the final return statement

                                  to <=:

                                                                                                                                

                                       i f ( s1 . charAt ( k ) <= s2 . charAt ( k ) )

                                               return true ;                  d. false                                               
                                                                                                                g. false

                                    SOLUTION 7.16 a. true

                                          b. true                             e. false                          h. false

                                          c. false                            f. true                           i. false

                                  SOLUTION 7.17 The variables in TestStringEquals are declared static
                                  because they are used in static methods. Whenever you call a method di-
                                  rectly from main(), it must be static because main() is static. Remember
                                  that static elements are associated with the class, not with its instances. So
                                  main() can only use static elements because they don't depend on the existence
                                  of instances.

                                  SOLUTION 7.18

                                   a. String s3 = s1.substring(s1.indexOf('n'))
                                         + s1.substring(0,s1.indexOf('n'));

                                  b. String s4 = s2.substring(6) + " " + s2.substring(0,5);
                                  c. String s5 = s2.substring(0,6) + s1.substring(0,3);

EXERCISES                         EXERCISE 7.1 Explain the difference between the following pairs of terms:

Note: For programming exercises,  a. Unit indexing and zero indexing.
first draw a UML class diagram    b. Data structure and data type.
describing all classes and their  c. StringBuffer and String.
inheritance relationships and/or  d. String and StringTokenizer.
associations.                     e. Declaring a variable and instantiating a String.
                                  f. A Font and a FontMetrics object.

                                  EXERCISE 7.2 Fill in the blanks.

                                  a. When the first character in a string has index 0, this is known as                      .

                                  b. A sequence of characters enclosed within quotes is known as a                        .
CHAPTER 7  Exercises                                       333

EXERCISE 7.3 Given the String str with the value "to be or not to be that is the
question," write Java expressions to extract each of the substrings shown below.
For each substring, provide two sets of answers. One that uses the actual index
numbers of the substrings--for example, the first "to" goes from 0 to 2--and a sec-
ond more general solution that will also retrieve the substring from the following
string "it is easy to become what you want to become." (Hint: In the second case,
use length() and indexOf() along with substring() in your expressions. If
necessary, you may use local variables to store intermediate results. The answer
to (a) is provided as an example.)

a. the first "to" in the string

                                                                                      

  str . substring (0 , 2)

  // Answer 1

  str . substring (

  str . indexOf ( "to" ) , str . indexOf ( "to" ) + 2) // Answer 2                    

b. the last "to" in the string       e. the first four characters in the string

c. the first "be" in the string      f. the last four characters in the string

d. the last "be" in the string

EXERCISE 7.4 Identify the syntax errors in each of the following, assuming that

s is the literal string "exercise":

a. s.charAt("hello")                 d. s.lastIndexOf(er)

b. s.indexOf(10)                     e. s.length

c. s.substring("er")

EXERCISE 7.5 Evaluate each of the following expressions, assuming that s is

the literal string "exercise":

a. s.charAt(5)                       d. s.lastIndexOf('e')

b. s.indexOf("er")                   e. s.length()

c. s.substring(5)

EXERCISE 7.6 Write your own equalsIgnoreCase() method using only
other String methods.

EXERCISE 7.7 Write your own String equality method without using
String. equals(). (Hint: Modify the precedes() method.)

EXERCISE 7.8 Even though Java's String class has a built-in toLowerCase()
method, write your own implementation of this method. It should take a String
parameter and return a String with all its letters written in lowercase.

EXERCISE 7.9 Write a method that converts its String parameter so that let-
ters are written in blocks five characters long. For example, consider the following
two versions of the same sentence:

                                                                                     

P l a i n : This i s how we would o r d i n a r i l y w r i t e a s e n t e n c e .

Blocked : T h i s i showw ewoul dordi n a r i l ywrit easen t e n c e .
                                                                                     

EXERCISE 7.10 Design and implement a Java Swing program that lets the user
type a document into a TextArea and then provides the following analysis of the
document: the number of words in the document, the number of characters in the
document, and the percentage of words that have more than six letters.

EXERCISE 7.11 Design and write a Java Swing program that searches for single-
digit numbers in a text and changes them to their corresponding words. For ex-
ample, the string "4 score and 7 years ago" would be converted into "four score
and seven years ago".
                   334         CHAPTER 7  Strings and String Processing

                   EXERCISE 7.12 A palindrome is a string that is spelled the same way backward
                   and forward. For example, mom, dad, radar, 727 and able was i ere i saw elba are all
                   examples of palindromes. Write a Java Swing program that lets the user type in a
                   word or phrase and then determines whether the string is a palindrome.

                   EXERCISE 7.13 Write a maze program that uses a string to store a representa-
                   tion of the maze. Write a method that accepts a String parameter and prints a
                   two-dimensional representation of a maze. For example, the maze shown here,
                   where O marks the entrance and exit can be generated from the following string:

                                                                                

                   String : XX XXXXXXXX XXX XXXX XX XXX XX XX XXX X XXXXXXXX X

                      O

                   XX XXXXXXX

                   X XXX XXX

                   X XX XX

                   X XX XX XX

                   XXO

                   XXXXXXXX X                                                   
                   

Sam Penn           EXERCISE 7.14 Write a method that takes a delimited string to store a name
14 Bridge St.      and address, from which you can print a mailing label. For example, if the string
Hoboken, NJ 01881  contains "Sam Penn:14 Bridge St.:Hoboken, NJ 01881," the method should print
                   the label shown in the margin.

                   EXERCISE 7.15 Design and implement a Java Swing program that plays Time

                   Bomb with the user. Here's how the game works. The computer picks a secret

                   word and then prints one asterisk for each letter in the word: * * * * *. The user

                   guesses at the letters in the word. For every correct guess, an asterisk is replaced by

                   a                                                            letter:

                   * e * * *. For every incorrect guess, the time bomb's fuse grows shorter. When

                   the fuse disappears, after say, six incorrect guesses, the bomb explodes. Store the

                   secret words in a delimited string and invent your own representation for the time

                   bomb.

                   EXERCISE 7.16 Challenge: The global replace function is a string-processing
                   algorithm found in every word processor. Write a method that takes three String
                   arguments: a document, a target string, and a replacement string. The method
                   should replace every occurrence of the target string in the document with the re-
                   placement string. For example, if the document is "To be or not to be, that is the
                   question," and the target string is "be,", and the replacement string is "see," the
                   result should be, "To see or not to see, that is the question."

                   EXERCISE 7.17 Challenge: Design and implement a Java Swing Program that
                   plays the following game with the user. Let the user pick a letter between A and
                   Z. Then let the computer guess, the secret letter. For every guess the player has to
                   tell the computer whether it's too high or too low. The computer should be able to
                   guess the letter within five guesses. Do you see why?
  CHAPTER 7  Exercises                                                                 335

  EXERCISE 7.18 Challenge: A list is a sequential data structure. Design a List
  class that uses a comma-delimited String--such as, "a,b,c,d,12,dog"--to imple-
  ment a list. Implement the following methods for this class:

                                                                                        

  void addItem ( Object o ) ;         // Use O b j e c t . t o S t r i n g ( )

  String getItem ( int position ) ;

  String toString ();

  void deleteItem ( int position ) ;

  void deleteItem ( String item ) ;

  int getPosition ( String item ) ;

  String getHead ( ) ;                // F i r s t e l e m e n t

  List getTail ();                    // A l l but t h e f i r s t e l e m e n t

    int length ( ) ;                  // Number o f i t e m s
  
                                                                                   

  EXERCISE 7.19 Challenge: Use a delimited string to create a PhoneList class
  with an instance method to insert names and phone numbers, and a method to
  look up a phone number when a user provides a person's name. Since your class
  will take care of looking things up, you don't have to worry about keeping the list
  in alphabetical order. For example, the following string could be used as such a
  directory:

                                                                                        

mom:860 -192 -9876:: b i l l g :654 -0987 -1234:: mary l a n c e l o t :123 -842 -1100  


  EXERCISE 7.20 Design and implement an application that displays a multi-line
  message in various fonts and sizes input by the user. Let the user choose from
  among a fixed selection of fonts, sizes, and styles.
336  CHAPTER 7  Strings and String Processing
Chapter 8

Inheritance and
Polymorphism

OBJECTIVES

After studying this chapter, you will
 Understand the concepts of inheritance and polymorphism.
 Know how Java's dynamic binding mechanism works.
 Be able to design and use abstract methods and classes.
 Be able to design and use polymorphic methods.
 Gain a better understanding of object-oriented design.

OUTLINE

8.1 Introduction
8.2 Java's Inheritance Mechanism
8.3 Abstract Classes, Interfaces, and Polymorphism
8.4 Example: A Toggle Button

         Special Topic: Historical Cryptography
8.5 Example: The Cipher Class Hierarchy
8.6 Case Study: A Two Player Game Hierarchy
8.7 Principles of Object-Oriented Design

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              337
                                   338  CHAPTER 8  Inheritance and Polymorphism

                                   8.1 Introduction

                                   Among the most important concepts in object oriented programming are
                                   the concepts of inheritance and polymorphism. We first introduced the
                                   idea of inheritance in Chapter 0. There we compared inheritance to the
                                   natural form of inheritance, in which horses and cows share certain inher-
                                   ited characteristics, such as being warm-blooded, by virtue of their being
                                   mammals. We also gave the example of a hierarchy of chess pieces and
                                   showed how different kinds of chess pieces, such as Pawn and Bishop, in-
                                   herited certain shared characteristics from their ChessPiece superclass.

                                      We took a more technical look at inheritance in Chapter 3, where we
                                   talked about the toString() method and how it is inherited from the
                                   Object class. We illustrated there how subclasses of Object could
                                   override the inherited toString() method in order to customize it for
                                   their purposes. We also introduced the idea of polymorphism, in which
                                   a method call, such as obj.toString(), can have different behaviors
                                   depending on the type of object, obj, on which it is called.

                                      In Chapter 4, we continued introducing inheritance and polymor-
                                   phism, when we learned about Java's Abstract Windowing Toolkit (AWT)
                                   and Swing hierarchies, the class hierarchies that are used to create Graph-
                                   ical User Interfaces (GUIs). We also learned how to extend a class to create
                                   our own subclass, and we made limited use of inheritance in the design
                                   of the SimpleGUI class. We were also introduced to the concept of a Java
                                   interface, and we learned how to use the ActionListener interface to
                                   enable a SimpleGUI to handle action events while the GUI is running.

                                      In this chapter we will take a much closer look at these important
                                   object-oriented concepts. We will learn how Java's dynamic binding mecha-
                                   nism works and how it makes polymorphism possible. Most importantly,
                                   we will see why inheritance and polymorphism are important elements of
                                   object-oriented design, and we will learn how to use these important tools
                                   to design several different programs. In keeping with our running games
                                   example, we will develop a TwoPlayerGame hierarchy and show how
                                   it can simplify the implementation of OneRowNim and other two-player
                                   games.

                                   8.2 Java's Inheritance Mechanism

Figure 8.1: A class hierarchy for  As we described in Chapter 0, class inheritance is the mechanism
horses.                            whereby a class acquires (inherits) the methods and variables of its super-
                                   classes. To remind you of the basic concept, let's repeat an earlier example:
                                   Just as horses inherit the attributes and behaviors associated with mam-
                                   mals and vertebrates, a Java subclass inherits the attributes and behaviors
                                   of its superclasses.

                                      Figure 8.1 uses a UML diagram to illustrate the relationships among
                                   horses, mammals, vertebrates, and animals. As the root of the hierarchy,
                                   which is always shown at the top, the Animal class contains the most gen-
                                   eral attributes, such as being alive and being able to move. All animals
                                   share these attributes. The class of vertebrates is a somewhat more spe-
                                   cialized type of animal, in that vertebrates have backbones. Similarly, the
                                   class of mammals is a further specialization over the vertebrates in that
SECTION 8.2  Java's Inheritance Mechanism  339

mammals are warm-blooded and nurse their young. Finally, the class of
horses is a further specialization over the class of mammals, in that all
horses have four legs. Some mammals, such as humans and penguins, do
not have four legs. Thus, by virtue of its class's position in this hierarchy,
we can infer that a horse is a living, moving, four-legged vertebrate, which
is warm blooded and nurses its young.

   We have deliberately used an example from the natural world to show
that the concept of inheritance in Java is inspired by its counterpart in the
natural world. But how exactly does the concept of inheritance apply to
Java (and to other object-oriented languages)? And, more importantly,
how do we use the inheritance mechanism in object-oriented design?

8.2.1 Using an Inherited Method

In Java, the public and protected instance methods and instance variables                     The Student class hi-
of a superclass are inherited by all of its subclasses. This means that objects
belonging to the subclasses can use the inherited variables and methods          
as their own.                                                                     Figure 8.2:

   We have already seen some examples of this in earlier chapters. For ex-       쮍rarchy.
ample, recall that by default all Java classes are subclasses of the Object      
class, which is the most general class in Java's class hierarchy. One public
method that is defined in the Object class is the toString() method.
Because every class in the Java hierarchy is a subclass of Object, every
class inherits the toString() method. Therefore, toString() can be
used with any Java object.

   To illustrate this, suppose we define a Student class as follows:

 

    public class Student {
           p r o t e c t e d S t r i n g name ;
           public Student ( String s ) {
                  name = s ;
           }
           public S t r i n g getName ( ) {
                  r e t u r n name ;
           }

    }
 

Figure 8.2 shows the relationship between this class and the Object class.
As a subclass of Object, the Student class inherits the toString()
method. Therefore, for a given Student object, we can call its
toString() as follows:

 

    Student s t u = new Student ( " Stu " ) ;
    System . out . println ( stu . toString ( ) ) ;
 

How does this work? That is, how does Java know where to find the
toString() method, which, after all, is not defined in the Student
class? The answer to this question is crucial to understanding how Java's
inheritance mechanism works.

   Note in this example that the variable stu is declared to be of type
Student and is assigned an instance of the Student class. When
the expression stu.toString() is executed, Java will first look in the
                                 340             CHAPTER 8  Inheritance and Polymorphism

                                 Student class for a definition of the toString() method. Not finding
                                 one there, it will then search up the Student class hierarchy (Fig. 8.2)
                                 until it finds a public or protected definition of the toString() method.
                                 In this case, it finds a toString() method in the Object class and it ex-
                                 ecutes that implementation of toString(). As you know from Chap-
                                 ter 3, this would result in the expression stu.toString() returning
                                 something like:

                                                                                                              

                                 Student@cde100                                                               
                                 

                                 The default implementation of toString() returns the name of the ob-
                                 ject's class and the address (cde100) where the object is stored in mem-
                                 ory. However, this type of result is much too general and not particularly
                                 useful.

                                 8.2.2 Overriding an Inherited Method

                                 In Chapter 3 we pointed out that the toString() method is designed to
                                 be overridden--that is, to be redefined in subclasses of Object. Overriding
                                 toString() in a subclass provides a customized string representation of
                                 the objects in that subclass. We showed that by redefining toString() in
                                 our OneRowNim class, we customized its actions so that it returned useful
                                 information about the current state of a OneRowNim game.

                                    To override toString() for the Student class, let's add the following
                                 method definition to the Student class:

                                                                                                              

                                 public String toString () {

                                      r e t u r n "My name i s " + name + " and I am a Student . " ;

Figure 8.3: The revised Student  }
class hierarchy.
                                                                                                              

                                 Given this change, the revised Student class hierarchy is shown in Fig-
                                 ure 8.3. Note that both Object and Student contain implementations of
                                 toString(). Now when the expression stu.toString() is invoked,
                                 the following, more informative, output is generated:

                                                                                                              

                                      My name i s Stu and I am a Student .                                    

                                 In this case, when Java encounters the method call stu.toString(),
                                 it invokes the toString() method that it finds in the Student class
                                 (Fig. 8.3).
SECTION 8.2  Java's Inheritance Mechanism                           341

   These examples illustrate two important object-oriented concepts: in-
heritance and method overriding.

JAVA EFFECTIVE DESIGN Inheritance. The public and protected
instance methods (and variables) in a class can be used by objects that
belong to the class's subclasses.

JAVA EFFECTIVE DESIGN Overriding a Method. Overriding an
inherited method is an effective way to customize that method for a
particular subclass.

8.2.3 Static Binding, Dynamic Binding
         and Polymorphism

The mechanism that Java uses in these examples is known as dynamic             Dynamic binding
binding, in which the association between a method call and the cor-           Polymorphism
rect method implementation is made at run time. In dynamic binding
a method call is bound to the correct implementation of the method at run
time by the Java Virtual Machine (JVM).

   Dynamic binding is contrasted with static binding, the mechanism by
which the Java compiler resolves the association between a method call
and the correct method implementation when the program is compiled.
In order for dynamic binding to work, the JVM needs to maintain some
kind of representation of the Java class hierarchy, including classes defined
by the programmer. When the JVM encounters a method call, it uses in-
formation about the class hierarchy to bind the method call to the correct
implementation of that method.

   In Java, all method calls use dynamic binding except methods that are
declared final or private. Final methods cannot be overridden, so
declaring a method as final means that the Java compiler can bind it
to the correct implementation. Similarly, private methods are not inher-
ited and therefore cannot be overridden in a subclass. In effect, private
methods are final methods and the compiler can perform the binding at
compile time.

   Java's dynamic-binding mechanism, which is also called late binding or
run-time binding, leads to what is know as polymorphism. Polymorphism
is a feature of object-oriented languages whereby the same method call
can lead to different behaviors depending on the type of object on which
the method call is made. The term polymorphism means, literally, having
many (poly) shapes (morphs). Here's a simple example:

                                                                                                           

  Object obj ;                       // S t a t i c t y p e : O b j e c t

  o b j = new Student ( " Stu " ) ;  // A c t u a l t y p e : S t u d e n t

System . out . p r i n t l n ( o b j . t o S t r i n g ( ) ) ; // P r i n t s " My name i s S t u . . . "

  o b j = new OneRowNim ( 1 1 ) ;    // A c t u a l t y p e : OneRowNim

System . out . println ( obj . toString ( ) ) ; // P r i n t s " n S t i c k s = 1 1 , p l a y e r = 1"    

The variable obj is declared to be of type Object. This is its static or
declared type. A variable's static type never changes. However, a variable
                    342                        CHAPTER 8  Inheritance and Polymorphism

Polymorphic method  also has an actual or dynamic type. This is the actual type of the object that
                    has been assigned to the variable. As you know, an Object variable can
                    be assigned objects from any Object subclass. In the second statement,
                    obj is assigned a Student object. Thus, at this point in the program,
                    the actual type of the variable obj is Student. When obj.toString()
                    is invoked in the third line, Java begins its search for the toString()
                    method at the Student class, because that is the variable's actual type.

                       In the fourth line, we assign a OneRowNim object to obj, thereby chang-
                    ing its actual type to OneRowNim. Thus, when obj.toString() is in-
                    voked in the last line, the toString() method is bound to the imple-
                    mentation found in the OneRowNim class.

                       Thus, we see that the same expression, obj.toString(), is bound al-
                    ternatively to two different toString() implementations, based on the
                    actual type of the object, obj, on which it is invoked. This is polymor-
                    phism and we will sometimes say that the toString() method is a poly-
                    morphic method. A polymorphic method is a method signature that be-
                    haves differently when it is invoked on different objects. An overridden
                    method, such as the toString() method, is an example of a polymor-
                    phic method, because its use can lead to different behaviors depending
                    upon the object on which it is invoked.

                       The previous example is admittedly somewhat contrived. In some
                    object-oriented languages, a code segment such as that above would use
                    static binding rather than dynamic binding. In other words, the com-
                    piler would be able to figure out the bindings. So let's take an example
                    where static binding, also called early binding, is not possible. Consider
                    the following method definition:

                                                                                                    

                    public void polyMethod ( Object obj ) {

                         System . out . println ( obj . toString ( ) ) ; // P o l y m o r p h i c

                    }

                                                                                                    

                    The method call in this method, obj.toString(), can't be bound to
                    the correct implementation of toString() until the method is actually
                    invoked--that is, at run time. For example, suppose we make the follow-
                    ing method calls in a program:

                                                                                                    

                         Student s t u = new Student ( " Stu " ) ;

                         polyMethod ( stu ) ;

                         OneRowNim nim = new OneRowNim ( ) ;

                         polyMethod ( nim ) ;                                                       

                    The first time polyMethod() is called, the obj.toString() is invoked
                    on a Student object. Java will use its dynamic binding mechanism
                    to associate this method call with the toString() implementation in
                    Student and output "My name is Stu and I am a Student." The sec-
                    ond time polyMethod() is called, the obj.toString() expression is
                    invoked on a OneRowNim object. In this case, Java will bind the method
                    call to the implementation in the OneRowNim class. The output generated
                    in this case will report how many sticks are left in the game.
SECTION 8.2  Java's Inheritance Mechanism      343

   The important point here is that polymorphism occurs when an over-
ridden method is called on a superclass variable, obj. In such a case, the
actual method implementation that is invoked is determined at run time.
The determination depends on the type of object that was assigned to the
variable. Thus, we say that the method call obj.toString() is poly-
morphic because it is bound to different implementations of toString()
depending on the actual type of the object that is bound to obj.

8.2.4 Polymorphism and Object-Oriented Design

Now that we understand how inheritance and polymorphism work                  Overloaded methods
in Java, it will be useful to consider an example that illustrates           
how these mechanisms can be useful in designing classes and meth-            
ods. We have been using the various System.out.print() and
System.out.println() methods since Chapter 1. The print()
and println() methods are examples of overloaded methods--that is,
methods that have the same name but different parameter lists. Remem-
ber that a method's signature involves its name, plus the type, num-
ber, and order of its parameters. Methods that have the same name but
different parameters are said to be overloaded.

   Here are the signatures of some of the different print() and
println() methods:



  print ( char c ) ;    println ( char c ) ;
  print ( int i );      println ( int i );
  print ( double d ) ;  println ( double d ) ;
  print ( float f );    println ( float f );
  print ( String s );   println ( String s );
  print ( Object o );   println ( Object o );


Basically, there is a print() and println() method for every type of
primitive data, plus methods for printing any type of object. When Java
encounters an expression involving print() or println() it chooses
which particular print() or println() method to call. To determine
the correct method, Java relies on the differences in the signatures of the
various print() methods. For example, because its argument is an int,
the expression print(5) is associated with the method whose signature
is print(int i) be cause its parameter is an int.

   Note that there is only one set of print() and println() meth-
ods for printing Objects. The reason is that polymorphism is used by
the print(Object o) and println(Object o) methods to print any
type of object. While we do not have access to the source code for these
               344     CHAPTER 8  Inheritance and Polymorphism

               methods, we can make an educated guess that their implementations
               utilize the polymorphic toString() method, as follows:

                                                                                            

                    public void print ( Object o) {
                           System . out . print ( o . toString ( ) ) ;

                    }

                    public void println ( Object o) {

                       System . out . println ( o . toString ( ) ) ;

                    }

                                                                                            

Extensibility  Here again we have a case where an expression, o.toString(),
               is bound dynamically to the correct implementation of toString()
               based on the type of Object that the variable o is bound to. If we
               call System.out.print(stu), where stu is a Student, then the
               Student.toString() method is invoked. On the other hand, if we
               call System.out.print(game), where game is a OneRowNim, then the
               OneRowNim.toString() method is invoked.

                  The beauty of using polymorphism in this way is the flexibility and
               extensibility that it allows. The print() and println() methods can
               print any type of object, even new types of objects that did not exist when
               these library methods were written.

               SELF-STUDY EXERCISES

               EXERCISE 8.1 To confirm that the print() and println() methods
               are implemented along the lines that we suggest here, compile and run the
               TestPrint program shown here. Describe how it confirms our claim.

                                                                                    

               public class TestPrint {

                       public s t a t i c void main ( S t r i n g args [ ] ) {

                       System . out . p r i n t l n (new Double ( 5 6 ) ) ;

                       System . out . p r i n t l n (new T e s t P r i n t ( ) ) ;

                    }

               }

                                                                                    

               EXERCISE 8.2 Override the toString() method in the TestPrint
               class and rerun the experiment. Describe how this adds further confirma-
               tion to our claim.

               8.2.5 Using super to Refer to the Superclass

               One question that might occur to you is: Once you override the default
               toString() method, is it then impossible to invoke the default method
               on a Student object? The default toString() method (and any method
               from an object's superclass) can be invoked using the super keyword. For
               example, suppose that within the Student class, you wanted to concate-
               nate the result of both the default and the new toString() methods.
               The following expression would accomplish that:

                                                                                            

                  super . toString ( ) + toString ( )                                       
                  
SECTION 8.2  Java's Inheritance Mechanism                                345

The super keyword specifies that the first toString() is the one imple-        Keyword super
mented in the superclass. The second toString() refers simply to the
version implemented within the Student class. We will see additional
examples of using the super keyword in the following sections.

SELF-STUDY EXERCISES

EXERCISE 8.3 Consider the following class definitions and determine
the output that would be generated by the code segment.

                                                                          

public class A {
       public void method ( ) { System . out . p r i n t l n ( "A" ) ; }

}

public class B extends A {
       public void method ( ) { System . out . p r i n t l n ( "B" ) ; }

}

  // D e t e r m i n e t h e o u t p u t from t h i s code segment

A a = new A ( ) ;

a . method ( ) ;

a = new B ( ) ;

a . method ( ) ;

B b = new B ( ) ;

b . method ( ) ;                                                          

EXERCISE 8.4 For the class B defined in the previous exercise, modify
its method() so that it invokes A's version of method() before printing
out B.

EXERCISE 8.5 Given the definitions of the classes A and B, which of the
following statements are valid? Explain.

                                                                          

  A a = new B ( ) ;

  a = new A ( ) ;

  B b = new A ( ) ;

  b = new B ( ) ;                                                         

8.2.6 Inheritance and Constructors

Java's inheritance mechanism applies to a class's public and protected in-
stance variables and methods. It does not apply to a class's constructors.
                                     346  CHAPTER 8  Inheritance and Polymorphism

                                     To illustrate some of the implications of this language feature, let's define
                                     a subclass of Student called CollegeStudent:

                                                                                                                    

                                     public class CollegeStudent extends Student {
                                            public CollegeStudent () { }
                                            public CollegeStudent ( String s ) {
                                                   super ( s ) ;
                                            }

                                          public String toString () {
                                               r e t u r n "My name i s " + name +
                                                              " and I am a C o l l e g e S t u d e n t . " ;

                                          }

                                     }

                                                                                                                    

Figure 8.4: The class hierarchy for  Because CollegeStudent is a subclass of Student, it inherits the pub-
CollegeStudent .                     lic and protected instance methods and variables from Student. So, a
                                     CollegeStudent has an instance variable for name and it has a public
Constructor chaining                 getName() method. Recall that a protected element, such as the name
                                     variable in the Student class, is accessible only within the class and its
                                     subclasses. Unlike public elements, it is not accessible to other classes.

                                        Note that CollegeStudent overrides the toString() method, giv-
                                     ing it a more customized implementation. The hierarchical relationship
                                     between CollegeStudent and Student is shown in Figure 8.4. A
                                     CollegeStudent is a Student and both are Objects.

                                        Note how we have implemented the CollegeStudent(String s)
                                     constructor. Because the superclass's constructors are not inherited, we
                                     have to implement this constructor in the subclass if we want to be able
                                     to assign a CollegeStudent's name during object construction. The
                                     method call, super(s), is used to invoke the superclass constructor and
                                     pass it s, the student's name. The superclass constructor will then assign s
                                     to the name variable.

                                        As we have noted, a subclass does not inherit constructors from its su-
                                     perclasses. However, if the subclass constructor does not explicitly invoke
                                     a superclass constructor, Java will automatically invoke the default su-
                                     perclass constructor--in this case, super(). By "default superclass con-
                                     structor" we mean the constructor that has no parameters. For a subclass
                                     that is several layers down in the hierarchy, this automatic invoking of the
                                     super() constructor will be repeated upwards through the entire class
                                     hierarchy. Thus when a CollegeStudent is constructed, Java will auto-
                                     matically call Student() and Object(). Note that if one of the super-
                                     classes does not contain a default constructor, this will result in a syntax
                                     error.

                                        If you think about this, it makes good sense. How else will the in-
                                     herited elements of the object be created? For example, in order for a
                                     CollegeStudent to have a name variable, a Student object, where
                                     name is declared, must be created. The CollegeStudent constructor
                                     then extends the definition of the Student class. Similarly, in order for a
                                     Student object to have the attributes common to all objects, an Object
                                     instance must be created and then extended into a Student.

                                        Thus, unless a constructor explicitly calls a superclass constructor, Java
                                     will automatically invoke the default superclass constructors. It does this
SECTION 8.3  Abstract Classes, Interfaces, and Polymorphism 347

before executing the code in its own constructor. For example, if you had
two classes, A and B, where B is a subclass of A, then whenever you create
an instance of B, Java will first invoke A's constructor before executing the
code in B's constructor. Thus, Java's default behavior during construction
of B is equivalent to the following implementation of B's constructor:

                                                                               

  public B() {

     A( ) ;  // C a l l t h e s u p e r c o n s t r u c t o r

     // Now c o n t i n u e w i t h t h i s c o n s t r u c t o r ' s c o d e

  }

                                                                               

Calls to the default constructors are made all the way up the class hierar-
chy, and the superclass constructor is always called before the code in the
class's constructor is executed.

SELF-STUDY EXERCISES

EXERCISE 8.6 Consider the following class definitions and describe
what would be output by the code segment.

                                                                               

public class A {
       public A( ) { System . out . p r i n t l n ( "A" ) ; }

}
public class B extends A {

       public B ( ) { System . out . println ( "B" ) ; }
}
public class C extends B {

       public C ( ) { System . out . p r i n t l n ( "C" ) ; }
}

  // D e t e r m i n e t h e o u t p u t .

A a = new A ( ) ;

B b = new B ( ) ;

C c = new C ( ) ;                                                              


8.3 Abstract Classes, Interfaces,
      and Polymorphism

In Java, there are three kinds of polymorphism:

     Overriding an inherited method.

     Implementing an abstract method.

     Implementing a Java interface.

In the previous section we saw examples of the first type of polymor-
phism. All forms of polymorphism are based on Java's dynamic binding
mechanism. In this section we will develop an example that illustrates
the other two types of polymorphism and discuss some of the design
implications involved in choosing one or the other approach.
                                    348  CHAPTER 8  Inheritance and Polymorphism

                                    8.3.1 Implementing an Abstract Method

Extensibility                       An important feature of polymorphism is the ability to invoke a polymor-
                                    phic method that has been defined only abstractly in the superclass. To
Figure 8.5: The Animal class hier-  illustrate this feature, we will develop a hierarchy of simulated animals
archy.                              that make characteristic animal sounds, an example that is widely used to
                                    illustrate polymorphism.
Rules for abstract classes
                                       As we all know from our childhood, animals have distinctive ways of
                                    speaking. A cow goes "moo"; a pig goes "oink"; and so on. Let's design
                                    a hierarchy of animals that simulates this characteristic by printing the
                                    characteristic sounds that these animals make. We want to design our
                                    classes so that any given animal will return something like "I am a cow
                                    and I go moo," when we invoke the toString() method. Moreover, we
                                    want to design this collection of classes so that it is extensible--that is, so
                                    that we can continue to add new animals to our menagerie without having
                                    to change any of the code in the other classes.

                                       Figure 8.5 provides a summary of the design we will implement. The
                                    Animal class is an abstract class. That's why its name is italicized in
                                    the UML diagram. The reason that this class is abstract is because its
                                    speak() method is an abstract method, which is a method definition
                                    that does not contain an implementation. That is, the method definition
                                    contains just the method's signature, not its body. Any class that contains
                                    an abstract method, must itself be declared abstract. Here is the definition
                                    of the Animal class:

                                                                                                                     

                                    public abs tr ac t c l a s s Animal {
                                           protected S t r i n g kind ; // Cow , p i g , c a t , e t c .

                                         public Animal ( ) { }
                                         public String toString () {

                                                r e t u r n " I am a " + kind + " and I go " + speak ( ) ;
                                         }

                                             public abstract String speak ( ) ;  // A b s t r a c t method

                                      }                                                                           
                                    

                                    Note how we declare the abstract method (speak()) and the abstract
                                    class. Because one or more of its methods is not implemented, an abstract
                                    class cannot be instantiated. That is, you cannot say:

                                                                                                                     

                                    Animal animal = new Animal ( ) ; // E r r o r : A n i m a l i s a b s t r a c t  
                                    

                                    Even though it is not necessary, we give the Animal class a constructor. If
                                    we had left this off, Java would have supplied a default constructor that
                                    would be invoked when Animal subclasses are created.

                                       Java has the following rules on using abstract methods and classes.

                                          Any class containing an abstract method must be declared an
                                            abstract class.

                                          An abstract class cannot be instantiated. It must be subclassed.

                                          A subclass of an abstract class may be instantiated only if it im-
                                            plements all of the superclass's abstract methods. A subclass
SECTION 8.3  Abstract Classes, Interfaces, and Polymorphism 349

      that implements only some of the abstract methods must itself
      be declared abstract.

    A class may be declared abstract even it contains no abstract
      methods. It could, for example, contain instance variables that are
      common to all its subclasses.

   Even though an abstract method is not implemented in the superclass,
it can be called in the superclass. Indeed, note how the toString()
method calls the abstract speak() method. The reason that this works
in Java is due to the dynamic binding mechanism. The polymorphic
speak() method will be defined in the various Animal subclasses. When
the Animal.toString() method is called, Java will decide which actual
speak() method to call based on what subclass of Animal is involved.

   Definitions for two such subclasses are shown in Figure 8.6. In each

                                          

public c lass Cat extends Animal {
       public Cat ( ) {
              kind = " cat " ;
       }

   public String speak ( ) {
          r e t u r n "meow" ;

   }

}

public c l a s s Cow extends Animal {

   public Cow ( ) {

      kind = "cow" ;

   }

   public String speak ( ) {

      r e t u r n "moo" ;

   }

}

                                          

      Figure 8.6: Two Animal subclasses.

case the subclass extends the Animal class and provides its own con-
structor and its own implementation of the speak() method. Note that
in their respective constructors, we can refer to the kind instance vari-
able, which is inherited from the Animal class. By declaring kind as
a protected variable, it is inherited by all Animal subclasses but hid-
den from all other classes. On the other hand, if kind had been declared
public, it would be inherited by Animal subclasses, but it would also
be accessible to every other class, which would violate the information
hiding principle.
                           350        CHAPTER 8  Inheritance and Polymorphism

                              Given these definitions, we can now demonstrate the power and flex-
                           ibility of inheritance and polymorphism. Consider the following code
                           segment:

                                                                                                           

                              Animal animal = new Cow ( ) ;                        // A cow    goes  moo
                               System . out . println ( animal . toString ( ) ) ;  // A c a t  goes
                               animal = new Cat ( ) ;                                                meow
                               System . out . println ( animal . toString ( ) ) ;
                                                                                                            

Advantage of polymorphism  We first create a Cow object and then invoke its (inherited) toString()
Extensibility              method. It returns, "I am a cow and I go moo." We then create a Cat
                           object and invoke its (inherited) toString() method, which returns, "I
                           am a cat and I go meow." In other words, Java is able to determine the
                           appropriate implementation of speak() at run time in each case. The
                           invocation of the abstract speak() method in the Animal.toString()
                           method is a second form of polymorphism.

                              What is the advantage of polymorphism here? The main advantage is
                           the extensibility that it affords our Animal hierarchy. We can define and
                           use completely new Animal subclasses without redefining or recompiling
                           the rest of the classes in the hierarchy. Note that the toString() method
                           in the Animal class does not need to know what type of Animal sub-
                           class will be executing its speak() method. The toString() method
                           will work correctly for any subclass of Animal because every non-abstract
                           subclass of Animal must implement the speak() method.

                              To get a better appreciation of the flexibility and extensibility of this
                           design, it might be helpful to consider an alternative design that does
                           not use polymorphism. One such alternative would be to define each
                           Animal subclass with its own speaking method. A Cow would have a
                           moo() method; a Cat would have a meow() method; and so forth. Given
                           this design, we could use a switch statement to select the appropriate
                           method call. For example, consider the following method definition:

                                                                                                           

                           public String t a l k ( Animal a ) {

                                i f ( a i n s t a n c e o f Cow)

                                r e t u r n " I am a " + kind + " and I go " + a . moo ( ) ;

                                else if ( a instanceof Cat )

                                r e t u r n " I am a " + kind + " and I go " + a . meow ( ) ;

                                else

                                r e t u r n " I don ' t know what I am" ;

                           }

                                                                                                           

                           In this example, we introduce the instanceof operator, which is a built-
                           in boolean operator. It returns true if the object on its left-hand side is an
                           instance of the class on its right-hand side.

                              The talk() method would produce more or less the same result. If
                           you call talk(new Cow()), it will return "I am a cow and I go moo."
                           However, with this design, it is not possible to extend the Animal hierar-
                           chy without rewriting and recompiling the talk() method.

                              Thus, one of the chief advantages of using polymorphism is the great
                           flexibility and extensibility it affords. We can define new Animal sub-
                           classes and define their speak() methods. These will all work with the
SECTION 8.3  Abstract Classes, Interfaces, and Polymorphism 351

toString() method in the Animal class, without any need to revise that
method.

   Another advantage of using abstract methods is the control that it gives
the designer of the Animal hierarchy. By making it an abstract class with
an abstract speak() method, any non-abstract Animal subclass must im-
plement the speak() method. This lends a great degree of predictabil-
ity to the subclasses in the hierarchy, making it easier to use them in
applications.

SELF-STUDY EXERCISES

EXERCISE 8.7 Following the examples in this section, define an
Animal subclass named Pig, which goes "oink."

EXERCISE 8.8 Show how you would have to modify the talk()
method defined above to incorporate the Pig class.

8.3.2 Implementing a Java Interface

A third form of polymorphism results through the implementation of Java      Java interface
interfaces, which are like classes but contain only abstract method def-
initions and constants (final) variables. An interface cannot contain
instance variables. We have already seen interfaces, such as when we
encountered the ActionListener interface in Chapter 4.

   The designer of an interface specifies what methods will be imple-
mented by classes that implement the interface. This is similar to what we
did when we implemented the abstract speak() method in the animal
example. The difference between implementing a method from an inter-
face and from an abstract superclass is that a subclass extends an abstract
superclass but it implements an interface.

   Java's interface mechanism gives us another way to design polymor-
phic methods. To see how this works, we will provide an alternative
design for our animal hierarchy. Rather than defining speak() as an
abstract method within the Animal superclass, we will define it as an
abstract method in the Speakable interface (Fig. 8.7).

                                                                        

public interface Speakable {
       public String speak ( ) ;

}

public c lass Animal {                                           etc .
       protected S t r i n g kind ; // Cow , p i g , c a t ,
       public Animal ( ) { }                                     "+
       public String toString () {
              r e t u r n " I am a " + kind + " and I go
                           ( ( Speakable ) this ) . speak ( ) ;
       }

}

                                                                        

   Figure 8.7: Defining and using the Speakable interface.

   Note the differences between this definition of Animal and the pre-
vious definition. This version no longer contains the abstract speak()
method. Therefore, the class itself is not an abstract class. However, be-
cause the speak() method is not declared in this class, we cannot call the
                       352  CHAPTER 8  Inheritance and Polymorphism

Cast operation         speak() method in the toString() method, unless we cast this object
Interface inheritance  into a Speakable object.

                          We encountered the cast operation in Chapter 5, where we used it with
                       primitive types such as (int) and (char). Here, we use it to specify
                       the actual type of some object. In this toString() example, this ob-
                       ject is some type of Animal subclass, such as a Cat. The cast operation,
                       (Speakable), changes the object's actual type to Speakable, which
                       syntactically allows its speak() method to be called.

                          Given these definitions, Animal subclasses will now extend the
                       Animal class and implement the Speakable interface:

                                                                                                      

                       public c l a s s Cat extends Animal implements Speakable {
                              public Cat ( ) { kind = " cat " ; }
                              public S t r i n g speak ( ) { r e t u r n "meow" ; }

                       }

                       public c l a s s Cow extends Animal implements Speakable {

                            public Cow ( ) { kind = "cow" ; }

                            public S t r i n g speak ( ) { r e t u r n "moo" ; }

                       }

                                                                                                      

                       To implement a Java interface, one must provide a method implementa-
                       tion for each of the abstract methods in the interface. In this case there is
                       only one abstract method, the speak() method.

                          Note, again, the expression from the Animal.toString() class

                                                                                                      

                       ( ( Speakable ) this ) . speak ( ) ;
                                                                                                      

                       which casts this object into a Speakable object. The reason that this cast
                       is required is because an Animal does not necessarily have a speak()
                       method. A speak() method is not defined in the Animal class. How-
                       ever, the Cat subclass of Animal does implement a sleep() method as
                       part of its Speakable interface. Therefore, in order to invoke speak()
                       on an object from one of the Animal subclasses, the object must actually
                       be a Speakable and we must perform the cast as shown here.

                          This illustrates, by the way, that a Cat, by virtue of extending the
                       Animal class and implementing the Speakable interface, is both an
                       Animal and a Speakable. In general, a class that implements an in-
                       terface, has that interface as one of its types. Interface implementation is
                       itself a form of inheritance. A Java class can be a direct subclass of only
                       one superclass. But it can implement any number of interfaces.

                          Given these definitions of the Cow and Cat subclasses, the following
                       code segment will produce the same results as in the previous section.

                                                                                                      

                          Animal animal = new Cow ( ) ;                        // A cow    goes  moo
                           System . out . println ( animal . toString ( ) ) ;  // A c a t  goes
                           animal = new Cat ( ) ;                                                meow
                           System . out . println ( animal . toString ( ) ) ;
                                                                                                        

                       Although the design is different, both approaches produce the same re-
                       sult. We will put off, for now, the question of how one decides whether
SECTION 8.4  Example: A Toggle Button  353

to use an abstract method or a Java interface. We will get to this question
when we design the TwoPlayerGame class hierarchy later in this chapter.

8.4 Example: A Toggle Button

The ability to extend an existing class is one of the most powerful fea-         Reusing code
tures of object-oriented programming. It allows objects to reuse code
defined in the superclasses without having to redefine or recompile the          Problem decomposition
code. As we saw in Chapter 4, a programmer-defined JFrame, such as
GreeterGUI, uses the public methods defined for JFrames, Frames,                                JButton
Windows, Containers, Components, and Objects simply because it                     +JButton(in str : String)
is a subclass of JFrame (Fig. 4.11). By the same token, it can use all of          +setText(in str : String)
the public and protected instance variables and constants defined in
these classes by simply referring to them in its own code.                                                        쳃nterface
                                                                                                                ActionListener
   In this section, we present an example of how inheritance can be used to                                +actionPerformed()
extend and customize the functionality of a Java library class. As we saw
in Chapter 4, a JButton is a GUI component that can be associated with                              ToggleButton
a particular action by implementing the ActionListener interface. For            -label1 : String
example, we used a JButton in the GreeterGUI to generate a greeting              -label2 : String
to the user.                                                                     +ToggleButton(in l1 : String, in l2 : String)
                                                                                 +actionPerformed()
   In this section, we will design a more sophisticated button. We will
call it a ToggleButton and define it as a JButton subclass that toggles          Figure 8.8: A ToggleButton isa
its label whenever it is clicked, in addition to carrying out some kind of       JButton with two labels.
associated action.

   A light switch behaves similarly to a ToggleButton in this sense.
Whenever you flick a light switch, it changes its label from "on" to "off,"
but it also turns the lights on or off. Although different switches are asso-
ciated with different lights, every light switch toggles its label each time
it is clicked. So let's design a ToggleButton that behaves like a light
switch.

   The main idea in our design is that a ToggleButton is a JButton
that has two labels. By default, a JButton has just a single label. Thus,
because of the type of behavior we want to elicit, we need to define
ToggleButton as a subclass of JButton with two String variables that
will serve as its alternate labels (Fig. 8.8). Note that we give it a construc-
tor method that will allow us to provide the initial value of its two label
strings. Another important feature of a ToggleButton is that it should
act as its own ActionListener so that it can toggle its label whenever
it is clicked. Therefore, it must also implement the ActionListener
interface.

   The complete definition of ToggleButton is given in Figure 8.9. Note
how we have defined its constructor. Recall that the JButton class has a
constructor method with the signature JButton(String), which allows
us to set a JButton's label during instantiation. We need to do the same
thing with one of ToggleButton's two labels. That is, when we create a
ToggleButton, we want to initialize its label to one of its two alternative
labels (here, "On" or "Off").

   Because constructor methods are not inherited by the subclass, we want
to invoke the superclass's constructor in the ToggleButton() construc-
tor using the super keyword. This must be done as the first statement in
                                   354                           CHAPTER 8  Inheritance and Polymorphism

Swapping algorithm                 the ToggleButton() constructor. By passing l1 to the super construc-
                                   tor we are making the first string that the user gives us the default label
                                   for our ToggleButton. This will be the label that appears on the button
                                   when it is first displayed in a Component.

                                      Notice also in the ToggleButton() constructor that the ToggleButton
                                   is designated as its own ActionListener, so whenever it is clicked, its
                                   actionPerformed() method will be invoked. The actionPerformed()
                                   method exchanges the button's current label for its other label. Swapping
                                   two values in memory is a standard programming practice used in lots
                                   of different algorithms. In order to do it properly, you must use a third
                                   variable to temporarily store one of the two values you are swapping. The
                                   comments in actionPerformed() provide a step-by-step trace of the
                                   values of the three variables involved.

                                     JAVA PROGRAMMING TIP Swapping Values. It is necessary to use
                                     a temporary variable whenever you are swapping two values, of any
                                     type, in memory. The temporary variable holds the first value while
                                     you overwrite it with the second value.

Swapping values requires a tempo-  The first statement in actionPerformed() creates a temporary String
rary variable                      variable named tempS and assigns it the value of label1. Recall that
                                   label1 was the button's initial label. To make this example easier to fol-
                                   low, let's suppose that initially label1 is "off" and that label2 is "on."
                                   After line 1 is executed, both tempS and label1 contain "off" as their
                                   value. Line 2 then assigns label2's value to label1. Now both label1

                                                                                                                          

                                   import java . awt .  ;
                                   import java . awt . event .  ;
                                   import javax . swing .  ;

                                   public class ToggleButton extends JButton
                                                                              implements ActionListener {

                                      private String label1 ; // T o g g l e between two l a b e l s
                                      private String label2 ;

                                     public ToggleButton ( String l1 , String l2 ) {// C o n s t r u c t o r

                                        super ( l1 ) ;                       // Use l 1 as t h e d e f a u l t l a b e l

                                        label1 = l1 ;

                                        label2 = l2 ;

                                        addActionListener ( this );

                                     }

                                     public void actionPerformed ( ActionEvent e ) {

                                        S t r i n g tempS = l a b e l 1 ; // Swap t h e l a b e l s

                                        label1 = label2 ;

                                        l a b e l 2 = tempS ;

                                        setText ( label1 );

                                     } // a c t i o n P e r f o r m e d ( )

                                   } // T o g g l e B u t t o n

                                                                                                                          

                                        Figure 8.9: Definition of the ToggleButton class.
SECTION 8.4  Example: A Toggle Button                            355

and label2 store "on" as their values. In line 3 we assign tempS's value           Multiple event handlers
to label2. Now label2 stores "off" and label1 stores "on," and we
have effectively swapped their original values.

   The next time we invoke actionPerformed(), label1 and label2
will have their opposite values initially. Swapping them a second time
will assign them their initial values again. We can continue toggling their
values in this way indefinitely. To complete the method, the last state-
ment in actionPerformed() assigns label1's current value as the
new ToggleButton's label.

   Now that we have seen that a ToggleButton toggles its label be-
tween two values, what about performing an associated action? To do
this, we need a design involving multiple event handlers, one to han-
dle the toggling of the button's label and the other to handle its associ-
ated action (Fig 8.10). In this design, lightSwitch has two listeners

Listens                                                                            Figure 8.10: The ToggleButton
                                                                                   has two ActionListeners.
                            1: generateClickEvent()                                When the button is clicked, the
                             2: actionPerformed()                                  JVM will call each listener's
                                                                                   actionPerformed() method,
lightSwitch : ToggleButton                  : JavaVirtualMachine                   and each listener will take its own
                                                                                   independent action.
         Listen                             2: acti
               s                                 onPer
                                                      form
                            : ToggleApplet                 ed()

that respond to its events: the lightSwitch itself, as a result of the             Object oriented design principles
actionPerformed() method in its class, and the ToggleFrame, as a
result of actionPerformed() method in this class.

   The implementation of this design is given by ToggleFrame, a pro-
gram that uses a ToggleButton (Fig. 8.11). Like the GUI we designed
in Chapter 4, this program extends the JFrame class and implements the
ActionListener interface. In this example we use a ToggleButton
to simulate a light switch. Note that we assign the program itself as an
ActionListener for the lightSwitch, so that

   When lightSwitch is clicked, the program displays the message,
"The light is on," or "The light is off," in the program's title bar (Fig. 8.12).
This is a somewhat trivial action but it illustrates that a ToggleButton
both toggles its own label and carries out some associated action.

   The ToggleButton design satisfies several key design principles of
object-oriented programming. First and foremost, it uses inheritance to
extend the functionality of the predefined JButton class--the extensibil-
ity principle. Secondly, it encapsulates a ToggleButton's essential be-
havior within the ToggleButton class itself--the modularity principle.
                                     356                            CHAPTER 8   Inheritance and Polymorphism
                                                                                                                        
                                              java . awt .  ;
                                      import  java . awt . event .  ;
                                      import  javax . swing .  ;
                                      import

                                    public class ToggleFrame extends JFrame
                                                                                      implements ActionListener {

                                       private ToggleButton lightSwitch ;

                                      public ToggleFrame ( ) {
                                         l i g h t S w i t c h = new ToggleButton ( " o f f " , "on" ) ;
                                         getContentPane ( ) . add ( l i g h t S w i t c h ) ;
                                         lightSwitch . addActionListener ( this );

                                      } // i n i t ( )

                                      public void actionPerformed ( ActionEvent e ) {
                                          s e t T i t l e ( "The l i g h t i s " + lightSwitch . getText ( ) ) ;

                                      } // a c t i o n P e r f o r m e d ( )

                                      public s t a t i c void main ( S t r i n g args [ ] )

                                      {

                                              JFrame f = new ToggleFrame ( ) ;

                                              f . setSize (200 ,200);

                                              f . setVisible ( true );

                                      }

                                    } // T o g g l e F r a m e

                                                                                                                   

                                              Figure 8.11: Definition of the ToggleFrame class.

Figure 8.12: When clicked,
ToggleFrame button causes
"The light is on" or "The light is
off" to appear in the window's
title bar.

                                    Finally, it hides the mechanism by which a ToggleButton manages its
                                    labels--the information-hiding principle.

                                     JAVA EFFECTIVE DESIGN Inheritance. Inheritance enables you to
                                     specialize an object's behavior. A ToggleButton does everything
                                     that a JButton does, plus it can toggle its own label.

                                    SELF-STUDY EXERCISES

                                    EXERCISE 8.9 Write a code segment (not a whole method) to swap two
                                    boolean variables, b1 and b2.
                                    EXERCISE 8.10 Suppose you are designing an GUI that plays a card
                                    game, and you want a single button that can be used both to deal the
                                    cards and to collect the cards. Write a code segment that creates this
                                    type of button, adds it to the JFrame, and designates the JFrame as its
                                    ActionListener.
SECTION 8.5  Example: The Cipher Class Hierarchy  357

Special Topic: Historical Cryptography

Cryptography, the study of secret writing, has had a long and interest-
ing history. Modern-day cryptographic techniques employ sophisticated
mathematics to encrypt and decrypt messages. Today's most secure encryp-
tion schemes are safe from attack by even the most powerful computers.
Given our widespread dependence on computers and the Internet, secure
encryption has become an important application area within computer
science. While the cryptographic techniques used up through World War
II are too simple to serve as the basis for modern-day encryption schemes,
they can provide an interesting and accessible introduction to this impor-
tant area of computer science.

   One of the earliest and simplest ciphers is the Caesar cipher, used by
Julius Caesar during the Gallic wars. According to this scheme, letters of
the alphabet are shifted by three letters, wrapping around at the end of the
alphabet:

                                                                              

PlainText :  abcdefghijklmnopqrstuvwxyz

CaesarShifted : defghijklmnopqrstuvwxyzabc                                    


When encrypting a message, you take each letter of the message and re-
place it with its corresponding letter from the shifted alphabet. To decrypt
a secret message, you perform the operation in reverse--that is, you take
the letter from the shifted alphabet and replace it with the correspond-
ing letter from the plaintext alphabet. Thus, "hello" would be Caesar en-
crypted as "khoor."

   The Caesar cipher is a substitution cipher, because each letter in the
plaintext message is replaced with a substitute letter from the ciphertext
alphabet. A more general form of a substitution cipher uses a keyword to
create a ciphertext alphabet:

                                                                              

PlainText : abcdefghijklmnopqrstuvwxyz

Ciphertext : xylophneabcdfgijkmqrstuvwz                                       


In this example, the keyword "xylophone," (with the second o removed) is
used to set up a substitution alphabet. According to this cipher, the word
"hello" would be encrypted as "epddi." Substitution ciphers of this form
are found frequently in cryptogram puzzles in the newspapers.

   Another type of cipher is known as a transposition cipher. In this type
of cipher, the letters in the original message are rearranged in some me-
thodical way. A simple example would be if we reversed the letters in
each word so that "hello" became "olleh."

8.5 Example: The Cipher Class Hierarchy

Suppose we wish to design a collection of cipher classes, including a         Problem decomposition
Caesar cipher and a transposition cipher. Because the basic operations
used in all forms of encryption are the same, both the Caesar class and
the Transpose class will have methods to encrypt() and decrypt()
                                              358                     CHAPTER 8  Inheritance and Polymorphism

                           Object             messages, where each message is assumed to be a string of words sepa-
                                              rated by spaces. These methods will take a String of words and trans-
                           Cipher             late each word using the encoding method that is appropriate for that ci-
          +encrypt(in s : String) : String    pher. Therefore, in addition to encrypt() and decrypt(), each cipher
          +decrypt(in s : String) : String    class will need polymorphic encode() and decode() methods, which
          +encode(in s : String) : String     take a single word and encode or decode it according to the rules of that
          +decode(in s : String) : String     particular cipher.

                 Caesar                          From a design perspective the encrypt() and decrypt() meth-
+encode(in s : String) : String               ods will be the same for every class: They simply break the message
+decode(in s : String) : String               into words and encode or decode each word. However, the encode()
                                              and decode() methods will be different for each different cipher. The
                            Transpose         Caesar.encode() method should replace each letter of a word with its
             +encode(in s : String) : String  substitute, whereas the Transpose.encode() method should rearrange
             +decode(in s : String) : String  the letters of the word. Given these considerations, how should we design
                                              this set of classes?
Figure 8.13: A hierarchy of ci-
pher classes. The Cipher class                   Because all of the various ciphers will have the same methods, it will
implements operations common                  be helpful to define a common Cipher superclass (Fig. 8.13). Cipher
to all ciphers. The Caesar                    will encapsulate those features that the individual cipher classes have
and Transpose classes imple-                  in common--the encrypt(), decrypt(), encode(), and decode()
ment functions unique to those                methods.
kinds of ciphers.
                                                 Some of these methods can be implemented in the Cipher class itself.
Inheritance                                   For example, the encrypt() method should take a message in a String
                                              parameter, encode each word in the message, and return a String result.
                                              The following method definition will work for any cipher:

                                                                                                                                               

                                              public String encrypt ( String s ) {                                                   Tokenize
                                                 S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( "" ) ;
                                                 S t r i n g T o k e n i z e r words = new S t r i n g T o k e n i z e r ( s ) ; //
                                                 while ( words . hasMoreTokens ( ) ) {

                                              // Encode e a c h word

                                                     r e s u l t . append ( encode ( words . nextToken ( ) ) + " " ) ;
                                                 }

                                                   return result . toString ( ) ;  // R e t u r n r e s u l t

                                              } // e n c r y p t ( )

                                                                                                                                               

                                              This method creates a local StringBuffer variable, result, and uses
                                              StringTokenizer to break the original String into its component
                                              words. It uses the encode() method to encode the word, appending
                                              the result into result. The result is converted back into a String and
                                              returned as the encrypted translation of s, the original message.

                                                 If we define encrypt() in the superclass, it will be inherited by all of
                                              Cipher's subclasses. Thus, if we define Caesar and Transpose as

                                                                                                                                     

                                              public class Caesar extends Cipher { . . . }

                                              public class Transpose extends Cipher { . . . }
                                                                                                                                     

                                              instances of these classes will be able to use the encrypt() method.
                                                 On the other hand, the polymorphic encode() method cannot be

                                              implemented within Cipher. This is because unlike the encrypt()
                                              method, which is the same for every Cipher subclass, the encode()
                                              method will be different for every subclass. However, by declaring the
SECTION 8.5  Example: The Cipher Class Hierarchy                                          359

encode() method as abstract, we can leave its implementation up to

the Cipher subclasses. Thus, within the Cipher class, we would define

encode() and decode() as follows:

                                                                                                

     // A b s t r a c t methods

  public a b s t r a c t S t r i n g encode ( S t r i n g word ) ;

  public a b s t r a c t S t r i n g decode ( S t r i n g word ) ;
                                                                                                

These declarations within the Cipher class tell the compiler that these
methods will be implemented in Cipher's subclasses. By defining it as
abstract, encode() can be used in the Cipher class, as it is within the
encrypt() method.

8.5.1 Class Design: Caesar

Figure 8.14 provides the full definition of the Cipher class. The
encode() and decode() methods are declared abstract. They are in-
tended to be implemented by Cipher's subclasses.

                                                                                                                                 

import java . u t i l .  ;

public abstract class Cipher {                                                               // Use a S t r i n g B u f f e r
   public String encrypt ( String s ) {                                                    Break s into i t s words
       S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( "" ) ;
       S t r i n g T o k e n i z e r words = new S t r i n g T o k e n i z e r ( s ) ; //    // For e a c h word i n s
       while ( words . hasMoreTokens ( ) ) {                                                 // Encode i t
           r e s u l t . append ( encode ( words . nextToken ( ) ) + " " ) ;
       }                                                                                       // R e t u r n t h e r e s u l t

       return result . toString ( ) ;
   } // e n c r y p t ( )

  public String decrypt ( String s ) {

  S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( "" ) ;               // Use a S t r i n g B u f f e r
                                                                                           // B r e a k s i n t o words
  S t r i n g T o k e n i z e r words = new S t r i n g T o k e n i z e r ( s ) ;          // For e a c h word i n s
                                                                                           // Decode i t
  while ( words . hasMoreTokens ( ) ) {
                                                                                           Return the decryption
     r e s u l t . append ( decode ( words . nextToken ( ) ) + " " ) ;

  }

  return result . toString ( ) ;                                                   //

  } // d e c r y p t ( )

     public abstract      String  encode ( String  word ) ;                                // A b s t r a c t methods
                          String  decode ( String  word ) ;
     public abstract                                                                                                          

  } // C i p h e r


     Figure 8.14: The abstract Cipher class.

   Note again that encrypt() and decrypt(), which are implemented                               encode() and decode() are
in Cipher, invoke encode() and decode(), respectively, which are de-                            polymorphic
clared in Cipher but implemented in Cipher's subclasses. Java's dy-
namic binding mechanism will take care of invoking the appropriate im-
plementation of encode() or decode(), depending on what type of ob-
ject is involved. For example, if caesar and transpose are Caesar and
                       360                  CHAPTER 8  Inheritance and Polymorphism

                       Transpose objects, respectively, then the following calls to encrypt()

                       will cause their respective encode() methods to be invoked:

                                                                                                      

                         // I n v o k e s c a e s a r . e n c o d e ( )

                         caesar . encrypt ( " hello world" ) ;

                         // I n v o k e s t r a n s p o s e . e n c o d e ( )

                         transpose . encrypt ( " hello world" ) ;                                     
                       

Method polymorphism    When caesar.encrypt() is called, it will in turn invoke caesar.en-
Character conversions  code()--that is, it will call the encode() method implemented in the
                       Caesar class. When transpose.encrypt() is invoked, it will in turn
                       invoke transpose.encode(). In this way, each object can perform the
                       encoding algorithm appropriate for its type of cipher.

                       8.5.2 Algorithm Design: Shifting Characters

                       The Caesar class is defined as an extension of Cipher (Fig. 8.15). The

                       only methods implemented in Caesar are encode() and decode().

                       The encode() method takes a String parameter and returns a String

                       result. It takes each character of its parameter (word.charAt(k)) and

                       performs a Caesar shift on the character. Note how the shift is done:

                                                                                                      

                         ch = ( char ) ( ' a ' + ( ch - ' a '+ 3) % 2 6 ) ; // C a e s a r s h i f t  
                       

                       Recall from Chapter 5 that char data in Java are represented as 16-bit
                       integers. This enables us to manipulate characters as numbers. Thus, to
                       shift a character by 3, we simply add 3 to its integer representation.

                       

                       public class Caesar extends Cipher {

                         public S t r i n g encode ( S t r i n g word ) {

                            S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;  // I n i t i a l i z e a s t r i n g b
                                                                                                     // For e a c h c h a r a c t e r i n
                            f o r ( i n t k = 0 ; k < word . l e n g t h ( ) ; k++) {                // Get t h e c h a r a c t e r
                                                                                                     // P e r f o r m c a e s a r s h i f t
                               char ch = word . charAt ( k ) ;
                                                                                                       Append i t t o new s t r i n g
                               ch = ( char ) ( 'a ' + ( ch -'a '+ 3) % 2 6 ) ;
                                                                                                     Return the result as a s
                               r e s u l t . append ( ch ) ;                    //

                            }

                            return result . toString ( ) ;                      //

                         } // en co de ( )

                         public S t r i n g decode ( S t r i n g word ) {

                            S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ; // I n i t i a l i z e a s t r i n g b

                            f o r ( i n t k = 0 ; k < word . l e n g t h ( ) ; k++) { // F o r e a c h c h a r a c t e r i n

                            char ch = word . charAt ( k ) ;                                          // Get t h e c h a r a c t e r

                               ch = ( char ) ( ' a ' + ( ch - ' a ' + 23) % 2 6 ) ; // P e r f o r m r e v e r s e s h

                               r e s u l t . append ( ch ) ;                                         // Append i t t o new s t r

                            }

                            return result . toString ( ) ;                     // R e t u r n t h e r e s u l t as a s t r

                         } // decode ( )

                         } // C a e s a r
                       

                                            Figure 8.15: The Caesar class.

                         For example, suppose that the character (ch) is h, which has an ASCII
SECTION 8.5  Example: The Cipher Class Hierarchy                  361

code of 104 (see Table 5.13). We want to shift it by 3, giving k, which has
a code of 107. In this case, we could simply add 3 to 104 to get the de-
sired result. However, suppose that ch was the character y, which has an
ASCII code of 121. If we simply add 3 in this case, we get 124, a code that
corresponds to the symbol "--," which is not our desired result. Instead,
we want the shift in this case to "wrap around" to the beginning of the
alphabet, so that y gets shifted into b. In order to accomplish this we need
to do some modular arithmetic.

   Let's suppose the 26 characters a to z were numbered 0 through 25, so
that a corresponds to 0, b to 1, and so on up to z as 25. If we take any
number N and divide it (modulo 26), we would get a number between 0
and 25. Suppose, for example, y were numbered 24. Shifting it by 3 would
give us 27, and 27 % 26 would give us 1, which corresponds to b. So, if
the a to z were numbered 0 through 25, then we can shift any character
within that range by using the following formula:

                                                                              
                                                                              
  ( ch + 3) % 26               // S h i f t by 3 wi th wraparound             

                                                                              
To map a character in the range a to z onto the integers 0 to 25, we can      
simply subtract a from it:
                                                                              

                                                                               Modular arithmetic
  'a ' - 'a ' = 0
  'b ' - 'a ' = 1
  'c ' - 'a ' = 2
  ...
  'z ' - 'a ' = 25


Finally, we simply map the numbers 0 through 25 back to the characters a
to z to complete the shift operation:



  ( char )( 'a ' + 0) = 'a '
  ( char )( 'a ' + 1) = 'b '
  ( char )( 'a ' + 2) = 'c '
  ...
  ( char )( 'a ' + 25) = 'z '


Note the use here of the cast operator (char) to covert an integer into a
char.

   To summarize, we can shift any character by 3 if we map it into the
range 0 to 25, then add 3 to it mod 26, then map that result back into
the range a to z. Thus, shifting y would go as follows:
362                        CHAPTER 8  Inheritance and Polymorphism

                                                                                            

  ( char ) ( ' a ' + ( ch -' a '+ 3) % 26) //

  Perform Caesar shift                                on ' y '
                                                    //
  ( char )( 'a ' + ( 'y ' - 'a ' +3) % 26) //
  ( char )(97 + (121 - 97 + 3) % 26)

  Map ' y ' t o 0 . . 2 5  26))         // S h i f t by  3 , wrapping              around
                                    // Map r e s u l t   back to 'a '              to 'z '
  ( char )(97 + (27 %
  ( char )(97 + 1)                             //
  ( char )(98)

  Convert from int to char

  'b '
                                                                                            

Note that in decode() a reverse Caesar shift is done by shifting by 23,
which is 26 - 3. If the original shift is 3, we can reverse that by shifting an
additional 23. Together this gives a shift of 26, which will give us back our
original string.

8.5.3 Class Design: Transpose

The Transpose class (Fig. 8.16) is structured the same as the Caesar
class. It implements both the encode() and decode() methods. The
key element here is the transpose operation, which in this case is a simple
reversal of the letters in the word. Thus, "hello" becomes "olleh". This
is very easy to do when using the StringBuffer.reverse() method.
The decode() method is even simpler, because all you need to do in this
case is call encode(). Reversing the reverse of a string gives you back
the original string.

                                                                                   

public class Transpose extends Cipher {

  // e n c o d e ( ) r e v e r s e s and r e t u r n s a word

  public S t r i n g encode ( S t r i n g word ) {
     S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( word ) ;
     return result . reverse ( ) . toString ( ) ;

  } // en co de ( )

  public S t r i n g decode ( S t r i n g word ) {

     r e t u r n encode ( word ) ;  // J u s t c a l l e n c o d e

  } // decode

} // T r a n s p o s e

                                                                                   

                        Figure 8.16: The Transpose class.

8.5.4 Testing and Debugging

Figure 8.17 provides a simple test program for testing Cipher and its sub-
classes. It creates a Caesar cipher and a Transpose cipher and then en-
SECTION 8.6  Case Study: A Two Player Game Hierarchy      363

                                                                                                 

public class TestEncrypt {

  public s t a t i c void main ( S t r i n g argv [ ] ) {

  Caesar c a e s a r = new Caesar ( ) ;

  String plain = " t h i s i s the s e c r e t message" ; // Here ' s t h e m e s s a g e

  String secret = caesar . encrypt ( plain ) ;             // E n c r y p t t h e message

  System . out . println ( "  Caesar Cipher Encryption " ) ;

  System . out . println ( " PlainText : " + plain ) ;     // D i s p l a y t h e r e s u l t s

  System . out . println ( "Encrypted : " + secret ) ;

  System . out . println ( "Decrypted : " + caesar . decrypt ( secret ) ) ; // D e c r y p t

  Transpose t r a n s p o s e = new Transpose ( ) ;

  secret = transpose . encrypt ( plain ) ;

  System . out . println ( "\n  Transpose Cipher Encryption " ) ;

  System . out . println ( " PlainText : " + plain ) ;     // D i s p l a y t h e r e s u l t s

  System . out . println ( "Encrypted : " + secret ) ;

  System . out . println ( "Decrypted : " + transpose . decrypt ( secret ) ) ; // D e c r y p t

  } // main ( )

} // end T e s t E n c r y p t

                                                                                                 

                 Figure 8.17: The TestEncrypt class.

crypts and decrypts the same sentence using each cipher. If you run this
program, it will produce the following output:

                                                                               

                 Caesar Cipher Encryption 
  PlainText :    this i s the secret message
  Encrypted :    wklv l v wkh vhfuhw phvvdjh
  Decrypted :    this i s the secret message

   Transpose Cipher Encryption 

  PlainText : this i s the secret message

  Encrypted : si ht s i eht terces egassem

  Decrypted : this i s the secret message                                      

SELF-STUDY EXERCISES

EXERCISE 8.11 Modify the Caesar class so that it will allow various
sized shifts to be used. (Hint: Use an instance variable to represent the
shift.)

EXERCISE 8.12 Modify Transpose.encode() so that it uses a rota-
tion instead of a reversal. That is, a word like "hello" should be encoded
as "ohell" with a rotation of one character.

8.6 Case Study: A Two Player Game Hierarchy

In this section we will redesign our OneRowNim game to fit within a hi-
erarchy of classes of two-player games, which are games that involve two
players. Many games that this characteristic: checkers, chess, tic-tac-toe,
guessing games, and so forth. However, there are also many games that
involve just 1 player: blackjack, solitaire, and others. There are also games
                                  364  CHAPTER 8  Inheritance and Polymorphism

Generic superclass                that involve two or more players, such as many card games. Thus, our
                                  redesign of OneRowNim as part of a two-player game hierarchy will not
Figure 8.18:        The  current  be our last effort to design a hierarchy of game-playing classes. We will
                                  certainly re-design things as we learn new Java language constructs and
OneRowNim class.                  as we try to extend our game library to other kinds of games.

                                     This case study will illustrate how we can apply inheritance and poly-
                                  morphism, as well as other object-oriented design principles. The justifica-
                                  tion for revising OneRowNim at this point is to make it easier to design and
                                  develop other two-player games. As we have seen, one characteristic of
                                  class hierarchies is that more general attributes and methods are defined
                                  in top-level classes. As one proceeds down the hierarchy, the methods
                                  and attributes become more specialized. Creating a subclass is a matter of
                                  specializing a given class.

                                  8.6.1 Design Goals

                                  One of our design goals is to revise the OneRowNim game so that it fits
                                  into a hierarchy of two-player games. One way to do this is to gener-
                                  alize the OneRowNim game by creating a superclass that contains those
                                  attributes and methods that are common to all two-player games. The su-
                                  perclass will define the most general and generic elements of two-player
                                  games. All two-player games, including OneRowNim, will be defined as
                                  subclasses of this top-level superclass and will inherit and possibly over-
                                  ride its public and protected variables and methods. Also, our top-level
                                  class will contain certain abstract methods, whose implementations will
                                  be given in OneRowNim and other subclasses.

                                     A second goal is to design a class hierarchy that makes it possible for
                                  computers to play the game, as well as human users. Thus, for a given
                                  two-player game, it should be possible for two humans to play each other,
                                  or for two computers to play each other, or for a human to play against a
                                  computer. This design goal will require that our design exhibit a certain
                                  amount of flexibility. As we shall see, this is a situation in which Java
                                  interfaces will come in handy.

                                     Another important goal is to design a two-player game hierarchy that
                                  can easily be used with a variety of different user interfaces, including
                                  command-line interfaces and GUIs. To handle this feature, we will de-
                                  velop Java interfaces to serve as interfaces between our two-player games
                                  and various user interfaces.

                                  8.6.2 Designing the TwoPlayerGame Class

                                  To begin revising the design of the OneRowNim game, we first need to
                                  design a top-level class, which we will call the TwoPlayerGame class.
                                  What variables and methods belong in this class? One way to answer
                                  this question is to generalize our current version of OneRowNim by mov-
                                  ing any variables and methods that apply to all two-player games up to
                                  the TwoPlayerGame class. All subclasses of TwoPlayerGame--which
                                  includes the OneRowNim class--would inherit these elements. Figure 8.18
                                  shows the current design of OneRowNim.

                                     What variables and methods should we move up to the TwoPlayer-
                                  Game class? Clearly, the class constants, PLAYER ONE and PLAYER TWO,
                                  apply to all two-player games. These should be moved up. On the
                                  other hand, the MAX PICKUP and MAX STICKS constants apply just to the
                                  OneRowNim game. They should remain in the OneRowNim class.
SECTION 8.6  Case Study: A Two Player Game Hierarchy  365

   The nSticks instance variable is a variable that only applies to the      Constructors are not inherited
OneRowNim game, but not to other two-player games. It should stay
in the OneRowNim class. On the other hand, the onePlaysNext vari-
able applies to all two-player games, so we will move it up to the
TwoPlayerGame class.

   Because constructors are not inherited, all of the constructor meth-
ods will remain in the OneRowNim class. The instance methods,
takeSticks() and getSticks(), are particular to OneRowNim, so
they should remain there. However, the other methods, getPlayer(),
gameOver(), getWinner(), and reportGameState(), are methods
that would be useful to all two-player games. Therefore these methods
should be moved up to the superclass. Of course, while these methods
can be defined in the superclass, some of the methods can only be imple-
mented in subclasses. For example, the reportGameState() method
reports the current state of the game, so it has to be implemented in
OneRowNim. Similarly, the getWinner() method defines how the win-
ner of the game is determined, a definition that can only occur in the sub-
class. Every two-player game needs methods such as these. Therefore,
we will define these methods as abstract methods in the superclass. The
intention is that TwoPlayerGame subclasses will provide game-specific
implementations for these methods.

   Given these considerations, we come up with the design shown in Fig-
ure 8.19. The design shown in this figure is much more complex than
designs we have used in earlier chapters. However, the complexity comes
from combining ideas already discussed in previous sections of this chap-
ter, so don't be put off by it.

   To begin with, notice that we have introduced two Java interfaces into
our design in addition to the TwoPlayerGame superclass. As we will
show, these interfaces lead to a more flexible design and one that can eas-
ily be extended to incorporate new two-player games. Let's take each
element of this design separately.

8.6.3 The TwoPlayerGame Superclass

As we have stated, the purpose of the TwoPlayerGame class is to serve as
the superclass for all two-player games. Therefore, it should define those
variables and methods that are shared by two-player games.

   The PLAYER ONE, PLAYER TWO, and onePlaysNext variables and
the getPlayer(), setPlayer(), and changePlayer() methods
have been moved up from the OneRowNim class. Clearly, these
variables and methods apply to all two-player games. Note that
we have also added three new variables: nComputers, computer1,
computer2 and their corresponding methods, getNComputers() and
addComputerPlayer(). We will use these elements to give our games
the ability to be played by computer programs. Because we want all of
our two-player games to have this capability, we define these variables
and methods in the superclass rather than in OneRowNim and subclasses
of TwoPlayerGame.
                                                 366     CHAPTER 8  Inheritance and Polymorphism
Figure 8.19: TwoPlayerGame is
the superclass for OneRowNim
and other two player games.

   Note that the computer1 and computer2 variables are declared to
be of type IPlayer. IPlayer is an interface, which contains a single
method declaration, the makeAMove() method:

                                                                                                                

                                                      public interface IPlayer {

                                                         public S t r i n g makeAMove ( S t r i n g prompt ) ;

                                                      }

                                                                                                                

Why do we use an interface here rather than some type of game-playing
object? This is a good design question. Using an interface here makes
our design more flexible and extensible because it frees us from having to
know the names of the classes that implement the makeAMove() method.
SECTION 8.6  Case Study: A Two Player Game Hierarchy  367

The variables computer1 and computer2 will be assigned objects that            Game-dependent algorithms
implement IPlayer via the addComputerPlayer() method.                          The IPlayer interface

   The algorithms used in the various implementations of makeAMove()          
are game-dependent--they depend on the particular game being played.          
It would be impossible to define a game-playing object that would suf-
fice for all two-player games. Instead, if we want an object that plays
OneRowNim, we would define a OneRowNimPlayer and have it imple-
ment the IPlayer interface. Similarly, if we want an object that plays
checkers, we would define a CheckersPlayer and have it implement
the IPlayer interface. By using an interface here, our TwoPlayerGame
hierarchy can deal with a wide range of differently named objects that
play games, as long as they implement the IPlayer interface. So, using
the IPlayer interface adds flexibility to our game hierarchy and makes
it easier to extend it to new, yet undefined, classes. We will discuss the
details of how to design a game player in one of the following sections.

   Turning now to the methods defined in TwoPlayerGame, we have
already seen implementations of getPlayer(), setPlayer(), and
changePlayer() in the OneRowNim class. We will just move those im-
plementations up to the superclass. The getNComputers() method is
the accessor method for the nComputers variable, and its implementa-
tion is routine. The addComputerPlayer() method adds a computer
player to the game. Its implementation is as follows:

 

    public void addComputerPlayer ( IPlayer player ) {
         i f ( nComputers == 0 )
               computer2 = player ;
         e l s e i f ( nComputers == 1 )
               computer1 = player ;
         else
               return ; // No more t h a n 2 p l a y e r s
         ++nComputers ;

    }
 

As we noted earlier, the classes that play the various TwoPlayerGames
must implement the IPlayer interface. The parameter for this method
is of type IPlayer. The algorithm we use checks the current value of
nComputers. If it is 0, which means that this is the first IPlayer added
to the game, the player is assigned to computer2. This allows the hu-
man user to be associated with PLAYERONE, if this is a game between a
computer and a human user.

   If nComputers equals 1, which means that we are adding a second
IPlayer to the game, we assign that player to computer1. In ei-
ther of these cases, we increment nComputers. Note what happens
if nComputers is neither 1 nor 2. In that case, we simply return
without adding the IPlayer to the game and without incrementing
nComputers. This, in effect, limits the number of IPlayers to two. (A
more sophisticated design would throw an exception to report an error.
but we will leave that for a subsequent chapter.)

   The addComputerPlayer() method is used to initialize a game after
it is first created. If this method is not called, the default assumption is
                     368                CHAPTER 8  Inheritance and Polymorphism

                     that nComputers equals zero and that computer1 and computer2 are
                     both null. Here's an example of how it could be used:

                                                                                                              

                          OneRowNim nim = new OneRowNim ( 1 1 ) ; // 1 1 s t i c k s

                          nim . add (new NimPlayer ( nim ) ) ;     // 2 c o m p u t e r p l a y e r s

                          nim . add (new NimPlayerBad ( nim ) ) ;                                             

Overriding a method  Note that the NimPlayer() constructor takes a reference to the game
Polymorphism         as its argument. Clearly, our design should not assume that the names of
                     the IPlayer objects would be known to the TwoPlayerGame superclass.
                     This method allows the objects to be passed in at run time. We will discuss
                     the details of NimPlayerBad in a subsequent section.

                        The getRules() method is a new method whose purpose is to return
                     a string that describes the rules of the particular game. This method is
                     implemented in the TwoPlayerGame class with the intention that it will
                     be overridden in the various subclasses. For example, its implementation
                     in TwoPlayerGame is:

                                                                                                              

                          public String getRules () {

                             r e t u r n "The r u l e s o f t h i s game a r e : " ;

                          }

                                                                                                              

                     and its redefinition in OneRowNim is:

                                                                                                              

                     public String getRules () {

                             r e t u r n "\n The Rules o f One Row Nim \n" +

                             " ( 1 ) A number o f s t i c k s between 7 and " + MAX STICKS +

                             " i s chosen .\n" +

                             " ( 2 ) Two p l a y e r s a l t e r n a t e making moves . \ n" +

                             " ( 3 ) A move c o n s i s t s o f s u b t r a c t i n g between 1 and\n\ t " +

                          MAX PICKUP +

                             " s t i c k s from the c u r r e n t number of s t i c k s . \ n" +

                             " ( 4 ) A p l a y e r who cannot l e a v e a p o s i t i v e \n\ t " +

                             " number of s t i c k s f o r the other player l o s e s . \ n" ;

                     }

                                                                                                              

                     The idea is that each TwoPlayerGame subclass will take responsibility for
                     specifying its own set of rules in a form that can be displayed to the user.

                        You might recognize that defining getRules() in the superclass and
                     allowing it to be overridden in the subclasses is a form of polymorphism.
                     It follows the design of the toString() method, which we discussed
                     earlier. This design will allow us to use code that takes the following form:

                                                                                                              

                             TwoPlayerGame game = new OneRowNim ( ) ;

                             System . out . p r i n t l n ( game . g e t R u l e s ( ) ) ;                    

                     In this example the call to getRules() is polymorphic. The dynamic
                     binding mechanism is used to invoke the getRules() method that is
                     defined in the OneRowNim class.

                        The remaining methods in TwoPlayerGame are defined abstractly.
                     The gameOver() and getWinner() methods are both methods that are
SECTION 8.6  Case Study: A Two Player Game Hierarchy      369

game dependent. That is, the details of their implementations depend on
the particular TwoPlayerGame subclass in which they are implemented.

   This is good example of how abstract methods should be used in de-
signing a class hierarchy. We give abstract definitions in the superclass
and leave the detailed implementations up to the individual subclasses.
This allows the different subclasses to tailor the implementations to their
particular needs, while allowing all subclasses to share a common signa-
ture for these tasks. This allows us to use polymorphism to create flexible,
extensible class hierarchies.

   Figure 8.20 shows the complete implementation of the abstract
TwoPlayerGame class. We have already discussed the most important
details of its implementation.

JAVA EFFECTIVE DESIGN Abstract Methods. Abstract methods
allow you to give general definitions in the superclass and to leave the
implementation details to the different subclasses.

8.6.4 The CLUIPlayableGame Interface

Let's turn now to the two interfaces shown in Figure 8.19. Taken to-          Extending an interface
gether, the purpose of these interfaces is to create a connection between
any two-player game and a command-line user interface (CLUI). The
interfaces provide method signatures for the methods that will imple-
ment the details of the interaction between a TwoPlayerGame and a
UserInterface. Because the details of this interaction vary from game
to game, it is best to leave the implementation of these methods to the
games themselves.

   Note that CLUIPlayableGame extends the IGame interface. The
IGame interface contains two methods that are used to define a stan-
dard form of communication between the CLUI and the game. The
getGamePrompt() method defines the prompt that is used to signal the
user for some kind of move--for example, "How many sticks do you
take (1, 2, or 3)?" And the reportGameState() method defines how
that particular game will report its current state--for example, "There
are 11 sticks remaining." CLUIPlayableGame adds the play() method
to these two methods. As we will see shortly, the play() method will
contain the code that will control the playing of the game.
The source code for these interfaces is very simple:

                                                                              

public i n t e r f a c e CLUIPlayableGame extends IGame {

   public abstract void play ( UserInterface ui ) ;

}

public i n t e r f a c e IGame {

   public Stri ng getGamePrompt ( ) ;

   public String reportGameState ( ) ;

} // IGame

                                                                              

Notice that the CLUIPlayableGame interface extends the IGame inter-
face. A CLUIPlayableGame is a game that can be played through a
CLUI. The purpose of its play() method is to contain the game depen-
dent control loop that determines how the game is played via some kind
 370                       CHAPTER 8  Inheritance and Polymorphism
                                                                                         

  public abstract   c l a s s TwoPlayerGame {
     public static  f i n a l i n t PLAYER ONE = 1 ;
     public static  f i n a l i n t PLAYER TWO = 2 ;

protected  boolean onePlaysNext = true ;
protected
           int nComputers = 0 ;  // How many c o m p u t e r s
protected
                                 // Computers a r e I P l a y e r s

           IPlayer computer1 , computer2 ;

     public void setPlayer ( int s t a r t e r ) {                         Methods
         i f ( s t a r t e r == PLAYER TWO)
             onePlaysNext = false ;                                                    
         else onePlaysNext = true ;

     } // s e t P l a y e r ( )
     public int getPlayer () {

         if ( onePlaysNext )
             r e t u r n PLAYER ONE ;

         e l s e r e t u r n PLAYER TWO ;
     } // g e t P l a y e r ( )
     public void changePlayer ( ) {

         onePlaysNext = ! onePlaysNext ;
     } // c h a n g e P l a y e r ( )
     public int getNComputers ( ) {

         return nComputers ;
     }

     public String getRules () {
         r e t u r n "The r u l e s o f t h i s game a r e : " ;

     }

     public void addComputerPlayer ( IPlayer player ) {
         i f ( nComputers == 0 )
             computer2 = player ;
         e l s e i f ( nComputers == 1 )
             computer1 = player ;
         else
             return ; // No more t h a n 2 p l a y e r s
         ++nComputers ;

     }

         public a b s t r a c t boolean gameOver ( ) ; // A b s t r a c t
         public abstract String getWinner ( ) ;
  } // TwoPlayerGame


           Figure 8.20: The TwoPlayerGame class

of user interface (UI). In pseudocode, a typical control loop for a game                       
would look something like the following:                                                    UI .

                                                                                               

    I n i t i a l i z e t h e game .
    While t h e game i s not over

       Report t h e c u r r e n t s t a t e o f t h e game v i a t h e UI .
       Prompt t h e user ( or t h e computer ) t o make a move v i a t h e
       Get t h e user ' s move v i a t h e UI .
       Make t h e move .
       Change to the other player .
 
SECTION 8.6  Case Study: A Two Player Game Hierarchy              371

The play loop sets up an interaction between the game and the UI. The
UserInterface parameter allows the game to connect directly to a par-
ticular UI. To allow us to play our games through a variety of UIs, we
define UserInterface as the following Java interface:

                                                                             

  public interface UserInterface {

   public String getUserInput ( ) ;

   public void report ( String s ) ;

   public void prompt ( String s ) ;

}

                                                                             

Any object that implements these three methods can serve as a UI for
one of our TwoPlayerGames. This is another example of the flexibility
of using interfaces in object-oriented design.

   To illustrate how we use UserInterface, let's attach it to our
KeyboardReader class, thereby letting a KeyboardReader serve as a
CLUI for TwoPlayerGames. We do this simply by implementing this
interface in the KeyboardReader class, as follows:

                                                                             

  public class KeyboardReader implements UserInterface                       

As it turns out, the three methods listed in UserInterface match three
of the methods in the current version of KeyboardReader. This is no
accident. The design of UserInterface was arrived at by identifying
the minimal number of methods in KeyboardReader that were needed
to interact with a TwoPlayerGame.

JAVA EFFECTIVE DESIGN Flexibility of Java Interfaces. A Java
interface provides a means of associating useful methods with a
variety of different types of objects, leading to a more flexible
object-oriented design.

The benefit of defining the parameter more generally as a User-              Generality principle
Interface, instead of as a KeyboardReader, is that we will eventu-
ally want to allow our games to be played via other kinds of command-
line interfaces. For example, we might later define an Internet-based
CLUI that could be used to play OneRowNim among users on the Inter-
net. This kind of extensibility--the ability to create new kinds of UIs and
use them with TwoPlayerGames-- is another important design feature
of Java interfaces.

JAVA EFFECTIVE DESIGN Extensibility and Java Interfaces. Using
interfaces to define useful method signatures increases the
extensibility of a class hierarchy.

   As Figure 8.19 shows, OneRowNim implements the CLUIPlayable-
Game interface, which means it must supply implementations of all three
abstract methods: play(), getGamePrompt(), and reportGame-
State().
                                 372  CHAPTER 8  Inheritance and Polymorphism

Interfaces vs. abstract methods  8.6.5 Object Oriented Design: Interfaces or Abstract
Flexibility of interfaces                 Classes

Inheritance and generality       Why are these methods defined in interfaces? Couldn't we just as easily
                                 define them in the TwoPlayerGame class and use inheritance to extend
                                 them to the various game subclasses? After all, isn't the net result the
                                 same, namely, that OneRowNim must implement all three methods.

                                    These are very good design questions, exactly the kinds of questions
                                 one should ask when designing a class hierarchy of any sort. As we
                                 pointed out in the Animal example earlier in the chapter, you can get the
                                 same functionality from a abstract interface and from an abstract super-
                                 class method. When should we put the abstract method in the superclass
                                 and when does it belong in an interface? A very good discussion of these
                                 and related object-oriented design issues is available in Java Design, 2nd
                                 Edition, by Peter Coad and Mark Mayfield (Yourdan Press, 1999). Our dis-
                                 cussion of these issues follows many of the guidelines suggested by Coad
                                 and Mayfield.

                                    We have already seen that using Java interfaces increases the flexibility
                                 and extensibility of a design. Methods defined in an interface exist inde-
                                 pendently of a particular class hierarchy. By their very nature, interfaces
                                 can be attached to any class, which makes them very flexible to use.

                                    Another useful guideline for answering this question is that the super-
                                 class should contain the basic common attributes and methods that define
                                 a certain type of object. It should not necessarily contain methods that
                                 define certain roles that the object plays. For example, the gameOver()
                                 and getWinner() methods are fundamental parts of the definition of
                                 a TwoPlayerGame. One cannot define a game without defining these
                                 methods. By contrast, methods such as play(), getGamePrompt(), and
                                 reportGameState() are important for playing the game but they do not
                                 contribute in the same way to the game's definition. Thus these methods
                                 are best put into an interface. So, one important design guideline is:

                                 JAVA EFFECTIVE DESIGN Abstract Methods. Methods defined
                                 abstractly in a superclass should contribute in a fundamental way
                                 toward the basic definition of that type of object, not merely toward
                                 one of its roles or its functionality.

                                 8.6.6 The Revised OneRowNim Class

                                 Figure 8.21 provides a listing of the revised OneRowNim class, one that fits
                                 into the TwoPlayerGame class hierarchy. Our discussion in this section
                                 will focus on just those features of the game that are new or revised.

                                    The gameOver() and getWinner() methods, which are now inher-
                                 ited from the TwoPlayerGame superclass, are virtually the same as in the
                                 previous version. One small change is that getWinner() now returns a
                                 String instead of an int. This makes that method more generally useful
                                 as a way of identifying the winner for all TwoPlayerGames.

                                    Similarly, the getGamePrompt() and reportGameState() meth-
                                 ods merely encapsulate functionality that was present in the earlier ver-
                                 sion of the game. In our earlier version the prompts to the user were
                                 generated directly by the main program. By encapsulating this infor-
SECTION 8.6  Case Study: A Two Player Game Hierarchy                     373

                                                                                             

public c l a s s OneRowNim extends TwoPlayerGame
                                                           implements CLUIPlayableGame {

   public s t a t i c f i n a l i n t MAX PICKUP = 3 ;
   public s t a t i c f i n a l i n t MAX STICKS = 1 1 ;
   p r i v a t e i n t n S t i c k s = MAX STICKS ;

  public OneRowNim ( ) { }                 // C o n s t r u c t o r s

  public OneRowNim( i n t s t i c k s ) {

  nSticks = sticks ;

  } // OneRowNim ( )

  public OneRowNim( i n t s t i c k s , i n t s t a r t e r ) {

  nSticks = sticks ;

  setPlayer ( starter );

  } // OneRowNim ( )

  public boolean t a k e S t i c k s ( i n t num) {

  i f (num < 1 | | num > MAX PICKUP | | num > n S t i c k s )

  return false ;                           // E r r o r

  else                                     // V a l i d move

  { n S t i c k s = n S t i c k s - num ;

        return true ;

  } // e l s e

  } // t a k e S t i c k s ( )

  public int getSticks () {

  return nSticks ;

  } // g e t S t i c k s ( )

  public String getRules () {

  r e t u r n "\n The Rules o f One Row Nim \n" +

  " ( 1 ) A number o f s t i c k s between 7 and " + MAX STICKS +

        " i s chosen .\n" +

  " ( 2 ) Two p l a y e r s a l t e r n a t e making moves . \ n" +

  " ( 3 ) A move c o n s i s t s o f s u b t r a c t i n g between 1 and\n\ t " +

        MAX PICKUP + " s t i c k s from t h e c u r r e n t number o f s t i c k s . \ n" +

  " ( 4 ) A p l a y e r who cannot l e a v e a p o s i t i v e \n\ t " +

  " number of s t i c k s f o r the other player l o s e s . \ n" ;

  } // g e t R u l e s ( )

  public boolean gameOver ( ) { /  F r o m T w o P l a y e r G a m e /

  r e t u r n ( n S t i c k s <= 0 ) ;

  } // gameOver ( )

  public String getWinner ( ) {            / From TwoPlayerGame /

  i f ( gameOver ( ) ) // {

  r e t u r n "" + g e t P l a y e r ( ) + " Nice game . " ;

  r e t u r n "The game i s not over y e t . " ; // Game i s n o t o v e r

  } // g e t W i n n e r ( )

                                                                                             

        Figure 8.21: The revised OneRowNim class, Part I.

mation in an inherited method, we make it more generally useful to all
TwoPlayerGames.

   The major change to OneRowNim comes in the play() method, which
controls the playing of the OneRowNim (Fig. 8.22). Because this version
of the game incorporates computer players, the play loop is a bit more
complex than in earlier versions of the game. The basic idea is still the
same: The method loops until the game is over. On each iteration of the
                       374                CHAPTER 8  Inheritance and Polymorphism
                                                                                                        

  / From CLUIPlayableGame /

  public Stri ng getGamePrompt ( ) {

  r e t u r n "\nYou can p i c k up between 1 and " +

                            Math . min (MAX PICKUP, n S t i c k s ) + " : " ;

  } // getGamePrompt ( )

  public String reportGameState () {

  i f ( ! gameOver ( ) )

     return ("\nSticks l e f t : " + getSticks () +

        " Who ' s turn : P l a y e r " + g e t P l a y e r ( ) ) ;

  else

     return ("\nSticks l e f t : " + getSticks () +

        " Game over ! Winner i s P l a y e r " + getWinner ( ) +"\n" ) ;

  } // r e p o r t G a m e S t a t e ( )

  public void play ( UserInterface ui ) {// From C L U I P l a y a b l e G a m e i n t e r f a c e

  int sticks = 0;

  ui . report ( getRules ( ) ) ;

  if ( computer1 != null )

  ui . report ( "\nPlayer 1 is a " + computer1 . toString ( ) ) ;

  if ( computer2 != null )

  ui . report ( "\nPlayer 2 is a " + computer2 . toString ( ) ) ;

  while ( ! gameOver ( ) ) {

  IPlayer computer = null ;                  // Assume no c o m p u t e r s

  ui . report ( reportGameState ( ) ) ;

  switch ( getPlayer ( ) ) {

  c a s e PLAYER ONE :                       // P l a y e r 1 ' s t u r n

        computer = computer1 ;

        break ;

  c a s e PLAYER TWO :                       // P l a y e r 2 ' s t u r n

        computer = computer2 ;

        break ;

  } // c a s e s

  i f ( computer != null ) {                 // I f c o m p u t e r ' s t u r n

        s t i c k s = I n t e g e r . p a r s e I n t ( computer . makeAMove ( "" ) ) ;

        ui . report ( computer . toString ( ) + " takes " +

                                             s t i c k s + " s t i c k s .\n" ) ;

  } else {                                // o t h e r w i s e , u s e r ' s t u r n

        ui . prompt ( getGamePrompt ( ) ) ;

        sticks =

        Integer . parseInt ( ui . getUserInput ( ) ) ; // Get u s e r ' s move

  }

  if ( takeSticks ( sticks ))                // I f a l e g a l move

        changePlayer ( ) ;

  } // w h i l e

  ui . report ( reportGameState ( ) ) ; // The game i s now o v e r

  } // p l a y ( )

} // OneRowNim c l a s s

                                                                                                    

                    Figure 8.22: The revised OneRowNim class, continued from previous page.

                    loop, one or the other of the two players, PLAYER ONE or PLAYER TWO,
                    takes a turn making a move--that is, deciding how many sticks to pick
                    up. If the move is a legal move, then it becomes the other player's turn.
SECTION 8.6  Case Study: A Two Player Game Hierarchy    375

   Let's look now at how the code distinguishes between whether it is
a computer's turn to move or a human player's turn. Note that at the
beginning of the while loop, it sets the computer variable to null. It
then assigns computer a value of either computer1 or computer2, de-
pending on whose turn it is. But recall that one or both of these vari-
ables may be null, depending on how many computers are playing the
game. If there are no computers playing the game, then both variables
will be null. If only one computer is playing, then computer1 will
be null. This is determined during initialization of the game, when the
addComputerPlayer() is called. (See above.)

   In the code following the switch statement, if computer is not null,
then we call computer.makeAMove(). As we know, the makeAMove()
method is part of the IPlayer interface. The makeAMove() method
takes a String parameter that is meant to serve as a prompt, and returns
a String that is meant to represent the IPlayer's move:

                                                                           

  public interface IPlayer {

   public S t r i n g makeAMove( S t r i n g prompt ) ;

}

                                                                           

In OneRowNim the "move" is an integer, representing the number of sticks   Encapsulation of game-dependent
the player picks. Therefore, in play() OneRowNim has to convert the        knowledge
String into an int, which represents the number of sticks the IPlayer
picks up.                                                                  Polymorphism

   On the other hand, if computer is null, this means that it is a human
user's turn to play. In this case, play() calls ui.getUserInput(), em-
ploying the user interface to input a value from the keyboard. The user's
input must also be converted from String to int. Once the value of
sticks is set, either from the user or from the IPlayer, the play()
method calls takeSticks(). If the move is legal, then it changes whose
turn it is, and the loop repeats.

   There are a couple of important points to notice about the design of
the play() method. First, the play() method has to know what to do
with the input it receives from the user or the IPlayer. This is game-
dependent knowledge. The user is inputting the number of sticks to
take in OneRowNim. For a tic-tac-toe game, the "move" might repre-
sent a square on the tic-tac-toe board. This suggests that play() is a
method that should be implemented in OneRowNim, as it is here, because
OneRowNim encapsulates the knowledge of how to play the One Row
Nim game.

   A second point is to notice that the method call computer.make-
AMove() is another example of polymorphism at work. The play()
method does not know what type of object the computer is, other than
that it is an IPlayer--that is, an object that implements the IPlayer
interface. As we will show in the next section, the OneRowNim game can
be played by two different IPlayers: one named NimPlayer and an-
other named NimPlayerBad. Each has its own game-playing strategy, as
implemented by their own versions of the makeAMove() method. Java
uses dynamic binding to decide which version of makeAMove() to in-
voke depending on the type of IPlayer whose turn it is. Thus, by defin-
ing different IPlayers with different makeAMove() methods, this use of
                            376  CHAPTER 8  Inheritance and Polymorphism

                            polymorphism makes it possible to test different game-playing strategies
                            against each other.

                            8.6.7 The IPlayer Interface

Figure 8.23: Design of the  The last element of our design is the IPlayer interface, which, as we
NimPlayerBad class.         just saw, consists of the makeAMove() method. To see how we use this
                            interface, let's design a class to play the game of OneRowNim. We will call
                            the class NimPlayerBad and give it a very weak playing strategy. For
                            each move it will pick a random number between 1 and 3, or between 1
                            and the total number of sticks left, if there are fewer than 3 sticks. (We will
                            leave the task of defining NimPlayer, a good player, as an exercise.)

                               As an implementer of the IPlayer interface, NimPlayerBad will
                            implement the makeAMove() method. This method will contain
                            NimPlayerBad's strategy (algorithm) for playing the game. The result
                            of this strategy will be the number of sticks that the player will pick up.

                               What other elements (variables and methods) will a NimPlayerBad
                            need? Clearly, in order to play OneRowNim, the player must know the
                            rules and the current state of the game. The best way to achieve this is to
                            give the Nim player a reference to the OneRowNim game. Then it can call
                            getSticks() to determine how many sticks are left, and it can use other
                            public elements of the OneRowNim game. Thus, we will have a variable of
                            type OneRowNim, and we will assign it a value in a constructor method.

                               Figure 8.23 shows the design of NimPlayerBad. Note that we have
                            added an implementation of the toString() method. This will be used
                            to give a string representation of the NimPlayerBad. Also, note that we
                            have added a private helper method named randomMove(), which will
                            simply generate an appropriate random number of sticks as the player's
                            move.

                                                                                                                                 

                              public class NimPlayerBad implements IPlayer {                                  NimPlayerBad '
                                  p r i v a t e OneRowNim game ;                                              word ' c l a s s '
                                 public NimPlayerBad (OneRowNim game ) {
                                     t h i s . game = game ;                                                                     
                                 } // NimPlayerBad ( )
                                 public S t r i n g makeAMove( S t r i n g prompt ) {
                                     r e t u r n "" + randomMove ( ) ;
                                 } // makeAMove ( )
                                  p r i v a t e i n t randomMove ( ) {
                                     i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;
                                     r et ur n 1 + ( i n t ) ( Math . random ( ) 
                                                  Math . min ( s t i c k s L e f t , game . MAX PICKUP ) ) ;
                                 } // randomMove ( )
                                 public String toString () {
                                     String className =
                                            this . getClass ( ) . toString ( ) ; // Gets ' c l a s s
                                     return className . substring ( 5 ) ; // Cut o f f t h e
                                 } // t o S t r i n g ( )

                              } // NimPlayerBad
                            

                                 Figure 8.24: The NimPlayerBad class.
SECTION 8.6  Case Study: A Two Player Game Hierarchy                              377

   The implementation of NimPlayerBad is shown in Figure 8.24. The
makeAMove() method converts the randomMove() to a String and
returns it, leaving it up to OneRowNim, the calling object, to convert
that move back into an int. Recall the statement in OneRowNim where
makeAMove() is invoked:

                                                                                        

  s t i c k s = I n t e g e r . p a r s e I n t ( computer . makeAMove ( "" ) ) ;       

In this context, the computer variable, which is of type IPlayer, is
bound to a NimPlayerBad object. In order for this interaction between
the game and a player to work, the OneRowNim object must know what
type of data is being returned by NimPlayerBad. This is a perfect use for
a Java interface, which specifies the signature of makeAMove() without
committing to any particular implementation of the method. Thus, the
association between OneRowNim and IPlayer provides a flexible and
effective model for this type of interaction.

JAVA EFFECTIVE DESIGN Interface Associations. Java interfaces
provide a flexible way to set up associations between two different
types of objects.

   Finally, note the details of the randomMove() and toString() meth-
ods. The only new thing here is the use of the getClass() method in
toString(). This is a method that is defined in the Object class and
inherited by all Java objects. It returns a String of the form "class X"
where X is the name of that object's class. Note here that we are removing
the word "class" from this string before returning the class name. This
allows our IPlayer objects to report what type of players they are, as in
the following statement from OneRowNim:

                                                                                        

ui . report ( "\nPlayer 1 is a " + computer1 . toString ( ) ) ;                         


If computer1 is a NimPlayerBad, it would report "Player1 is a Nim-
PlayerBad."
            378                        CHAPTER 8  Inheritance and Polymorphism

            SELF-STUDY EXERCISES

            EXERCISE 8.13 Define a class NimPlayer that plays the optimal strat-
            egy for OneRowNim. This strategy was described in Chapter 5.

            8.6.8 Playing OneRowNim

            Let's now write a main() method to play OneRowNim:

                                                                                              

            public s t a t i c void main ( S t r i n g args [ ] ) {                 2? " ) ;
               KeyboardReader kb = new KeyboardReader ( ) ;                         ? ");
               OneRowNim game = new OneRowNim ( ) ;
               kb . prompt ( "How many computers a r e playing , 0 , 1 , or
               i n t m = kb . getKeyboardInteger ( ) ;
               for ( int k = 0 ; k < m; k++) {
                   kb . prompt ( "What type o f player , " +
                                            "NimPlayerBad = 1 , or NimPlayer = 2
                   i nt choice = kb . getKeyboardInteger ( ) ;
                   i f ( c h o i c e == 1 ) {
                       I P l a y e r computer = new NimPlayerBad ( game ) ;
                      game . addComputerPlayer ( computer ) ;
                   } else {
                       I P l a y e r computer = new NimPlayer ( game ) ;
                      game . addComputerPlayer ( computer ) ;
                   }

                 }

                 game . play ( kb ) ;

                 } // main ( )

                                                                                              

Generality  After creating a KeyboardReader and then creating an instance of
            OneRowNim, we prompt the user to determine how many computers are
            playing. We then repeatedly prompt the user to identify the names of the
            IPlayer and use the addComputerPlayer() method to initialize the
            game. Finally, we get the game started by invoking the play() method,
            passing it a reference to the KeyboardReader, our UserInterface.

               Note that in this example we have declared a OneRowNim variable to
            represent the game. This is not the only way to do things. For example,
            suppose we wanted to write a main() method that could be used to play
            a variety of different TwoPlayerGames. Can we make this code more
            general? That is, can we rewrite it to work with any TwoPlayerGame?

               A OneRowNim object is also a TwoPlayerGame, by virtue of inheri-
            tance, and it is also a CLUIPlayableGame, by virtue of implementing
            that interface. Therefore, we can use either of these types to represent the
            game. Thus, one alternative way of coding this is as follows:

                                                                                          

                    TwoPlayerGame game = new OneRowNim ( ) ;

                    ...

                    I P l a y e r computer = new NimPlayer ( ( OneRowNim) game ) ;

                    ...

                    ( ( CLUIPlayableGame ) game ) . play ( kb ) ;                         

            Here we use a TwoPlayerGame variable to represent the game. However,
            note that we now have to use a cast expression, (CLUIPlayableGame),
SECTION 8.6  Case Study: A Two Player Game Hierarchy             379

in order to call the play() method. If we don't cast game in this way,
Java will generate the following syntax error:

                                                                          

OneRowNim . j a v a : 1 2 6 : cannot r e s o l v e symbol

symbol : method play ( KeyboardReader )

  l o c a t i o n : c l a s s TwoPlayerGame

       game . play ( kb ) ;

       ^                                                                  

The reason for this error is that play() is not a method in the
TwoPlayerGame class, so the compiler cannot find the play() method.
By using the cast expression, we are telling the compiler to consider
game to be a CLUIPlayableGame. That way it will find the play()
method. Of course, the object assigned to nim must actually implement
the CLUIPlayableGame interface in order for this to work at run time.
We also need a cast operation in the NimPlayer() constructor in or-
der to make the argument (computer) compatible with that method's
parameter.

   Another alternative for the main() method would be the following:

                                                                          

CLUIPlayableGame game = new OneRowNim ( ) ;

  ...

  I P l a y e r computer = new NimPlayer ( ( OneRowNim) game ) ;

  ( ( TwoPlayerGame ) game ) . addComputerPlayer ( computer ) ;

  ...

game . play ( kb ) ;

  nim . play ( kb ) ;                                                     

By representing the game as a CLUIPlayableGame variable, we don't
need the cast expression to call play(), but we do need a different cast
expression, (TwoPlayerGame), to invoke addComputerPlayer().
Again, the reason is that the compiler cannot find the addComputer-
Player() method in the CLUIPlayableGame interface, so we must tell
it to consider game as a TwoPlayerGame, which of course it is. We still
need the cast operation for the call to the NimPlayer() constructor.

   All three of the code options that we have considered will generate
something like the interactive session shown in Figure 8.25 for a game
in which two IPlayers play each other.

   Given our object-oriented design for the TwoPlayerGame hierarchy,
we can now write generalized code that can play any TwoPlayerGame
that implements the CLUIPlayableGame interface. We will give a spe-
cific example of this in the next section.

8.6.9 Extending the TwoPlayerGame Hierarchy

Now that we have described the design and the details of the
TwoPlayerGame class hierarchy, let's use it to develop a new game. If
we've gotten the design right, developing new two-player games and
adding them to the hierarchy should be much simpler than developing
them from scratch.

   The new game is a guessing game in which the two players take turns
guessing a secret word. The secret word will be generated randomly from
  380     CHAPTER 8  Inheritance and Polymorphism

                                                                            

How many computers a r e playing , 0 , 1 , or 2? {\ c o l o r { cyan }2}

 The Rules o f One Row Nim 
( 1 ) A number of s t i c k s between 7 and 11 i s chosen .
( 2 ) Two p l a y e r s a l t e r n a t e making moves .
( 3 ) A move c o n s i s t s o f s u b t r a c t i n g between 1 and

              3 s t i c k s from the c u r r e n t number of s t i c k s .
( 4 ) A p l a y e r who cannot l e a v e a p o s i t i v e

                number of s t i c k s f o r the other player l o s e s .

  Player  1 i s a NimPlayerBad
  Player  2 i s a NimPlayer
  Sticks  l e f t : 11 Who ' s turn : P l a y e r 1 NimPlayerBad t a k e s 2 s t i c k s .
  Sticks  l e f t : 9 Who ' s turn : P l a y e r 2 NimPlayer t a k e s 1 s t i c k s .
  Sticks  l e f t : 8 Who ' s turn : P l a y e r 1 NimPlayerBad t a k e s 2 s t i c k s .
  Sticks  l e f t : 6 Who ' s turn : P l a y e r 2 NimPlayer t a k e s 1 s t i c k s .
  Sticks  l e f t : 5 Who ' s turn : P l a y e r 1 NimPlayerBad t a k e s 3 s t i c k s .
  Sticks  l e f t : 2 Who ' s turn : P l a y e r 2 NimPlayer t a k e s 1 s t i c k s .
  Sticks  l e f t : 1 Who ' s turn : P l a y e r 1 NimPlayerBad t a k e s 1 s t i c k s .
  Sticks  l e f t : 0 Game over ! Winner i s P l a y e r 2 Nice game .

                                                                                                       

  Figure 8.25: A typical run of the OneRowNim using a command-line user
  interface.

  a collection of words maintained by the game object. The letters of the
  word will be hidden with question marks, as in "????????." On each turn
  a player guesses a letter. If the letter is in the secret word, it replaces one
  or more question marks, as in "??????E?." A player continues to guess
  until an incorrect guess is made and then it becomes the other player's
  turn. Of course, we want to develop a version of this game that can be
  played either by two humans, or by one human against a computer--that
  is, against an IPlayer--or by two different IPlayers.

     Let's call the game class WordGuess. Following the design
  of OneRowNim, we get the design shown in Figure 8.26. The
  WordGuess class extends the TwoPlayerGame class and implements the
  CLUIPlayableGame interface. We don't show the details of the inter-
  faces and the TwoPlayerGame class, as these have not changed. Also,
  following the design of NimPlayerBad, the WordGuesser class imple-
  ments the IPlayer interface. Note how we show the association between
  WordGuess and zero or more IPlayers. A WordGuess uses between
  zero and two instances of IPlayers, which in this game are implemented
  as WordGuessers.

     Let's turn now to the details of the WordGuess class, whose source
  code is shown in Figures 8.27 and 8.28. The game needs to have a supply
  of words from which it can choose a secret word to present to the players.
  The getSecretWord() method will take care of this task. It calculates
  a random number and then uses that number, together with a switch
  statement, to select from among several words that are coded right into
  the switch statement. The secret word is stored in the secretWord vari-
  able. The currentWord variable stores the partially guessed word. Ini-
  tially, currentWord consists entirely of question marks. As the players
SECTION 8.6  Case Study: A Two Player Game Hierarchy  381
                                                               Figure 8.26: Design of the
                                                               WordGuess class as part of
                                                               TwoPlayerGame hierarchy.

make correct guesses, currentWord is updated to show the locations of
the guessed letters. Because currentWord will change as the game pro-
gresses, it is stored in a StringBuffer, rather than in a String. Recall
that Strings are immutable in Java, whereas a StringBuffer contains
methods to insert letters and remove letters.

   The unguessedLetters variable stores the number of letters remain-
ing to be guessed. When unguessedLetters equals 0, the game is over.
This condition defines the gameOver() method, which is inherited from
TwoPlayerGame. The winner of the game is the player who guessed the
last letter in the secret word. This condition defines the getWinner()
method, which is also inherited from TwoPlayerGame. The other meth-
ods that are inherited from TwoPlayerGame or implemented from the
CLUIPlayableGame are also implemented in a straightforward manner.

   A move in the WordGuess game consists of trying to guess a let-
ter that occurs in the secret word. The move() method processes the
player's guesses. It passes the guessed letter to the guessLetter()
method, which checks whether the letter is a new, secret letter. If so,
guessLetter() takes care of the various housekeeping tasks. It adds the
letter to previousGuesses, which keeps track of all the players' guesses.
It decrements the number of unguessedLetters, which will become 0
when all the letters have been guessed. And it updates currentWord
to show where all occurrences of the secret letter are located. Note how
382                            CHAPTER 8  Inheritance and Polymorphism

                                                                                                

public c l a s s WordGuess extends TwoPlayerGame implements CLUIPlayableGame {
       private String secretWord ;
       private StringBuffer currentWord ;
       private StringBuffer previousGuesses ;
       private int unguessedLetters ;

     public WordGuess ( ) {
            secretWord = getSecretWord ( ) ;
            currentWord = new S t r i n g B u f f e r ( secretWord ) ;
            previousGuesses = new S t r i n g B u f f e r ( ) ;
            for ( int k = 0; k < secretWord . length ( ) ; k++)
                 currentWord . setCharAt (k , ' ? ' ) ;
            unguessedLetters = secretWord . length ( ) ;

     } // WordGuess ( )
     public String getPreviousGuesses () {

            return previousGuesses . toString ( ) ;
     } // g e t P r e v i o u s G u e s s e s ( )
     public String getCurrentWord ( ) {

            return currentWord . toString ( ) ;
     } // getCurrentWord ( )
     private String getSecretWord () {

            i n t num = ( i n t ) ( Math . random ( )  1 0 ) ;
            switch (num)
            { c a s e 0 : r e t u r n "SOFTWARE" ;

                   c a s e 1 : r e t u r n "SOLUTION" ;
                   c a s e 2 : r e t u r n "CONSTANT" ;
                   c a s e 3 : r e t u r n "COMPILER" ;
                   c a s e 4 : r e t u r n "ABSTRACT" ;
                   c a s e 5 : r e t u r n "ABNORMAL" ;
                   c a s e 6 : r e t u r n "ARGUMENT" ;
                   c a s e 7 : r e t u r n "QUESTION" ;
                   case 8 : return "UTILIZES" ;
                   c a s e 9 : r e t u r n "VARIABLE" ;
                   d e f a u l t : r e t u r n "MISTAKES" ;
            } //s w i tc h
     } // getSecretWord ( )
     private boolean guessLetter ( char l e t t e r ) {
          previousGuesses . append ( l e t t e r ) ;
          i f ( secretWord . indexOf ( l e t t e r ) == -1)
                   r e t u r n f a l s e ; // l e t t e r i s not i n secretWord
            e l s e // f i n d p o s i t i o n s o f l e t t e r i n secretWord
            { for ( int k = 0; k < secretWord . length ( ) ; k++)
                   { i f ( secretWord . charAt ( k ) == l e t t e r )

                          { i f ( currentWord . charAt ( k ) == l e t t e r )
                                         r e t u r n f a l s e ; //// a l r e a d y guessed

                                  currentWord . setCharAt (k , l e t t e r ) ;
                                  u n g u e s s e d L et t e r s --; //one l e s s t o f i n d
                          } // i f
                   } // f o r
                   return true ;
            } // e l s e
     } // g u e s s L e t t e r ( )

     public String getRules () {  // Overridden from TwoPlayerGame

     r e t u r n "\n The Rules o f Word Guess \n" +

     " ( 1 ) The game g e n e r a t e s a s e c r e t word . \ n" +

     " ( 2 ) Two p l a y e r s a l t e r n a t e t a k i n g moves . \ n" +

     " ( 3 ) A move c o n s i s t s o f guessing a l e t t e r i n t h e word . \ n" +

     " ( 4 ) A player continues guessing u n t i l a l e t t e r i s wrong . \ n" +

     " ( 5 ) The game i s over when a l l l e t t e r s o f t h e word a r e guessed\n" +

     " ( 6 ) The p l a y e r guessing the l a s t l e t t e r o f the word wins . \ n" ;

     } // g e t R u l e s ( )                                                                   

     Figure 8.27: The WordGuess class, Part I.

guessLetter() uses a for-loop to cycle through the letters in the secret
word. As it does so, it replaces the question marks in currentWord with
the correctly guessed secret letter. The guessLetter() method returns
false if the guess is incorrect. In that case, the move() method changes the
SECTION 8.6  Case Study: A Two Player Game Hierarchy                                        383

                                                                                                            

  public boolean gameOver ( ) { // From TwoPlayerGame
         r e t u r n ( u n g u e s s e d L e t t e r s <= 0 ) ;

  } // gameOver ( )
  public S t r i n g getWinner ( ) { // From TwoPlayerGame

         i f ( gameOver ( ) )
                return "Player " + getPlayer ( ) ;

         e l s e r e t u r n "The game i s not over . " ;
  } // getWinner ( )
  public String reportGameState () {

         i f ( ! gameOver ( ) )
                r e t u r n "\nCurrent word " + currentWord . t o S t r i n g ( ) + " Previous gu ess es "
                       + previousGuesses + "\nPlayer " + getPlayer ( ) + " guesses next . " ;

         else
                r e t u r n "\nThe game i s now over ! The s e c r e t word i s " + secretWord
                    + "\n" + getWinner ( ) + " has won! \ n" ;

  } // reportGameState ( )
  public S t r i n g getGamePrompt ( ) { // From CLUIPlayableGame

         r e t u r n "\nGuess a l e t t e r t h a t you t h i n k i s i n t h e s e c r e t word : " ;
  } // getGamePrompt ( )
  public S t r i n g move ( S t r i n g s ) {

         char l e t t e r = s . toUpperCase ( ) . charAt ( 0 ) ;
         i f ( g u e s s L e t t e r ( l e t t e r ) ) { // i f c o r r e c t

                return "Yes , the l e t t e r " + l e t t e r +
                             " I S i n t h e s e c r e t word\n" ;

           } else {
                  changePlayer ( ) ;
                  r e t u r n " Sorry , " + l e t t e r + " i s NOT a " +
                               "new l e t t e r i n t h e s e c r e t word\n" ;

           }

  } // move ( )
  public void play ( U s e r I n t e r f a c e u i ) { // From CLUIPlayableGame

         ui . report ( getRules ( ) ) ;
         if ( computer1 != null )

                ui . report ( "\nPlayer 1 i s a " + computer1 . toString ( ) ) ;
         if ( computer2 != null )

                ui . report ( "\nPlayer 2 i s a " + computer2 . toString ( ) ) ;

  while ( ! gameOver ( ) ) {

  IPlayer computer = null ;                          // Assume no computers         playing

  ui . report ( reportGameState ( ) ) ;

  switch ( getPlayer ( ) ) {

  c a s e PLAYER ONE :                   // P l a y e r 1 ' s turn

                computer = computer1 ;

                break ;

  c a s e PLAYER TWO :                   // P l a y e r 2 ' s turn

                computer = computer2 ;

                break ;

  } // c a s e s

  i f ( computer != null ) {             // I f computer ' s turn

                u i . r e p o r t ( move ( computer . makeAMove ( " " ) ) ) ;

  } else {                               // otherwise , u s er ' s turn

                ui . prompt ( getGamePrompt ( ) ) ;

                u i . r e p o r t ( move ( u i . g e t U s e r I n p u t ( ) ) ) ;

  }

  } // while

  u i . r e p o r t ( reportGameState ( ) ) ; // The game i s now over

  } //play ( )

} //WordGuess c l a s s                                                                                     


                Figure 8.28: The WordGuess class, continued.

player's turn. When correct guesses are made, the current player keeps                            Reusing code
the turn.

   The WordGuess game is a good example of a string-processing prob-
lem. It makes use of several of the String and StringBuffer meth-
ods that we learned in Chapter 7. The implementation of WordGuess, as
an extension of TwoPlayerGame, is quite straight forward. One advan-
384               CHAPTER 8  Inheritance and Polymorphism

                                                                                           

public class WordGuesser implements IPlayer {
   p r i v a t e WordGuess game ;
   public WordGuesser ( WordGuess game ) {
       t h i s . game = game ;
   }

  public S t r i n g makeAMove( S t r i n g prompt ) {
     S t r i n g u s e d L e t t e r s = game . g e t P r e v i o u s G u e s s e s ( ) ;
     char letter ;
     do { // P i c k o n e o f 2 6 l e t t e r s
         l e t t e r = ( char ) ( 'A ' + ( i n t ) ( Math . random ( )  2 6 ) ) ;
     } while ( usedLetters . indexOf ( l e t t e r ) != -1);
     return "" + letter ;

  }

  public String toString ( ) { // r e t u r n s ' NimPlayerBad '
     String className = this . getClass ( ) . toString ( ) ;
     return className . substring ( 5 ) ;

  }

} // WordGuesser

                                                                                           

     Figure 8.29: The WordGuesser class.

tage of the TwoPlayerGame class hierarchy is that it decides many of the
important design issues in advance. Developing a new game is largely
a matter of implementing methods whose definitions have already been
determined in the superclass or in the interfaces. This greatly simplifies
the development process.

   Let's now discuss the details of WordGuesser class (Fig. 8.29).
Note that the constructor takes a WordGuess parameter. This allows
WordGuesser to be passed a reference to the game, which accesses
the game's public methods, such as getPreviousGuesses(). The
toString() method is identical to the toString() method in the
NimPlayerBad example. The makeAMove() method, which is part of
the IPlayer interface, is responsible for specifying the algorithm that the
player uses to make a move. The strategy in this case is to repeatedly pick
a random letter from A to Z until a letter is found that is not contained in
previousGuesses. That way, the player will not guess letters that have
already been guessed.

8.7 Principles Of Object-Oriented Design

To conclude this chapter, it will be helpful to focus briefly on how the
examples we've seen address the various object-oriented design (OOD)
principles we set out at the beginning of the book.

     Divide-and-Conquer Principle. Notice how all of the problems
       tackled in this chapter have been solved by dividing them into sev-
       eral classes, with each of the classes divided into separate methods.
       The very idea of a class hierarchy is an application of this principle.

     Encapsulation Principle. The superclasses in our designs, Cipher
       and TwoPlayerGame, encapsulate those features of the class hier-
SECTION 8.7  Principles Of Object-Oriented Design  385

archy that are shared by all objects in the hierarchy. The subclasses,
CaesarCipher and OneRowNim, encapsulate features that make
them distinctive with the class hierarchy.

 Interface Principle. The several Java interfaces we've designed,
   IPlayer, CLUIPlayableGame and UserInterface, specify
   clearly how various types of related objects will interact with each
   other through the methods contained in the interfaces. Clean inter-
   faces make for clear communication among objects.

 Information Hiding Principle. We have continued to make con-
   sistent use of the private and public qualifiers, and have now
   introduced the protected qualifier to extend this concept. The in-
   heritance mechanism gives subclasses access to protected and public
   elements of their superclasses.

 Generality Principle. As you move down a well-designed class hi-
   erarchy, you go from the more general to the more specific features of
   the objects involved. The abstract encode() method specifies the gen-
   eral form that encoding will take while the various implementations
   of this method in the subclasses provide the specializations neces-
   sary to distinguish, say, Caesar encoding from Transpose encoding.
   Similarly, the abstract makeAMove() method in the IPlayer inter-
   face provides a general format for a move in a two-player game,
   while its various implementations provide the specializations that
   distinguish one game from another.

 Extensibility Principle. Overriding inherited methods and imple-
   menting abstract methods from either an abstract superclass or a
   Java interface provide several well-designed ways to extend the
   functionality in an existing class hierarchy. Extending a class is a
   form of specialization of the features inherited from the superclass.

     Abstraction Principle. Designing a class hierarchy is an exercise in
       abstraction, as the more general features of the objects involved are
       moved into the superclasses. Similarly, designing a Java interface or
       an abstract superclass method is a form of abstraction, whereby the
       signature of the method is distinguished from its various implemen-
       tations.

   These, then, are some of the ways that the several examples we have
considered and this chapter's discussion have contributed to a deepening
of our understanding of object-oriented design.
                      386                   CHAPTER 8  Inheritance and Polymorphism

CHAPTER SUMMARY       Technical Terms

                      abstract method       dynamic binding     static binding (early
                                                                   binding)
                      actual type (dynamic  (late binding)
                                                                static type (declared
                        type)               interface              type)

                      ciphertext            overloaded method   substitution cipher
                                                                transposition cipher
                      class inheritance     plaintext

                      cryptography          polymorphic method

                                            polymorphism

                      Summary of Important Points

                       Inheritance is an object-oriented mechanism whereby subclasses in-
                        herit the public and protected instance variables and methods from
                        their superclasses.

                       Dynamic binding (or late binding) is the mechanism by which a
                        method call is bound to (associated with) the correct implementation
                        of the method at run time. In Java, all method calls, except for final
                        or private methods, are resolved using dynamic binding.

                       Static binding (or early binding) is the association of a method call with
                        its corresponding implementation at compile time.

                       Polymorphism is an object-oriented language feature in which a
                        method call can lead to different actions depending on the object on
                        which it is invoked. A polymorphic method is a method signature
                        that is given different implementation by different classes in a class
                        hierarchy.

                       A static type is a variable's declared type. A dynamic type, or actual
                        type, is the type of object assigned to that variable at a given point in a
                        running program.

                       An abstract method is a method definition that lacks an implemen-
                        tation. An abstract class is one that contains one or more abstract
                        methods. An abstract class can be subclassed but not instantiated.

                       A Java interface is a class that contains only method signatures and
                        (possibly) constant declarations, but no variables. An interface can
                        be implemented by a class by providing implementations for all of its
                        abstract methods.

SOLUTIONS TO          SOLUTION 8.1 Running the TestPrint program will produce the output
SELF-STUDY EXERCISES  shown here. It is clear that the inherited toString() method is used by
                      println() when printing a TestPrint object.

                                                                                       

                        56.0

                        TestPrint@be2d65                                               

                      SOLUTION 8.2 If you override the toString() method in TestPrint, you
                      should get something like the output shown here, depending on how you code
CHAPTER 8  Solutions to Self-Study Exercises                             387

toString(). It is clear that the toString() method is used polymorphously
by println().

                                                                          

   56.0

   Hello from TestPrint                                                   

SOLUTION 8.3 The output produced when constructing objects of type A and B
in the order shown in the exercise would be as follows, with each letter occurring
on a separate line:

                                                                          

AB B                                                                      


SOLUTION 8.4 The new implementation of B's method() will invoke A's ver-
sion of the method before printing B. This will print "A A B A B".

                                                                          

   void method ( ) {

         super . method ( ) ;

         System . out . println ( "B" ) ;

   }

                                                                          

SOLUTION 8.5 Give the definitions of classes A and B in the exercise,     the
marked statements would be invalid:                                        

                                                                           

 A a = new B ( ) ;    // V a l i d a B i s an A          necessarily  aB
  a = new A ( ) ;     // Ok
  B b = new A ( ) ;   // I n v a l i d . An A i s n o t
  b = new B ( ) ;     // OK


SOLUTION 8.6 Given the class definitions and code segment in this exercise, the
output would be, A A B A B C, with each letter printing on a separate line.

SOLUTION 8.7 Definition of an Pig subclass of Animal:

                                                                          

   public c l a s s Pig extends Animal {
        public Pig () {
               kind = "pig" ;
        }

      public String speak ( ) {
             return "oink" ;

      }

}

                                                                          
388                       CHAPTER 8  Inheritance and Polymorphism

SOLUTION 8.8 If polymorphism was not used in our design, the talk()
method would have to be modified to the following in order to accommodate a
Pig subclass:

                                                                                 

public String t a l k ( Animal a ) {

   i f ( a i n s t a n c e o f Cow)

     r e t u r n " I am a " + kind + " and I go " + a . moo ( ) ;

     else if ( a instanceof Cat )

     r e t u r n " I am a " + kind + " and I go " + a . meow ( ) ;

     else if (a instanceof Pig )

     r e t u r n " I am a " + kind + " and I go " + a . oink ( ) ;

     else

     r e t u r n " I don ' t know what I am" ;

}

                                                                                 

SOLUTION 8.9 Code to swap two boolean variables:

                                                                                 

   boolean temp = b1 ; // S a v e b 1 ' s v a l u e

   b1 = b2 ;              // Change b1 t o b2

   b2 = temp ;            // Change b2 t o b1 ' s o r i g i n a l v a l u e

                                                                                         

SOLUTION 8.10 Creating a ToggleButton that can be used to deal or collect
cards:

                                                                                 

   private ToggleButton dealer =

                new ToggleButton ( " d e a l " , " c o l l e c t " ) ;

   add ( d e a l e r ) ;

   dealer . addActionListener ( this );                                          

SOLUTION 8.11 Modify the Caesar class so that it will allow various-sized
shifts to be used.

                                                                                 

private int shift ;

public void set Shif t ( int n) { s h i f t = n ;    }

public int getShift ()                       { return shift ; }

// M o d i f i c a t i o n t o e n c o d e ( ) :

ch = ( char ) ( ' a ' + ( ch - ' a '+ s h i f t ) % 2 6 ) ; // S h i f t

// M o d i f i c a t i o n t o decode ( ) :

ch = ( char ) ( ' a ' + ( ch - ' a '+ (26- s h i f t ) ) % 2 6 ) ; // S h i f t  


SOLUTION 8.12 Modify Transpose.encode() so that it uses a rotation in-
stead of a reversal. The operation here is very similar to the shift operation in
the Caesar cipher. It uses modular arithmetic to rearrange the letters in the word.
For example, suppose the word is "hello". Its letters are indexed from 0 to 4. The
CHAPTER 8  Exercises                                                          389

following table shows how the expression ((k+2) % 5) will rearrange the letters
as k varies from 0 to 4:

                                                                                      

      k charAt (k) (k+2) % 5 charAt (( k+2) % 5)
      -------------------------------------------

      0 'h '                   2                  'l '

      1 'e '                   3                  'l '

      2 'l '                   4                  'o '

      3 'l '                   0                  'h '

      4 'o '                   1                  'e '

// M o d i f i c a t i o n t o e n c o d e ( ) :

public S t r i n g encode ( S t r i n g word ) {

      S t r i n g B u f f e r r e s u l t = new S t r i n g B u f f e r ( ) ;

      f o r ( i n t k = 0 ; k < word . l e n g t h ( ) ; k++)

       r e s u l t . append ( word . charAt ( ( k +2) % word . l e n g t h ( ) ) ) ;

      return result . toString ( ) ;

}

                                                                                      

SOLUTION 8.13 A NimPlayer class that plays the optimal OneRowNim game
would be identical to the NimPlayerBad class except the move():int method
would be replaced with the following implementation:

                                                                                      

   public i n t move ( ) {
        i n t s t i c k s L e f t = game . g e t S t i c k s ( ) ;
        i f ( s t i c k s L e f t % ( game . MAX PICKUP + 1 ) ! = 1 )
               r e t u r n ( s t i c k s L e f t - 1 ) % ( game . MAX PICKUP + 1 ) ;
        else {
               i n t maxPickup = Math . min ( game . MAX PICKUP, s t i c k s L e f t ) ;
                 r et ur n 1 + ( i n t ) ( Math . random ( )  maxPickup ) ;
        }

   }

                                                                                      

EXERCISE 8.1 Fill in the blanks in each of the following sentences:                         EXERCISES

a. A method that lacks a body is an                     method.                             Note: For programming exercises,
                                                                                            first draw a UML class diagram
b. An         is like a class except that it contains only instance methods, no             describing all classes and their
                                                                                            inheritance relationships and/or
      instance variables.                                                                   associations.

c. Two ways for a class to inherit something in Java is to                     a class and

              an interface.

d. Instance variables and instance methods that are declared                          or

              are inherited by the subclasses.

e. An object can refer to itself by using the           keyword.

f. If a GUI class intends to handle ActionEvents, it must implement the

              interface.

g. A          method is one that does different things depending upon the

      object that invokes it.

EXERCISE 8.2 Explain the difference between the following pairs of concepts:
390  CHAPTER 8  Inheritance and Polymorphism

a. Class and interface.
b. Stub method and abstract method.
c. Extending a class and instantiating an object.
d. Defining a method and implementing a method.
e. A protected method and a public method.
f. A protected method and a private method.

EXERCISE 8.3 Draw a hierarchy to represent the following situation. There are
lots of languages in the world. English, French, Chinese, and Korean are exam-
ples of natural languages. Java, C, and C++ are examples of formal languages.
French and Italian are considered romance languages, while Greek and Latin are
considered classical languages.

EXERCISE 8.4 Look up the documentation for the JButton class on Sun's Web
site:

                                                                     

h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/a p i/  


List the names of all the methods that would be inherited by the ToggleButton
subclass that we defined in this chapter.

EXERCISE 8.5 Design and write a toString() method for the ToggleButton
class defined in this chapter. The toString() method should return the
ToggleButton's current label.

EXERCISE 8.6 Design a class hierarchy rooted in the class Employee that in-
cludes subclasses for HourlyEmployee and SalaryEmployee. The attributes
shared in common by these classes include the name, and job title of the employee,
plus the accessor and mutator methods needed by those attributes. The salaried
employees need an attribute for weekly salary, and the corresponding methods for
accessing and changing this variable. The hourly employees should have a pay
rate and an hours worked variable. There should be an abstract method called
calculateWeeklyPay(), defined abstractly in the superclass and implemented
in the subclasses. The salaried worker's pay is just the weekly salary. Pay for an
hourly employee is simply hours worked times pay rate.

EXERCISE 8.7 Design and write a subclass of JTextField called Integer-
Field that is used for inputting integers but behaves in all other respects like a
JTextField. Give the subclass a public method called getInteger().

EXERCISE 8.8 Implement a method that uses the following variation of the Cae-
sar cipher. The method should take two parameters, a String and an int N. The
result should be a String in which the first letter is shifted by N, the second by
N + 1, the third by N + 2, and so on. For example, given the string "Hello," and an
initial shift of 1, your method should return "Igopt."
Write a method that converts its String parameter so that letters are written in
blocks five characters long.

EXERCISE 8.9 Design and implement an GUI that lets the user type a document
into a TextArea and then provides the following analysis of the document: the
number of words in the document, the number of characters in the document, and
the percentage of words that have more than six letters.

EXERCISE 8.10 Design and implement a Cipher subclass to implement the fol-
lowing substitution cipher: Each letter in the alphabet is replaced with a letter from
the opposite end of the alphabet: a is replaced with z, b with y, and so forth.
CHAPTER 8  Exercises                         391

EXERCISE 8.11 One way to design a substitution alphabet for a cipher is to use a
keyword to construct the alphabet. For example, suppose the keyword is "zebra."
You place the keyword at the beginning of the alphabet, and then fill out the other
21 slots with remaining letters, giving the following alphabet:

                                              

Cipher alphabet : zebracdfghijklmnopqstuvwxy

Plain alphabet :  abcdefghijklmnopqrstuvwxyz  


Design and implement an Alphabet class for constructing these kinds of sub-
stitution alphabets. It should have a single public method that takes a keyword
String as an argument and returns an alphabet string. Note that an alphabet
cannot contain duplicate letters, so repeated letters in a keyword like "xylophone"
would have to be removed.

EXERCISE 8.12 Design and write a Cipher subclass for a substitution cipher
that uses an alphabet from the Alphabet class created in the previous exercise.

EXERCISE 8.13 Challenge: Find a partner and concoct your own encryption
scheme. Then work separately with one partner writing encode() and the other
writing decode(). Test to see that a message can be encoded and then decoded
to yield the original message.

EXERCISE 8.14 Design a TwoPlayerGame subclass called Multiplication-
Game. The rules of this game are that the game generates a random multiplication
problem using numbers between 1 and 10, and the players, taking turns, try to
provide the answer to the problem. The game ends when a wrong answer is given.
The winner is the player who did not give a wrong answer.

EXERCISE 8.15 Design a class called MultiplicationPlayer that plays the
multiplication game described in the previous exercise. This class should imple-
ment the IPlayer interface.

EXERCISE 8.16 Design a TwoPlayerGame subclass called RockPaperScis-
sors. The rules of this game are that each player, at the same time, picks either a
rock, a paper, or a scissors. For each round, the rock beats the scissors, the scissors
beats the paper, and the paper beats the rock. Ties are allowed. The game is won
in a best out of three fashion when one of the players wins two rounds.

EXERCISE 8.17 Design a class called RockPaperScissorsPlayer that plays
the the game described in the previous exercise. This class should implement the
IPlayer interface.
392  CHAPTER 8  Inheritance and Polymorphism
Chapter 9

Arrays and Array Processing

OBJECTIVES

After studying this chapter, you will
 Know how to use array data structures.
 Be able to solve problems that require collections of data.
 Know how to sort an array of data.
 Be familiar with sequential and binary search algorithms.
 Gain a better understanding of inheritance and polymorphism.

OUTLINE

9.1 Introduction
9.2 One-Dimensional Arrays
9.3 Simple Array Examples
9.4 Example: Counting Frequencies of Letters
9.5 Array Algorithms: Sorting
9.6 Array Algorithms: Searching
9.7 Two-Dimensional Arrays
9.8 Multidimensional Arrays (Optional)
9.9 Object-Oriented Design: Polymorphic Sorting (Optional)
9.10 From the Java Library: java.util.Vector
9.11 Case Study: An N-Player Computer Game
9.12 A GUI-Based Game (Optional Graphics)

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              393
                          394                      CHAPTER 9  Arrays and Array Processing

                          9.1 Introduction

                          In this chapter we will learn about arrays. An array is a named collection
                          of contiguous storage locations--storage locations that are next to each
                          other--that contain data items of the same type.

                             Arrays offer a more streamlined way to store data than using individual
                          data items for each variable. Arrays also allow you to work with their data
                          more efficiently than with data stored in individual variables.

                             Let's see why. Suppose you want to create a GUI that has 26 buttons
                          on it, one for each letter of the alphabet. Given our present knowledge
                          of Java, our only alternative would be to declare a separate JButton
                          variable for each letter of the alphabet:

                                                                                                       

                               JButton button1 ;

                               JButton button2 ;

                               ...

                               JButton button26 ;                                                      

                          Obviously, requiring 26 separate variables for this problem is tedious and
                          inconvenient. Similarly, to instantiate and assign a label to each button
                          would require 26 statements:

                                                                                                       

                               button1 = new J B u t t o n ( "A" ) ;

                               button2 = new J B u t t o n ( "B" ) ;

                               ...

                               button26 = new J B u t t o n ( "Z" ) ;                                  

                          This approach is also tedious. What we need is some way to use a loop
                          to process each button, using a loop counter, k, to refer to the kth button
                          on each iteration of the loop. An array lets us do that. For example, the
                          following code will declare an array for storing 26 JButtons and then
                          instantiate and label each button:

                                                                                                       

                               J B u t t o n l e t t e r [ ] = new J B u t t o n [ 2 6 ] ;

                               for ( int k = 0; k < 26; k++)

                                    l e t t e r [ k ] = new J B u t t o n ( "A" + k ) ;                

                          You don't yet understand the code in this segment, but you can see how
                          economical it is. It uses just three lines of code to do what would have
                          required 50 or 60 lines of code without arrays.

                             Our discussion of arrays will show how to store and retrieve data from
                          one-, two-, and three-dimensional arrays. We also study sorting and
                          searching algorithms to process arrays. Finally, we illustrate how arrays
                          can be used in a variety of applications, including an animation problem,
                          a sorting class, and a card-playing program.

The array data structure  9.2 One-Dimensional Arrays

                          An array is considered a data structure. A data structure is an organized
                          collection of data. In an array, data are arranged in a linear or sequen-
SECTION 9.2  One-Dimensional Arrays              395

tial structure, with one element following another. When referencing ele-        Zero indexing
ments in an array, we refer to the position of the particular element within
the array. For example, if the array is named arr, then the elements are         Figure 9.1: An array of 15 integers
named arr[0], arr[1], arr[2], ... arr[n-1], where n gives                        named arr.
the number of elements in the array. This naming also reflects the fact that
the array's data are contained in storage locations that are next to each
other. In Java, as in C, C++, and some other programming languages, the
first element of an array has index 0. (This is the same convention we used
for Strings.)

Array name                            Subscripts

  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Contents

arr -2 8 -1 -3 16 20 25 16 16 8 18 19 45 21 -2

   Figure 9.1 shows an array named arr that contains 15 int elements.
The syntax for referring to elements of an array is

arrayname [ subscript ]

where arrayname is the name of the array--any valid identifier will do--         Subscript expressions
and subscript is the position of the element within the array. As Fig-
ure 9.1 shows, the first element in the array has subscript 0, the second
has subscript 1, and so on.

   A subscript is an integer quantity contained in square brackets that is
used to identify an array element. An subscript must be either an integer
value or an integer expression. Using Figure 9.1 to illustrate an example,
suppose that j and k are integer variables equaling 5 and 7, respectively.
Each of the following then would be valid references to elements of the
array arr:

                                                                                 

  arr [4]       // R e f e r s t o 16
  arr [ j ]
  arr [ j + k]  // I s a r r [ 5 ] which r e f e r s t o 20
  arr [k % j ]
                // I s a r r [ 5 + 7 ] which i s a r r [ 1 2 ] which r e f e r s t o 45

                // I s a r r [ 7 % 5 ] w h i c h i s a r r [ 2 ] w h i c h r e f e r s t o -1

                                                                                               

These examples show that when an expression, such as j + k, is used as
a subscript, it is evaluated (to 12 in this case) before the reference is made.

   It is a syntax error to use a noninteger type as an array subscript. Each
of the following expressions would be invalid:

                                                                                 

  arr [5.0]     // 5 . 0 i s a f l o a t and can ' t be an a r r a y s u b s c r i p t
  arr ["5"]
                // "5" i s a s t r i n g n o t an i n t e g e r

                                                                                                 

For a given array, a valid array subscript must be in the range 0 ... N-1,
where N is the number of elements in the array or it is considered out-of-
bounds. An out-of-bounds subscript creates a run-time error--that is, an
error that occurs when the program is running--rather than a syntax error,
                         396  CHAPTER 9  Arrays and Array Processing

                         which can be detected when the program is compiled. For the array arr,
                         each of the following expressions contain out-of-bounds subscripts:

                                                                                                        

                         arr [-1] // A r r a y s c a n n o t have n e g a t i v e s u b s c r i p t s

                         arr [ '5 ' ] // Char '5 ' promoted t o i t s Unicode value , 53

                         arr [15] // The l a s t e l e m e n t o f a r r has s u b s c r i p t 14

                         arr [ j k ] // S i n c e j  k e q u a l s 35                                   
                         

                         Each of these references would lead to an IndexOutOfBoundsException.
                         (Exceptions are covered in detail in Chapter 10.)

                         JAVA LANGUAGE RULE Array Subscripts. Array subscripts must
                         be integer values in the range 0...(N-1), where N is the number of
                         elements in the array.

Are arrays objects?       JAVA DEBUGGING TIP Array Subscripts. In developing array
Components and elements   algorithms, it's important to design test data that show that array
                          subscripts do not cause run-time errors.

                         9.2.1 Declaring and Creating Arrays

                         For the most part, arrays in Java are treated as objects. Like objects, they
                         are instantiated with the new operator and they have instance variables
                         (for example, length). Like variables for objects, array variables are con-
                         sidered reference variables. When arrays are used as parameters, a refer-
                         ence to the array is passed rather than a copy of the entire array. The
                         primary difference between arrays and full-fledged objects is that arrays
                         aren't defined in terms of an Array class. Thus, arrays don't fit into Java's
                         Object hierarchy. They don't inherit any properties from Object and
                         they cannot be subclassed.

                            You can think of an array as a container that contains a number of vari-
                         ables. As we've seen, the variables contained in an array object are not
                         referenced by name but by their relative position in the array. The vari-
                         ables are called components. If an array object has N components, then we
                         say that the array length is N. Each of the components of the array has the
                         same type, which is called the array's component type. An empty array is
                         one that contains zero variables.

                            A one-dimensional array has components that are called the array's
                         elements. Their type is the array's element type. An array's elements
                         may be of any type, including primitive and reference types. This means
                         you can have arrays of int, char, boolean, String, Object,
                         Image, TextField, TwoPlayerGame, and so on.

                            When declaring a one-dimensional array, you have to indicate both the
                         array's element type and its length. Just as in declaring and creating other
                         kinds of objects, creating an array object requires that we create both a
SECTION 9.2  One-Dimensional Arrays                                         397

name for the array and then the array itself. The following statements
create the array shown in Figure 9.1:

                                                                                  

int arr [];                   // D e c l a r e a name f o r t h e a r r a y

a r r = new i n t [ 1 5 ] ; // C r e a t e t h e a r r a y i t s e l f            


These two steps can be combined into a single statement as follows:

                                                                                  

i n t a r r [ ] = new i n t [ 1 5 ] ;
                                                                                  

In this example, the array's element type is int and its length is 15,
which is fixed and cannot be changed. This means that the array contains
15 variables of type int, which will be referred to as arr[0], arr[1],
...arr[14].

9.2.2 Array Allocation

Creating the array in Figure 9.1 means allocating 15 storage locations that       Allocating memory
can store integers. Note that one difference between declaring an array
and declaring some other kind of object is that square brackets ([]) are
used to declare an array type. The brackets can be attached either to the
array's name or to its type, as in the following examples:

                                                                                  

  int arr [];   // The b r a c k e t s may f o l l o w t h e a r r a y ' s name
  int [] arr ;
                // The b r a c k e t s may f o l l o w t h e a r r a y ' s t y p e

                                                                                       

The following example creates an array of five Strings and then uses
a for loop to assign the strings "hello1", "hello2", "hello3",
"hello4", and "hello5" to the five array locations:

                                                                                                                               

String strarr [];                      // D e c l a r e a name f o r t h e a r r a y
s t r a r r = new S t r i n g [ 5 ] ;             // C r e a t e t h e a r r a y i t s e l f

                                                                             // A s s i g n s t r i n g s t o t h e a r r a y

for ( int k = 0; k < s t r a r r . length ; k++)

// For e a c h e l e m e n t

  s t r a r r [ k ] = new S t r i n g ( " h e l l o " + ( k + 1 ) ) ; // A s s i g n a s t r i n g                             

Note that the expression k < strarr.length specifies the loop bound.              length vs. length()
Every array has a length instance variable, which refers to the number of
elements contained in the array. As we mentioned, arrays, like Strings,
are zero indexed, so the last element of the array is always given by its
length-1. However, length is an instance variable for arrays, whereas
length() is an instance method for Strings. Therefore, it would be a
syntax error in this example to refer to strarr.length().

JAVA DEBUGGING TIP Array Length. A common syntax error
involves forgetting that for arrays length is an instance variable, not
an instance method, as it is for Strings.

   In the example, we first use the new operator to create strarr, an array
of type String of length five. We then use a String constructor to create
Figure 9.2: Creating an array of             398                              CHAPTER 9  Arrays and Array Processing
five Strings involves six objects,
because the array itself is a sepa-                           strarr                  String strarr[]; // Null array variable
rate object. In (a), the array vari-                  (a)
able is declared. In (b), the ar-                                                     // Creates an array of null String
ray is instantiated, creating an ar-                          strarr                  // references.
ray of five null references. In (c),                  (b)                             strarr=new String [5];
the five Strings are created and
assigned to the array.                                                                        // Creates 5 Strings and
                                                                                              / assigns them to the array
                                               (c)                    strarr                  for (int k=0; k 6 strarr.length; k++)

                                                                                                  strarr[k]=new String();

                                                    lengleng valuvaluvalu lengvalu : String value=""
                                                                     leng length : int=0

Arrays of objects                            the five Strings that are stored in the array. It is important to realize that
                                             creating an array to store five Objects (as opposed to five primitive data
school                                       elements) does not also create the Objects themselves that will be stored
                                             in the array.
                              : Student
                  name : String="Aristotle"     When an array of objects is created, the array's elements are references
                                             to those objects (Fig. 9.2). Their initial values, like all reference variables,
                    : Student                are null. So to create and initialize the array strarr, we need to create
           name : String="Plato"             six objects--the array itself, which will contain five Strings, and then the
                                             five Strings that are stored in strarr.
                  : Student
       name : String="Socrates"                 One more example will help underscore this point. The following state-
                                             ments create four new Objects, an array to store three Students plus the
Figure 9.3: An array of Students.            three Students themselves:

                                                                                                                                                 

                                             Student s c h o o l [ ] = new Student [ 3 ] ;              // A 3  Student array
                                             s c h o o l [ 0 ] = new Student ( " S o c r a t e s " ) ;  // The  f i r s t Student
                                             s c h o o l [ 1 ] = new Student ( " P l a t o " ) ;

                                             // The s e c o n d S t u d e n t

                                             s c h o o l [ 2 ] = new S t u d e n t ( " A r i s t o t l e " ) ; // T h e t h i r d S t u d e n t
                                                                                                                                                 

                                             The first statement creates an array named school to store three
                                             Students, and the next three statements create the individual Students
                                             and assign them to the array (Fig. 9.3). Thus, creating the array and
                                             initializing its elements require four new statements.

                                                The following sequence of statements would lead to a null pointer
                                             exception because the array's elements have not been instantiated:

                                                                                                                                                 

                                             S t u d e n t s t u d e n t s [ ] = new S t u d e n t [ 3 ] ; // A 3 S t u d e n t a r r a y

                                             System . out . p r i n t l n ( students [ 0 ] . getName ( ) ) ;                                     
                                             
SECTION 9.2  One-Dimensional Arrays                                                  399

In this case, students[0] is a null reference, thus causing the exception.

JAVA DEBUGGING TIP Array Instantiation. Creating a new array
does not also create the objects that are stored in the array. They must
be instantiated separately. It is a semantic error to refer to an
uninstantiated (null) array element.

Now that we've assigned the three Students to the array, we can refer

to them by means of subscripted references. A reference to the Student

named "Socrates" is now school[0], and a reference to the Student

named "Plato" is school[1]. In other words, to refer to the three indi-

vidual students we must refer to their locations within school. Of course,

we can also use variables, such as loop counters, to refer to a Student's

location within school. The following for loop invokes each Student's

getState() method to print out its current state:

                                                                                           

  for ( int k = 0; k < school . length ; k++)                                              쯵chool
         System . out . println ( school [k ] . getState ( ) ) ;



   What if the three Students already existed before the array was cre-                                      student3
ated? In that case, we could just assign their references to the array
elements, as in the following example:

                                                                                                              : Student
                                                                                                    name : String="Aristotle"
Student s t u d e n t 1 = new Student ( " S o c r a t e s " ) ;

Student s t u d e n t 2 = new Student ( " P l a t o " ) ;

Student s t u d e n t 3 = new Student ( " A r i s t o t l e " ) ;                                           : Student
                                                                                                    name : String="Plato"
S t u d e n t s c h o o l = new S t u d e n t [ 3 ] ; // A 3 S t u d e n t a r r a y                                       stude

school [0] = student1 ;

school [1] = student2 ;

school [2] = student3 ;                                                                                 : Student
                                                                                             name : String="Socrates"
                                                                                                                           studen

In this case, each of the three Student objects can be referenced by two                    Figure 9.4: Arrays of objects store
different references--its variable identifier (such as student1) and its ar-                references to the objects, not the
ray location (such as school[0]). For arrays of objects, Java stores just                   objects themselves.
the reference to the object in the array itself, rather than the entire object.
This conserves memory, since references require only 4 bytes each whereas                  
each object may require hundreds of bytes (Fig. 9.4).

   When an array of N elements is created, the compiler allocates storage
for N variables of the element's type. In the case of arr that we discussed
earlier, the compiler would allocate storage for 15 ints--60 contiguous
bytes of storage, because each int requires 4 bytes (32 bits) of storage. If
we declare an array of 20 doubles,

 

double a r r [ ] = new double [ 2 0 ] ;
                                                                                           

the compiler will allocate 160 bytes of storage--20 variables of 8 bytes                   How much memory?
(64 bits) each. In the case of the Student examples and String exam-
ples, because these are objects (not primitive types), the compiler will al-
locate space for N addresses, where N is the length of the array and where
each address requires 4 bytes.
                        400                             CHAPTER 9  Arrays and Array Processing

                        SELF-STUDY EXERCISE

                        EXERCISE 9.1 How much space (in bytes) would be allocated for each
                        of the following?

                        a. int a[] = new int[5];
                        b. double b[] = new double[10];
                        c. char c[] = new char[30];
                        d. String s[] = new String[10];
                        e. Student p[] = new Student[5];

                        9.2.3 Initializing Arrays

Default initialization  Array elements are automatically initialized to default values that depend
Array initializer       on the element type: Boolean elements are initialized to false, and inte-
                        ger and real types are initialized to 0. Reference types--that is, arrays of
Array assignment        objects--are initialized to null.

                           Arrays can also be assigned initial values when they are created, al-
                        though this is feasible only for relatively small arrays. An array initializer
                        is written as a list of expressions separated by commas and enclosed by
                        braces. For example, we can declare and initialize the array shown in
                        Figure 9.1 with the following statement:

                                                                                                        

                        int arr [] = { -2 ,8 , -1 , -3 ,16 ,20 ,25 ,16 ,16 ,8 ,18 ,19 ,45 ,21 , -2};
                                                                                                        

                        Similarly, to create and initialize an array of Strings, we can use the
                        following statement:

                                                                                                        

                        String s t r i n g s [ ] = {" hello " , "world" , "goodbye" , " love " } ;
                                                                                                        

                        This example creates and stores four Strings in the array. Subsequently,
                        to refer to "hello", we would use the reference strings[0], and to refer
                        to "love", we would use the reference strings[3]. Note in these exam-
                        ples that when an array declaration contains an initializer, it is not neces-
                        sary to use new and it is not necessary to specify the number of elements
                        in the array. The number of elements is determined from the number of
                        values in the initializer list.

                        9.2.4 Assigning and Using Array Values

                        Array elements can be used in the same way as other variables. The only
                        difference, of course, is that references to the elements are subscripted.
                        For example, the following assignment statements assign values to the
                        elements of two arrays, named arr and strings:

                                                                                                        

                        arr [0] = 5;

                        arr [5] = 10;

                        arr [2] = 3;

                        s t r i n g s [ 0 ] = "who" ;

                        s t r i n g s [ 1 ] = "what" ;

                        s t r i n g s [ 2 ] = s t r i n g s [ 3 ] = "where" ;
                                                                                                        
SECTION 9.3  Simple Array Examples                                                  401

The following loop assigns the first 15 squares--1, 4, 9 ...--to the
array arr:

                                                                                            

  for ( int k = 0; k < arr . length ; k++)

  arr [k] = (k+1)  (k+1);                                                                   

The following loop prints the values of the array arr:

                                                                                            

  for ( int k = 0; k < arr . length ; k++)

  System . out . println ( arr [k ] ) ;                                                     

SELF-STUDY EXERCISES

EXERCISE 9.2 Declare an array named farr that contains ten floats
initialized to the values 1.0, 2.0, ..., 10.0.

EXERCISE 9.3 Write an expression that prints the first element of farr.

EXERCISE 9.4 Write an assignment statement that assigns 100.0 to the
last element in farr.

EXERCISE 9.5 Write a loop to print all of the elements of farr.

9.3 Simple Array Examples

The program in Figure 9.5 creates two arrays of ten elements each and
displays their values on the Java console. In this example, the elements

                                                                                            

public class PrintArrays {
   s t a t i c f i n a l i n t ARRSIZE = 1 0 ;

// The a r r a y ' s s i z e                                                         array
                                                                                     array
   s t a t i c i n t i n t A r r [ ] = new i n t [ ARRSIZE ] ; // C r e a t e i n t
   s t a t i c double realArr [ ] = { 1.1 , 2.2 , 3.3 , 4.4 ,

         5.5 , 6.6 , 7.7 , 8.8 , 9.9 , 10.10 }; // And a d o u b l e

  public s t a t i c void main ( S t r i n g args [ ] ) {
     System . out . println ( " Ints \ t Reals" ) ;

// P r i n t a h e a d i n g

                              // For e a c h i n t and d o u b l e e l e m e n t

  for ( int k = 0; k < intArr . length ; k++)
       System . out . println ( intArr [k] + " \ t " +
                                                      realArr [k ] ) ;

// P r i n t them

  } // main ( )

} // P r i n t A r r a y s

                                                                                            

Figure 9.5: A program that displays two arrays. Its output is shown in
Figure 9.6

of intArr have not been given initial values whereas the elements of
realArr have been initialized. Note the use of the integer constant
                           402  CHAPTER 9  Arrays and Array Processing

Maintainability principle  ARRSIZE to store the arrays' size. By using the constant in this way, we
                           do not have to use the literal value 10 anywhere in the program, thereby
                           making it easier to read and to modify the program. If we want to change
                           the size of the array that the program handles, we can just change the
                           value of ARRSIZE. This is an example of the maintainability principle.

                           JAVA EFFECTIVE DESIGN Symbolic Constants. Using symbolic
                           constants (final variables) instead of literal values makes the program
                           easier to read and to maintain.

Ints  Reals                Note the use of the static qualifier throughout the PrintArrays
                           class. This enables us to refer to the array and the other variables from
0     1.1                  within the main() method. If intArr were not declared static,
                           we would get the compiler error attempt to make static use of
0     2.2                  a non-static variable. This use of static is justified mainly as
                           a coding convenience rather than a principle of object-oriented design.
0     3.3                  The only examples we've seen so far in which static elements were a
                           necessary design element were the use of static elements in the Math
0     4.4                  class--Math.PI and Math.sqrt()--and the use of static final variables
                           in TwoPlayerGame--TwoPlayerGame.PLAYER ONE.
0     5.5
                              For large arrays, it is not always feasible to initialize them in an ini-
0     6.6                  tializer statement. Consider the problem of initializing an array with the
                           squares of the first 100 integers. Not only would it be tedious to set these
0     7.7                  values in an initializer statement, it would also be error prone, since it is
                           relatively easy to type in the wrong value for one or more of the squares.
0     8.8
                            JAVA DEBUGGING TIP Array Initialization. Initializer statements
0     9.9                   should be used only for relatively small arrays.

0     10.1

FIGURE 9.6 Output of the
PrintArrays program.

1 4 9 16 25                The example in Figure 9.7 creates an array of 50 integers and then fills the
36 49 64 81 100            elements with the values 1, 4, 9, 16, and so on. It then prints the entire
121 144 169 196 225        array.
256 289 324 361 400
441 484 529 576 625           This example illustrates some important points about the use of array
676 729 784 841 900        variables. The array's elements are individual storage locations. In this
961 1024 1089 1156 1225    example, intArr has 50 storage locations. Storing a value in one of these
1296 1369 1444 1521 1600   variables is done by an assignment statement:
1681 1764 1849 1936 2025
2116 2209 2304 2401 2500                                                                                  

FIGURE 9.8 Output of the   intArr [k] = (k+1)  (k+1);                                                     
Squares program.           

Zero vs. unit indexing     The use of the variable k in this assignment statement allows us to vary
                           the location that is assigned on each iteration of the for loop. Note that
                           in this example, k occurs as the array index on the left-hand side of this
                           expression, while k+1 occurs on the right-hand side as the value to be
                           squared. The reason for this is that arrays are indexed starting at 0 but we
                           want our table of squares to begin with the square of 1. So the square of
                           some number n+1 will always be stored in the array whose index is one
                           less than the number itself--that is, n.
SECTION 9.4  Example: Counting Frequencies of Letters                                  403
                                                                                          

                                                                                          
public class Squares {

  s t a t i c f i n a l i n t ARRSIZE = 5 0 ;  // The a r r a y ' s s i z e

  s t a t i c i n t i n t A r r [ ] = new i n t [ ARRSIZE ] ; // I n s t a n t i a t e

  public s t a t i c void main ( S t r i n g args [ ] ) {

  for ( int k = 0; k < intArr . length ; k++)// I n i t i a l i z e

  intArr [k] = (k+1)  (k+1);

  System . out . p r i n t ( "The f i r s t 50 squares are " ) ;

  for ( int k = 0; k < intArr . length ; k++) { // P r i n t

  i f ( k % 5 == 0 )                           // For e a c h 5 t h s q u a r e

  System . out . println ( " " ) ; // p r i n t a new l i n e

  System . out . print ( intArr [k] + " " ) ;

  } // f o r

  } // main ( )

  } // S q u a r e s


Figure 9.7: A program with an array that stores the squares of the first 50
integers. Its output is shown in Figure 9.8.

   An array's length variable can always be used as a loop bound when                   
iterating through all elements of the array:                                            

                                                                                         Off-by-one error

    for ( int k = 0; k < intArr . length ; k++)
           intArr [k] = (k+1)  (k+1);

 

However, it is important to note that the last element in the array is always
at location length-1. Attempting to refer to intArr[length] would
cause an IndexOutOfBoundsException because no such element ex-
ists.

  JAVA DEBUGGING TIP Off-by-One Error. Because of zero
  indexing, the last element in an array is always length - 1. Forgetting
  this fact can cause an off-by-one error.

SELF-STUDY EXERCISE

EXERCISE 9.6 Declare an array of 100 doubles and write a loop to as-
sign the first 100 square roots to its elements. [Use Math.sqrt(double).]

9.4 Example: Counting Frequencies of Letters

Suppose you wish to write a program to help break a text message that has
been encrypted with one of the historical ciphers that we have discussed
in the two previous chapters. It is well known that historical ciphers of-
ten can be broken, that is, the plaintext can be found from the ciphertext,
by examining the frequencies of letters and comparing them to the aver-
age frequencies of typical samples of plaintext. For example, E and T are
the two most frequently used letters in the English language. So, in a ci-
phertext encrypted with a Caesar cipher, E and T are good guesses as the
                  404                          CHAPTER 9  Arrays and Array Processing

                  plaintext letter corresponding to the most frequent letter in a ciphertext
                  message.

                     Let's write a program that will count how many times each of the 26
                  letters of the English language appears in a given string. There are a num-
                  ber of ways to design such a program depending on how flexible you wish
                  the program to be. Let us keep this example simple by assuming that we
                  will only be interested in counting occurrences of the letters A through Z
                  and not of occurrences of spaces or punctuation marks. Assume further
                  that we will change lowercase letters in our string sample to uppercase
                  before counting letters and that we will want to print out the frequencies
                  of letters to the console window. Finally, assume that, later in the chapter
                  after we discuss sorting arrays, we will want to enhance our program so
                  that it can print out the letter frequencies in order of increasing frequency.

                  9.4.1 A Class to Store the Frequency of One Letter

                  It is clear that an array should be used for storing the frequencies, but a
                  decision must also be made as to what to store as the array elements. If
                  we store letter frequencies as int values, with the frequency of A stored
                  at index 0, and the frequency of B at index 1, and so forth, we will not
                  be able to rearrange the frequencies into increasing order without losing
                  track of which letter corresponds to which frequency. One way of solving
                  this problem is to create an array of objects, where each object stores both
                  a letter and its frequency.

                     So let us design a LetterFreq class that stores a letter in an instance
                  variable of type char and its frequency in an instance variable of type
                  int. These instance variables can be declared as:

                                                                                                  

                       private char letter ;       //A c h a r a c t e r b e i n g c o u n t e d

                       private int freq ;          // The f r e q u e n c y o f l e t t e r

                                                                                                  

                  We will want a constructor that can initialize these two values and two
                  accessor methods to return these values. We are familiar enough with
                  these kinds of methods that it will not be necessary to discuss them any
                  further. We need one additional method to increment freq whenever we
                  encounter the letter while processing the string:

                                                                                                  

                       public void incrFreq ( ) {

                       freq ++;

                       } // s e t F r e q ( )

                                                                                                  

                     A UML diagram for the LetterFreq class is given in Figure 9.9 and
                  the class definition is given in Figure 9.10. Note that we will have to make
                  a minor modification to this class later in this chapter to enable us to sort
                  an array of objects from this class.

Figure 9.9:  UML  for 9.4.2 A Class to Count Letter Frequencies
LetterFreq.
                  Now let us turn to designing a class named AnalyzeFreq that will use
                  an array of objects of type LetterFreq to count the frequencies of the
                  letters A through Z in a given string. The array, let's call it freqArr, will
                  be the only instance variable of the class. The class needs a constructor
                  to instantiate the array and to create the 26 array elements, each with a
SECTION 9.4  Example: Counting Frequencies of Letters                       405
                                                                               

                                                                               
public class LetterFreq {     //A c h a r a c t e r b e i n g c o u n t e d
       private char letter ;  // The f r e q u e n c y o f l e t t e r
       private int freq ;

         public LetterFreq ( char ch , int f r e ) {
                 l e t t e r = ch ;
                freq = fre ;

         }
         public char getLetter () {

                return letter ;
         }
         public int getFreq () {

                return freq ;
         }
         public void incrFreq ( ) {

                freq ++;
         }
  } // L e t t e r F r e q


                   Figure 9.10: The LetterFreq class definition.

different letter and an initial frequency of 0. This class should also have                             UML for
two methods: a method to count the frequencies of the 26 letters in a given               
string and a method that prints out the frequency of each letter to the                   
console window. The UML diagram for the class is given in Figure 9.11.
                                                                                           Figure 9.11:
   The array instance variable can be declared by:                                        쯅nalyzeFreq.

                                                                                          
                                                                                          
      private LetterFreq [ ] freqArr ; //An a r r a y o f f r e q u e n c i e s
 

The constructor creates an array of 26 elements to store references to
LetterFreq objects with the statement

 

      f r e q A r r = new L e t t e r F r e q [ 2 6 ] ;
 

The indices of the array range from 0 to 25 and the elements at these
locations should store the letters A to Z. Recall that in Java, char data
are a form of int data and can be used in arithmetic. If we let k be an
integer that ranges between 0 and 25, then the expression (char)('A'
+ k) will correspond to the letters A to Z. . Thus, the following loop will
initialize the array correctly.

 

    for ( int k = 0; k < 26; k++) {
           f r e q A r r [ k ] = new L e t t e r F r e q ( ( char ) ( 'A ' + k ) , 0 ) ;

    } // f o r
 

The countLetters() method must identify the array index for
LetterFreq object that stores a letter between A and Z. If let is a char
variable that stores such a letter, then the expression (let - 'A') will
give the index of the array element corresponding to let. Thus the fol-
406                                    CHAPTER 9  Arrays and Array Processing

lowing code will calculate the frequencies the letters in the string param-
eter, str:

                                                                                  

     public void countLetters ( String str ) {

     char let ;                        // For use i n t h e l o o p .

     s tr = s t r . toUpperCase ( ) ;

     for ( int k = 0; k < str . length ( ) ; k++) {

                 let = str . charAt (k ) ;

                 i f ( ( l e t >= 'A ' ) && ( l e t <= 'Z ' ) ) {

                 freqArr [ l e t - 'A ' ] . i n c r F r e q ( ) ;

                 } // i f

     } // f o r

     } // c o u n t L e t t e r s ( )

                                                                                  

The definition of the printArray() method is completely straight for-
ward:

                                                                                  

public void printArray ( ) {

     for ( int k = 0; k < 26; k++) {

     System . out . print ( " l e t t e r : " + freqArr [k ] . getLetter ( ) ) ;

     System . out . println ( " freq : " + freqArr [k ] . getFreq ( ) ) ;

     } // f o r

} // p r i n t A r r a y ( )

                                                                                  

The entire definition of AnalyzeFreq is given in Figure 9.12. We will
modify this class later in the chapter to be able to sort the array after count-
ing. The following main() method, either in this class or in its own class
will demonstrate how the class methods are used.

                                                                                  

public s t a t i c void main ( S t r i n g [ ] argv ) {

     AnalyzeFreq a f = new AnalyzeFreq ( ) ;

     a f . c o u n t L e t t e r s ( "Now i s t h e time f o r a l l good s t u d e n t s " +

     " to study computer related topics . " ) ;

     af . printArray ( ) ;

} // main ( )

                                                                                  

SELF-STUDY EXERCISES

EXERCISE 9.7 Rewrite the main() of the AnalyzeFreq class so that
it opens a file named freqtest.txt and counts the frequencies of the
letters of the text stored in the file. You will need to use the Scanner
class to read from the file as was done in Chapter 4. Create a file named
freqtest.txt that contains several hundred characters of typical En-
glish text to test the new main() method

9.5 Array Algorithms: Sorting

Sorting an array is the process of arranging its elements in ascending or
descending order. Sorting algorithms are among the most widely used
algorithms. Any time large amounts of data are maintained, there is some
SECTION 9.5  Array Algorithms: Sorting                                             407

                                                                                    

public class AnalyzeFreq {
   private LetterFreq [ ] freqArr ; //An a r r a y o f f r e q u e n c i e s

  public AnalyzeFreq ( ) {

     f r e q A r r = new L e t t e r F r e q [ 2 6 ] ;

     for ( int k = 0; k < 26; k++) {

     f r e q A r r [ k ] = new L e t t e r F r e q ( ( char ) ( 'A ' + k ) , 0 ) ;

     } // f o r

  }

  public void countLetters ( String str ) {

     char l e t ; // For use i n t h e l o o p .

     s t r = s tr . toUpperCase ( ) ;

     for ( int k = 0; k < str . length ( ) ; k++) {

     let = str . charAt (k ) ;

     i f ( ( l e t >= 'A ' ) && ( l e t <= 'Z ' ) ) {

     freqArr [ l e t - 'A ' ] . i n c r F r e q ( ) ;

     } // i f

     } // f o r

  }

  public void printArray ( ) {

     for ( int k = 0; k < 26; k++) {

     System . out . print ( " l e t t e r : " + freqArr [k ] . getLetter ( ) ) ;

     System . out . println ( " freq : " + freqArr [k ] . getFreq ( ) ) ;

     } // f o r

  }

} // A n a l y z e F r e q

                                                                                    

     Figure 9.12: The AnalyzeFreq class definition.

need to arrange them in a particular order. For example, the telephone
company needs to arrange its accounts by the last name of the account
holder as well as by phone number.

9.5.1 Insertion Sort

The first sorting algorithm we'll look at is known as insertion sort, so
named because as it traverses through the array from the first to the last
element, it inserts each element into its correct position in the partially
sorted array.

   For an array of N elements, let's think of the array as divided into two
parts. The sorted part will be the left hand side of the array. And the
unsorted part will be the right hand side of the array. Initially, the sorted
part consists of the first element in the array--the element at index 0.

   Insertion sort moves through the unsorted portion of the array--that is
its loop variable, k, ranges from 1 through N-1. On each iteration it inserts
the kth element into its correct position in the sorted part of the array. To
insert an element into the sorted part of the array, it may be necessary to
move elements greater than the one being inserted out of the way.
    408                                     CHAPTER 9  Arrays and Array Processing

    In pseudocode, insertion sort can be represented as follows:

                                                                                           

I n s e r t i o n Sort of an array , arr , of N elements into ascending order

1 . For k a s s i g n e d 1 through N-1

2 . Remove t h e element a r r [ k ] and s t o r e i t i n x .

3 . For i s t a r t i n g a t k-1 and f o r a l l preceding elements g r e a t e r than x

4.  Move a r r [ i ] one p o s i t i o n t o t h e r i g h t i n t h e a r r a y .

5. Insert x at its correct location .                                                      


    As is apparent from the pseudocode, we have a nested for loops. The outer
    (k) loop, iterates through the array from 1 to N-1. The inner loop iterates
    as many times as necessary, starting with the element just to the left of the
    kth element in order to insert the kth element into its correct position in
    the sorted portion. Note that the kth element is always removed from the
    array (and stored in the variable x), to make room for elements that have
    to be moved to the right.

       To see how this works, consider an integer array containing the ages of
    five friends:

                                                                                           

    21 | 20 27 24 19                        x = 20

         k                                                                                 

    For this five-element array, insertion sort initially will assume that the el-
    ement at index 0 is in the correct position. The vertical line marks the
    boundary between the sorted and unsorted portions of the array. The
    outer loop will look at each of the remaining elements, one at a time, in-
    serting it into its proper position in the sorted portion of the array. To
    insert 20, the number at index 1, the inner loop will move 21 to the right
    by one position. To do this, the algorithm will remove 20 from its location
    and store it in x. It will then move 21 one space to the right. Finally, it
    will insert 20, which is stored in x, at index 0, where it belongs relative to
    the other elements in the sorted part of the array. At this point, the sorted
    portion of the array consists of the first two elements, which are in the
    correct order, relative to each other.

                                                                                           

    20 21 | 27 24 19                        x = 27

            k                                                                              

    For the next element, 27, none of elements in the sorted portion need to be
    moved, so the inner for loop will iterate zero times. This gives us:

                                                                                           

    20 21 27 | 24 19                        x = 24

               k                                                                           

    For the fourth element, 24, only the previous element, 27, needs to be
    moved to the right, giving:

                                                                                           

    20 21 24 27 | 19                        x = 19

                                         k                                                 
SECTION 9.5  Array Algorithms: Sorting                                        409

At this point, the sorted part of the array consists of the first four elements,
which are in the correct order relative to each other. Finally, for the last
element, 19, all of the elements in the sorted part of the array need to be
moved one space to the right. This will require four iterations of the inner
loop. We show the state of the array after each iteration of the inner for
loop:

                                                                                    

                      k

  20 21 24 27 | 19 Remove 19 and s t o r e i t x = 19

  20 21 24 27 | 27 Move 27 t o t h e r i g h t

  20 21 24 24 | 27 Move 24 t o t h e r i g h t

  20 21 21 24 | 27 Move 21 t o t h e r i g h t

  20 20 21 24 | 27 Move 20 t o t h e r i g h t

  19 20 21 24 27 | I n s e r t x=19 at index 0
                                                                                    

Clearly, the fact that so many elements may have to moved on each it-
eration of the outer loop shows that insertion sort is not a very efficient
algorithm.

   The Sort class (Fig 9.13) provides an implementation of the
insertionSort() method. There are several points worth noting about
this code. First, because it takes an int array as a parameter, the
insertionSort() method will sort any array of integers, regardless of
the array's length.

                                                                               

public class Sort {

  public void insertionSort ( int arr [ ] ) {

  i n t temp ; // T e m p o r a r y v a r i a b l e f o r i n s e r t i o n

  for ( int k = 1; k < arr . length ; k++) {

     temp = a r r [ k ] ; // R e m o v e e l e m e n t f r o m a r r a y

     int i ;             // For l a r g e r p r e c e d i n g e l e m e n t s

     f o r ( i = k-1; i >= 0 && a r r [ i ] > temp ; i --)

              arr [ i +1] = arr [ i ] ; // Move i t r i g h t by one

     a r r [ i +1] = temp ;                // I n s e r t t h e e l e m e n t

  }

  } // i n s e r t i o n S o r t ( )

  public void print ( int arr [ ] ) {

  for ( int k = 0; k < arr . length ; k++)// F o r e a c h i n t e g e r

     System . out . print ( arr [ k ] + " \ t " ) ; // P r i n t i t

  System . out . println ( ) ;

  } // p r i n t ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  int intArr [ ] = { 21 , 20 , 27 , 24 , 19 };

  S o r t s o r t e r = new S o r t ( ) ;

  sorter . print ( intArr );

  sorter . insertionSort ( intArr ) ; // P a s s i n g an a r r a y

  sorter . print ( intArr );

  } // main ( )

} // S o r t

                                                                               

Figure 9.13: Source code for the insertionSort() method. Note in
main() how an integer array is passed to the method.
                          410  CHAPTER 9  Arrays and Array Processing

Array parameters             Second, note how empty brackets ([]) are used to declare an array pa-
Selection sort algorithm  rameter. If the brackets were omitted, then arr would be indistinguish-
                          able from an ordinary int parameter. Using the brackets indicates that
                          this method takes an array of integers as its parameter.

                          JAVA DEBUGGING TIP Array Parameter. When declaring an array
                          parameter, empty brackets must be used either after the array name or
                          after the type name to distinguish it from a non-array parameter.

                             Third, note how an array of integers is passed to the insertionSort()
                          method in the main() method:

                                                                                                           

                               sorter . insertionSort ( intArr ) ; // P a s s i n t A r r to t h e method  

                          That is, when passing an array to a method, you use just the name of the
                          array, without brackets. Both of the following statements would cause
                          syntax errors:

                                                                                                           

                            sorter . insertionSort ( intArr [ ] ) ; //    Err :  Can ' t have  brackets
                            sorter . insertionSort ( intArr [ 5 ] ) ; //  Err :  passing an
                                                                                               integer

                                                                                                           

                          In the first case, empty brackets are only used when you declare an array
                          variable, not when you are passing the array to a method. In the second
                          case, intArr[5] is an int, not an array, and cannot legally be passed to
                          insertionSort().

                          JAVA DEBUGGING TIP Passing an Array Argument. It is a syntax
                          error to use empty brackets when passing an array argument to a
                          method, where the only the array's name should be used. Empty
                          rackets are only used when declaring an array variable.

                          Finally, within the insertionSort() method itself, note that we declare
                          the index for the inner for loop outside of the for statement. This is so
                          it can be used outside the scope of the for loop to insert temp at location
                          arr[i+1], its correct location. Note also that the index of its correct loca-
                          tion is i+1, rather than just i. This is because the inner loop might iterate
                          past location 0, which would give i a value of -1 at that point.

                          9.5.2 Selection Sort

                          There are a large variety of array sorting algorithms. Selection sort is dif-
                          ferent from, but comparable to, insertion sort in its overall performance.
                          To illustrate the selection sort algorithm, suppose you want to sort a deck
                          of 25 index cards, numbered from 1 to 25. Lay the 25 cards out on a table,
                          one card next to the other. Starting with the first card, look through the
                          deck and find the smallest card, the number 1 card, and exchange it with
                          the card in the first location. Then, go through the deck again starting
                          at the second card, find the next smallest card, the number 2 card, and
                          exchange it with the card in the second location. Repeat this process 24
                          times.
SECTION 9.5  Array Algorithms: Sorting                                        411

Translating this strategy into pseudocode gives the following algorithm:

                                                                                    

S e l e c t i o n s o r t o f a 25-card deck from small t o l a r g e

1. For count assigned 1 to 24 // O u t e r l o o p

2. smallestCard = count

3 . For currentCard assigned count+1 to 25 // I n n e r l o o p

4.  I f deck [ currentCard ] < deck [ smallestCard ]

5.  smallestCard = currentCard

6. I f smallestCard != count // You need to swap

7   Swap deck [ count ] and deck [ s m a l l e s t C a r d ]
                                                                                    

For a deck of 25 cards, you need to repeat the outer loop 24 times. In other
words, you must select the smallest card and insert it in its proper location
24 times. The inner loop takes care of finding the smallest remaining card.

   On each iteration of this outer loop, the algorithm assumes that the card
specified by the outer loop variable, count, is the smallest card (line 2). It
usually won't be, of course, but we have to start somewhere.

   The inner loop then iterates through the remaining cards (from
count+1 to 25) and compares each one with the card that is currently
the smallest (lines 4 and 5). Whenever it finds a card that is smaller than
the smallest card, it designates it as the smallest card (line 5). At the end of
the loop, the smallestCard variable will remember where the smallest
card is in the deck.

   Finally, when the inner loop is finished, the algorithm swaps the small-
est card with the card in the location designated by count.

9.5.3 Algorithm: Swapping Memory Elements

An important feature of the selection sort algorithm is its need to swap             Swapping algorithm
two array elements, or cards, to continue our example. Swapping two                 
memory elements, whether they are array elements or not, requires the
use of a temporary variable. For example, to swap the jth and kth elements          
in an int array named arr, you would use the following algorithm:
                                                                                     Swapping blunder
                                                                                    
                                                                                    
i n t temp = a r r [ j ] ; // S t o r e t h e j t h e l e m e n t i n t e m p

arr [ j ] = arr [k ] ; // Move t h e kth e l e m e n t i n t o j

  a r r [ k ] = temp ;  // Move t h e j t h e l e m e n t i n t o k


The temp variable temporarily stores the jth element so its value is not
lost when its location is overwritten by the kth element. The need for
this variable is a subtlety that beginning programmers frequently over-
look. But consider what would happen if we used the following erroneous
algorithm:



  arr [ j ] = arr [k ] ; // E r r o n e o u s swap code
  arr [k] = arr [ j ];

412                            CHAPTER 9  Arrays and Array Processing

If arr[j] refers to 4 and arr[k] refers to 2 in the array 1 4 2 8, then
the erroneous algorithm would produce 1 2 2 8, the wrong result.

JAVA PROGRAMMING TIP Swapping Variables. When swapping
two memory elements, a temporary variable must be used to store one
of the elements while its memory location is being overwritten.

The following method implements the swap algorithm for two elements,
el1 and el2 of an int array:

                                                                                        

void swap ( i n t a r r [ ] , i n t el1 , i n t e l 2 ) {

     i n t temp = a r r [ e l 1 ] ; // A s s i g n f i r s t e l e m e n t t o t e m p

     arr [ el1 ] = arr [ el2 ] ; // O v e r w r i t e f i r s t with second

     a r r [ e l 2 ] = temp ;  // O v e r w r i t e s e c o n d w i t h f i r s t

} // swap ( )

                                                                                        

SELF-STUDY EXERCISES

EXERCISE 9.8 Sort the array, 24 18 90 1 0 85 34 18, using the insertion
sort algorithm. Show the order of the elements after each iteration of the
outer loop.

EXERCISE 9.9 Sort the array, 24 18 90 1 0 85 34 18, using the selection
sort algorithm. Show the order of the elements after each iteration of the
outer loop.

EXERCISE 9.10 Write a Java code segment to swap two Student ob-
jects, student1 and student2.

EXERCISE 9.11 Write a Java implementation of the selectionSort()
method to sort an array of int.

9.5.4 Passing a Value and Passing a Reference

Recall from Chapter 3 that when an Object is passed to a method, a copy
of the reference to the Object is passed. Because an array is an object,
a reference to the array is passed to insertionSort(), rather than the
whole array itself. This is in contrast to how a value of a primitive type is
passed. In that case, a copy of the actual value is passed.
SECTION 9.5  Array Algorithms: Sorting                                      413

JAVA LANGUAGE RULE Primitive vs. Object Parameters. When a
value of a primitive data type--int, double, char, boolean--
is passed as an argument to a method, a copy of the value is passed;
when a reference to an Object is passed, a copy of the reference is
passed.

One implication of this distinction is that for arguments of primitive type,
the original argument cannot be changed from within the method be-
cause the method has only a copy of its value. For example, the follow-
ing method takes an int parameter n, which is incremented within the
method:

                                                                                  
                                                                                  
  public void add1 ( int n ) {
     System . out . print ( "n = " + n ) ;                                         Passing a primitive value
     n = n + 1;                                                                   
     System . out . println ( " , n = " + n ) ;                                   

  }                                                                                Passing an object
                                                                                  
                                                                                  
But because n is a parameter of primitive type, incrementing it within the
method has no effect on its associated argument. Thus, in the following            Method call overhead
segment, the value of Num--n's associated argument--will not be affected
by what goes on inside the add() method. The output produced by the
code segment is shown in the comments:



i n t Num = 5 ;

System . out . p r i n t l n ( "Num = " + Num) ; // P r i n t s Num = 5

add1 (Num) ;                                   // P r i n t s n = 5 , n = 6

  System . out . p r i n t l n ( "Num = " + Num) ; // P r i n t s Num = 5


Note that while n's value has changed inside the method, Num's value
remains unaffected.

   The case is much different when we pass a reference to an object. In
that case, the object itself can be manipulated from within the method.
The insertionSort() method is a good illustration. In the following
code segment, the array anArr is printed, then sorted, and then printed
again:



  S o r t s o r t e r = new S o r t e r ( ) ;

  int anArr [ ] = { 5 , 10 , 16 , -2, 4 , 6 , 1 } ;

  sorter . print ( anArr ) ;                   // P r i n t s 5 1 0 1 6 -2 4 6 1

  sorter . insertionSort ( anArr ) ; // S o r t s a n A r r

    sorter . print ( anArr ) ;                 // P r i n t s -2 1 4 5 6 1 0 1 6


As you can see, the object itself (the array) has been changed from within
the method. This shows that changes within insertionSort to the ar-
ray referenced by arr are actually being made to anArr itself. If fact,
because insertionSort() is passed a copy of the reference variable
anArr, both arr and anArr are references to the very same object--that
is, to the same array (Fig. 9.14).

   The justification for passing a reference to an object rather than the en-
                                                 414             CHAPTER 9  Arrays and Array Processing
Figure 9.14: When an array is
passed to a method, both the pa-                            Method Definition (parameter)            Method Call (argument)
rameter and the corresponding ar-
gument refer to the same object.                            public void insertionSort (int arr [ ])     insertionSort (anArr)
                                                            {                                        61
                                                            ...
                                                            }

                                                                                   5 10 16 -2 4

tire object itself is a matter of efficiency. A reference uses just 4 bytes of
data, whereas an object may use thousands of bytes. It would just be too
inefficient to copy hundreds of bytes each time an object is passed to a
method. Instead, the method is passed a reference to the object, thereby
giving it access to the object without incurring the expense of copying
large amounts of data. Indeed, Java provides no way to pass a copy of an
object to a method.

SELF-STUDY EXERCISE

EXERCISE 9.12 Give the values that will be stored in myArr and k after

you invoke mystery(myArr, k), where myArr, k and mystery() are

declared as follows:

                                                                                                                               

i n t myArr [ ] = { 1 , 2 , 3 , 4 , 5 } ;                                                  int k = 3;

void mystery ( i n t a [ ] , i n t m) {

                                                      ++a [m] ;

                                                      --m;

}

                                                                                                                               

9.6 Array Algorithms: Searching

Suppose we have a large array and we need to find one of its elements. We
need an algorithm to search the array for a particular value, usually called
the key. If the elements of the array are not arranged in any particular
order, the only way we can be sure to find the key, assuming it is in the
array, is to search every element, beginning at the first element, until we
find it.

9.6.1 Sequential Search

This approach is known as a sequential search, because each element of
the array will be examined in sequence until the key is found (or the end
of the array is reached). A pseudocode description of this algorithm is as
follows:

                                                                                                                               

   1. For each element of the array

   2.                                                       I f the element equals the key

   3.                                                            Return i t s index

   4. I f the key i s not found in the array

   5.                                                       Return -1 ( t o i n d i c a t e f a i l u r e )                    
   
SECTION 9.6  Array Algorithms: Searching                                                   415

   This algorithm can easily be implemented in a method that searches                                                   Search
an integer array, which is passed as the method's parameter. If the key is                       +sequentialSearch(in arr : int[], in key : int)
found in the array, its location is returned. If it is not found, then -1 is                     +binarySearch(in arr : int[], in key : int)
returned to indicate failure.
                                                                                                  Figure 9.15: The Search class.
   The Search class (Figs. 9.15 and 9.16) provides the Java implementa-
tion of the sequentialSearch() method. The method takes two pa-
rameters: the array to be searched and the key to be searched for. It uses
a for statement to examine each element of the array, checking whether
it equals the key or not. If an element that equals the key is found, the
method immediately returns that element's index. Note that the last state-
ment in the method will only be reached if no element matching the key
is found.

                                                                                            

public class Search {

  public int sequentialSearch ( int arr [ ] , int key ) {

  for ( int k = 0; k < arr . length ; k++)

  i f ( a r r [ k ] == key )

  return k;

  return -1;                                // F a i l u r e i f t h i s i s r e a c h e d

  } // s e q u e n t i a l S e a r c h ( )

  public int binarySearch ( int arr [ ] , int key ) {

  int low = 0 ;                             // I n i t i a l i z e bounds

  int high = arr . length - 1;

  while ( low <= high ) { // W h i l e n o t d o n e

  i n t mid = ( low + high ) / 2 ;

  i f ( a r r [ mid ] == key )

  r e t u r n mid ;                         // S u c c e s s

  e l s e i f ( a r r [ mid ] < key )

  low = mid + 1 ;                           // S e a r c h t o p h a l f

  else

  high = mid - 1 ;                          // S e a r c h bottom h a l f

  } // w h i l e

  return -1;         // P o s t : i f low > h i g h s e a r c h f a i l e d

  } // b i n a r y S e a r c h ( )

}// S e a r c h

                                                                                            

Figure 9.16: The Search class contains both a sequentialSearch()
and a binarySearch().

 JAVA EFFECTIVE DESIGN Sentinel Return Value. Like Java's
 indexOf() method, the sequentialSearch() returns a sentinel
 value (-1) to indicate that the key was not found. This is a common
 design for search methods.

9.6.2 Binary Search

If the elements of an array have been sorted into ascending or descending
order, it is not necessary to search sequentially through each element of
the array in order to find the key. Instead, the search algorithm can make
                   416  CHAPTER 9  Arrays and Array Processing

How many guesses?  use of the knowledge that the array is ordered and perform what's known
                   as a binary search, which is a divide-and-conquer algorithm that divides
                   the array in half on each iteration and limits its search to just that half that
                   could contain the key.

                      To illustrate the binary search, recall the familiar guessing game in
                   which you try to guess a secret number between 1 and 100, being told
                   "too high" or "too low" or "just right" on each guess. A good first guess
                   should be 50. If this is too high, the next guess should be 25, because if
                   50 is too high the number must be between 1 and 49. If 50 was too low,
                   the next guess should be 75, and so on. After each wrong guess, a good
                   guesser should pick the midpoint of the sublist that would contain the
                   secret number.

                      Proceeding in this way, the correct number can be guessed in at most
                   log2N guesses, because the base-2 logarithm of N is the number of times
                   you can divide N in half. For a list of 100 items, the search should take
                   no more than seven guesses (27 = 128 > 100). For a list of 1, 000 items, a
                   binary search would take at most ten guesses (210 = 1, 024 > 1, 000).

                      So a binary search is a much more efficient way to search, provided the
                   array's elements are in order. Note that "order" here needn't be numeric
                   order. We could use binary search to look up a word in a dictionary or a
                   name in a phone book.
                   A pseudocode representation of the binary search is given as follows:

                                                                                                     

                   TO SEARCH AN ARRAY OF N ELEMENTS IN ASCENDING ORDER

                   1 . Assign 0 low and a s s i g n N-1 t o high i n i t i a l l y

                   2 . As long as low i s not g r e a t e r than high

                   3.   Assign ( low + high ) / 2 t o mid

                   4.   I f t he element a t mid e q u a l s t he key

                   5.   then return i t s index

                   6.   E l s e i f th e element a t mid i s l e s s than th e key

                   7.   then a s s i g n mid + 1 t o low

                   8.   E l s e a s s i g n mid - 1 t o high

                   9 . I f t h i s i s reached r e t u r n -1 t o i n d i c a t e f a i l u r e      
                   

                   Just as with the sequential search algorithm, this algorithm can easily be
                   implemented in a method that searches an integer array that is passed
                   as the method's parameter (Fig. 9.16). If the key is found in the array,
                   its location is returned. If it is not found, then -1 is returned to indicate
                   failure. The binarySearch() method takes the same type of parameters
                   as sequentialSearch(). Its local variables, low and high, are used
                   as pointers, or references, to the current low and high ends of the array,
                   respectively. Note the loop-entry condition: low <= high. If low ever
                   becomes greater than high, this indicates that key is not contained in the
                   array. In that case, the algorithm returns -1.

                      As a binary search progresses, the array is repeatedly cut in half and
                   low and high will be used to point to the low and high index values in
                   that portion of the array that is still being searched. The local variable mid
                   is used to point to the approximate midpoint of the unsearched portion
                   of the array. If the key is determined to be past the midpoint, then low
                   is adjusted to mid+1; if the key occurs before the midpoint, then high is
SECTION 9.7  Two-Dimensional Arrays                 417

set to mid-1. The updated values of low and high limit the search to the
unsearched portion of the original array.

   Unlike sequential search, binary search does not have to examine ev-
ery location in the array to determine that the key is not in the array.
It searches only that part of the array that could contain the key. For
example, suppose we are searching for -5 in the following array:

                                                                                  
                                                                                  
  int sortArr [] =                                                                
       { 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18 ,19 ,20};
                                                                                  

                                                                                   Figure
The -5 is smaller than the smallest array element. Therefore, the algo-            class.
rithm will repeatedly divide the low end of the array in half until the con-
dition low > high becomes true. We can see this by tracing the values
that low, mid, and high will take during the search:



  Key I t e r a t i o n Low High Mid
----------------------------------

   -5 0  0  19  9
   -5 1         4
   -5 2  0  8   1
   -5 3         0
   -5 4  0  3   Failure

         0  0

         0  -1

As this trace shows, the algorithm examines only four locations to                                TestSearch
determine that -5 is not in the array. After checking location 0,                            +getInput() : int
the new value for high will become -1, which makes the condition                             +main()
low <= high false. So the search will terminate.
                                                                                           9.17: The TestSearch
   The TestSearch class (Figs. 9.17 and 9.18) provides a program that
can be used to test two search methods. It creates an integer array,
whose values are in ascending order. It then uses the getInput()
method to input an integer from the keyboard and then performs both
a sequentialSearch() and a binarySearch() for the number.

SELF-STUDY EXERCISE

EXERCISE 9.13 For the array containing the elements 2, 4, 6, and so on
up to 28 in that order, draw a trace showing which elements are examined
if you search for 21 using a binary search.

9.7 Two-Dimensional Arrays

A two-dimensional array, an array whose components are themselves ar-
rays, is necessary or useful for certain kinds of problems. For example,
you would use this type of array if you are doing a scientific study in
which you have to track the amount of precipitation for every day of the
year.

   One way to organize these data would be to create a one-dimensional
array, consisting of 365 elements:

                                                                                  

double r a i n f a l l [ ] = new double [ 3 6 5 ] ;
                                                                                  
                         418                       CHAPTER 9  Arrays and Array Processing

                                                                                                       

                       import java . io .  ;
                       public class TestSearch {

                          public static int getInput () {
                              KeyboardReader kb = new KeyboardReader ( ) ;
                              kb . prompt ( " This program searches f o r values in an array . " ) ;
                              kb . prompt (
                              " Input any p o s i t i v e integer ( or any negative to quit ) : " ) ;
                              return kb . getKeyboardInteger ( ) ;

                          } // g e t I n p u t ( )

                         public s t a t i c void main ( S t r i n g args [ ] ) throws IOException {

                         int intArr [] = { 2 ,4 ,6 ,8 ,10 ,12 ,14 ,16 ,18 ,20 ,22 ,24 ,26 ,28};

                         Search s e a r c h e r = new Search ( ) ;

                         int key = 0 , keyAt = 0;

                         key = getInput ( ) ;

                         while ( key >= 0 ) {

                         keyAt = searcher . sequentialSearch ( intArr , key ) ;

                         i f ( keyAt != -1)

                              System . out . println ( " Sequential : " + key +

                                                   " i s at intArr [ " + keyAt + " ] " ) ;

                         else

                              System . out . println ( " Sequential : " + key

                                                   + " is not contained in intArr [] " ) ;

                         keyAt = searcher . binarySearch ( intArr , key ) ;

                         i f ( keyAt != -1)

                              System . out . println ( " Binary : " + key +

                                                   " i s at intArr [ " + keyAt + " ] " ) ;

                         else

                              System . out . println ( " Binary : " + key +

                                                   " is not contained in intArr [] " ) ;

                         key = getInput ( ) ;

                         } // w h i l e

                         } // main ( )

                       } // T e s t S e a r c h

                                                                                                       

                                                 Figure 9.18: The TestSearch class.

What data do we need?    However, with this representation, it would make it very difficult to cal-
                         culate the average rainfall within a given month, which might be an im-
                         portant part of your study.

                            A better representation for this problem would be to use a two-
                         dimensional array, one dimension for the months and one for the days.
                         The following statement declares the array variable rainfall and cre-
                         ates a 12 by 31 array object as its reference:

                                                                                                       

                         double r a i n f a l l [ ] [ ] = new double [ 1 2 ] [ 3 1 ] ;                 
                         

                         Thus, rainfall is an array of arrays. You can think of the first array as
                         the 12 months required for the problem. And you can think of each month
                         as an array of 31 days. The months will be indexed from 0 to 11, and the
                         days will be indexed from 0 to 30.
SECTION 9.7  Two-Dimensional Arrays                                419

   The problem with this representation is that when we want to refer to           Choosing an appropriate
the rainfall for January 5, we would have to use rainfall[0][4]. This              representation
is awkward and misleading. The problem is that dates--1/5/1999--are
unit indexed, while arrays are zero indexed. Because it will be difficult to      
remember this fact, our representation of the rainfall data may cause us to       
make errors when we start writing our algorithms.

   We can easily remedy this problem by just defining our array to have
an extra month and an extra day each month:

 

    double r a i n f a l l [ ] [ ] = new double [ 1 3 ] [ 3 2 ] ;
 

This representation creates an array with 13 months, indexed from 0 to 12,
with 32 days per month, indexed from 0 to 31. However, we can simply
ignore the 0 month and 0 day by using unit indexing in all of the algo-
rithms that process the array. In other words, if we view this array as
a two-dimensional table, consisting of 13 rows and 32 columns, we can
leave row 0 and column 0 unused (Fig. 9.19).

Ignore this   Use the elements        Ignore                                      Figure 9.19: A two-dimensional
  column     within this rectangle    this row                                    array with 13 rows and 32
                                                                                  columns. To represent 12 months
0,0 0,1 0,2 0,3 . . . 0,29 0,30 0,31                                              of the year, we can simply ignore
                                                                                  row 0 and column 0.
1,0 1,1 1,2 1,3 . . . 1,29 1,30 1,31 January
2,0 2,1 2,2 2,3 . . . 2,29 2,30 2,31 February
.
.
.
11,0 11,1 11,2 11,3 . . . 11,29 11,30 11,31 November
12,0 12,1 12,2 12,3 . . . 12,29 12,30 12,31 December

   As Figure 9.19 shows, the very first element of this 416-element array
has subscripts (0,0) while the last location has subscripts (12,31). The main
advantages of this representation is that the program as a whole will be
much easier to read and understand and much less prone to error.

JAVA EFFECTIVE DESIGN Readability. To improve a program's
robustness and readability, it may be preferable to use unit array
indexing by declaring extra array elements and ignoring those with
index 0.

   In order to refer to an element in a two-dimensional array, you need to         Referencing two-dimensional arrays
use two subscripts. For the rainfall array, the first subscript will specify      
the month and the second will specify the day within the month. Thus, the
following statements assign 1.15 to the rainfall element representing             
January 5, and then print its value:

 

    r a i n f a l l [ 1 ] [ 5 ] = 1.15; // R a i n f a l l f o r J a n u a r y 5
    System . out . println ( r a i n f a l l [ 1 ] [ 5 ] ) ;
 
                                     420                   CHAPTER 9  Arrays and Array Processing

                                     Just as in the case of one-dimensional arrays, it is an error to attempt

                                     to reference an element that is not in the array. Each of the following

                                     examples would cause Java to raise an IndexOutOfBoundsException:

                                                                                                                     

                                     r a i n f a l l [ 1 3 ] [ 3 2 ] = 0.15 ; // No s u c h e l e m e n t

                                     rainfall [11][33] = 1.3;  // No s u c h c o l u m n

                                     r a i n f a l l [ 1 4 ] [ 3 0 ] = 0 . 7 4 ; // No s u c h row
                                                                                                                     

                                     If the initial values of an array's elements are supposed to be zero,

                                     there is no need to initialize the elements. Java will do it automatically

Initializing two-dimensional arrays  when you create the array with new. However, for many array problems
Nested for loops
Array of arrays                      it is necessary to initialize the array elements to some other value. For

                                     a two-dimensional array, this would require a nested loop. To illustrate

                                     this algorithm, let's use a nested for loop to initialize each element of the

                                     rainfall array to 0:

                                                                                                                     

                                     // Note t h a t b o t h l o o p s a r e u n i t i n d e x e d .

                                     f o r ( i n t month = 1 ; month < r a i n f a l l . length ; month++)

                                          f o r ( i n t day = 1 ; day < r a i n f a l l [ month ] . length ; day++)

                                          r a i n f a l l [ month ] [ day ] = 0 . 0 ;                                

                                     Note that both for loops use unit indexing. This is in keeping with our
                                     decision to leave month 0 and day 0 unused.

                                        Remember that when you have a nested for loop, the inner loop iterates
                                     faster than the outer loop. Thus, for each month, the inner loop will iterate
                                     over 31 days. This is equivalent to processing the array as if you were
                                     going across each row and then down to the next row in the representation
                                     shown in Figure 9.19.

                                        Note that for a two-dimensional array, both dimensions have an asso-
                                     ciated length variable, which is used in this example to specify the up-
                                     per bound of each for loop. For the rainfall array, the first dimension
                                     (months) has a length of 13 and the second dimension (days) has a length
                                     of 32.

                                        Another way to view the rainfall array is to remember that it is an
                                     array of arrays. The length of the first array, which corresponds to the
                                     number (13) of months, is given by rainfall.length. The length of
                                     each month's array, which corresponds to the number of days (32) in a
                                     month, is given by rainfall[month].length.

                                        The outer loop of the nested for loop iterates through months 1 through
                                     12, and the inner for loop iterates through days 1 through 31. In this way,
                                     372 = 12  31 elements of the array are set to 0.0. In Table 9.1, the boldface
                                     numbers along the top represent the day subscripts, while the boldface
                                     numbers along the left represent the month subscripts.

                                     SELF-STUDY EXERCISES

                                     EXERCISE 9.14 Declare a two-dimensional array of int, named
                                     int2d, that contains five rows, each of which contains ten integers.

                                     EXERCISE 9.15 Write a statement that prints the last integer in the third
                                     row of the array that you created in the previous exercise. Then write an
SECTION 9.7  Two-Dimensional Arrays                                  421

TABLE 9.1 The initialized rainfall array. The unused array
elements are shown as dashes.

       0    1             2    3                 렁  30    31

  0    -    -             -    -                 렁    -   -

  1    -    0.0           0.0  0.0               렁  0.0   0.0

  2    -    0.0           0.0  0.0               렁  0.0   0.0

  ...  ...  ...           ...  ...               ...  ...   ...

10 -        0.0           0.0  0.0               렁  0.0   0.0

11 -        0.0           0.0  0.0               렁  0.0   0.0

12 -        0.0           0.0  0.0               렁  0.0   0.0

assignment statement that assigns 100 to the last element in the int2d
array.

EXERCISE 9.16 Write a loop to print all of the elements of int2d,
which you declared in the previous exercise. Print one row per line with
a space between each element on a line.

9.7.1 Two-Dimensional Array Methods

Now that we have figured out how to represent the data for our scien-
tific experiment, let's develop methods to calculate some results. First, we
want a method to initialize the array. This method will simply incorporate
the nested loop algorithm we developed previously:

                                                                               

public void initRain ( double rain [ ] [ ] ) {

       f o r ( i n t month = 1 ; month < r a i n . length ; month++)

            f o r ( i n t day = 1 ; day < r a i n [ month ] . length ; day++)

            r a i n [ month ] [ day ] = 0 . 0 ;

} // i n i t R a i n ( )

                                                                               

Note how we declare the parameter for a multidimensional array. In addi-       Array parameters
tion to the element type (double), and the name of the parameter (rain),
we must also include a set of brackets for each dimension of the array.

   Note also that we use the parameter name within the method to refer
to the array. As with one-dimensional arrays, the parameter is a refer-
ence to the array, which means that any changes made to the array within
the method will persist when the method is exited.

The avgDailyRain() Method                                                      Algorithm design

One result that we need from our experiment is the average daily rainfall.
To calculate this result, we would add up all of the rainfalls stored in the
12  31 array and divide by 365. Of course, the array itself contains more
than 365 elements. It contains 416 elements, but we're not using the first
month of the array, and within some months--those with fewer than 31
days--we're not using some of the day elements. For example, there's
no such day as rainfall[2][30], which would represent February 30.
However, because we initialized all of the array's elements to 0, the rain-
                                422                               CHAPTER 9  Arrays and Array Processing

Method design                   fall recorded for the non-days will be 0, which won't affect our overall
                                average.

                                   The method for calculating average daily rainfall should take our two-
                                dimensional array of double as a parameter, and it should return a
                                double. Its algorithm will use a nested for loop to iterate through the
                                elements of the array, adding each element to a running total. When the
                                loops exits, the total will be divided by 365 and returned:

                                                                                                              

                                public double avgDailyRain ( double rain [ ] [ ] ) {

                                     double t o t a l = 0;

                                     f o r ( i n t month = 1 ; month < r a i n . length ; month++)

                                     f o r ( i n t day = 1 ; day < r a i n [ month ] . length ; day++)

                                     t o t a l += r a i n [ month ] [ day ] ;

                                     return total /365;

                                } // a v g D a i l y R a i n ( )

                                                                                                              

                                The avgRainForMonth() Method

Algorithm design                One reason we used a two-dimensional array for this problem is so we
                                could calculate the average daily rainfall for a given month. Let's write
Method design                   a method to solve this problem. The algorithm for this method will not
Method design: What data do we  require a nested for loop. We will just iterate through the 31 elements of a
need?                           given month, so the month subscript will not vary. For example, suppose
                                we are calculating the average for January, which is represented in our
                                array as month 1:

                                                                                                              

                                double t o t a l = 0;

                                for ( int day = 1 ; day < r a i n f a l l [ 1 ] . length ; day++)

                                     t o t a l = t o t a l + r a i n f a l l [ 1 ] [ day ] ;                  

                                Thus, the month subscript is held constant (at 1) while the day subscript
                                iterates from 1 to 31. Of course, in our method we would use a parameter
                                to represent the month, thereby allowing us to calculate the average daily
                                rainfall for any given month.

                                   Another problem that our method has to deal with is that months don't
                                all have 31 days, so we can't always divide by 31 to compute the monthly
                                average. There are various ways to solve this problem, but perhaps the
                                easiest is to let the number of days for that month be specified as a third
                                parameter. That way, the month itself and the number of days for the
                                month are supplied by the user of the method:

                                                                                                              

                                public double avgRainForMonth ( double rain [ ] [ ] ,

                                                                        i n t month , i n t nDays ) {

                                     double t o t a l = 0;

                                     f o r ( i n t day = 1 ; day < r a i n [ month ] . length ; day++)

                                     t o t a l = t o t a l + r a i n [ month ] [ day ] ;

                                     return t o t a l /nDays ;

                                } // a v g R a i n F o r M o n t h ( )

                                                                                                              
SECTION 9.7  Two-Dimensional Arrays         423

Given this definition, we can call this method to calculate and print the
average daily rainfall for March as in the following statement:

                                                                                                 

System . out . p r i n t l n ( "March : " +

  avgRainForMonth ( r a i n f a l l , 3 , 3 1 ) ) ;                                              

Note that when passing the entire two-dimensional array to the method,
we just use the name of the array. We do not have to follow the name with
subscripts.

9.7.2 Passing Part of an Array to a Method

Instead of passing the entire rainfall array to the avgRainForMonth()                             Method design: What data?
method, we could redesign this method so that it is only passed the par-                         
ticular month that's being averaged. Remember that a two-dimensional
array is an array of arrays, so if we pass the month of January, we are                          
passing an array of 32 days. If we use this approach, we need only two                           
parameters: the month, which is array of days, and the number of days in                         
that month:
                                                                                                  Specifying an argument
 

    public double avgRainForMonth ( double monthRain [ ] ,
                                                                                i n t nDays ) {

           double t o t a l = 0;
           for ( int day = 1 ; day < monthRain . length ; day++)

                   t o t a l = t o t a l + monthRain [ day ] ;
           return t o t a l /nDays ;
    } // a v g R a i n F o r M o n t h ( )
 

Given this definition, we can call it to calculate and print the average daily
rainfall for March as in the following statement:

 

    System . out . p r i n t l n ( "March : " +
                                            avgRainForMonth ( r a i n f a l l [ 3 ] , 3 1 ) ) ;

 

In this case, we're passing an array of double to the method, but in
order to reference it, we have to pull it out of the two-dimensional ar-
ray by giving its row subscript as well. Thus, rainfall[3] refers to
one month of data in the two-dimensional array, the month of March.
But rainfall[3] is itself a one-dimensional array. Figure 9.20 helps to
clarify this point.

   It's important to note that deciding whether to use brackets when pass-
ing data to a method is not just a matter of whether you are passing an ar-
ray. It is a matter of what type of data the method parameter specifies. So,
whenever you call a method that involves a parameter, you have to look
at the method definition to see what kind of data that parameter specifies.
Then you must supply an argument that refers to that type of data.

   For our two-dimensional rainfall array, we can refer to the entire
array as rainfall. We can refer to one of its months as rainfall[j],
where j is any integer between 1 and 12. And we can refer to any of its
                      424               CHAPTER 9  Arrays and Array Processing

                               rainfall -- refers to the whole 2-d array                            Figure 9.2
                                                                                                    ual eleme

                                        rainfall[3] -- refers to the 1-d array                      in a two-d

                                        that represents March's data

                                        rainfall[1][14] refers to the double value
                                           that represents rainfall amt on Jan 14

                               012 ...                                          31

                           0                                                        J
                                                                                    F
                           1            1.1                                        M
                                                                                    A
                           2                                                       M
                                                                                    J
                           .                                                        J
                                                                                    A
                           .                                                        S
                                                                                    O
                           .                                                        N
                                                                                    D
                           11
                           12
                           13

                      elements as rainfall[j][k], where j is any integer between 1 and 12,
                      and k is any integer between 1 and 31.

                       JAVA LANGUAGE RULE Arguments and Parameters. The
                       argument in a method call must match the data type in the method
                       definition. This applies to all parameters, including array parameters.

                      The Rainfall class (Figs. 9.21 and 9.22) shows how we can test our            Figure 9.2

                                                                             Rainfall

                           +initRain(in rain : double[][])
                           +avgDailyRain(in rain : double[][]) : double
                           +avgDailyRainForMonth(in monthRain : double[], in nDays : int) : double
                           +main()

                      array algorithms. It creates the rainfall array in the main() method. It
                      then initializes the array and prints out average daily rainfall and average
                      daily rainfall for the month of March. However, note that we have made a
                      slight modification to the initRain() method. Instead of just assigning
                      0 to each element, we assign a random value between 0 and 2.0:

                                                                                                    

                      r a i n [ month ] [ day ] = Math . random ( )  2 . 0 ;                        
                      

Generating test data  Using the Math.random() method in this way enables us to generate
                      some realistic test data. In this case, we have scaled the data so that the
                      daily rainfall is between 0 and 2 inches. (Rainfall like this would probably
                      be appropriate for an Amazonian rain forest!) Testing our algorithms with
SECTION 9.7  Two-Dimensional Arrays                                         425

                                                                                                    

public class Rainfall {

  / 

   I n i t i a l i z e s the r a i n f a l l array

   @ p a r a m r a i n i s a 2 D- a r r a y o f r a i n f a l l s

   Pre : r a i n i s non n u l l

   P o s t : r a i n [ x ] [ y ] == 0 f o r a l l x , y i n t h e a r r a y

   Note that the loops use unit indexing .

  /

  public void initRain ( double rain [ ] [ ] ) {

  f o r ( i n t month = 1 ; month < r a i n . length ; month++)

      f o r ( i n t day = 1 ; day < r a i n [ month ] . length ; day++)

      r a i n [ month ] [ day ] = Math . random ( )  2 . 0 ;                 // Random  rainfall

  } // i n i t R a i n ( )

  / 

   Computes average daily r a i n f a l l for a year of r a i n f a l l data

   @ p a r a m r a i n i s a 2 D- a r r a y o f r a i n f a l l s

   @ r e t u r n The sum o f r a i n [ x ] [ y ] / 3 5 6

   Pre : r a i n i s non n u l l

   P o s t : The sum o f r a i n / 3 6 5 i s c a l c u l a t e d

   Note that the loops are unit indexed

  /

  public double avgDailyRain ( double rain [ ] [ ] ) {
     double t o t a l = 0;
     f o r ( i n t month = 1 ; month < r a i n . length ; month++)
         f o r ( i n t day = 1 ; day < r a i n [ month ] . length ; day++)
             t o t a l += r a i n [ month ] [ day ] ;
     return total /365;

  } // a v g D a i l y R a i n ( )

  / 

   Computes average d a i l y r a i n f a l l f o r a given month c o n t a i n i n g nDays

   @ p a r a m m o n t h R a i n i s a 1 D- a r r a y o f r a i n f a l l s

   @param nDays i s the number of days in monthRain

   @ r e t u r n The sum o f monthRain / nDays

   P r e : 1 <= n D a y s <= 3 1

   P o s t : The sum o f monthRain / nDays i s c a l c u l a t e d

  /

  public double avgRainForMonth ( double monthRain [ ] , i n t nDays ) {
     double t o t a l = 0;
     for ( int day = 1 ; day < monthRain . length ; day++)
         t o t a l = t o t a l + monthRain [ day ] ;
     return t o t a l /nDays ;

  } // a v g R a i n F o r M o n t h ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {
     double r a i n f a l l [ ] [ ] = new double [ 1 3 ] [ 3 2 ] ;
     R a i n f a l l data = new R a i n f a l l ( ) ;
     data . initRain ( rainfall ) ;
     System . out . p r i n t l n ( "The average daily r a i n f a l l = "
                                      + data . avgDailyRain ( rainfall ) ) ;
     System . out . p r i n t l n ( "The average d a i l y r a i n f a l l f o r March = "
                                      + data . avgRainForMonth ( r a i n f a l l [ 3 ] , 3 1 ) ) ;

  } // main ( )

}// R a i n f a l l

                                                                                                    

                     Figure 9.22: Definition of the Rainfall class.
426  CHAPTER 9  Arrays and Array Processing

these data provides some indication that our methods are in fact working
properly.

JAVA EFFECTIVE DESIGN Generating Test Data. The
Math.random() method can be used to generate numeric test data,
when large amounts of data are required. The data can be scaled to fit
within the range that the actual data are expected to have.

SELF-STUDY EXERCISES

EXERCISE 9.17 Suppose you're going to keep track of the daily news-
paper sales at the local kiosk. Declare a 52  7 two-dimensional array of
int and initialize each of its elements to 0.

EXERCISE 9.18 Write a method to calculate the average number of
newspapers sold per week, using the array you declared in the previous
exercise.

EXERCISE 9.19 Write a method to calculate the average number of
newspapers sold on Sundays, using the array you declared in the previous
exercise. Assume that Sunday is the last day of the week.

9.8 Multidimensional Arrays (Optional)

Java doesn't limit arrays to just two dimensions. For example, suppose
we decide to extend our rainfall survey to cover a ten-year period. For
each year we now need a two-dimensional array. This results in a three-
dimensional array consisting of an array of years, each of which contains
an array of months, each of which contains an array of days:

                                                                                

f i n a l i n t NYEARS = 1 0 ;

f i n a l i n t NMONTHS = 1 3 ;

f i n a l i n t NDAYS = 3 2 ;

double r a i n f a l l [ ] [ ] = new double [NYEARS ] [NMONTHS] [NDAYS ] ;      


Following the design convention of not using the 0 month and 0 days, we
end up with a 10  13  32 array. Note the use of final variables to
represent the size of each dimension of the array. This helps to make the
program more readable.

   In Figure 9.23, each year of the rainfall data is represented as a separate
page. On each page, there is a two-dimensional table that consists of 12
rows (1 per month) and 31 columns (1 per day).

   You might imagine that our study could be extended to cover rain-
fall data from a number of different cities. That would result in a four-
dimensional array, with the first dimension now being the city. Of course,
for this to work, cities would have to be represented by integers, because
array subscripts must be integers.

   As you might expect, algorithms for processing each element in a three-
dimensional table would require a three-level nested loop. For example,
  SECTION 8  Multidimensional Arrays                                           427
                                                                                        Figure 9.23: Three-dimensional
       012 ...                 year 0                      31                           data might be viewed as a collec-
                                      year 1                      31                    tion of pages, each of which con-
    0         012 ...                        year 2                      31             tains a two-dimensional table.

    1
    20
           1          012 ...
    .. 2 01
    . .2                                                                     J
       ..                                                                    F
       ..                                                                    M
                                                                             A
              .                                                              M
                                                                             J
    11                                                                       J
    1213 11                                                                  A
                                                                             S
           12 11                                                             O
           13 12                                                             N
                                                                             D
                  13

  the following algorithm would be used to initialize all elements of our
  three-dimensional rainfall array:

                                                                                      

for ( int year = 0; year < r a i n f a l l . length ; year++)

  f o r ( i n t month = 0 ; month < r a i n f a l l [ year ] . length ; month++)

  f o r ( i n t day = 0 ; day < r a i n f a l l [ year ] [ month ] . length ; day++)

  r a i n f a l l [ year ] [ month ] [ day ] = 0 . 0 ;                                

  Note again the proper use of the length attribute for each of the
  three dimensions of the array. In the outer loop, rainfall.length,
  we're referring to the number of years. In the middle loop,
  rainfall[year].length, we're referring to number of months within
  a given year. In the inner loop, rainfall[year][month].length,
  we're referring to the number of days within a month.

     If we added a fourth dimension to our array and wanted to extend
  this algorithm to initialize it, we would simply embed the three-level loop
  within another for loop that would iterate over each city.

  9.8.1 Array Initializers

  It is possible to use an initializer with a multidimensional array. For in-
  stance, the following examples create several small arrays and initialize
  their elements:

                                                                                      

  int a [][] = {{1 ,2 ,3} , {4 ,5 ,6}};

  char c [ ] [ ] = {{ ' a ' , 'b ' } , { ' c ' , 'd ' }};

  double d [ ] [ ] [ ] =

       {{1.0 ,2.0 ,3.0} , {4.0 ,5.0} , {6.0 ,7.0 ,8.0 ,9.0}};                         

  The first of these declarations creates a 2  3 array of integers. The second
  example creates a 2  2 array of characters, and the third example creates
  an array of double consisting of three rows, each of which has a different
  number of elements. The first row contains three elements, the second
  contains two elements, and the last row contains four elements. As this
  last example shows, the rows in a multidimensional array don't all have
  to have the same length.
                                           428              CHAPTER 9  Arrays and Array Processing

                                              Using initializers, as in these examples, is feasible only for relatively
                                           small arrays. To see why, just imagine what the initializer expression
                                           would be for our three-dimensional rainfall array. It would require
                                           4, 160 = 10  13  32 zeroes, separated by commas!

                                           JAVA PROGRAMMING TIP Array Initializers. Initializer
                                           (assignment) expressions can be used to assign initial values to
                                           relatively small arrays. For larger arrays, an initializer method should
                                           be designed.

           Object                          9.9 OBJECT-ORIENTED DESIGN:
                                                 Polymorphic Sorting (Optional)
 +toString() : String
                         쳃nterface       One limitation of the sort routines developed so far is that they only
                        Comparable         work on one particular type of data. If you've written an insertion
                                           sort to sort ints, you can't use it to sort doubles. What would be
          +compareTo(in o : Object) : int  far more desirable is a polymorphic sort method--that is, one method
                                           that could sort any kind of data. This is easily done by making use of
                        Integer            Java wrapper classes, such as Integer and Double, together with the
                                           java.lang.Comparable interface, which is specially designed for this
      +Integer(in i : int)                 purpose.
      +parseInt(in s : String) : int
      +toString() : String                    The java.lang.Comparable interface consists of the compareTo()
      +compareTo(in o : Object) : int      method:

                         Float                                                                                           

      +Float(in f : Float)                 public abstract interface Comparable {
      +parseFloat(in s : String) : float
      +toString() : String                      public i nt compareTo ( Object o ) ; // A b s t r a c t m e t h o d
      +compareTo(in o : Object) : int
                                           }
Figure 9.24: Java wrapper classes,
such as Integer and Double,                                                                                              
implement the Comparable in-
terface.                                   By implementing compareTo(), a class can impose an order on its ob-
                                           jects. The Comparable interface is implemented by all of Java's wrapper
                                           classes--that is, by Integer, Double, Float, Long, and so on (Fig. 9.24).

                                              As we saw in Chapter 8, Java interfaces allow us to create a form of mul-
                                           tiple inheritance. For example, as Figure 9.24 shows, an Integer is both an
                                           Object and a Comparable. One implication of this is that an Integer
                                           can be used in any method that takes either an Object parameter or a
                                           Comparable parameter.

                                              The compareTo() method takes an Object parameter and returns an
                                           int. It is meant to be invoked as o1.compareTo(o2), where o1 and o2
                                           are objects of the same type. Classes that implement compareTo() must
                                           abide by the following rules for its return value:

                                                                                                                         

                                           i f ( o1 < o2 )  then o1 . compareTo ( o2 ) < 0

                                           i f ( o1 . e q u a l s ( o2 ) ) then o1 . compareTo ( o2 ) == 0

                                           i f ( o1 > o2 )  then o1 . compareTo ( o2 ) > 0                               
                                           

                                           In other words, if o1 < o2, then o1.compareTo(o2) will return a neg-
                                           ative integer. If o1 > o2, then o1.compareTo(o2) will return a posi-
SECTION 9  OOD: Polymorphic Sorting                                              429

tive integer. And if o1 and o2 are equal, then o1.compareTo(o2) will
return 0.

   For a class that implements Comparable, we can use the compareTo()
method to help sort its elements. For example, the following revised
version of insertionSort() method can be used to sort any array of
Comparable objects--that is, any array of objects whose class imple-
ments Comparable:

                                                                                       

public void sort ( Comparable [ ] arr ) {

  Comparable temp ; // T e m p o r a r y v a r i a b l e f o r i n s e r t i o n

  for ( int k = 1; k < arr . length ; k++) {

     temp = a r r [ k ] ;    // Remove i t from a r r a y

     int i ;

     f o r ( i = k-1; i >= 0 && a r r [ i ] . compareTo ( temp ) > 0 ; i --)

     arr [ i +1] = arr [ i ] ; // Move i t r i g h t by one

     a r r [ i +1] = temp ;  // I n s e r t t h e e l e m e n t

  }

} // s o r t ( )

                                                                                       

In this version, the parameter is an array of Comparable. Thus, we can
pass it any array whose elements implement Comparable, including an
array of Integer or Float, and so on. Then, to compare elements of a
Comparable array, we use the compareTo() method:

                                                                                       

  f o r ( i = k-1; i >= 0 && a r r [ i ] . compareTo ( temp ) > 0 ; i --)
                                                                                       

Note that our algorithm no longer refers to ints, as in the original in-                                     TestSort
sertion sort. Indeed, it doesn't mention the specific type--Integer,                          +MAXSIZE : int
Float, or whatever--of the objects that it is sorting. It refers only to                      +sort(in arr : Comparable[])
Comparables. Therefore, we can use this method to sort any type                               +print(in arr : Comparable[])
of object, as long as the object's class implements the Comparable                            +main()
interface. Thus, by using Comparable, we have a more general
insertionSort() method, one that can sort any one-dimensional array                    Figure 9.25: The TestSort()
of Comparables.                                                                        class.

   The TestSort class (Figs. 9.25 and 9.26) provides an example of how
to use the polymorphic sort() method.

   It contains three methods: The sort() method that we just described;
a polymorphic print() method, which can be used to print the val-
ues of any array of Comparable; and a main() method. The main()
method creates arrays of Integer and Float and then uses the poly-
morphic sort() method to sort them. Note how the print() method
uses the polymorphic toString() method to print the elements of a
Comparable array.

   This example of polymorphic sorting illustrates once again the great
power of inheritance and polymorphism in object-oriented programming.
The Integer and Float classes use class inheritance to inherit features
from the Object class, and they use interface implementation to inherit
the compareTo() method from the Comparable class. By implement-
ing versions of the toString() and compareTo() methods that are ap-
propriate for these wrapper classes, Java makes it easier to use Integer
and Float objects in a variety of contexts. Taken together, inheritance
                                             430  CHAPTER 9  Arrays and Array Processing

                                             and polymorphism enable us to design very general and extensible algo-
                                             rithms. In this example, we defined a sort() method that can sort an
                                             array containing any kind of object as long as the object implements the
                                             Comparable interface.

                                             9.9.1 The java.util.Arrays.sort() Method

                                             While sorting algorithms provide a good way to introduce the concepts
                                             of array processing, real-world programmers never write their own sort
                                             algorithms. Instead they use library methods, which have been writ-
                                             ten and optimized by programming experts. Moreover, library sort rou-
                                             tines use sort algorithms that are much more efficient than the ones we've
                                             discussed.

                                                The java.util.Arrays class contains a polymorphic sort method
                                             that is very simple to use. For example, here's how we would use it to sort
                                             the two arrays declared in the TestSort program:

                                                                                                                            

                                             java . util . Arrays . sort ( iArr ) ;

                                             java . util . Arrays . sort ( fArr ) ;
                                                                                                                            

                                             That's all there is to it! Obviously, learning how to use Java's class and
                                             method library, saves real-word programmers lots of effort.

                       Vector                SELF-STUDY EXERCISES

+Vector()                                    EXERCISE 9.20 Add a definition of a compareTo() method to the
+Vector(in size : int)                       LetterFreq class so that it implements the Comparable interface. The
+addElement(in o : Object)                   method should define one object to be less than another object if its freq
+elementAt(in index : int) : Object          instance variable is less.
+insertElementAt(in o : Object, in x : int)
+indexOf(in o : Object) : int                EXERCISE 9.21 Add a definition of a sort() method that can be
+lastIndexOf(in o : Object) : int            added to the definition of the AnalyzeFreq class. Make it so the
+removeElementAt(in index : int)             array in the class can be sorted into ascending order using the or-
+size() : int                                dering of LetterFreq defined in the previous exercise. Use the
                                             java.util.Arrays.sort() method.
Figure  9.27:      The
                  class.                     EXERCISE 9.22 Rewrite the main() of the AnalyzeFreq class to
java.util.Vector                             make use of the sort() method of the previous exercise.

                                             9.10 From the Java Library: java.util.Vector

        java.sun.com/j2se/1.5.0/docs/api/    The java.util.Vector class implements an array of objects that can
                                             grow in size as needed. One limitation of regular arrays is that their
                                             lengths remain fixed. Once the array is full--once every element is used--
                                             you can't allocate additional elements.

                                                The Vector class contains methods for storing and retrieving ob-
                                             jects, and for accessing objects by their index position within the Vector
                                             (Fig. 9.27).

                                                One use for a Vector would be when a program needs to store input
                                             from the user or a file without knowing in advance how many items there
                                             are. Using a Vector is less efficient than an array in terms of processing
                                             speed, but it gives you the flexibility of growing the data structure to meet
                                             the storage requirements.
SECTION 9.11  Case Study: An N-Player Computer Game  431

   As an illustration of this idea, the program in Figure 9.28 creates a ran-  Vectors store objects
dom number of integers and then stores them in a Vector. The Vector,
which is declared and instantiated in main(), is initially empty. Integers
from 0 to the random bound are then inserted into the Vector. In this
case, insertions are done with the addElement() method, which causes
the Vector object to insert the element at the next available location,
increasing its size, if necessary.

   Once all the integers have been inserted, the printVector() method
is called. Note that it uses the size() method to determine how many
elements the Vector contains. This is similar to using the length()
method to determine the number of characters in a String.

   Finally, note that a Vector stores objects. It cannot be used to store
primitive data values. You cannot store an int in a Vector. Therefore,
we need to use the Integer wrapper class to convert ints into Integers
before they can be inserted into the Vector. Because you can't just print
an Integer, or any other Object, the toString() method is used to
print the string representation of the object.

   By defining Vector to store Objects, Java's designers have made it as
general as possible and, therefore, as widely useful as possible.

JAVA EFFECTIVE DESIGN Generality. Defining a data collection,
such as an array or a Vector, in terms of the Object class makes it
capable of storing and processing any type of value, including values
of primitive data types. This is because the Object class is the root
of the Java class hierarchy.

9.11 Case Study: An N-Player Computer Game

In this section we will make use of arrays to extend our game-playing
library by developing a design that can support games that involve more
than two players. We will use an array to store a variable number of play-
ers. Following the object-oriented design principles described in Chap-
ter 8, we will make use of inheritance and polymorphism to develop a
design that is flexible and extensible, one that can be used to implement
a wide variety of computer games. As in our TwoPlayer game example
from Chapter 8, our design will allow both humans and computers to play
the games. To help simplify the example, we will modify the WordGuess
game that we developed in the Chapter 8. As you will see, it requires rela-
tively few modifications to convert it from a subclass of TwoPlayerGame
to a subclass of ComputerGame, the superclass for our N-Player game
hierarchy.

9.11.1 The ComputerGame Hierarchy

Figure 9.29 provides a summary overview of the ComputerGame hierar-
chy. This figure shows the relationships among the many classes and in-
terfaces involved. The two classes whose symbols are bold, WordGuess
and WordGuesser, are the classes that define the specific game we will
be playing. The rest of the classes and interfaces are designed to be used
with any N-player game.
                               432                 CHAPTER 9  Arrays and Array Processing

                                  At the root of this hierarchy is the abstract ComputerGame class. Note
                               that it uses from 1 to N Players. These objects will be stored in a one-
                               dimensional array in ComputerGame. Recall from Chapter 8 that an
                               IPlayer was any class that implements the makeAMove() method. In this
                               design, we have put the abstract makeAMove() method into the Player
                               class, a class that defines a generic player of computer games. For the
                               WordGuess game, the WordGuesser class extends Player. In order to
                               play Word Guess, we will create a WordGuess instance, plus one or more
                               instances of WordGuessers. This is similar to the OneRowNim example
                               from the previous chapter,

                                  Note where the TwoPlayerGame and OneRowNim classes occur in the
                               hierarchy. TwoPlayerGame will now be an extension of ComputerGame.
                               This is in keeping with the fact that a two-player game is a special kind
                               of N-player computer game. As we will see when we look at the de-
                               tails of these classes, TwoPlayerGame will override some of the methods
                               inherited from ComputerGame.

                                  Because it contains the abstract makeAMove() method, the Player
                               class is an abstract class. Its purpose is to define and store certain data
                               and methods that can be used by any computer games. For example, one
                               important piece of information defined in Player is whether the player
                               is a computer or a person. Player's data and methods will be inherited
                               by WordGuesser and by other classes that extend Player. Given its
                               position in the hierarchy, we will be able to define polymorphic methods
                               for WordGuessers that treat them as Players. As we will see, this will
                               give our design great flexibility and extensibility.

                               9.11.2 The ComputerGame Class

Figure 9.30: The ComputerGame  Figure 9.30 shows the design details of the ComputerGame class. One
class.                         of the key tasks of the ComputerGame class is to manage the one or
                               more computer game players. Because this is a task that is common to
                               all computer games, it makes sense to manage it here in the superclass.
                               Toward this end, ComputerGame declares four instance variables and
                               several methods. Three int variables define the total number of play-
                               ers (nPlayers), the number of players that have been added to the game
                               (addedPlayers), and the player whose turn it is (whoseTurn). An ar-
                               ray named player stores the Players. In keeping with the zero indexing
                               convention of arrays, we number the players from 0 to nPlayers-1. These
                               variables are all declared protected, so that they can be referenced di-
                               rectly by ComputerGame subclasses, but as protected variables, they
                               remain hidden from all other classes.

                                  The ComputerGame(int) constructor allows the number of players
                               to be set when the game is constructed. The default constructor sets the
                               number of players to one. The constructors create an array of length
                               nPlayers:

                                                                                                            

                               public ComputerGame ( i n t n ) {

                                    nPlayers = n;

                                    p l a y e r = new P l a y e r [ n ] ; // C r e a t e t h e a r r a y

                               }

                                                                                                            
SECTION 9.11  Case Study: An N-Player Computer Game  433

The setPlayer() and getPlayer() methods are the mutator and ac-               
cessor methods for the whoseTurn variable. This variable allows a user        
to determine and set whose turn it is, a useful feature for initializing a
game. The changePlayer() method uses the default expression,                  
                                                                              
 
                                                                               polymorphism
     whoseTurn = ( whoseTurn + 1) % nPlayers
 

for changing whose turn it is. Assuming that players are numbered from 0
to nPlayers-1, this code gives the turn to the next player, wrapping around
to player 0, if necessary. Of course, a subclass of ComputerGame can
override this method if the game requires some other order of play.

   The addPlayer(Player) method is used to add a new Player to
the game, including any subclass of Player. The method assumes that
addedPlayers is initialized to 0. It increments this variable by 1 each
time a new player is added to the array. For the game WordGuess, we
would be adding Players of type WordGuesser to the game.

   The complete source code for ComputerGame is shown in Figure 9.31.
There are several points worth noting about this implementation. First,
note that just as in the case of the abstract TwoPlayerGame class from
Chapter 8, the methods gameOver() and getWinner() are defined as
abstract and the getRules() method is given a generic implementa-
tion. The intent here is that the subclass will override getRules() and
will provide game-specific implementations for the abstract methods.

   Second, note how the addPlayer() method is coded. It uses the
addedPlayers variable as the index into the player array, which al-
ways has length nPlayers. An attempt to call this method when the
array is already full will lead to the following exception being thrown by
Java:

 

    Exception in thread ` ` main ' '
           java . lang . ArrayIndexOutOfBoundsException : 2
           a t ComputerGame . addPlayer ( ComputerGame . j a v a : 2 2 )
           a t TwentyOne . main ( TwentyOne . j a v a : 1 2 1 )

 

In other words, it is an error to try to add more players than will fit in
the player array. In Chapter 11, we will learn how to design our code to
guard against such problems.

   Finally, note the implementation of the listPlayers() method
(Fig. 9.31). Here is a good example of polymorphism at work.
The elements of the player array have a declared type of Player.
Their dynamic type is WordGuesser. So when the expression
player[k].toString() is invoked, dynamic binding is used to bind
this method call to the implementation of toString() defined in the
WordGuesser class. Thus, by allowing toString() to be bound at run
time, we are able to define a method here that doesn't know the exact
types of the objects it will be listing.

   The power of polymorphism is the flexibility and extensibility it lends
to our class hierarchy. Without this feature, we would not be able to define
                             434     CHAPTER 9  Arrays and Array Processing

                             listPlayers() here in the superclass, and would instead have to define
                             it in each subclass.

                             JAVA EFFECTIVE DESIGN Extensibility. Polymorphic methods
                             allow us to implement methods that can be applied to
                             yet-to-be-defined subclasses.

                             9.11.3 The WordGuess and WordGuesser Classes

                             We will assume here that you are familiar with the WordGuess example
                             from Chapter 8. If not, you will need to review that section before proceed-
                             ing. Word Guess is a game in which players take turns trying to guess a
                             secret word by guessing its letters. Players keep guessing as long as they
                             correctly guess a letter in the word. If they guess wrong, it becomes the
                             next player's turn. The winner of the game is the person who guesses the
                             last letter secret letter, thereby completely identifying the word.

                                Figure 9.32 provides an overview of the WordGuess class. If you com-
                             pare it with the design we used in Chapter 8, the only change in the in-
                             stance methods and instance variables is the addition of a new constructor,
                             WordGuess(int), and an init() method. This constructor takes an in-
                             teger parameter representing the number of players. The default construc-
                             tor assumes that there is one player. Of course, this version of WordGuess
                             extends the ComputerGame class, rather than the TwoPlayerGame class.
                             Both constructors call the init() method to initialize the game:

Figure 9.32:  The WordGuess                                                                                
class.
                                  public WordGuess ( ) { super ( 1 ) ; i n i t ( ) ; }

                                  public WordGuess ( i n t m) { super (m) ; i n i t ( ) ; }

                                  public void i n i t ( ) {

                                     secretWord = getSecretWord ( ) ;

                                     currentWord = new S t r i n g B u f f e r ( secretWord ) ;

                                     previousGuesses = new S t r i n g B u f f e r ( ) ;

                                     for ( int k = 0; k < secretWord . length ( ) ; k++)

                                     currentWord . setCharAt (k , ' ? ' ) ;

                                     unguessedLetters = secretWord . length ( ) ;

                                  }

                                                                                                           

                                The only other change required to convert WordGuess to an N-player
                             game, is to rewrite its play() method. Because the new play() method
                             makes use of functionality inherited from the ComputerGame() class,
SECTION 9.11  Case Study: An N-Player Computer Game       435

it is actually much simpler than the play() method in the Chapter 8
version:

                                                                                          

public void play ( UserInterface ui ) {
   ui . report ( getRules ( ) ) ;
   ui . report ( listPlayers ( ) ) ;
   ui . report ( reportGameState ( ) ) ;

   while ( ! gameOver ( ) ) {
      WordGuesser p = ( WordGuesser ) player [ whoseTurn ] ;
      if (p . isComputer ( ) )
          u i . r e p o r t ( submitUserMove ( p . makeAMove ( getGamePrompt ( ) ) ) ) ;
      else {
          ui . prompt ( getGamePrompt ( ) ) ;
          ui . report ( submitUserMove ( ui . getUserInput ( ) ) ) ;
      }

   ui . report ( reportGameState ( ) ) ;

   } // w h i l e

}

                                                                                          

The method begins by displaying the game's rules and listing its players.
The listPlayers() method is inherited from the ComputerGame class.
After displaying the game's current state, the method enters the play loop.
On each iteration of the loop, a player is selected from the array:

                                                                                   

   WordGuesser p = ( WordGuesser ) player [ whoseTurn ] ;                          

The use of the WordGuesser variable, p, just makes the code some-
what more readable. Note that we have to use a cast operator,
(WordGuesser), to convert the array element, a Player, into a
WordGuesser. Because p is a WordGuesser, we can refer directly to
its isComputer() method.

   If the player is a computer, we prompt it to make a move, submit the
move to the submitUserMove() method, and then report the result.
This is all done in a single statement:

                                                                                   

   u i . r e p o r t ( submitUserMove ( p . makeAMove ( getGamePrompt ( ) ) ) ) ;  

If the player is a human, we prompt the player and use the
KeyboardReader's getUserInput() method to read the user's move.
We then submit the move to the submitUserMove() method and report
the result. At the end of the loop, we report the game's updated state.
                              436  CHAPTER 9  Arrays and Array Processing

                              The following code segment illustrates a small portion of the interaction
                              generated by this play() method:

                                                                                                                 

                                   Current word ? ? ? ? ? ? ? ? Previous g u e s s e s GLE

                                   P l a y e r 0 g u e s s e s next . Sorry , Y i s NOT a new l e t t e r

                                                            i n t h e s e c r e t word

                                   Current word ? ? ? ? ? ? ? ? Previous g u e s s e s GLEY

                                   P l a y e r 1 g u e s s e s next . Sorry , H i s NOT a new l e t t e r

                                                            i n t h e s e c r e t word

                                   Current word ? ? ? ? ? ? ? ? Previous g u e s s e s GLEYH

                                   Player 2 guesses next .

                                   Guess a l e t t e r t h a t you t h i n k i s i n t h e s e c r e t word : a

                                   Yes , t h e l e t t e r A i s i n t h e s e c r e t word                      

                              In this example, players 0 and 1 are computers and player 2 is a human.
                                 In our new design, the WordGuesser class is a subclass of Player

                              (Figure 9.33). The WordGuesser class itself requires no changes other
                              than its declaration:

                                                                                                                 

                                   public class WordGuesser extends Player                                       

Figure 9.33: The WordGuesser  As we saw when we were discussing the WordGuess class, the play()
class extends Player.         method invokes WordGuesser's isComputer() method. But this
                              method is inherited from the Player class. The only other method used
                              by play() is the makeAMove() method. This method is coded exactly
                              the same as it was in the previous version of WordGuesser.

                                 Figure 9.34 shows the implementation of the Player class. Most of
                              its code is very simple. Note that the default value for the kind vari-
                              able is HUMAN and the default id is -1, indicating the lack of an assigned
                              identification.

                                 What gives Player its utility is the fact that it encapsulates those at-
                              tributes and actions that are common to all computer game players. Defin-
                              ing these elements, in the superclass, allows them to be used throughout
                              the Player hierarchy. It also makes it possible to establish an association
                              between a Player and a ComputerGame.

                                 Given the ComputerGame and Player hierarchies and the many in-
                              terfaces they contain, the task of designing and implementing a new N-
                              player game is made much simpler. This too is due to the power of object-
                              oriented programming. By learning to use a library of classes, such as
SECTION 11  A GUI-Based Game                                   437

these, even inexperienced programmers can create relatively sophisticated
and complex computer games.

JAVA EFFECTIVE DESIGN Code Reuse. Re-using library code by
extending classes and implementing interfaces makes it much simpler
to create sophisticated applications.

   Finally, the following main() method instantiates and runs an instance
of the WordGuess game in a command-line user interface (CLUI):

                                                                                  

public s t a t i c void main ( S t r i n g args [ ] )

{ KeyboardReader kb = new KeyboardReader ( ) ;

  ComputerGame game = new WordGuess ( 3 ) ;

  game . addPlayer (new WordGuesser ( ( WordGuess ) game , 0 ,

                                                       P l a y e r .HUMAN) ) ;

  game . addPlayer (new WordGuesser ( ( WordGuess ) game , 1 ,

                                                       P l a y e r .COMPUTER ) ;

  game . addPlayer (new WordGuesser ( ( WordGuess ) game , 2 ,

                                                       P l a y e r .COMPUTER ) ;

  ( ( CLUIPlayableGame ) game ) . play ( kb ) ;

} // main ( )

                                                                                  

In this example, we create a three player game in which two of the players
are computers. Note how we create a new WordGuesser, passing it a
reference to the game itself, as well as its individual identification num-
ber, and its type (HUMAN or COMPUTER). To run the game, we simply
invoke its play() method. You know enough now about object-oriented
design principles to recognize that the use of play() in this context is an
example of polymorphism.

9.12 A GUI-Based Game (Optional Graphics)

Most modern computer games do not use a command-line interface. This
section addresses this shortcoming by expanding our ComputerGame hi-
erarchy so that it works with Graphical User Interfaces (GUIs) as well as
Command-Line User Interfaces (CLUIs).

   The Sliding Tile Puzzle is a puzzle game. It is played by one player,
a human. The puzzle consists of six tiles arranged on a board contain-
ing seven spaces. Three of the tiles are labeled L and three are labeled R.
Initially the tiles are arranged as RRR LLL. In other words, the R tiles are
arranged to the left of the L tiles, with the blank space in the middle. The
object of the puzzle is to rearrange the tiles into LLL RRR. The rules are
that tiles labeled R can only move right. Tiles labeled L can only move
left. Tiles may move directly into the blank space or they can jump over
one tile into the blank space.

   Our purpose in this section is to develop a GUI that plays this game.
An appropriate GUI is shown Figure 9.35. Here the tiles and the blank
space are represented by an array of buttons. To make a move the user
clicks on the 'tile' he or she wishes to move. The GUI will assume that the
user wants to move that tile into the blank space. If the proposed move
                                   438  CHAPTER 9  Arrays and Array Processing

                                   is legal, the GUI will carry out the move. Otherwise, it will just ignore it.
                                   For example, if the user were to click on the third R button from the left,
                                   a legal move, the GUI would rearrange the labels on the buttons so that
                                   their new configuration would be RR RLLL. On the other hand, if the user
                                   were to click on the rightmost L button, the GUI would ignore that move,
                                   because it is illegal.

                                   9.12.1 The GUIPlayableGame Interface

                                   How should we extend our game-playing hierarchy to accommodate

                                   GUI-based games? As we learned in Chapter 4, one difference between

                                   GUI-based applications and CLUI-based applications, is the locus of con-

                                   trol. In a CLUI-based application, control resides in the computational ob-

                                   ject which, for games, is the game object. That's why the play() method

                                   in our CLUI-based games contains the game's control loop. By contrast,

                                   control resides in the GUI's event loop in GUI-based applications. That's

                                   why, we learned how to manage Java's event hierarchy in Chapter 4.
                                   Thus, in the GUI shown in Figure 9.35, the GUI will listen and take action

                                   when the user clicks one of its buttons.

                                   However, given that control will reside in the GUI, there is still a need

                                   for communication between the GUI and the game object. In the CLUI-

                                   based games, we have used the CLUIPlayableGame interface to man-

                                   age the communication between the game and the user interface. We

                                   will follow the same design strategy in this case. Thus, we will design a

                                   GUIPlayableGame interface that can be implemented by any game that

                                   wishes to use a GUI (Fig. 9.36).

                                   What method(s) should this interface contain? One way to answer this

                                   question is to think about the type of interaction that must take place when
                                   the user clicks one of the tiles. If the user clicks the third R button, the

                                   GUI should pass this information to the game. The game should then

                                   decide whether or not that is a legal move and communicate this back to

                                   the GUI. Assuming it is a legal move, the game should also update its

                                   representation of the game's state to reflect that the tile array has changed.

                                   And it should somehow make communicate the game's state to the GUI.

                                   Because it is impossible to know in advance just what form of data

                                   a game's moves might take, we will use Java Strings to communicate

Figure  9.36:                 The  between the user interface and the game object. Thus, a method with the

GUIPlayableGame interface          following signature will enable us to submit a String representing the

extends the IGame interface.       user's move to the game and receive in return a String representing the

                                   game object's response to the move:

                                                                                                                   

                                        submitUserMove ( S t r i n g move ) : S t r i n g ;                        

                                   In addition to this method, a GUI interface could use the reportGame-
                                   State() and getGamePrompt() methods that are part of the IGame
                                   interface. Th design shown in Figure 9.36 leads to the following definition
                                   for the GUIPlayableGame interface:

                                                                                                                   

                                   public i n t e r f a c e GUIPlayableGame extends IGame {

                                        public String submitUserMove ( String theMove ) ;

                                   }

                                                                                                                   
SECTION 12  A GUI-Based Game                                                       439

Because it extends IGame, this interface inherits the getGamePrompt()
and reportGameState() from the IGame interface. The GUI should be
able to communicate with any game that implements this interface.

9.12.2 The SlidingTilePuzzle

Let's now discuss the design and details of the SlidingTilePuzzle it-
self. Its design is summarized in Figure 9.37. Most of the methods should
be familiar to you, because the design closely follows the design we em-
ployed in the WordGuess example. It has implementations of inher-
ited methods from the ComputerGame class and the GUIPlayableGame
interface.

   We will represent the sliding tile puzzle in a one-dimensional array of
char. We will store the puzzle's solution in a Java String and we will
use an int variable to keep track of where the blank space is in the array.
This leads to the following class-level declarations:

                                                                                         
                                                                                         
    private  char puzzle [ ] = { 'R ' , 'R ' , 'R ' , '  ' , 'L ' , 'L ' , 'L ' };
    private  S t r i n g s o l u t i o n = "LLL RRR" ;
    private  int blankAt = 3;


Note how we initialize the puzzle array with the initial configuration of
seven characters. Taken together, these statements initialize the puzzle's
state.

   Because a puzzle is a one-person game and our sliding tile puzzle will
be played by a human, this leads to a very simple constructor definition:

                                                                                         

    public SlidingTilePuzzle () {                                                        쯊igure  9.37:  The

           super ( 1 ) ;

   }


We call the super() constructor (ComputerGame()) to create a one-                        SlidingTilePuzzle is a
person game.
                                                                                         ComputerGame that implements
   The puzzle's state needs to be communicated to the GUI as a String.
This is the purpose of the reportGameState() method:                                     the GUIPlayableGame interface.

                                                                                         

    public String reportGameState () {                                                   
           S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
           sb . append ( puzzle ) ;
           return sb . toString ( ) ;

   }


We use a StringBuffer() to convert the puzzle, a char array, into a
String.
440                        CHAPTER 9  Arrays and Array Processing

   The most important method for communicating with the GUI is the
submitUserMove() method:

                                                                    

public String submitUserMove ( String usermove ) {

     int t i l e = Integer . parseInt ( usermove ) ;

     char ch = puzzle [ t i l e ] ;

     i f ( ch == ' L ' &&

           ( blankAt == t i l e -1 | | blankAt == t i l e -2))

     swapTiles ( tile , blankAt ) ;

     e l s e i f ( ch == 'R ' &&

           ( blankAt == t i l e +1 | | blankAt == t i l e + 2 ) )

     swapTiles ( tile , blankAt ) ;

     else

     r e t u r n " That ' s an i l l e g a l move . \ n" ;

     r e t u r n " That move i s l e g a l . \ n" ;

}

                                                                    

This is the method that processes the user's move, which is communi-
cated through the GUI. As we saw, the puzzle's 'tiles' are represented by
an array of buttons in the GUI. The buttons are indexed 0 through 6 in the
array. When the user clicks a button, the GUI should pass its index, repre-
sented as a String to the submitUserMove() method. Given the index
number of the tile that was selected by the user, this method determines if
the move is legal.

   The Integer.parseInt() method is used to extract the tile's index
from the method's parameter. This index is used to get a 'tile' from the
puzzle array. The logic in this method reflects the rules of the game. If
the tile is an L, then it can only move into a blank space that is either 1 or 2
spaces to its left. Similarly, an R tile can only move into a blank space that
is 1 or 2 spaces to its right. All other moves are illegal. For legal moves, we
simply swap the tile and the blank space in the array, a task handled by
the swap() method. In either case, the method returns a string reporting
whether the move was legal or illegal.

   Figure 9.38 shows the full implementation for the SlidingTilePuzzle,
the remaining details of which are straight forward.
SECTION 12  A GUI-Based Game                       441

9.12.3 The SlidingGUI Class

Let's now implement a GUI that can be used to play the sliding tile puzzle.      Figure  9.39:  The SlidingGUI
We will model the GUI itself after those we designed in Chapter 4.               class.

   Figure 9.39 provides a summary of the design. As an implemen-
tor of the ActionListener interface, SlidingGUI implements the
actionPerformed() method, which is where the code that controls the
puzzle is located. The main data structure is an array of seven JButtons,
representing the seven tiles in the puzzles. The buttons' labels will reflect
the state of the puzzle. They will be rearranged after every legal move by
the user. The reset button is used to reinitialize the game. This allows
users to play again or to start over if they get stuck.

   The puzzleState is a String variable that stores the puzzle's current
state, which is updated repeatedly from the SlidingTilePuzzle by
calling its reportGameState() method. The private labelButtons()
method will read the puzzleState and use its letters to set the labels of
the GUI's buttons.

   The implementation of SlidingGUI is shown in Figure 9.40. Its con-
structor and buildGUI() methods are responsible for setting up the GUI.
We use of a for loop in buildGUI() to create the JButtons, asso-
ciate an ActionListener with them, and add them to the GUI. Except
for the fact that we have an array of buttons, this is very similar to the
GUI created in Chapter 4. Recall that associating an ActionListener
with the buttons allows the program to respond to button clicks in its
actionPerformed() method.

   Note how an instance of the SlidingTilePuzzle is created in the
constructor, and how its state is retrieved and stored in the puzzleState
variable:

                                                                                 

  puzzleState = sliding . reportGameState ( ) ;                                  

The labelButtons() method transfers the letters in puzzleState
onto the buttons.

   The most important method in the GUI is the actionPerformed()
method. This method controls the GUI's actions and is called automat-
ically whenever one of the GUI's buttons is clicked. First, we check
whether the reset button has been clicked. If so, we reset the puzzle
by creating a new instance of SlidingTilePuzzle and re-initializing
the prompt label.

   Next we use a for loop to check whether one of the tile buttons has
been clicked. If so, we use the loop index, k, as the tile's identification and
submit this to the puzzle as the user's move:

                                                                                 

i f ( e . g e t S o u r c e ( ) == t i l e [ k ] )

  r e s u l t = ( ( GUIPlayableGame ) sliding ) . submitUserMove ( ""+ k ) ;     

The cast operation is necessary here because we declared sliding as
a SlidingTilePuzzle rather than as a GUIPlayableGame. Note
also that we have to convert k to a String when passing it to
submitUserMove().
                 442              CHAPTER 9  Arrays and Array Processing

                    As a result of this method call, the puzzle returns a result, which is
                 checked to see if the user's move was illegal. If result contains the word
                 "illegal", the computer beeps to signal an error:

                                                                                                    

                      i f ( r e s u l t . indexOf ( " i l l e g a l " ) != -1)

                      java . awt . Toolkit . getDefaultToolkit ( ) . beep ( ) ;                     

                 The java.awt.Toolkit is a class that contains lots of useful meth-
                 ods, including the beep() method. Note that no matter what action
                 is performed, a reset or a tile click, we update puzzleState by call-
                 ing reportGameState() and use it to relabel the tile buttons. The
                 last task in the actionPerformed() method is to invoke the puzzle's
                 gameOver() method to check if the user has successfully completed the
                 puzzle. If so, we display a congratulatory message in the GUI's window.

                    Finally, the main() for a GUI is very simple, consisting of a single line
                 of code:

                                                                                                    

                      new SlidingGUI ( " S l i d i n g T i l e Puzzle " ) ;                         

                 Once a SlidingGUI is created, with the title of "Sliding Tile Puzzle," it
                 will open a window and manage the control of the puzzle.

CHAPTER SUMMARY  Technical Terms

                 array            insertion sort                                sequential search
                 array            multidimensional                              sorting
                                                                                subscript
                    initializer      array                                      two-dimensional
                 array length     one-dimensional
                 binary search                                                     array
                 data structure      array
                 element          polymorphic sort
                 element type
                                     method
                                  selection sort

                 Summary of Important Points

                  An array is a named collection of contiguous storage locations, each
                    of which stores a data item of the same data type. Each element of an
                    array is referred to by a subscript--that is, by its position in the array. If
                    the array contains N elements, then its length is N and its indexes are
                    0, 1, ...N-1.

                  Array elements are referred to using the following subscript notation
                    arrayname[subscript], where arrayname is any valid identifier, and sub-
                    script is an integer value in the range 0 to arrayname.length - 1.
                    The array's length instance variable can be used as a bound for loops
                    that process the array.
CHAPTER 9  Solutions to Self-Study Exercises                                             443

 An array declaration provides the name and type of the array. An array
  instantiation uses the keyword new and causes the compiler to allocate
  memory for the array's elements:

                                                                                               

  int arr [ ] ; // D e c l a r e a one - d i m e n s i o n a l a r r a y v a r i a b l e

  a r r = new i n t [ 1 5 ] ; / / A l l o c a t e 1 5 i n t l o c a t i o n s f o r i t        


 Multidimensional arrays have arrays as their components:

                                                                                               

  int twoDarr [ ] [ ] ; // D e c l a r e a    two - d i m e n s i o n a l a r r a y v a r i a b l e
  twoDarr = new i n t [ 1 0 ] [ 1 5 ] ; //
                                              Allocate 150 int locations

                                                                                            

 An array's values must be initialized by assigning values to each array
  location. An initializer expression may be included as part of the array
  declaration.

 Insertion sort and selection sort are examples of array sorting algo-
  rithms. Both algorithms require several passes over the array.

 When an array is passed as a argument to a method, a reference to the
  array is passed rather than the entire array itself.

 Swapping two elements of an array, or any two locations in memory,
  requires the use of a temporary variable.

 Sequential search and binary search are examples of array searching
  algorithms. Binary search requires that the array be sorted.

 For multidimensional arrays, each dimension of the array has its own
  length variable.

 Inheritance and polymorphism are useful design features for develop-
  ing a hierarchy of computer games.

SOLUTION 9.1 Space (in bytes) allocated for each of the following?                             SOLUTIONS TO
                                                                                               SELF-STUDY EXERCISES
  a. int a[] = new int[5];                    // 5 * 4 = 20 bytes

  b. double b[] = new double[10]; // 10 * 8 = 80 bytes

  c. char c[] = new char[30];                 // 30 * 2 = 60 bytes

d. String s[] = new String[10]; // 10 * 4 (reference) = 40 bytes

  e. Student s[] = new Student[5]; // 5 * 4 (reference) = 20 bytes

SOLUTION 9.2 An array containing 10 floats, 1.0 to 10.0.

                                                                                          

float farr [] = {1.0 ,2.0 ,3.0 ,4.0 ,5.0 ,6.0 ,7.0 ,8.0 ,9.0 ,10.0};                      


SOLUTION 9.3 Prints the first element of farr.

                                                                                          

System . out . println ( farr [ 0 ] ) ;                                                   


SOLUTION 9.4 Assigns 100.0 to the last element in farr.

                                                                                          

f a r r [ f a r r . length -1] = 1 0 0 . 0 ;
                                                                                          
444                    CHAPTER 9  Arrays and Array Processing

SOLUTION 9.5 A loop to print all of the elements of farr.

                                                                                     

for ( int j = 0; j < farr . length ; j ++)

     System . out . println ( farr [ j ] ) ;                                         

SOLUTION 9.6 An array containing the first 100 square roots.

                                                                                     

double doubarr [ ] = new double [ 1 0 0 ] ;

for ( int k = 0; k < doubarr . length ; k++)

     doubarr [ k ] = Math . s q r t ( k + 1 ) ;                                      

SOLUTION 9.7 Analyzing the letter frequencies in a file.

                                                                                     

import java . io .  ;

import java . u t i l . Scanner ;

public s t a t i c void main ( S t r i n g [ ] argv ) {

  Scanner fileScan ; // To read l i n e s of t e x t                          from   the f i l e
                                                                            text       Windows
  String str ;         // To s t o r e t h e l i n e o f
                                                                             // For              
  AnalyzeFreq a f = new AnalyzeFreq ( ) ;                                   count

  try {               // C r e a t e a S c a n n e r

     F i l e t h e F i l e = new F i l e ( " f r e q t e s t . t x t " ) ;

     fileScan = Scanner . create ( theFile ) ;

     fileScan = fileScan . useDelimiter ( "\r\n" ) ;

     while ( fileScan . hasNext ( ) ) { // Read and

     str = fileScan . next ( ) ;

     af . countLetters ( str );

     } // w h i l e

     af . printArray ( ) ; // P r i n t f r e q u e n c i e s

  } catch ( Exception e) {

     e . printStackTrace ();

  } // c a t c h ( )

  } // main ( )


SOLUTION 9.8 Sort 24 18 90 1 0 85 34 18 with insertion sort.

                                                                                     

  24 18 90 1 0 85 34 18 // I n i t i a l

  18 24 90 1 0 85 34 18 // P a s s 1

  18 24 90 1 0 85 34 18 // P a s s 2

  1 18 24 90 0 85 34 18 // P a s s 3

  0 1 18 24 90 85 34 18 // P a s s 4

  0 1 18 24 85 90 34 18 // P a s s 5

  0 1 18 24 34 85 90 18 // P a s s 6

  0 1 18 18 24 34 85 90 // P a s s 7                                                 
CHAPTER 9  Solutions to Self-Study Exercises                                                445

SOLUTION 9.9 Sort 24 18 90 1 0 85 34 18 with selection sort.

                                                                                             

24 18 90 1 0 85 34 18 // I n i t i a l

0 18 90 1 24 85 34 18 // P a s s 1

0 1 90 18 24 85 34 18 // P a s s 2

0 1 18 90 24 85 34 18 // P a s s 3

0 1 18 18 24 85 34 90 // P a s s 4

0 1 18 18 24 85 34 90 // P a s s 5

0 1 18 18 24 34 85 90 // P a s s 6

0 1 18 18 24 34 85 90 // P a s s 7
                                                                                             

SOLUTION 9.10 Code to swap two Students.

                                                                                             

Student tempStud = student1 ;

student1 = student2 ;

student2 = tempStud ;
                                                                                             

SOLUTION 9.11 Implementation of the selectionSort().

                                                                                             

  public void selectionSort ( int arr [ ] ) {

  int smallest ;                       // L o c a t i o n o f s m a l l e s t e l e m e n t

  for ( int k = 0; k < arr . length -1; k++) {

      smallest = k;

      for ( int j = k+1; j < arr . length ; j ++)

      if ( arr [ j ] < arr [ smallest ])

                smallest = j ;

      if ( smallest != k) { // Swap s m a l l e s t and kth

      i n t temp = a r r [ s m a l l e s t ] ;

      arr [ smallest ] = arr [k];

      a r r [ k ] = temp ;

      } // i f

  } // o u t e r f o r

} // s e l e c t i o n S o r t ( )

                                                                                             

SOLUTION 9.12 After mystery(myArr,k), myArr will store 1,2,3,5,5 and k
will store 3.

SOLUTION 9.13 Binary search trace for 21 in 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
24, 26, 28:

                                                                                             

key i t e r a t i o n low high mid
--------------------------------------

21 0            0                   13  6

21 1            7                   13  10

21 2            7                   9   8

21 3            9                   9   9

21 4            10                  9   failure                                              


SOLUTION 9.14 A two-dimensional array with 5 rows of 10 integers.

                                                                                             

i n t i n t 2 d [ ] [ ] = new i n t [ 5 ] [ 1 0 ] ;                                          

446                         CHAPTER 9  Arrays and Array Processing

SOLUTION 9.15 Prints the last integer in the third row int2d and assigns 100
to its last element.

                                                                

System . out . println ( int2d [ 2 ] [ 9 ] ) ;

int2d [4][9] = 100;
                                                                

SOLUTION 9.16 Prints all of the elements of int2d.

                                                                

for ( int k = 0; k < int2d . length ; k++) {

     for ( int j = 0; j < int2d [k ] . length ; j ++)

     System . out . print ( int2d [k ] [ j ] + " " ) ;

     System . out . println ( ) ;      // new l i n e

}

                                                                

SOLUTION 9.17 A 52  7 two-dimensional array of int.

                                                                

i n t s a l e s [ ] [ ] = new i n t [ 5 2 ] [ 7 ] ;

for ( int k = 0; k < sales . length ; k++)

     for ( int j = 0; j < sales [k ] . length ; j ++)

     sales [k][ j ] = 0;                                        

SOLUTION 9.18 A method to calculate average number of newspapers per
week.

                                                                

double avgWeeklySales ( int arr [ ] [ ] ) {

     double t o t a l = 0;

     for ( int k = 0; k < arr . length ; k++)

     for ( int j = 0; j < arr [k ] . length ; j ++)

     t o t a l += a r r [ k ] [ j ] ;

     return total /52;

}

                                                                

SOLUTION 9.19 A method to calculate average Sunday newspapers.

                                                                

double avgSundaySales ( int arr [ ] [ ] ) {

     double t o t a l = 0;

     for ( int k = 0; k < arr . length ; k++)

     t o t a l += a r r [ k ] [ 6 ] ;

     return total /52;

}

                                                                
CHAPTER 9  Exercises                                                      447

SOLUTION 9.20 A compareTo() for LetterFreq.

                                                                           

public int compareTo ( Object l f ) {

       LetterFreq letFreq = ( LetterFreq ) lf ;

       if ( freq < letFreq . getFreq ())

         return -1;

       else if ( freq > letFreq . getFreq ())

         return +1;

       else return 0; // The f r e q u e n c i e s must be e q u a l .

} // compareTo ( )

                                                                           

SOLUTION 9.21 A sort() for AnalyzeFreq.

                                                                           

public void sort ( ) {

       java . util . Arrays . sort ( freqArr ) ;

} // s o r t ( )

                                                                           

SOLUTION 9.22 A new AnalyzeFreq.main() that uses sort().

                                                                           

public s t a t i c void main ( S t r i n g [ ] argv ) {

  AnalyzeFreq a f = new AnalyzeFreq ( ) ;

  a f . c o u n t L e t t e r s ( "Now i s t h e time f o r a l l good s t u d e n t s " +

       " to study computer-r e l a t e d t o p i c s . " ) ;

  af . sort ();

  af . printArray ( ) ;

} // main ( )

                                                                           

EXERCISE 9.1 Explain the difference between the following pairs of terms:                   EXERCISES

a. An element and an element type.                                                          Note: For programming exercises,
b. A subscript and an array element.                                                        first draw a UML class diagram
c. A one-dimensional array and two-dimensional array.                                       describing all classes and their
d. An array and a vector.                                                                   inheritance relationships and/or
e. A insertion sort and a selection sort.                                                   associations.
f. A binary search and a sequential search.

EXERCISE 9.2 Fill in the blanks.

a. The process of arranging an array's elements into a particular order is known

  as                 .

b. One of the preconditions of the binary search method is that the array has to be

                  .

c. An                   is an object that can store a collection of elements of the same

  type.

d. An                   is like an array except that it can grow.

e. For an array, its        is represented by an instance variable.

f. An expression that can be used during array instantiation to assign values to

  the array is known as an        .
448                            CHAPTER 9  Arrays and Array Processing

g. A  is an array of arrays.

h. A sort method that can be used to sort different types of data is known as a

      method.

i. To instantiate an array you have to use the            operator.

j. An array of objects stores       to the objects.

EXERCISE 9.3 Make each of the following array declarations:

a. A 4  4 array of doubles.
b. A 20  5 array of Strings.
c. A 3  4 array of char initialized to `*';
d. A 2  3  2 array of boolean initialized to true.
e. A 3  3 array of Students.
f. A 2  3 array of Strings initialized to "one," "two," and so on.

EXERCISE 9.4 Identify and correct the syntax error in each of the following
expressions:

a. int arr = new int[15];
b. int arr[] = new int(15);
c. float arr[] = new [3];
d. float arr[] = new float {1.0,2.0,3.0};
e. int arr[] = {1.1,2.2,3.3};
f. int arr[][] = new double[5][4];
g. int arr[][] = { {1.1,2.2}, {3.3, 1} };

EXERCISE 9.5 Evaluate each of the following expressions, some of which may
be erroneous:

                                                                           

  int arr [] = { 2 ,4 ,6 ,8 ,10 };                                                
                                    f. arr[ 5 % 2 ]
                                    g. arr[ arr[ arr[0] ] ]
  a. arr[4]                         h. arr[ 5 / 2.0 ]
  b. arr[ arr.length ]              i. arr[ 1 + (int) Math.random() ]
  c. arr[ arr[0] ]                  j. arr[ arr[3] / 2 ]
  d. arr[ arr.length / 2 ]
  e. arr[ arr[1] ]

EXERCISE 9.6 What would be printed by the following code segment?

                                                                           

int arr [ ] = { 24 , 0 , 19 , 21 , 6 , -5, 10 , 16};

f o r ( i n t k = 0 ; k < a r r . l e n g t h ; k += 2 )

  System . out . println ( arr [k] ) ;                                     

EXERCISE 9.7 What would be printed by the following code segment?

                                                                           

int arr [ ] [ ] = { {24 , 0 , 19} , {21 , 6 , -5}, {10 , 16 , 3} ,

                                                          {1 , -1, 0} } ;

for ( int j = 0; j < arr . length ; j ++)

  for ( int k = 0; k < arr [ j ] . length ; k++)

      System . out . println ( arr [ j ] [ k] ) ;                          
CHAPTER 9  Exercises                                                    449

EXERCISE 9.8 What would be printed by the following code segment?

                                                                         

int arr [ ] [ ] = { {24 , 0 , 19} , {21 , 6 , -5}, {10 , 16 , 3} ,

                                                        {1 , -1, 0} } ;

for ( int j = 0; j < arr [ 0 ] . length ; j ++)

   for ( int k = 0; k < arr . length ; k++)

           System . out . println ( arr [k ] [ j ] ) ;                   

EXERCISE 9.9 What's wrong with the following code segment, which is sup-
posed to swap the values of the int variables, n1 and n2?

                                                                         

i n t temp = n1 ;

n2 = n1 ;

n1 = temp ;
                                                                         

EXERCISE 9.10 Explain why the following method does not successfully swap
the values of its two parameters? Hint: Think about the difference between value
and reference parameters.

                                                                         

public void swapEm( i n t n1 , i n t n2 ) {

   i n t temp = n1 ;

   n1 = n2 ;

   n2 = temp ;

}

                                                                         

EXERCISE 9.11 Declare and initialize an array to store the following two-
dimensional table of values:

                                                                         

1234

5678

9 10 11 12                                                               


EXERCISE 9.12 For the two-dimensional array you created in the previous ex-
ercise, write a nested for loop to print the values in the following order: 1 5 9 2 6
10 3 7 11 4 8 12. That is, print the values going down the columns instead of going
across the rows.

EXERCISE 9.13 Define an array that would be suitable for storing the following
values:

a. The GPAs of 2,000 students.
b. The lengths and widths of 100 rectangles.
c. A week's worth of hourly temperature measurements, stored so that it is easy

    to calculate the average daily temperature.
d. A board for a tic-tac-toe game.
e. The names and capitals of the 50 states.

EXERCISE 9.14 Write a code segment that will compute the sum of all the ele-
ments of an array of int.

EXERCISE 9.15 Write a code segment that will compute the sum of the elements
in a two-dimensional array of int.
450                CHAPTER 9  Arrays and Array Processing

EXERCISE 9.16 Write a method that will compute the average of all the ele-
ments of a two-dimensional array of float.

EXERCISE 9.17 Write a method that takes two parameters, an int array and an
integer, and returns the location of the last element of the array that is greater than
or equal to the second parameter.

EXERCISE 9.18 Write a program that tests whether a 3  3 array, input by the

user, is a magic square. A magic square is an N  N matrix of numbers in which
every number from 1 to N2 must appear just once, and every row, column, and

diagonal must add up to the same total--for example,

                   

672

159

834                


EXERCISE 9.19 Revise the program in the previous exercise so that it allows the
user to input the dimensions of the array, up to 4  4.

EXERCISE 9.20 Modify the AnalyzeFreq program so that it can display the
relative frequencies of the 10 most frequent and 10 least frequent letters.

EXERCISE 9.21 The merge sort algorithm takes two collections of data that have
been sorted and merges them together. Write a program that takes two 25-element
int arrays, sorts them, and then merges them, in order, into one 50-element array.

EXERCISE 9.22 Challenge: Design and implement a BigInteger class that
can add and subtract integers with up to 25 digits. Your class should also include
methods for input and output of the numbers. If you're really ambitious, include
methods for multiplication and division.

EXERCISE 9.23 Challenge: Design a data structure for this problem: As man-
ager of Computer Warehouse, you want to track the dollar amount of purchases
made by those clients that have regular accounts. The accounts are numbered
from 0, 1, ..., N. The problem is that you don't know in advance how many
purchases each account will have. Some may have one or two purchases. Others
may have 50 purchases.

EXERCISE 9.24 An anagram is a word made by rearranging the letters of another
word. For example, act is an anagram of cat, and aegllry is an anagram of allergy.
Write a Java program that accepts two words as input and determines if they are
anagrams.

EXERCISE 9.25 Challenge: An anagram dictionary is a dictionary that organizes
words together with their anagrams. Write a program that lets the user enter up
to 100 words (in a TextField, say). After each word is entered, the program
should display (in a TextArea perhaps) the complete anagram dictionary for
the words entered. Use the following sample format for the dictionary. Here the
words entered by the user were: felt, left, cat, act, opt, pot, top.

                   

act : act cat

eflt : felt left

opt : opt pot top  

CHAPTER 9  Exercises  451

EXERCISE 9.26 Acme Trucking Company has hired you to write software to
help dispatch its trucks. One important element of this software is knowing
the distance between any two cities that it services. Design and implement a
Distance class that stores the distances between cities in a two-dimensional ar-
ray. This class will need some way to map a city name, Boise, into an integer that
can be used as an array subscript. The class should also contain methods that
would make it useful for looking up the distance between two cities. Another
useful method would tell the user the closest city to a given city.

EXERCISE 9.27 Rewrite the main() method for the WordGuess example so
that it allows the user to input the number of players and whether each players is
a computer or a human. Use a KeyboardReader.

EXERCISE 9.28 Write a smarter version of the WordGuesser class that
"knows" which letters of the English language are most frequent. HINT: Rather
than using random guesses, store the player's guesses in a string in order of
decreasing frequency: "ETAONRISHLGCMFBDGPUKJVWQXYZ".

EXERCISE 9.29 Write a CLUI version of the SlidingTilePuzzle. You will
need to make modifications to the SlidingTilePuzzle class.
   452                              CHAPTER 9  Arrays and Array Processing

                                                                                              

public class TestSort {
   public s t a t i c i n t MAXSIZE = 2 5 ;

   public void sort ( Comparable [ ] arr ) {

   Comparable temp ;                // Temporary v a r i a b l e f o r i n s e r t i o n

   for ( int k = 1; k < arr . length ; k++) { // F o r e a c h e l e m e n t

      temp = a r r [ k ] ;                              // Remove i t

      int i ;

      f o r ( i = k-1; i >= 0 && a r r [ i ] . compareTo ( temp ) > 0 ; i --)

        arr [ i +1] = arr [ i ] ; // Move l a r g e r t o t h e r i g h t

      a r r [ i +1] = temp ;        // I n s e r t t h e e l e m e n t

   }

   } // s o r t ( )

   public void print ( Comparable arr [ ] ) {
      for ( int k = 0; k < arr . length ; k++) {
          i f ( k % 5 == 0 ) System . out . p r i n t l n ( ) ; // New r o w
             System . out . print ( arr [k ] . toString ( ) + "\ t " ) ;
      }

      System . out . println ( ) ;
   }

   // S o r t s two d i f f e r e n t t y p e s o f a r r a y w it h t h e same method .

   public s t a t i c void main ( S t r i n g args [ ] ) {
      I n t e g e r i A r r [ ] = new I n t e g e r [ T e s t S o r t . MAXSIZE ] ;
      F l o a t fArr [ ] = new F l o a t [ T e s t S o r t . MAXSIZE ] ;
      f o r ( i n t k = 0 ; k < T e s t S o r t . MAXSIZE ; k++) { // C r e a t e d a t a
          i A r r [ k ] = new I n t e g e r ( ( i n t ) ( Math . random ( )  1 0 0 0 0 ) ) ;
          fArr [ k ] = new F l o a t ( Math . random ( )  1 0 0 0 0 ) ;
      }

   T e s t S o r t t e s t = new T e s t S o r t ( ) ;

   test . sort ( iArr );            // S o r t and      print  Integers
                                                        print  Floats
   test . print ( iArr );

   test . sort ( fArr ) ;           // S o r t and

   test . print ( fArr ) ;

   } // main ( )

}

                                                                                              

   Figure 9.26: TestSort uses the polymorphic sort() method to sort
   either Integers or Floats.
CHAPTER 9  Exercises                                                             453

                                                                                                   

import java . u t i l . Vector ;

public c l a s s VectorDemo {

  public s t a t i c void printVector ( Vector v) {
     for ( int k=0; k < v . size ( ) ; k++)
         System . out . println (v . elementAt (k ) . toString ( ) ) ;

  } // p r i n t V e c t o r ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {
     V e c t o r v e c t o r = new V e c t o r ( ) ; // An e m p t y v e c t o r

        i n t bound = ( i n t ) ( Math . random ( )  2 0 ) ;

        f o r ( i n t k = 0 ; k < bound ; k++ ) // I n s e r t a r a n d o m

        v e c t o r . addElement ( new I n t e g e r ( k ) ) ; // n u m b e r o f I n t e g e r s

        printVector ( vector );   // P r i n t t h e e l e m e n t s

     }  // main ( )

  }//   VectorDemo

                                                                                                    

        Figure 9.28: Demonstration of the Vector class.

                                                                                                   Figure 9.29: Overview of the
                                                                                                   ComputerGame class hierarchy.
454                      CHAPTER 9  Arrays and Array Processing

                                                                          

public a b s t r a c t c l a s s ComputerGame {
   protected int nPlayers ;
   protected int addedPlayers = 0;
   protected int whoseTurn ;
   protected Player player [ ] ; // An a r r a y o f p l a y e r s

  public ComputerGame ( ) {

     nPlayers = 1;                // D e f a u l t : 1 p l a y e r game

     p l a y e r = new P l a y e r [ 1 ] ;

  }

  public ComputerGame ( i n t n ) {

     nPlayers = n;

     p l a y e r = new P l a y e r [ n ] ; // N- P l a y e r g a m e

  }

  public void setPlayer ( int s t a r t e r ) {

     whoseTurn = s t a r t e r ;

  }

  public int getPlayer () {

     return whoseTurn ;

  }

  public void addPlayer ( Player p) {

     player [ addedPlayers ] = p;

     ++addedPlayers ;

  }

  public void changePlayer ( ) {

     whoseTurn = ( whoseTurn + 1) % nPlayers ;

  }

  public String getRules () {

     r e t u r n "The r u l e s o f t h i s game a r e : " ;

  }

  public String listPlayers () {

     StringBuffer result =

     new S t r i n g B u f f e r ( "\nThe p l a y e r s a r e : \ n" ) ;

     for ( int k = 0; k < nPlayers ; k++)

     r e s u l t . append ( " Player " + k + " " +

                         player [ k ] . toString ( ) + "\n" ) ;

     r e s u l t . append ( "\n" ) ;

     return result . toString ( ) ;

  }

  public a b s t r a c t boolean gameOver ( ) ; // A b s t r a c t

  public abstract String getWinner ( ) ; // methods

} // ComputerGame

                                                                          

     Figure 9.31: Implementation of the ComputerGame class.
CHAPTER 9  Exercises                                                      455

                                                                           

public abstract   class Player {
   public static  f i n a l i n t COMPUTER= 0 ;
   public static  f i n a l i n t HUMAN= 1 ;
   protected int  id = -1; // I d b e t w e e n 0 and n P l a y e r s -1
   protected int  kind = HUMAN; // D e f a u l t i s HUMAN

     public Player () { }                                                  }
     public Player ( int id , int kind ) {                                   

         this . id = id ;
         this . kind = kind ;
     }

     public void setID ( int k) { id = k ; }
     public int getID () { return id ; }
     public void setKind ( int k) { kind = k ; }
     public int getKind ( ) { return kind ; }
     public boolean isComputer ( ) { r e t u r n kind == COMPUTER;
     public a b s t r a c t S t r i n g makeAMove( S t r i n g prompt ) ;
  } // P l a y e r


  Figure 9.34: Implementation of the Player class.

                                                                                Figure 9.35: The Sliding Tile Puz-
                                                                                zle.
456                                     CHAPTER 9  Arrays and Array Processing

                                                                                 

public c l a s s S l i d i n g T i l e P u z z l e extends ComputerGame
                                                  implements GUIPlayableGame {

   private char puzzle [ ] = { 'R ' , 'R ' , 'R ' , ' ' , 'L ' , 'L ' , 'L ' };
   p r i v a t e S t r i n g s o l u t i o n = "LLL RRR" ;
   private int blankAt = 3;
   public SlidingTilePuzzle ( ) { super ( 1 ) ; }

  public boolean gameOver ( ) { // T r u e i f p u z z l e           solved
     S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
     sb . append ( puzzle ) ;
     return sb . toString ( ) . equals ( solution ) ;

  }

  public String getWinner ( ) {
     i f ( gameOver ( ) )
         r e t u r n "\nYou did i t ! Very Nice ! \ n" ;
     e l s e r e t u r n "\nGood t r y . Try again ! \ n" ;

  }

  public String reportGameState () {
     S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;
     sb . append ( puzzle ) ;
     return sb . toString ( ) ;

  }

  public Stri ng getGamePrompt ( ) {
     r e t u r n "To move a t i l e , c l i c k on i t . " ;

  } // prompt ( )

  public String submitUserMove ( String usermove ) {

     int t i l e = Integer . parseInt ( usermove ) ;

     char ch = puzzle [ t i l e ] ;

     i f ( ch== ' L ' && ( blankAt== t i l e -1 | | blankAt== t i l e -2))

     swapTiles ( tile , blankAt ) ;

     e l s e i f ( ch== 'R ' &&

           ( blankAt== t i l e +1 | | blankAt== t i l e + 2 ) )

     swapTiles ( tile , blankAt ) ;

     else

     r e t u r n " That ' s an i l l e g a l move . \ n" ;

     r e t u r n " That move i s l e g a l . \ n" ;

  }

  private void swapTiles ( int ti , int bl ) {

     char ch = puzzle [ t i ] ;

     puzzle [ t i ] = puzzle [ bl ] ;

     puzzle [ bl ] = ch ;

     blankAt = t i ; // R e s e t t h e b l a n k

  }

} // S l i d i n g T i l e P u z z l e

                                                                                 

     Figure 9.38: Implementation of the SlidingTilePuzzle class.
CHAPTER 9  Exercises                                                                   457

                                                                                        

import javax . swing .  ;

import java . awt .  ;

import java . awt . event .  ;

public class SlidingGUI extends JFrame implements ActionListener {

  p r i v a t e J B u t t o n t i l e [ ] = new J B u t t o n [ 7 ] ;

  p r i v a t e J B u t t o n r e s e t = new J B u t t o n ( " R e s e t " ) ;

  private SlidingTilePuzzle sliding ;

  private String puzzleState ;

  private Label label ;

  p r i v a t e S t r i n g prompt = " Goal : [ LLL RRR ] . " +

  " C l i c k on t h e t i l e you want t o move . " +

  " I l l e g a l moves are ignored . " ;

  public SlidingGUI ( String t i t l e ) {

  s l i d i n g = new S l i d i n g T i l e P u z z l e ( ) ;

  buildGUI ( ) ;

  setTitle ( title );

  pack ( ) ;

  setVisible ( true );

  } // SlidingGUI ( )

  private void buildGUI ( ) {

  Container contentPane = getContentPane ( ) ;

  contentPane . s e t L a y o u t (new BorderLayout ( ) ) ;

  J P a n e l b u t t o n s = new J P a n e l ( ) ;

  puzzleState = sliding . reportGameState ( ) ;

  for ( int k = 0; k < t i l e . length ; k++) {

     t i l e [ k ] = new J B u t t o n ( " "+ p u z z l e S t a t e . charAt ( k ) ) ;

     tile [k ] . addActionListener ( this ) ;

     buttons . add ( t i l e [ k ] ) ;

  }

  reset . addActionListener ( this ) ;

  l a b e l = new Label ( prompt ) ;

  buttons . add ( r e s e t ) ;

  contentPane . add ( " Center " , buttons ) ;

  contentPane . add ( " South " , l a b e l ) ;

  } // buildGUI ( )

  private void labelButtons ( String s ) {

  for ( int k = 0; k < t i l e . length ; k++)

     t i l e [ k ] . setText ( ""+ s . charAt ( k ) ) ;

  } // l a b e l B u t t o n s ( )

  public void actionPerformed ( ActionEvent e ) {

  String result = "" ;

  i f ( e . g e t S o u r c e ( ) == r e s e t ) { // R e s e t c l i c k e d ?

     s l i d i n g = new S l i d i n g T i l e P u z z l e ( ) ;

     label . setText ( prompt ) ;

  }

  f o r ( i n t k = 0 ; k < t i l e . l e n g t h ; k++) // T i l e c l i c k e d ?

     i f ( e . g e t S o u r c e ( ) == t i l e [ k ] )

     r e s u l t = ( ( GUIPlayableGame ) sli ding ) . submitUserMove ( ""+ k ) ;

  i f ( r e s u l t . indexOf ( " i l l e g a l " ) != -1)

     java . awt . Toolkit . getDefaultToolkit ( ) . beep ( ) ;

  puzzleState = sliding . reportGameState ( ) ;

  labelButtons ( puzzleState );

  i f ( s l i d i n g . gameOver ( ) )

     l a b e l . s e t T e x t ( "You did i t ! Very n i c e ! " ) ;

  } // act ionPerf ormed ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  new SlidingGUI ( " S l i d i n g T i l e Puzzle " ) ;

  } // main ( )

} // SlidingGUI                                                                         


     Figure 9.40: Implementation of the SlidingGUI class.
458  CHAPTER 9  Arrays and Array Processing
Chapter 10

Exceptions: When Things
Go Wrong

OBJECTIVES

After studying this chapter, you will
 Understand Java's exception-handling mechanisms.
 Be able to use the Java try/catch statement.
 Know how to design effective exception handlers.
 Appreciate the importance of exception handling in program design.
 Be able to design your own Exception subclasses.

OUTLINE

10.1 Introduction
10.2 Handling Exceptional Conditions
10.3 Java's Exception Hierarchy
10.4 Handling Exceptions Within a Program
10.5 Error Handling and Robust Program Design
10.6 Creating and Throwing Your Own Exceptions
10.7 From the Java Library: javax.swing.JOptionPane

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              459
                    460                         CHAPTER 10  Exceptions: When Things Go Wrong

                    10.1 Introduction

Exception           Mistakes happen. Making mistakes is the norm rather than the exception.
Exception handling  This is not to say that we make mistakes more often than we get it right.
                    It is to say that (almost) nothing we do or build is ever perfectly correct,
                    least of all computer software. No matter how well-designed a program
                    is, there is always the chance that some kind of error will arise during its
                    execution.

                       An exception is an erroneous or anomalous condition that arises while
                    a program is running. Examples of such conditions that we have dis-
                    cussed in this text include attempting to divide by 0 (arithmetic excep-
                    tion), reading a decimal value when an integer is expected (number format
                    exception), attempting to write to a file that doesn't exist (I/O exception),
                    or referring to a nonexistent character in a string (index out of bounds
                    exception). The list of potential errors and anomalies is endless.

                       A well-designed program should include code to guard against errors
                    and other exceptional conditions when they arise. This code should be in-
                    corporated into the program from the very first stages of its development.
                    That way it can help identify problems during development. In Java, the
                    preferred way of handling such conditions is to use exception handling,
                    a divide-and-conquer approach that separates a program's normal code
                    from its error-handling code.

                       This chapter describes Java's exception handling features. We begin by
                    contrasting the traditional way of handling errors within a program with
                    Java's default exception-handling mechanism. We show how exceptions
                    are raised (thrown) and handled (caught) within a program and iden-
                    tify the rules that apply to different kinds of exceptions. We then focus
                    on some of the key design issues that govern when, where, and how to
                    use exceptions in your programs. Finally, we show how to design and
                    implement one's own Exception subclass.

                    10.2 Handling Exceptional Conditions

                    To introduce you to handling exceptional conditions, Figure 10.1 shows
                    a method that computes the average of the first N integers, an admit-

                                                                                           

                      / 

                       Precondition : N > 0

                       P o s t c o n d i t i o n : avgFirstN ( ) = ( 1 + 2 + . . . + N)/N

                      /

                    public double avgFirstN ( i n t N) {

                          i n t sum = 0 ;

                          f o r ( i n t k = 1 ; k <= N; k++)

                          sum += k ;

                          r e t u r n sum/N;    // What i f N i s 0?

                    } // a v g F i r s t N ( )

                                                                                           

                    Figure 10.1: Poor design. No attempt is made to guard against a divide-
                    by-zero error.
   SECTION 10.2  Handling Exceptional Conditions             461
                                                                       

  / 

   Precondition : N > 0

   P o s t c o n d i t i o n : a v g F i r s t N ( ) e q u a l s ( 1 + 2 + . . . + N) divided by N

  /

public double avgFirstN ( i n t N) {
       i n t sum = 0 ;
       i f (N <= 0 ) {
          System . out . println (
                   "ERROR avgFirstN : N <= 0 . Program t e r m i n a t i n g . " ) ;
          System . ex it ( 0 ) ;
       }

      f o r ( i n t k = 1 ; k <= N; k++)

      sum += k ;

      r e t u r n sum/N;    // What i f N i s 0?

} // a v g F i r s t N ( )

                                                                                                    

Figure 10.2: One way to handle a divide-by-zero error might be to ter-
minate the program, if there is an attempt to divide by 0, assuming it's
the kind of program that can be safely aborted. This version does not use
exception handling.

tedly contrived example. We use it mainly to illustrate the basic con-                              Divide-by-zero error
cepts involved in exception handling. As its precondition suggests, the
avgFirstN() method expects that N will be greater than 0. If N happens
to be 0, an error will occur in the expression sum/N, because you cannot
divide an integer by 0.

10.2.1 Traditional Error Handling

Obviously, the method in Figure 10.1 should not simply ignore the possi-
bility that N might be 0. Figure 10.2 shows a revised version of the method,
which includes code that takes action if the method's precondition fails.
Because there is no way to compute an average of 0 elements, the revised
method decides to abort the program. Aborting the program appears to
be a better alternative than returning 0 or some other default value (like
-1) as the method's result and thereby allowing an erroneous value to
spread throughout the program. That would just compound the error.

  JAVA EFFECTIVE DESIGN Unfixable Error. If an unfixable error is
  detected, it is far better to terminate the program abnormally than to
  allow the error to propagate throughout the program.

The revised avgFirstN() method takes the traditional approach to er-
ror handling: Error-handling code is built right into the algorithm. If N
happens to be 0 when avgFirstN() is called, the following output will
be generated:

                                                                                      

  ERROR avgFirstN : N <= 0 . Program t e r m i n a t i n g .
                                                                                      
 462                 CHAPTER 10   Exceptions: When Things Go Wrong
                 CalcAverage {                                                   

  public  class

  public double avgFirstN ( i n t N) {

          i n t sum = 0 ;

          f o r ( i n t k = 1 ; k <= N; k++)

                 sum += k ;

          r e t u r n sum/N;       // What i f N i s 0?

  } // a v g F i r s t N ( )

}// C a l c A v e r a g e

public class CalcAvgTest {

  public s t a t i c void main ( S t r i n g args [ ] ) {

          CalcAverage ca = new CalcAverage ( ) ;

          System . out . p r i n t l n ( "AVG + " + ca . avgFirstN ( 0 ) ) ;

  }// main

}// C a l c A v g T e s t

                                                                              

Figure 10.3: Note that there are two public classes defined in this figure,
which would be saved in separate Java files.

10.2.2 Java's Default Exception Handling

To help detect and handle common runtime errors, Java's creators incor-
porated an exception-handling model into the language itself. In the case
of our divide-by-zero error, the Java Virtual Machine (JVM) would detect
the error and abort the program. To see this, consider the program in Fig-
ure 10.3. Note that the avgFirstN() method is passed an argument of
0 in the CalcAvgTest.main(). When the JVM detects the error, it will
abort the program and print the following message:

                                                                                   

  Exception in thread "main"

  java . lang . ArithmeticException : / by zero

          a t CalcAverage . avgFirstN ( Compiled Code )

          at CalcAvgTest . main ( CalcAvgTest . java : 5 )                         

The error message describes the error and provides a trace of the method
calls, from last to first, that led to the error. This trace shows that the error
occurred in the CalcAverage.avgFirstN() method, which was called
by the CalcAvgTest.main() method.

   As this example suggests, Java's default exception handling is able to
detect and handle certain kinds of errors and exceptional conditions. In
the next section, we will identify what kinds of conditions are handled by
the JVM.

10.3 Java's Exception Hierarchy

The Java class library contains a number of predefined exceptions, some
of which are shown in Figure 10.4. The most general type of exception,
java.lang.Exception, is located in the java.lang package, but most
of its subclasses are contained in other packages. Some of the various
SECTION 10.3  Java's Exception Hierarchy                      463
                                                                       Figure 10.4: Part of Java's excep-
java.lang         ArithmeticException                                  tion hierarchy. All subclasses of
        Object    ArrayStoreException                                  RuntimeException are known
                  ClassCastException                                   as unchecked exceptions. Java pro-
     Throwable    IllegalArgumentException                             grams are not required to catch
     Exception    IllegalMonitorException                              these exceptions.
RuntimeException  IndexOutOfBoundsException
                  NegativeArrayException         NumberFormatException
                  NullPointerException
                  SecurityException              ArrayIndexOutOfBoundsException

                                                 StringIndexOutOfBoundsException

IOException classes are contained in the java.io package, while oth-      Exception hierarchy
ers are contained in the java.net package. In general, exception classes
are placed in the package that contains the methods that throw those
exceptions.

   Each of the classes in Figure 10.4 identifies a particular type of
exception, and each is a subclass of the Exception class. Ob-
viously a subclass defines a more specific exception than its su-
perclass. Thus, both ArrayIndexOutOfBoundsException and
StringIndexOutOfBoundsException are more specific than Index-
OutOfBoundsException.

TABLE 10.1 Some of Java's important exceptions.

Class                            Description

ArithmeticException              Division by zero or some other kind of arithmetic problem
ArrayIndexOutOfBoundsException   An array index is less than zero or greater

FileNotFoundException               than or equal to the array's length
IllegalArgumentException         Reference to a file that cannot be found
IndexOutOfBoundsException        Calling a method with an improper argument
NullPointerException             An array or string index is out of bounds
NumberFormatException            Reference to an object that has not been instantiated
StringIndexOutOfBoundsException  Use of an illegal number format, such as when calling a method
                                 A String index is less than zero or greater than

                                    or equal to the String's length

   Table 10.1 gives a brief summary of some of the most important excep-
tions. You've undoubtedly encountered some of these exceptions, because
they are thrown by methods we have used repeatedly in programming
examples. Table 10.2 summarizes the exceptions raised by some of the
methods we've used most frequently.
                                464          CHAPTER 10  Exceptions: When Things Go Wrong

TABLE 10.2 Some of Java's important exceptions by method.

Class                   Method               Exception Raised                 Description

Double                  valueOf(String)      NumberFormatException            The String is not a double
Integer                 parseInt(String)     NumberFormatException            The String is not a int
String                  String(String)       NullPointerException             The String is null
                        indexOf(String)      NullPointerException             The String is null
                        lastIndexOf(String)  NullPointerException             The String is null
                        charAt(int)          StringIndexOutOfBoundsException  The int is not a valid index
                        substring(int)       StringIndexOutOfBoundsException  The int is not a valid index
                        substring(int,int)   StringIndexOutOfBoundsException  An int is not a valid index

Checked exceptions              SELF-STUDY EXERCISE

                                EXERCISE 10.1 What type of exception would be thrown for the fol-
                                lowing statements?

                                a. Integer.parseInt("26.2");
                                b. String s; s.indexOf('a');
                                c. String s = "hello"; s.charAt(5);

                                10.3.1 Checked and Unchecked Exceptions

                                Java's exception hierarchy is divided into two types of exceptions. A
                                checked exception is one that can be analyzed by the Java compiler.
                                Checked exceptions are thrown by methods such as the Buffered-
                                Reader.readLine() method, in which there is a substantial likelihood
                                that something might go wrong. When the compiler encounters one
                                of these method calls, it checks whether the program either handles or
                                declares the exception. Compile-time checking for these exceptions is
                                designed to reduce the number of exceptions that are not properly han-
                                dled within a program. This improves the security of Java programs.

                                 JAVA LANGUAGE RULE Checked Exceptions. A checked
                                 exception, such as an IOException, must either be handled or
                                 declared within the program.

Declaring an exception          The throws Clause

                                The IOException, which we encountered in Chapter 4 , is a checked
                                exception. The Java compiler knows that readLine() is a method that
                                can throw an IOException. A method that contains an expression that
                                might throw a checked exception must either handle the exception or de-
                                clare it. Otherwise, the compiler would generate a syntax error. The sim-
                                plest way to avoid such a syntax error is to declare the exception, in our case
                                that means qualifying the method header with the expression throws
                                IOException.

                                   In general, any method that contains an expression that might throw a
                                checked expression must declare the exception. However, because one
                                method can call another method, declaring exceptions can get a little
                                tricky. If a method calls another method that contains an expression that
SECTION 10.3  Java's Exception Hierarchy                          465

might throw an unchecked exception, then both methods must have a
throws clause. For example, consider the following program:

                                                                            

import java . io .  ;
public cl ass Example {

       BufferedReader input = new BufferedReader
                      (new InputStreamReader ( System . i n ) ) ;

       public void doRead ( ) throws IOException {

            // May t h r o w I O E x c e p t i o n

          String inputString = input . readLine ( ) ;
   }

   public s t a t i c void main ( S t r i n g argv [ ] )
                                       throws IOException {

          Example ex = new Example ( ) ;
          ex . doRead ( ) ;
   }

}

                                                                            

In this case, the doRead() method contains a readLine() expres-
sion, which might throw an IOException. Therefore, the doRead()
method must declare that it throws IOException. However, because
doRead() is called by main(), the main() method must also declare the
IOException.

JAVA LANGUAGE RULE Where to Use throws. Unless a checked
exception, such as an IOException, is caught and handled by a
method, it must be declared with a throws clause within the method
and within any method that calls that method.

   The alternative approach would be to catch the IOException within
the body of the method. We will discuss this approach in the next section.

Unchecked Exceptions                                                        Runtime (unchecked) exceptions

An unchecked exception is any exception belonging to a subclass of
RuntimeException (Fig. 10.4). Unchecked exceptions are not checked
by the compiler. The possibility that some statement or expression will
lead to an ArithmeticException or NullPointerException is ex-
tremely difficult to detect at compile time. The designers of Java decided
that forcing programmers to declare such exceptions would not signifi-
cantly improve the correctness of Java programs.

   Therefore, unchecked exceptions do not have to be handled within
a program. And they do not have to be declared in a throws clause.
As shown in the chapter's early divide-by-zero exception example,
unchecked exceptions are handled by Java's default exception handlers,
unless your program takes specific steps to handle them directly. In many
                                      466  CHAPTER 10  Exceptions: When Things Go Wrong

                                      cases leaving the handling of such exceptions up to Java may be the best
                                      course of action, as we will see Section 10.5.

                                      JAVA LANGUAGE RULE Unchecked Exceptions. An unchecked
                                      exception--one belonging to some subclass of
                                      RunTimeException--does not have to be caught within your
                                      program.

                     Throwable        10.3.2 The Exception Class
              +getMessage()
              +printStackTrace()      The java.lang.Exception class itself is very simple, consisting of
                                      just two constructor methods (Fig. 10.5). The Throwable class, from
                     Exception        which Exception is derived, is the root class of Java's exception and
     +Exception()                     error hierarchy. It contains definitions for the getMessage() and
     +Exception(in message : String)  printStackTrace() methods, which are two methods that we will use
                                      frequently in our error-handling routines.
Figure 10.5: The java.lang.Ex-
ception class.                        SELF-STUDY EXERCISE

                                      EXERCISE 10.2 Which of the following are examples of unchecked
                                      exceptions?

                                      a. IOException
                                      b. IndexOutOfBoundsException
                                      c. NullPointerException
                                      d. ClassNotFoundException
                                      e. NumberFormatException

                                      10.4 Handling Exceptions Within a Program

Pulling the program's fire alarm      This section will describe how to handle exceptions within the program
                                      rather than leaving them to be handled by the JVM.
Thrower  Exception  Catcher
                                      10.4.1 Trying, Throwing, and Catching an Exception
         쳕ses  쳕ses
         throws  catches              In Java, errors and other abnormal conditions are handled by throwing
                                      and catching exceptions. When an error or an exceptional condition is
Object                    Object      detected, you can throw an exception as a way of signaling the abnormal
                                      condition. This is like pulling the fire alarm. When an exception is thrown,
Figure 10.6: Exception handling.      an exception handler will catch the exception and deal with it (Fig. 10.6).
When an exception occurs, an ob-      We will discuss try blocks, which typically
ject will throw an Exception.
The exception handler, possibly          are associated with catching exceptions, later in the section.
the same object, will catch it.          If we go back to our avgFirstN() example, the typical way of
                                      handling this error in Java would be to throw an exception in the
                                      avgFirstN() method and catch it in the calling method. Of course, the
                                      calling method could be in the same object or it could belong to some
                                      other object. In the latter case, the detection of the error is separated from
                                      its handling. This division of labor opens up a wide range of possibilities.
                                      For example, a program could dedicate a single object to serve as the han-
                                      dler for all its exceptions. The object would be sort of like the program's
                                      fire department.
                                         To illustrate Java's try/throw/catch mechanism, let's revisit the
                                      CalcAvgTest program. The version shown in Figure 10.7 mimics
SECTION 10.4  Handling Exceptions Within a Program                                  467

                                                                                                    

public class CalcAverage {

  / 

   Precondition : N > 0

   Postcondition : avgFirstN ( ) equals the average of ( 1 + 2 + . . . +N)

  /

  public double avgFirstN ( i n t N) {

  i n t sum = 0 ;

  i f (N <= 0 )

      throw new I l l e g a l A r g u m e n t E x c e p t i o n ( "ERROR :  Illegal  argument" ) ;

  f o r ( i n t k = 1 ; k <= N; k++)

      sum += k ;

  r e t u r n sum/N;           // What i f N i s 0?

  } // a v g F i r s t N ( )

} // C a l c A v e r a g e

public class CalcAvgTest {

  public s t a t i c void main ( S t r i n g args [ ] ) {

  try {

      CalcAverage ca = new CalcAverage ( ) ;

      System . out . p r i n t l n ( "AVG + " + ca . avgFirstN ( 0 ) ) ;

  }

  catch ( IllegalArgumentException e ) { // E x c e p t i o n Handler

      System . out . println ( e . getMessage ( ) ) ;

      e . printStackTrace ();

      System . ex it ( 0 ) ;

  }

  }// main

}// C a l c A v g T e s t

                                                                                                    

Figure 10.7: In this version of the calcAvgTest program, an Illegal-
ArgumentException thrown in CalcAverage.avgFirstN(), would
be handled by the catch clause in CalcAvgTest.main().

the way Java's default exception handler works. If the avgFirstN()
method is called with an argument that is zero or negative, an
IllegalArgumentException is thrown. The exception is caught by
the catch clause in the CalcAvgTest.main() method.

   Let's go through this example step by step. The first thing to notice is
that if the CalcAverage.avgFirstN() method has a zero or negative
argument, it will throw an exception:

                                                                                          

  i f (N <= 0 )                                                            Illegal  argument" ) ;
     throw new I l l e g a l A r g u m e n t E x c e p t i o n ( "ERROR :                             



Note the syntax of the throw statement. It creates a new Illegal-
ArgumentException object and passes it a message that describes the
error. This message becomes part of the exception object. It can be re-
trieved using the getMessage() method, which is inherited from the
Throwable class (Fig. 10.4).

   When a throw statement is executed, the JVM interrupts the normal ex-
ecution of the program and searches for an exception handler. We will de-
468  CHAPTER 10  Exceptions: When Things Go Wrong

scribe the details of this search shortly. In this case, the exception handler
is the catch clause contained in the CalcAvgTest.main() method:

                                                                                         

catch ( IllegalArgumentException e ) {// E x c e p t i o n Handler

     System . out . println ( e . getMessage ( ) ) ;

     e . printStackTrace ();

     System . exit ( 0 ) ;

}

                                                                                         

When an IllegalArgumentException is thrown, the statements
within this catch clause are executed. The first statement uses the
getMessage() method to print a copy of the error message. The sec-
ond statement uses the printStackTrace() method, which is defined
in Throwable and inherited by all Exceptions, to print a trace of the
method calls leading up to the exception. The last statement causes the
program to terminate.

   When we run this program, the following output will be generated as
a result of the illegal argument error:

                                                                                                   

ERROR : Can ' t average 0 elements

j a v a . lang . I l l e g a l A r g u m e n t E x c e p t i o n : ERROR : I l l e g a l argument

     a t j a v a . lang . Throwable . f i l l I n S t a c k T r a c e ( Native Method )

     a t java . lang . Throwable.< i n i t >(Throwable . java : 9 4 )

     a t java . lang . Exception .< i n i t >( Exception . java : 4 2 )

     at java . lang . RuntimeException.< init >

                              ( RuntimeException . java :47)

     at java . lang . IllegalArgumentException.< init >

                              ( IllegalArgumentException . java :43)

     a t CalcAverage . avgFirstN ( Compiled Code )

     at CalcAvgTest . main ( CalcAvgTest . java : 5 )                                              

Thus, as in the previous example of Java's default exception handler, our
exception handler also prints out a description of the error and a trace of
the method calls that led up to the error. However, in this example, we are
directly handling the exception rather than leaving it up to Java's default
exception handler. Of course, this example is intended mainly for illus-
trative purposes. It would make little sense to write our own exception
handler if it does nothing more than mimic Java's default handler.

JAVA EFFECTIVE DESIGN Using an Exception. Unless your
program's handling of an exception is significantly different from
Java's default handling of it, the program should just rely on the
default.

Finally, note that the catch clause is associated with a try block. The
handling of exceptions in Java takes place in two parts: First, we try to
SECTION 10.4  Handling Exceptions Within a Program                        469

execute some statements, which may or may not lead to an exception.
These are the statements contained within the try clause:

                                                                                

  try  {                                                                        
       CalcAverage ca = new CalcAverage ( ) ;
  }    System . out . p r i n t l n ( "AVG + " + ca . avgFirstN ( 0 ) ) ;        Responding to the fire alarm

                                                                                 Figure 10.8: Playing catch: In
Second, we provide one or more catch clauses to handle par-                      this design, the Illegal-
ticular types of exceptions. In this case, we are only handling                  ArgumentException is thrown
IllegalArgumentExceptions.                                                       by the CalcAverage.avg-
                                                                                 FirstN() method and caught
   As we said earlier, throwing an exception is like pulling a fire alarm.       by the catch clause within
The throw occurs somewhere within the scope of the try block. The "fire          CalcAvgTest.main() method.
department" in this case is the code contained in the catch clause that
immediately follows the try block. This is the exception handler for this
particular exception. There's something like a game of catch going on
here: Some method within the try block throws an Exception object,
which is caught and handled by the catch block located in some other
object (Fig. 10.8).

                                        Exception

                                        IllegalArgumentException

       CalcAverage                      쳕ses  쳕ses   CalcAvgTest
                                        throws  catches

       +avgFirstN(in N : int) : double                   +main()

10.4.2 Separating Error Checking from Error Handling                            Divide and conquer

As we see in the CalcAvgTest example, an important difference be-
tween Java's exception handling and more traditional approaches is that
error handling can be separated from the normal flow of execution within
a program. The CalcAverage.avgFirstN() method still checks for
the error and it still throws IllegalArgumentException if N does
not satisfy the method's precondition. But it does not contain code for
handling the exception. The exception-handling code is located in the
CalcAvgTest class.

   Thus, the CalcAvgTest program creates a clear separation between
the normal algorithm and the exception-handling code. One advantage of
this design is that the normal algorithm is uncluttered by error-handling
code and, therefore, easier to read.

   Another advantage is that the program's response to errors has been
organized into one central location. By locating the exception handler
in CalcAvgTest.main(), one exception handler can be used to han-
dle other errors of that type. For example, this catch clause could handle
all IllegalArgumentExceptions that get thrown in the program. Its
use of printStackTrace() will identify exactly where the exception
occurred. In fact, because a Java application starts in the main() method,
                 470                       CHAPTER 10  Exceptions: When Things Go Wrong

                 encapsulating all of a program's executable statements within a single try
                 block in the main() method will effectively handle all the exceptions that
                 occur within a program.

                   JAVA EFFECTIVE DESIGN Normal Versus Exceptional Code. A key
                   element of Java's exception-handling mechanism is that the exception
                   handler--the catch block--is distinct from the code that throws the
                   exception--the try block. The try block contains the normal algorithm.
                   The catch block contains code for handling exceptional conditions.

The try block    10.4.3 Syntax and Semantics of Try/Throw/Catch
The catch block
                 A try block begins with the keyword try followed by a block of code
                 enclosed within curly braces. A catch clause or catch block consists of the
                 keyword catch, followed by a parameter declaration that identifies the
                 type of Exception being caught, followed by a collection of statements
                 enclosed within curly braces. These are the statements that handle the
                 exception by taking appropriate action.

                    Once an exception is thrown, control is transferred out of the try block
                 to an appropriate catch block. Control does not return to the try block.

                  JAVA LANGUAGE RULE Try Block Control. If an exception is
                  thrown, the try block is exited and control does not return to it.

                 The complete syntax of the try/catch statement is summarized in Fig-
                 ure 10.9. The try block is meant to include a statement or statements that

                                                                                                        

                   try {

                          // B l o c k o f s t a t e m e n t s

                          // At l e a s t one o f which may t h r o w an e x c e p t i o n

                          if ( / Some c o n d i t i o n o b t a i n s / )
                                 throw new ExceptionName ( ) ;

                 } catch ( ExceptionName ParameterName ) {

                      // B l o c k o f s t a t e m e n t s t o be e x e c u t e d

                      // I f t h e E x c e p t i o n N a m e e x c e p t i o n i s thrown i n t r y

                 } catch ( ExceptionName2 ParameterName ) {

                      // B l o c k o f s t a t e m e n t s t o be e x e c u t e d

                      // I f t h e E x c e p t i o n N a m e 2 e x c e p t i o n i s thrown i n t r y

                 . . . // P o s s i b l y  other  catch         clauses
                  } finally {

                      // O p t i o n a l b l o c k o f s t a t e m e n t s t h a t i s e x e c u t e d

                      // Whether an e x c e p t i o n i s thrown or n o t

                 }

                                                                                                        

                          Figure 10.9: Java's try/catch statement.

                 might throw an exception. The catch blocks--there can be one or more--
                 are meant to handle exceptions that are thrown in the try block. A catch
                 block will handle any exception that matches its parameter class, includ-
                 ing subclasses of that class. The finally block clause is an optional clause
                 that is always executed, whether an exception is thrown or not.
SECTION 10.4  Handling Exceptions Within a Program  471

   The statements in the try block are part of the program's normal flow        Normal flow of execution
of execution. By encapsulating a group of statements within a try block,        Exceptional flow of execution
you thereby indicate that one or more exceptions may be thrown by those        
statements, and that you intend to catch them. In effect, you are trying a     
block of code with the possibility that something might go wrong.
                                                                               
   If an exception is thrown within a try block, Java exits the block and      
transfers control to the first catch block that matches the particular kind
of exception that was thrown. Exceptions are thrown by using the throw          Exceptions are objects
statement, which takes the following general form:
                                                                                Arranging catch clauses
 

    throw new ExceptionClassName ( OptionalMessageString ) ;
 

The keyword throw is followed by the instantiation of an object of the
ExceptionClassName class. This is done the same way we instanti-
ate any object in Java: by using the new operator and invoking one of
the exception's constructor methods. Some of the constructors take an
OptionalMessageString, which is the message that gets returned by
the exception's getMessage() method.

   A catch block has the following general form:

 

    catch ( ExceptionClassName ParameterName ) {

              // E x c e p t i o n h a n d l i n g s t a t e m e n t s

    }
 

A catch block is very much like a method definition. It contains a param-
eter, which specifies the class of exception that is handled by that block.
The ParameterName can be any valid identifier, but it is customary to use
e as the catch block parameter. The parameter's scope is limited to the
catch block, and it is used to refer to the caught exception.

   The ExceptionClassName must be one of the classes in Java's exception
hierarchy (see Fig. 10.4). A thrown exception will match any parameter of
its own class or any of its superclasses. Thus, if an ArithmeticExcep-
tion is thrown, it will match both an ArithmeticException parame-
ter and an Exception parameter, because ArithmeticException is a
subclass of Exception.

   Note that there can be multiple catch clauses associated with a given
try block, and the order with which they are arranged is important. A
thrown exception will be caught by the first catch clause it matches.
Therefore, catch clauses should be arranged in order from most specific
to most general (See the exception hierarchy in Figure 10.4). If a more
general catch clause precedes a more specific one, it will prevent the more
specific one from executing. In effect, the more specific clause will be hid-
den by the more general one. You might as well just not have the more
specific clause at all.
                       472    CHAPTER 10  Exceptions: When Things Go Wrong

                          To illustrate how to arrange catch clauses, suppose an Arithmetic-
                       Exception is thrown in the following try/catch statement:

                                                                                                      

                       try {

                              // Suppose an A r i t h m e t i c E x c e p t i o n i s thrown h e r e

                       } catch ( ArithmeticException e) {

                              System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

                              e . printStackTrace ();

                              System . exit ( 1 ) ;

                       } catch ( Exception e) {

                              System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

                       }

                                                                                                      

Which handler to use?  In this case, the exception would be handled by the more specific
                       ArithmeticException block. On the other hand, if some other kind
                       of exception is raised, it will be caught by the second catch clause. The
                       Exception class will match any exception that is thrown. Therefore, it
                       should always occur last in a sequence of catch clauses.

                       JAVA PROGRAMMING TIP Arranging Catch Clauses. Catch
                       clauses should be arranged from most specific to most general. The
                       Exception clause should always be the last in the sequence.

                       10.4.4 Restrictions on the try/catch/finally
                                 Statement

                       There are several important restrictions that apply to Java's exception-
                       handling mechanism. We'll describe these in more detail later in this
                       chapter.

                        A try block must be immediately followed by one or more catch clauses
                          and a catch clause may only follow a try block.

                        A throw statement is used to throw both checked exceptions and
                          unchecked exceptions, where unchecked exceptions are those belong-
                          ing to RuntimeException or its subclasses. Unchecked exceptions
                          need not be caught by the program.

                        A throw statement must be contained within the dynamic scope of
                          a try block, and the type of Exception thrown must match at least
                          one of the try block's catch clauses. Or the throw statement must be
                          contained within a method or constructor that has a throws clause for
                          the type of thrown Exception.

                        JAVA LANGUAGE RULE Try/Catch Syntax. A try block must be
                        followed immediately--with no intervening code--by one or more
                        catch blocks. A catch block can only be preceded by a try block or by
                        another catch block. You may not place intervening code between
                        catch blocks.
SECTION 10.4  Handling Exceptions Within a Program        473

10.4.5 Dynamic Versus Static Scoping

How does Java know that it should execute the catch clause in                       Dynamic scope
CalcAvgTest.main() when an exception is thrown in avgFirstN()?
Also, doesn't the latest version of avgFirstN() (Fig. 10.7) violate the             Static scope
restriction that a throw statement must occur within a try block?
                                                                                    Figure 10.10: Dynamic versus
   An exception can only be thrown within a dynamically enclosing try               static scoping. Static scoping
block. This means that the throw statement must fall within the dynamic             refers to how the program is writ-
scope of an enclosing try block. Let's see what this means.                         ten. Look at its definitions. Dy-
                                                                                    namic scoping refers to how the
   Dynamic scoping refers to the way a program is executed. For ex-                 program executes. Look at what
ample, in CalcAverage (Fig. 10.7), the avgFirstN() method is called                 it actually does.
from within the try block located in CalcAvgTest.main(). Thus, it falls
within the dynamic scope of that try block.

   Contrast dynamic with what you have learned about static scope,
which we've used previously to define the scope of parameters and lo-
cal variables (Fig. 10.10). Static scoping refers to the way a program is
written. A statement or variable occurs within the scope of a block if its
text is actually written within that block. For example, consider the def-
inition of MyClass (Fig. 10.11). The variable X occurs within the (static)
scope of method1(), and the variable Y occurs within the (static) scope
of method2().

class MyClass{                               Static Scope: Follow the definitions.
                                             Neither method1() nor method2() is
  public void method1 () {                   in the static scope of main().
    int X=1;
    System.out.println("Hello" + X);                            MyClass

  }                                          method1 () method2 () main ()

  public void method2 () {                   X  Y
    int Y=2;
    System.out.println("Hello" + Y);         Dynamic Scope: Follow the execution.
                                             If Math.random()>0.5, method2()
  }                                          is in the dynamic scope of main().

  public static void main(String argv[ ]) {                      main()
    MyClass myclass=new MyClass();
    if(Math.random()>0.5)                       method2()
      myclass.method2 () ;
    else
      myclass.method1 () ;

  }

}

   A method's parameters and local variables occur within its static scope.
Also, in the MyClass definition, the System.out.println() state-
ments occur within the static scope of method1() and method2(), re-
spectively. In general, static scoping refers to where a variable is de-
clared or where a statement is located. Static scoping can be completely
determined by just reading the program.

   Dynamic scoping can only be determined by running the program. For
example, in MyClass the order in which its statements are executed de-
pends on the result of Math.random(). Suppose that when random()
is executed it returns the value 0.99. In that case, main() will call
method2(), which will call System.out.println(), which will print
                   474               CHAPTER 10  Exceptions: When Things Go Wrong

                                                                                    

                   public class MyClass {
                          public void method1 ( ) {
                                 int X = 1;
                                 System . out . println ( "Hello" + X ) ;
                          }

                        public void method2 ( ) {
                               int Y = 2;
                               System . out . println ( "Hello" + Y ) ;

                        }

                        public s t a t i c void main ( S t r i n g argv [ ] ) {
                               MyClass myclass = new MyClass ( ) ;
                               i f ( Math . random ( ) > 0 . 5 )
                                      myclass . method2 ( ) ;
                               else
                                      myclass . method1 ( ) ;

                        }

                   } // MyClass

                                                                                    

                        Figure 10.11: An example of dynamic versus static scoping.

                   "Hello2." In that case, the statement System.out.println("Hello"
                   + Y) has the following dynamic scope:

                                                                                                    

                     main ( )

                        method2 ( )

                               System . out . println ( "Hello" + Y ) ;                             

                   It occurs within the (dynamic) scope of method2(), which is within the
                   (dynamic) scope of main(). On the other hand, if the result of random()
                   had been 0.10, that particular println() statement wouldn't have been
                   executed at all. Thus, to determine the dynamic scope of a particular
                   statement, you must trace the program's execution. In fact, this is what
                   the printStackTrace() method does. It prints a trace of a statement's
                   dynamic scope.

                   10.4.6 Exception Propagation: Searching for a Catch Block

Method call stack  When an exception is thrown, Java uses both static and dynamic scop-
                   ing to find a catch clause to handle it. Java knows how the program is
                   defined--after all, it compiled it. Thus, the static scope of a program's
                   methods is determined by the compiler. Java also places a record of every
                   method call the program makes on a method call stack. A method call
                   stack is a data structure that behaves like a stack of dishes in the cafeteria.
                   For each method call, a method call block is placed on top of the stack (like
                   a dish), and when a particular method call returns, its block is removed
                   from the top of the stack (Fig. 10.12).

                      An important feature of the method call stack is that the current ex-
                   ecuting method is always represented by the top block on the method
                   call stack. If an exception happens during that method call, you can trace
                   backward through the method calls, if necessary, to find an exception han-
                   dler for that exception. In Figure 10.12, you can visualize this back trace
                   as a matter of reversing the direction of the curved arrows.
SECTION 10.4  Handling Exceptions Within a Program                          475
                                                                                     Figure 10.12: The method call
public class Propagate{                             Method Call Stack                stack for the Propagate pro-
                                                 The state of the stack on           gram. The curved arrows give a
   public void method1 (int n) {                 the first iteration of the          trace of the method calls leading
                                                 for loop in method3().              to the program's present state.
      method2(n);
                                                     method3 ()
   }                                                 n=0 k=0

   public void method2 (int n) {                     method2 ()
                                                     n=0
      method3(n);
                                                     method1 ()
   }                                                 n=0

   public void method3 (int n) {                     main()

      for(int k=0; k<5; k++) { //Block1

         if(k % 2==0) {                //Block2

            System.out.println(k/n) ;

         }

      }

   }

   public static void main(String args[ ]) {

      Propagate p=new propagate() ;

      p.method1(0) ;

   }

}

   In order to find a matching catch block for an exception, Java uses         Method stack trace
its knowledge of the program's static and dynamic scope to perform a
method stack trace. The basic idea is that Java traces backward through
the program until it finds an appropriate catch clause. The trace begins
within the block that threw the exception. Of course, one block can be
nested (statically) within another block. If the exception is not caught by
the block in which it is thrown, Java searches the enclosing block. This is
static scoping. If it is not caught within the enclosing block, Java searches
the next higher enclosing block, and so on. This is still static scoping.

   If the exception is not caught at all within the method in which it was
thrown, Java uses the method call stack (Fig. 10.12) to search backward
through the method calls that were made leading up to the exception.
This is dynamic scoping. In the case of our CalcAvgTest() example
(Fig. 10.7), Java would search backward to the CalcAvgTest.main()
method, which is where avgFirstN() was called, and it would find
the catch clause there for handling IllegalArgumentExceptions. It
would, therefore, execute that catch clause.

SELF-STUDY EXERCISES

EXERCISE 10.3 Suppose a program throws an ArrayIndexOutOf-
BoundsException. Using the exception hierarchy in Figure 10.4, de-
termine which of the following catch clauses could handle that exception.

a. catch (RunTimeException e)
b. catch (StringIndexOutOfBoundsException e)
c. catch (IndexOutOfBoundsException e)
d. catch (Exception e)
e. catch (ArrayStoreException e)
476                 CHAPTER 10  Exceptions: When Things Go Wrong

EXERCISE 10.4 In the program that follows suppose that the first time
random() is called it returns 0.98, and the second time it is called it
returns 0.44. What output would be printed by the program?

                                                                         

class MyClass2 {
       public void method1 ( double X) {
              if (X > 0.95)
                     throw new A r i t h m e t i c E x c e p t i o n (X
                                       + " is out of range" ) ;
              System . out . println ( "Hello " + X ) ;
      }

     public void method2 ( double Y) {
            if (Y > 0.5)
                     throw new A r i t h m e t i c E x c e p t i o n (Y
                                     + " is out of range" ) ;
            System . out . println ( "Hello " + Y ) ;

     }

     public s t a t i c void main ( S t r i n g argv [ ] ) {
            MyClass2 myclass = new MyClass2 ( ) ;
            try {
                   myclass . method1 ( Math . random ( ) ) ;
                   myclass . method2 ( Math . random ( ) ) ;
            } catch ( ArithmeticException e) {
                   System . out . println ( e . getMessage ( ) ) ;
            }

     } // main ( )

} // MyClass2

                                                                         

EXERCISE 10.5 For the values returned by random() in the previ-
ous exercise, show what would be output if printStackTrace() were
called in addition to printing an error message.

EXERCISE 10.6 In the MyClass2 program, suppose that the first time
random() is called it returns 0.44, and the second time it is called it
returns 0.98. What output would be printed by the program?

EXERCISE 10.7 For the values returned by random() in the previ-
ous exercise, show what would be output if printStackTrace() were
called instead of printing an error message.
SECTION 10.5  Error Handling and Robust Program Design 477

EXERCISE 10.8 Find the divide-by-zero error in the following pro-
gram, and then show what stack trace would be printed by the program:

                                                                       

public class BadDivide {
       public void method1 ( int n ) {
              method2 (100 , n ) ;
       }

   public void method2 ( int n , int d) {
            System . out . println (n / d ) ;

   }

   public s t a t i c void main ( S t r i n g args [ ] ) {
          BadDivide bd = new BadDivide ( ) ;
          for ( int k = 0; k < 5; k++)
                 bd . method1 ( k ) ;

   }

}

                                                                       

EXERCISE 10.9 Modify method2() so that it handles the divide-by-
zero exception itself, instead of letting Java handle it. Have it print an
error message and a stack trace.

EXERCISE 10.10 What would be printed by the following code seg-
ment if someValue equals 1000?

                                                                       

int M = someValue ;

try {

   System . out . println ( " Entering try block" ) ;

   i f (M > 1 0 0 )

       throw new Ex ce pti on (M + " i s too l a r g e " ) ;

   System . out . println ( " Exiting try block" ) ;

} catch ( Exception e) {

   System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

}

                                                                       

EXERCISE 10.11 What would be printed by the code segment in the
preceding question if someValue equals 50?

EXERCISE 10.12 Write a try/catch block that throws an Exception
if the value of variable X is less than zero. The exception should be an
instance of Exception and, when it is caught, the message returned by
getMessage() should be "ERROR: Negative value in X coordinate."

10.5 Error Handling and Robust
        Program Design

An important element of program design is to develop appropriate ways       Let Java do it?
of handling erroneous and exceptional conditions. As we have seen, the
JVM will catch any unchecked exceptions that are not caught by the pro-
gram itself. For your own (practice) programs, the best design may sim-
                             478                  CHAPTER 10  Exceptions: When Things Go Wrong

                             ply be to use Java's default exception handling. The program will termi-
                             nate when an exception is thrown, and then you can debug the error and
                             recompile the program.

                                On the other hand, this strategy would be inappropriate for commercial
                             software, which cannot be fixed by its users. A well-designed commercial
                             program should contain exception handlers for those truly exceptional
                             conditions that may arise.

                                In general there are three ways to handle an exceptional condition that
                             isn't already handled by Java (Table 10.3). If the exceptional condition

                             TABLE 10.3 Exception-handling strategies.

                             Kind of Exception Kind of Program Action to Be Taken

                             Caught by Java       Stoppable     Let Java handle it
                             Fixable condition                  Fix the error and resume execution
                             Unfixable condition                Report the error and terminate

                             Unfixable condition Not stoppable     the program
                                                                Report the error and resume

                                                                   processing

What action should we take?  cannot be fixed, the program should be terminated, with an appropriate
                             error message. Second, if the exceptional condition can be fixed without
                             invalidating the program, then it should be remedied and the program's
                             normal execution should be resumed. Third, if the exception cannot be
                             fixed, but the program cannot be terminated, the exceptional condition
                             should be reported or logged in some way, and the program should be
                             resumed.

                             JAVA EFFECTIVE DESIGN Handling Exceptions. There are three
                             general ways to handle exceptions: (1) Report the exception and
                             terminate the program; (2) fix the exceptional condition and resume
                             normal execution; and (3) report the exception to a log and resume
                             execution.

Program development          10.5.1 Print a Message and Terminate

                             Our illegal argument example is a clear case in which the exception is best
                             handled by terminating the program. In this case, this particular error
                             is best left to Java's default exception handling, which will terminate the
                             program when the exception is thrown. There is simply no way to satisfy
                             the postcondition of the avgFirstN() method when N is less than or
                             equal to 0. This type of error often calls attention to a design flaw in the
 SECTION 10.5  Error Handling and Robust Program Design 479

program's logic that should be caught during program development. The
throwing of the exception helps identify the design flaw.

 JAVA EFFECTIVE DESIGN Exceptions and Program
 Development. Java's built-in exception handling helps identify
 design flaws during program development. Your own use of
 exceptions should follow this approach.

Similar problems can (and often do) arise in connection with errors that      Don't spread bad data!
are not caught by Java. For example, suppose that your program receives
an erroneous input value, whose use would invalidate the calculation it
is making. This won't be caught by Java. But it should be caught by
your program, and an appropriate alternative here is to report the error
and terminate the program. Fixing this type of error may involve adding
routines to validate the input data before they are used in the calculation.

   In short, rather than allowing an erroneous result to propagate through-
out the program, it is best to terminate the program.

JAVA EFFECTIVE DESIGN Report and Terminate. If an unfixable
exception arises in a program that can be terminated, it is better to
report the error and terminate the program. That would be better than
allowing it to run with an erroneous value.

10.5.2 Log the Error and Resume                                               Failsafe programs
                                                                              Programs that can't be stopped
Of course, the advice to stop the program assumes that the program can be
terminated reasonably. Some programs--such as programs that monitor
the space shuttle or programs that control a nuclear magnetic resonance
(NMR) machine--cannot (and should not) be terminated because of such
an error.

   Such programs are called failsafe because they are designed to run with-
out termination. For these programs, the exception should be reported in
whatever manner is most appropriate, but the program should continue
running. If the exceptional condition invalidates the program's computa-
tions, then the exception handler should make it clear that the results are
tainted.

   Other programs--such as programs that analyze a large transaction
database--should be designed to continue processing after catching such
errors. For example, suppose the program a large airline runs a program
once a day to analyze the ticketing transactions that took place. This
kind of program might use exceptions to identify erroneous transactions
or transactions that involve invalid data of some sort. Because there are
bound to be many errors of this kind in the database, it is not reason-
able to stop the program. This kind of program shouldn't stop until it
has finished processing all of the transactions. An appropriate action for
this kind of program is to log the exceptions into some kind of file and
continue processing the transactions.

   Suppose a divide-by-zero error happened in one of these programs. In
that case, you would override Java's default exception handling to ensure
that the program is not terminated. More generally, it's important that
                                      480                   CHAPTER 10  Exceptions: When Things Go Wrong

                                      these types of programs be designed to catch and report such exceptions.
                                      This type of exception handling should be built right into the program's
                                      design.

                                        JAVA EFFECTIVE DESIGN Report and Resume. If an unfixable
                                        exception arises in a program that cannot be terminated reasonably,
                                        the exception should be reported and the program should continue
                                        executing.

                                      10.5.3 Fix the Error and Resume

Problem statement                     As an example of a problem that can be addressed as the program runs,
                                      consider the task of inputting an integer into a text field. As you have
                     JTextField       probably experienced, if a program is expecting an integer and you at-
                                      tempt to input something beside an integer, a NumberFormatException
                       IntField       is generated and the program will terminate. For example, if you enter
            +IntField()               "$55" when prompted to input an integer dollar amount, this will gen-
            +IntField(in size : int)  erate an exception when the Integer.parseInt() method is invoked.
            +getInt() : int           The input string cannot be parsed into a valid int. However, this is the
                                      kind of error that can be addressed as the program is running.
Figure 10.13: An IntField is a
JTextField that accepts only in-         Let's design a special IntField that functions like a normal text field
tegers.                               but accepts only integers. If the user enters a value that generates a
                                      NumberFormatException, an error message should be printed and the
                                      user should be invited to try again. As

                                         Figure 10.13 shows, we want this special field to be a subclass of
                                      JTextField and to inherit the basic JTextField functionality. It
                                      should have the same kind of constructors that a normal JTextField
                                      has. This leads to the definition shown in Figure 10.14.

                                                                                                             

                                      import javax . swing .  ;

                                      public class IntField extends JTextField {

                                           public IntField () {

                                              super ( ) ;

                                           }

                                           public IntField ( int size ) {

                                              super ( size ) ;

                                           }

                                           public int getInt ( ) throws NumberFormatException {

                                              return Integer . parseInt ( getText ( ) ) ;

                                           } // g e t I n t ( )

                                      } // I n t F i e l d

                                                                                                             

                                      Figure 10.14: A NumberFormatException might be thrown by the
                                      Integer.parseInt() method in IntField.getInt().

What constructors do we need?            Note that the constructor methods use super to call the JTextField
                                      constructor. For now, these two constructors should suffice. However,
                                      later we will introduce a third constructor that allows us to associate a
                                      bound with the IntField later in this chapter.
SECTION 10.5  Error Handling and Robust Program Design 481

   Our IntField class needs a method that can return its contents. This          What methods do we need?
method should work like JTextField.getText(), but it should re-                 
turn a valid integer. The getInt() method takes no parameters and               
will return an int, assuming that a valid integer is typed into the
IntField. If the user enters "$55," a NumberFormatException will
be thrown by the Integer.parseInt() method. Note that getInt()
declares that it throws this exception. This is not necessary because a
NumberFormatException is not a checked exception, but it makes the
code clearer.

   Where and how should this exception be handled? The exception can-
not easily be handled within the getInt() method. This method has to
return an integer value. If the user types in a non-integer, there's no way
to return a valid value. Therefore, it's better just to throw the exception to
the calling method, where it can be handled more easily.

   In a GUI application or applet, the calling method is likely to be an
actionPerformed() method, such as the following:

 

    public void actionPerformed ( ActionEvent e ) {
        try {
           userInt = intField . getInt ();
           message = "You input " + u s e r I n t + " Thank you . " ;
       } catch ( NumberFormatException ex ) {
           JOptionPane . showMessageDialog ( this ,
             "The input must be an i n t e g e r . Please re-enter . " ) ;
       } finally {
               repaint ();
       }

    } // a c t i o n P e r f o r m e d ( )
 

The call to getInt() is embedded in a try/catch block. This leads
to the design summarized in Figure 10.15. The IntField throws an
exception that is caught by the GUI, which then displays an error message.

: NumberFormatException               : JOptionPane                             Figure 10.15: If the user
                                                                                types a non-integer into an
: IntField          : AppletSubclass                                            IntField, it will throw a
           throw()                                                              NumberFormatException. The
                                                                                GUI will display an error message
                    catch()                                                     in a JOptionPane (a dialog
                                                                                window).

                             showMessageDialog()

   If the user inputs a valid integer, the program will just report a mes-
sage that displays the value. A more real-world example would make a
more significant use of the value. On the other hand, if the user types
an erroneous value, the program will pop up the dialog box shown in
Figure 10.16. (See the "From the Library" section of this chapter for more
on dialog boxes.) When the user clicks the OK button, the program will
resume normal execution, so that when an exception is raised, the enter
value is not used, and no harm is done by an erroneous value. The user
                                                 482  CHAPTER 10  Exceptions: When Things Go Wrong
Figure 10.16: This exception han-
dler opens a dialog box to display
an error message.

Defensive design: Anticipating an  can try again to input a valid integer. Note that the finally clause repaints
exception                          the GUI. In this case, repainting would display the appropriate message
                                   on the applet or the application.

                                      This is an example of what we might call defensive design. Defensive de-
                                   sign is when we anticipate a possible input error and take steps to ensure
                                   that a bad value is not propagated throughout the program.

                                    JAVA EFFECTIVE DESIGN Defensive Design. Well-designed code
                                    should anticipate potential problems, especially potential input
                                    problems. Effective use of exceptions can help with this task.

Anticipating exceptions               Admittedly, the sense in which the error here is "fixed" is simply that
                                   the user's original input is ignored and reentered. This is a legitimate
                                   and simple course of action for this particular situation. It is far prefer-
                                   able to ignoring the exception. If the program does not handle this excep-
                                   tion itself, Java will catch it and will print a stack trace and terminate the
                                   program. That would not be a very user-friendly interface!

                                      Clearly, this is the type of exceptional condition that should be antici-
                                   pated during program design. If this happens to be a program designed
                                   exclusively for your own use, then this type of exception handling might
                                   be unnecessary. But if the program is meant to be used by others, it is im-
                                   portant that the program be able to handle erroneous user input without
                                   crashing.

                                    JAVA EFFECTIVE DESIGN Fixing an Exception. If a method can
                                    handle an exception effectively, it should handle it locally. This is both
                                    clearer and more efficient.

                                   JAVA EFFECTIVE DESIGN Library Exception Handling. Many of
                                   Java's library classes do not handle their own exceptions. The thinking
                                   behind this design is that the user of the class is in a better position to
                                   handle the exception in a way that's appropriate for the application.
SECTION 10.5  Error Handling and Robust Program Design 483

10.5.4 To Fix or Not to Fix

Let's now consider a problem where it is less clear whether an excep-
tion can be successfully fixed "on the fly." Suppose you have a program
that contains an array of Strings, which is initially created with just two
elements.

                                                                                          

S t r i n g l i s t [ ] = new S t r i n g [ 2 ] ;
                                                                                          

If an attempt is made to add more than two elements to the array, an                      Problem statement
ArrayIndexOutOfBoundsException will be raised. This exception
can be handled by extending the size of the array and inserting the ele-
ment. Then the program's normal execution can be resumed.

   To begin creating such a program, let's first design a method that will
insert a string into the array. Suppose that this is intended to be a private
method that will only be used within the program. Also, let's suppose that
the program maintains a variable, count, that tracks how many values
have been stored in the array. Therefore, it will not be necessary to pass
the array as a parameter. So, we are creating a void method with one
parameter, the String to be inserted:

                                                                                          

private void insertString ( String str ) {

      // Might throw A r r a y I n d e x O u t O f B o u n d s E x c e p t i o n

   l i s t [ count ] = str ;

   ++count ;

}

                                                                                          

The comment notes where an exception might be thrown.                                     Algorithm design
   Can we handle this exception? When this exception is raised, we could

create a new array with one more element than the current array. We
could copy the old array into the new array and then insert the String in
the new location. Finally, we could set the variable list, the array refer-
ence, so that it points to the new array. Thus, we could use the following
try/catch block to handle this exception:

                                                                                          

private void insertString ( String str ) {                                                        JPanel
       try {
              l i s t [ count ] = str ;
       } catch ( ArrayIndexOutOfBoundsException e ) {

      // C r e a t e a new a r r a y

      S t r i n g newList [ ] = new S t r i n g [ l i s t . l e n g t h + 1 ] ;

      for ( int k = 0; k < l i s t . length ; k++) // Copy a r r a y

              newList [k] = l i s t [k ] ;

      newList [ count ] = str ; // I n s e r t i n t o new a r r a y                                       FixArrayBound

      l i s t = newList ;                          // Make o l d p o i n t t o new           -list[] : String
                                                                                             -inField : JTextField
   } finally {                    // S i n c e t h e e x c e p t i o n i s now f i x e d     -prompt : JLabel
                                                                                             -count : int
      count ++;                   // I n c r e a s e t h e c o u n t
                                                                                             +FixArrayBound()
   }                                                                                         +paintComponent(in g : Graphics)
                                                                                             -insertString(in s : String)
} // i n s e r t S t r i n g ( )                                                             +actionPerformed()
                                                                                             +main()
                                                                                          

The effect of the catch clause is to create a new array, still referred to as
list, but that contains one more element than the original array.

                                                                                          Figure  10.17:     The

                                                                                          FixArrayBound class uses

                                                                                          exception handling to extend the
                                    484  CHAPTER 10  Exceptions: When Things Go Wrong

                                       Note the use of the finally clause here. For this problem it's impor-
                                    tant that we increment count in the finally clause. This is the only
                                    way to guarantee that count is incremented exactly once whenever an
                                    element is assigned to the array.

                                       The design of the FixArrayBound class is shown in Figure 10.17.
                                    It provides a simple GUI interface that enables you to test the
                                    insertString() method. This program has a standard Swing interface,
                                    using a JFrame as the top-level window. The program's components are
                                    contained within a JPanel that's added to the JFrame in the main()
                                    method.

                                       Each time the user types a string into the text field, the action-
                                    Performed() method calls the insertString() method to add the
                                    string to the array. On each user action, the JPanel is repainted. The
                                    paintComponent() method simply clears the panel and then displays
                                    the array's elements (Fig. 10.18).

                                    JAVA DEBUGGING TIP Clearing the JPanel. Swing components,
                                    such as JPanel, do not automatically clear their backgrounds. This
                                    must be done explicitly in the paintComponent() method.

Poor program design                    The complete implementation of FixArrayBound is given in Fig-
                                    ure 10-19. This example illustrates how an exception can be handled suc-
                                    cessfully and the program's normal flow of control resumed. However,
                                    the question is whether such an exception should be handled this way.

                                       Unfortunately, this is not a well-designed program. The array's initial
                                    size is much too small for the program's intended use. Therefore, the fact
                                    that these exceptions arise at all is the result of poor design. In general,
                                    exceptions should not be used as a remedy for poor design.

                                     JAVA EFFECTIVE DESIGN Truly Exceptional Conditions. A
                                     well-designed program should use exception handling to deal with
                                     truly exceptional conditions, not to process conditions that arise under
                                     normal or expected circumstances.

Proper array usage                  For a program that uses an array, the size of the array should be chosen so
                                    that it can store all the objects required by the program. If the program is
                                    some kind of failsafe program, which cannot afford to crash, then some-
                                    thing like the previous approach might be justified, provided this type
                                    of exception occurs very rarely. Even in that case it would be better to
                                    generate a message that alerts the program's user that this condition has
                                    occurred. The alert will indicate a need to modify the program's memory
                                    requirements and restart the program.

Figure 10.18: The strings dis-
played are stored in an array that
is extended each time a new string
is entered.
SECTION 10.5  Error Handling and Robust Program Design 485

                                                                                                       

import java . awt .  ;
import java . awt . event .  ;
import javax . swing .  ;

public class FixArrayBound extends JPanel
                                                  implements ActionListener {

   public s t a t i c f i n a l i n t WIDTH = 3 5 0 , HEIGHT = 1 0 0 ;
   p r i v a t e J T e x t F i e l d i n F i e l d = new J T e x t F i e l d ( 1 0 ) ;
   p r i v a t e J L a b e l prompt = new J L a b e l (

                                       " Input a word and type <ENTER>: " ) ;

                                            // I n i t i a l l y l i s t has 2 e l e m e n t s

   p r i v a t e S t r i n g l i s t [ ] = new S t r i n g [ 2 ] ;
   private int count = 0;

  public FixArrayBound ( ) {
     inField . addActionListener ( this );
     add ( prompt ) ;
     add ( i n F i e l d ) ;
     s e t S i z e (WIDTH, HEIGHT ) ;

  } // F i x A r r a y B o u n d ( )

  public void paintComponent ( Graphics g) {
     g . setColor ( getBackground ( ) ) ; // C l e a r t h e b a c k g r o u n d
     g . f i l l R e c t ( 0 , 0 , WIDTH, HEIGHT ) ;
     g . setColor ( getForeground ( ) ) ;
     S t r i n g tempS = "" ;
     for ( int k = 0; k < l i s t . length ; k++)
         tempS = tempS + l i s t [ k ] + " " ;
     g . drawString ( tempS , 10 , 5 0 ) ;

  } // p a i n t C o m p o n e n t

  private void insertString ( String str ) {

  try {

     l i s t [ count ] = str ;

  } catch ( ArrayIndexOutOfBoundsException e ) {

     S t r i n g newList [ ] = new S t r i n g [ l i s t . l e n g t h + 1 ] ; // New           array
                                                                                                new
     for ( int k = 0; k < l i s t . length ; k++) // Copy o l d t o

     newList [k] = l i s t [k ] ;

     newList [ count ] = str ; // I n s e r t i t e m i n t o new

     l i s t = newList ;                  // Make o l d p o i n t t o new

  } finally {                             // The e x c e p t i o n i s now f i x e d

     count ++;                            // so i n c r e a s e t h e c o u n t

  }

  } // i n s e r t S t r i n g ( )

  public void actionPerformed ( ActionEvent evt ) {

  insertString ( inField . getText ( ) ) ;

  inField . setText ("" ) ;

  repaint ();

  } // a c t i o n P e r f o r m e d ( )

                                                                                                       

Figure 10.19: FixArrayBound increases the size of the array when a
ArrayIndexOutOfBoundsException is raised.
                                     486                 CHAPTER 10  Exceptions: When Things Go Wrong

                                                                                                                                

                                          public s t a t i c void main ( S t r i n g args [ ] ) {
                                                 JFrame f = new JFrame ( " Array F i x e r " ) ;
                                                 FixArrayBound panel = new FixArrayBound ( ) ;
                                                 f . getContentPane ( ) . add ( panel ) ;
                                                 f . s e t S i z e ( panel .WIDTH, panel . HEIGHT ) ;
                                                 f . setVisible ( true );
                                                 f . addWindowListener (new WindowAdapter ( ) {
                                                        public void windowClosing ( WindowEvent e ) {
                                                               System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n
                                                        }

                                          });

                                          } // main ( )

                                     } // F i x A r r a y B o u n d

                                                                                                                                

                                     Figure 10.19: (continued) FixArrayBound increases the size of the array
                                     when ArrayIndexOutOfBoundsException is raised.

Choosing the correct data structure     If it is not known in advance how many objects will be stored in an
                                     array, a better design would be to make use of the java.util.Vector
                                     class (see "From the Java Library" in Chapter 9). Vectors are designed to
                                     grow as new objects are inserted. In some ways the exception-handling
                                     code in our example mimics the behavior of a vector. However, the
                                     Vector class makes use of efficient algorithms for extending its size. By
                                     contrast, exception-handling code is very inefficient. Because exceptions
                                     force the system into an abnormal mode of execution, it takes considerably
                                     longer to handle an exception than it would to use a Vector for this type
                                     of application.

                                       JAVA EFFECTIVE DESIGN Appropriate Data Structure. A major
                                       component of problem solving is choosing the best way to represent
                                       the data. A vector should be used as an array structure whenever the
                                       size of the array will grow and shrink dynamically during the
                                       program's execution.

                                     SELF-STUDY EXERCISE

                                     EXERCISE 10.13 For each of the following exceptions, determine
                                     whether it can be handled in such a way that the program can be resumed
                                     or whether the program should be terminated:

                                     a. A computer game program detects a problem with one of its GUI ele-
                                        ments and throws a NullPointerException.

                                     b. A factory assembly-line control program determines that an important
                                        control value has become negative and generates an Arithmetic-
                                        Exception.

                                     c. A company's Web-based order form detects that its user has entered an
                                        invalid String and throws a SecurityException.

          Exception
     +getMessage()
IntOutOfRangeException
 SECTION 10.6  Creating and Throwing Your Own Exceptions 487

10.6 Creating and Throwing Your Own
        Exceptions

Like other Java classes, the Exception class can be extended to handle

cases that are not already covered by Java's built-in exceptions. Exceptions

that you define will be handled the same way by the Java interpreter, but

you will have to throw them yourself.

For example, Figure 10.20 shows the design of an exception that can

be used for validating that an integer is less than or equal to a certain

maximum value. It would be coded as follows:

                                                                                        

  / 

   I n t O u t O f R a n g e E x c e p t i o n r e p o r t s an e x c e p t i o n when

      an i n t e g e r exceeds i t s bound .

  /

public class IntOutOfRangeException extends Exception {

           public IntOutOfRangeException ( i n t Bound ) {                              
               super ( "The input value exceeds the bound " + Bound ) ;
                                                                                                               JTextField
           }
    }                                                                                                            IntField
                                                                                              -bound : int
                                                                                              +IntField()
The class extends Exception and consists entirely of a constructor                            +IntField(in size : int)
method that calls the superclass constructor. The argument passed                             +IntField(in size : int, in max : int)
to the superclass constructor is the message that will be returned by                         +getInt() : int
getMessage() when an instance of this exception is created.
                                                                                        
   Now let's consider an example where this new exception will be                        Figure 10.21: The revised
thrown. Suppose we wish to constrain the IntField class that we de-                      IntField class contains a
veloped previously (Fig. 10.14) so that it will only accept numbers that are             bound on the size of the numbers
less than a certain bound. First, let's modify IntField so that its bound                that should be entered.
can be set when an instance is created. We want its bound to be an instance
variable with some initial value, and we want to provide a constructor that             
can be used to override the default (Fig. 10.21).

   This leads to the following revision of IntField:

 

    public class IntField extends JTextField {
           p r i v a t e i n t bound = I n t e g e r .MAX VALUE;

           public I n t F i e l d ( i n t s i z e , i n t max ) {
                  super ( size ) ;
                  bound = max ;

           }

            // The r e s t o f t h e c l a s s i s u n c h a n g e d f o r now

    } // I n t F i e l d
 

Our new constructor has the signature IntField(int,int), which
doesn't duplicate any of JTextField's constructors. This is good design,
because in extending a class, we want to be careful about the effect that
our definitions have on the original methods in the superclass. Superclass
methods should be overridden by design, not by accident. If a method is
488                   CHAPTER 10  Exceptions: When Things Go Wrong

                                                                                 

import javax . swing .  ;

public class IntField extends JTextField {
       p r i v a t e i n t bound = I n t e g e r .MAX VALUE;

     public IntField ( int size ) {
            super ( size ) ;

     }

     public I n t F i e l d ( i n t s i z e , i n t max ) {
            super ( size ) ;
            bound = max ;

     }

     public int getInt ( ) throws NumberFormatException ,
                                                      IntOutOfRangeException {

            i n t num = I n t e g e r . p a r s e I n t ( g e t T e x t ( ) ) ;
            i f (num > bound )

                   throw new IntOutOfRangeException ( bound ) ;
            r e t u r n num ;
     } // g e t I n t ( )

} // I n t F i e l d

                                                                                 

Figure 10.22: The revised IntField class containing the revised
getInt() method.

redefined inadvertently, it might not function as expected by users of the
subclass.

 JAVA EFFECTIVE DESIGN Extending a Class. When extending a
 class, care must taken to ensure that the superclass's methods are not
 inadvertently overridden. A superclass method should only be
 overridden by design, not by accident.

   Note how we have handled the problem of setting the default value
of the bound. Integer.MAX VALUE is a class constant that sets the
maximum value for the int type. It's an appropriate value to use, be-
cause any valid int that the user types should be less than or equal to
MAX VALUE. Given these changes to IntField, let's now incorporate our
new exception into its getInt() method (Fig. 10.22).

   This new version of getInt() throws an exception if the integer en-
tered by the user is greater than the IntField's bound. Here again, it
is difficult to handle this exception appropriately in this method. The
method would either have to return an erroneous value--because it must
return something--or it must terminate. Neither is an acceptable alterna-
tive. It is far better to throw the exception to the calling method.

   The IntFieldTester class (Fig. 10.23) has the design and function-
ality shown in Figure 10.15. It provides a simple GUI interface to test
the IntField class. It prompts the user to type an integer that is less
than 100, and then it echoes the user's input. Note how the exception is
SECTION 10.7  From the Java Library: JOptionPane                     489

handled in the actionPerformed() method. If an exception is thrown
in IntField.getInt(), the actionPerformed() method pops up an
error dialog, and the erroneous input is not used. Instead, the user is given
another chance to enter a valid integer.

SELF-STUDY EXERCISES

EXERCISE 10.14 Define a new Exception named FieldIsEmpty-
Exception, which is meant to be thrown if the user forgets to enter a
value into a IntField.

EXERCISE 10.15 Modify the IntField.getInt() method so that it
throws and catches the FieldIsEmptyException.

10.7 From the Java Library: JOptionPane

A dialog box is a window that can be opened by a program to communi-                                 java.sun.com/j2se/1.5.0/docs/api/
cate in some way with the user. Dialog boxes come in many varieties and
have many uses in a GUI environment. You've undoubtedly encountered            
them when using your own computer.
                                                                               
   For example, a file dialog is opened whenever you want to open or save
a file. It provides an interface that lets you name the file and helps you                                         Creates
search through the computer's directory structure to find a file.                      TopLevelWindow

   A warning dialog or error dialog is opened whenever a program needs                                          DialogWindow
to notify or warn you that some kind of error occurred. It usually presents
an error message and an OK button that you click to dismiss the dialog.         Figure 10.24: A dialog window
                                                                                cannot stand alone. It must be cre-
   Dialogs are easy to create and use in Java. The Swing component              ated by a top-level window.
set provides several different kinds of basic dialogs that can be incorpo-
rated into your program with one or two lines of code. For example, the
IntFieldTester class makes use of a simple message dialog to report
an input error to the user. This dialog was created by the following code
segment in the program (see Figure 10.23):



  catch ( NumberFormatException e ) {                  reenter ." );

     JOptionPane . showMessageDialog ( this ,

         "The input must be an i n t e g e r . Please

  }


This method call displays the window shown in Figure 10.16. It con-
tains the error message and an OK button that is used to close the win-
dow. The showMessageDialog() method is a static method of the
javax.swing.JOptionPane class. This class provides a collection of
similar methods for creating and displaying basic dialog boxes.

   A dialog differs from other kinds of top-level windows--such
as JApplet and JFrame--in that it is associated with another
window (Fig. 10-24). The first parameter in this version of the
showMessageDialog() method is a reference to the dialog's parent
window. The second parameter is a String representing the message.

   The basic message dialog used in this example is known as a modal
dialog. This means that once it's been displayed, you can't do anything
else until you click the OK button and dismiss the dialog. It's also possible
                 490                    CHAPTER 10  Exceptions: When Things Go Wrong
                                                                                                              
  import     java . awt .  ;
  import     java . awt . event .  ;
  import     javax . swing .  ;

public class IntFieldTester extends JPanel
                                                                      implements ActionListener {

   public s t a t i c f i n a l i n t WIDTH = 3 0 0 , HEIGHT = 3 0 0 ;
   p r i v a t e J L a b e l prompt = new J L a b e l ( " Input an i n t e g e r <= 1 0 0 : " ) ;
   p r i v a t e I n t F i e l d i n t F i e l d = new I n t F i e l d ( 1 2 , 1 0 0 ) ;
   private int userInt ;
   private String message = "Hello" ;

  public IntFieldTester () {
     add ( prompt ) ;
     intField . addActionListener ( this );
     add ( i n t F i e l d ) ;
     s e t S i z e (WIDTH, HEIGHT ) ;

  } // I n t F i e l d T e s t e r ( )

  public void paintComponent ( Graphics g ) {

  g . setColor ( getBackground ( ) ) ;                     // C l e a r t h e p a n e l

  g . f i l l R e c t ( 0 , 0 , WIDTH, HEIGHT ) ;

  g . setColor ( getForeground ( ) ) ;

  g . drawString ( message , 10 , 7 0 ) ;

  } // p a i n t C o m p o n e n t ( )

  public void actionPerformed ( ActionEvent evt ) {
     try {
         userInt = intField . getInt ();
         message = "You input " + u s e r I n t + " Thank you . " ;
     } catch ( NumberFormatException e ) {
         JOptionPane . showMessageDialog ( this ,
           "The input must be an i n t e g e r . Please r e e n t e r . " ) ;
     } catch ( IntOutOfRangeException e ) {
         JOptionPane . showMessageDialog ( this , e . getMessage ( ) ) ;
     } finally {
         repaint ();
     }

  } // a c t i o n P e r f o r m e d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  JFrame f = new JFrame ( " I n t F i e l d T e s t e r " ) ;

  I n t F i e l d T e s t e r panel = new I n t F i e l d T e s t e r ( ) ;

  f . getContentPane ( ) . add ( panel ) ;

  f . s e t S i z e ( panel .WIDTH, panel . HEIGHT ) ;

  f . setVisible ( true );

  f . addWindowListener (new WindowAdapter ( ) {

          public void windowClosing ( WindowEvent e ) {

             System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

          }

  });

  } // main ( )

} // I n t F i e l d T e s t e r

                                                                                                   

             Figure 10.23: An application that uses an IntField object to process
             integers.
SECTION 10.7  From the Java Library: JOptionPane                             491

to create nonmodal dialogs. These can stay around on the screen while you          Modal and nonmodal dialogs
move on to other tasks.

   Note that the dialog box also contains an icon that symbolizes the pur-
pose of the message (Fig. 10.25). The icon is representative of the dialog's

                                                                                   Figure 10.25: An error dialog.

message type. Among the basic types available in JOptionPane are the
following:

                                                                                   
                                                                                   
  JOptionPane . PLAIN MESSAGE          // D e f a u l t                            
  JOptionPane . INFORMATIONAL MESSAGE                                              
  JOptionPane .WARNING MESSAGE                                                     
  JOptionPane . QUESTION MESSAGE
  JOptionPane . ERROR MESSAGE                                                      
                                                                                    Basic Swing dialogs

To set the dialog to anything other than the default (informational) type,
you can use the following version of showMessageDialog():



  showMessageDialog ( Component comp , O b j e c t message ,
                                   S t r i n g t i t l e , i n t msgType ) ;



The first parameter is a reference to the parent window. The second is the
message string. The third is a string used as the dialog window's title, and
the fourth is one of the five dialog types. For example, we can change our
dialog to an error dialog with the following statement:



  catch ( IntOutOfRangeException e ) {
         JOptionPane . showMessageDialog ( this ,
                        e . getMessage ( ) ,
                       "Error dialog" ,
                        JOptionPane . ERROR MESSAGE ) ;

  }


This would produce the dialog shown in Figure 10.25.
   The other kinds of basic dialogs provided by the JOptionPane class

are listed in Table 10.4. All of the dialogs listed there can be created with a
line or two of code. In addition to these, it's also possible to create sophis-
ticated dialogs that can be as customized as any other GUI interface you
can build in Java.
                 492          CHAPTER 10  Exceptions: When Things Go Wrong

                      TABLE 10.4 Basic dialogs provided by JOptionPane.

                      Dialog          Description

                      Message Dialog  Presents a simple error or informational message
                      Confirm Dialog  Prompts the user to confirm a particular action
                      Option Dialog   Lets the user choose from some options
                      Input Dialog    Prompts and inputs a string

                    In this chapter, you have learned how to handle exceptional conditions
                 that occur in programs. You now know that Java has a default excep-
                 tion handler that can take of many situations, and you also understand
                 that proper program design using Java excpetion-handling elements helps
                 deal with many other situations. This chapter continues the emphasis on
                 good program design for creating useful, stable programs.

CHAPTER SUMMARY  Technical Terms

                 catch block          exception                          static scope
                 catch an exception   exception handling                 throw an exception
                 checked exception    finally block                      try block
                 dialog box           method call stack                  unchecked exception
                 dynamic scope        method stack trace
                 error dialog         modal dialog

                 The Try/Catch Statement

                 The try/catch/finally statement has the following syntax:

                                                                                                           

                 try {

                      // B l o c k o f s t a t e m e n t s

                      // At l e a s t one o f which may t h r o w an e x c e p t i o n

                        i f (  Some c o n d i t i o n o b t a i n s / )
                               throw new ExceptionName ( ) ;

                 } catch ( ExceptionName ParameterName ) {

                      // B l o c k o f s t a t e m e n t s t o be e x e c u t e d

                          // I f t h e E x c e p t i o n N a m e e x c e p t i o n i s thrown i n t r y

                 }
                 ..
                 } catch ( ExceptionName2 ParameterName ) {

                      // B l o c k o f s t a t e m e n t s t o be e x e c u t e d

                          // I f t h e E x c e p t i o n N a m e 2 e x c e p t i o n i s thrown i n t r y

                 } finally {

                      // O p t i o n a l b l o c k o f s t a t e m e n t s t h a t i s e x e c u t e d

                      // Whether an e x c e p t i o n i s thrown or n o t

                 }

                                                                                                           

                 The try block is meant to include a statement or statements that might
                 throw an exception. The catch blocks--there can be one or more--are
                 meant to handle exceptions that are thrown in the try block. A catch block
CHAPTER 10  Chapter Summary  493

will handle any exception that matches its parameter class, including sub-
classes of that class. The finally block is optional. It will be executed
whether an exception is thrown or not. If an exception is thrown in the
try block, the try block is exited permanently.

   The throw statement inside the try block is there to illustrate how
throw can be used. You will usually not see a throw statement in a try
block, because most throws are done from within Java library methods,
which are called from a try block.

Summary of Important Points

 In Java, when an error or exceptional condition occurs, you throw an
   Exception, which is caught by special code known as an exception
   handler. A throw statement--throw new Exception()--is used to
   throw an exception.

 A try block is a block of statements containing one or more statements
   that may throw an exception. Embedding a statement in a try block
   indicates your awareness that it might throw an exception and your
   intention to handle the exception.

 Java distinguishes between checked and unchecked exceptions. Checked
   exceptions must either be caught by the method in which they occur
   or you must declare that the method containing that statement throws
   the exception.

 Unchecked exceptions are those that belong to subclasses of Runtime-
   Exception. If they are left uncaught, they will be handled by Java's
   default exception handlers.

 A catch block is a block of statements that handles the exceptions that
   match its parameter. A catch block can only follow a try block, and
   there may be more than one catch block for each try block.

 The try/catch syntax allows you to separate the normal parts of an
   algorithm from special code meant to handle errors and exceptional
   conditions.

 A method stack trace is a trace of the method calls that have led
   to the execution of a particular statement in the program. The
   Exception.printStackTrace() method can be called by excep-
   tion handlers to print a trace of exactly how the program reached the
   statement that threw the exception.

 Static scoping refers to how the text of the program is arranged. If a vari-
   able is declared within a method or a block, its static scope is confined
   to that method or block.

 Dynamic scoping refers to how the program is executed. A statement is
   within the dynamic scope of a method or block if it is called from that
   method or block, or if it is called by some other method that was called
   from that method or block.

 When searching for a catch block to handle an exception thrown by a
   statement, Java searches upward through the statement's static scope
   and backward through its dynamic scope until it finds a matching
   catch block. If none is found, the Java Virtual Machine will handle the
   exception itself by printing an error message and a method stack trace.

 Many Java library methods throw exceptions when an error occurs.
   These throw statements do not appear in the program. For example,
                      494         CHAPTER 10  Exceptions: When Things Go Wrong

                        Java's integer division operator will throw an ArithmeticException
                        if an attempt is made to divide by zero.
                       Generally, there are four ways to handle an exception: (1) Let Java han-
                        dle it; (2) fix the problem that led to the exception and resume the pro-
                        gram; (3) report the problem and resume the program; and (4) print an
                        error message and terminate the program. Most erroneous conditions
                        reported by exceptions are difficult or impossible to fix.
                       A finally statement is an optional part of a try/catch block. State-
                        ments contained in a finally block will be executed whether an excep-
                        tion is raised or not.
                       A well-designed program should use exception handling to deal with
                        truly exceptional conditions, not as a means of normal program control.
                       User-defined exceptions can be defined by extending the Exception
                        class or one of its subclasses.

SOLUTIONS TO          SOLUTION 10.1
SELF-STUDY EXERCISES   a. Integer.parseInt("26.2"); ==> NumberFormatException
                       b. String s; s.indexOf('a'); ==> NullPointerException
                       c. String s = "hello"; s.charAt(5); ==> StringIndexOutOfBoundsExcepti

                      SOLUTION 10.2 The unchecked exceptions are IndexOutOfBoundsException,
                      NumberFormatException, and NullPointerException, because these are
                      subclasses of RuntimeException. The others are checked exceptions.

                      SOLUTION 10.3 An ArrayIndexOutOfBoundsException could be handled
                      by the handlers in a, c, or d, because their classes are all superclasses of Array-
                      IndexOutOfBoundsException.

                      SOLUTION 10.4 If Math.random() in MyClass2 returns 0.98 and then 0.44,
                      the program will generate the following output:

                                                                                

                      0.98 is out of range
                                                                                

                      Note that because the out-of-range error occurs in method1(), method2() is not
                      called at all.

                      SOLUTION 10.5 If Math.random() in MyClass2 returns 0.98 and then 0.44,
                      the following stack trace would be printed:

                                                                                

                      java . lang . ArithmeticException : 0.98 is out of range

                           at MyClass2 . method1 ( MyClass2 . java : 3 )

                           at MyClass2 . main ( MyClass2 . java : 1 5 )         

                      SOLUTION 10.6 If Math.random() in MyClass2 returns 0.44 and then 0.98,
                      the program will generate the following output:

                                                                                

                      Hello 0.44

                      0.98 is out of range                                      
                      
CHAPTER 10  Solutions to Self-Study Exercises                          495

SOLUTION 10.7 If Math.random() in MyClass2 returns 0.44 and then 0.98,
the following stack trace would be printed:

                                                                        

java . lang . ArithmeticException : 0.98 is out of range

   at MyClass2 . method2 ( MyClass2 . java : 8 )

   at MyClass2 . main ( MyClass2 . java : 1 6 )                         

SOLUTION 10.8 The divide-by-zero error in BadDivide occurs in the expres-
sion n/d in Method2(). It would generate the following stack trace:

                                                                        

java . lang . ArithmeticException : divide by zero

   at BadDivide . method2 ( BadDivide . java : 7 )

   at BadDivide . method1 ( BadDivide . java : 3 )

   at BadDivide . main ( BadDivide . java : 1 3 )                       

SOLUTION 10.9 The following version of BadDivide.method2() will handle
the divide-by-zero error itself:

                                                                        

public void method2 ( int n , int d) {
       try {
              System . out . println (n / d ) ;
       } catch ( ArithmeticException e) {
              System . out . println ( e . getMessage ( ) ) ;
              e . printStackTrace ();
              System . exit ( 0 ) ;
       }

}

                                                                        

SOLUTION 10.10 If someValue equals 1000, the code segment will print

                                                                        

Entering try block

ERROR : 1000 i s too l a r g e                                          


SOLUTION 10.11 If someValue equals 50, the code segment will print

                                                                        

Entering try block

Exiting try block
                                                                        

SOLUTION 10.12

                                                                        

try {

   if (X < 0)

   throw new Ex ce pti on (

               "ERROR : Negative value i n X c o o r d i n a t e " ) ;

} catch ( Exception e) {

   System . out . println ( e . getMessage ( ) ) ;

}

                                                                        

SOLUTION 10.13
                                  496                     CHAPTER 10  Exceptions: When Things Go Wrong

                                     a. It depends. This is a computer game, so one way to handle this problem
                                          would be to generate a message into a log file and resume the game. If
                                          the GUI element is crucial to the game, it's hard to see how it could be
                                          successfully handled.

                                  b. It depends. You would have to decide whether it would be more harmful or
                                       dangerous to continue production than not.

                                     c. The program could report the security violation to the user and to the system
                                          manager and then keep accepting user input.

                                  SOLUTION 10.14

                                                                                                                                  

                                  public class FieldIsEmptyException extends Exception {
                                         public FieldIsEmptyException () {
                                                super ( "The input f i e l d i s empty " ) ;
                                         }

                                  }

                                                                                                                                  

                                  SOLUTION 10.15

                                                                                                                                  

                                  public int getInt () {
                                         i n t num = 0 ;
                                         try {
                                                String data = getText ( ) ;
                                                if ( data . equals ("" ))
                                                       throw new F i e l d I s E m p t y E x c e p t i o n ( ) ;
                                                num = I n t e g e r . p a r s e I n t ( g e t T e x t ( ) ) ;
                                                i f (num > bound )
                                                       throw new IntOutOfRangeException ( bound ) ;
                                         } catch ( FieldIsEmptyException e) {
                                                System . out . println ( " Error : " + e . getMessage ( ) ) ;
                                         } catch ( NumberFormatException e ) {
                                            System . out . p r i n t l n ( " E r r o r : You must input an i n t e g e r .
                                                                                                        Please try again . " ) ;
                                         } catch ( IntOutOfRangeException e ) {
                                                System . out . println ( e . getMessage ( ) ) ;
                                                return 0;
                                         }

                                       r e t u r n num ;

                                  }

                                                                                                                                  

EXERCISES                         EXERCISE 10.1 Explain the difference between the following pairs of terms:

Note: For programming exercises,  a. Throwing an exception and catching an exception.
first draw a UML class diagram    b. Try block and catch block.
describing all classes and their  c. Catch block and finally block.
inheritance relationships and/or  d. Try block and finally block.
associations.                     e. Dynamic scope and static scope.
                                  f. Dialog box and top-level window.
                                  g. Checked and unchecked exception.
                                  h. Method stack and method call.

                                  EXERCISE 10.2 Fill in the blanks.
CHAPTER 10  Exercises                                                                     497

a.              an exception is Java's way of signaling that some kind of abnormal

    situation has occurred.

b. The only place that an exception can be thrown in a Java program is within a

                .

c. The block of statements placed within a catch block is generally known as an

                .

d. To determine a statement's       scope, you have to trace the program's

    execution.

e. To determine a statement's       scope, you can just read its definition.

f. When a method is called, a representation of the method call is placed on the

                .

g. The root of Java's exception hierarchy is the             class.

h. A               exception must be either caught or declared within the method in

    which it might be thrown.

i. An              exception can be left up to Java to handle.

EXERCISE 10.3 Compare and contrast the four different ways of handling ex-
ceptions within a program.

EXERCISE 10.4 Suppose you have a program that asks the user to input a string
of no more than five letters. Describe the steps you'd need to take in order to
design a StringTooLongException to handle cases where the user types in too
many characters.

EXERCISE 10.5 Exceptions require more computational overhead than normal
processing. Explain.

EXERCISE 10.6 Suppose the following ExerciseExample program is cur-
rently executing the if statement in method2():

                                                                                           

public class ExerciseExample {
   public void method1 ( i n t M) {
       try {
          System . out . println ( " Entering try block" ) ;
          method2 ( M ) ;
          System . out . println ( " Exiting try block" ) ;
       } catch ( Exception e) {
          System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;
       }

    } // method1 ( )

    public void method2 ( i n t M) {
       i f (M > 1 0 0 )
           throw new A r i t h m e t i c E x c e p t i o n (M + " i s too l a r g e " ) ;

    }

    public s t a t i c void main ( S t r i n g argv [ ] ) {

       ExerciseExample ex = new ExerciseExample ( ) ;

       ex . method1 ( 5 0 0 ) ;

    }

} // E x e r c i s e E x a m p l e

                                                                                           

Draw a picture of the method call stack that represents this situation.
498  CHAPTER 10  Exceptions: When Things Go Wrong

EXERCISE 10.7 Repeat the previous exercise for the situation where the pro-
gram is currently executing the second println() statement in method1().

EXERCISE 10.8 Draw a hierarchy chart that represents the static scoping rela-
tionships among the elements of the ExerciseExample program.

EXERCISE 10.9 What would be printed by the ExerciseExample program
when it is run?

EXERCISE 10.10 What would be printed by the ExerciseExample program,
if the statement in its main method were changed to ex.method1(5)?

EXERCISE 10.11 Consider again the ExerciseExample program. If the ex-
ception thrown were Exception rather than ArithmeticException, explain
why we would get the following error message: java.lang.Exception must
be caught, or it must be declared....

EXERCISE 10.12 Write a try/catch block that throws an Exception if the
value of variable X is less than zero. The exception should be an instance of
Exception and, when it is caught, the message returned by getMessage()
should be "ERROR: Negative value in X coordinate."

EXERCISE 10.13 Look at the IntFieldTester program (Fig. 10.23) and the
IntField class definition (Fig. 10.22). Suppose the user inputs a value that's
greater than 100. Show what the method call stack would look like when the
IntField.getInt() method is executing the num > bound expression.

EXERCISE 10.14 As a continuation of the previous exercise, show what the
program's output would be if the user input a value greater than 100.

EXERCISE 10.15 As a continuation of the previous exercise, modify the
IntOutOfRangeException handler so that it prints the message call stack. Then
show what it would print.

EXERCISE 10.16 Define a subclass of RuntimeException named Invalid-
PasswordException, which contains two constructors. The first constructor
takes no parameters and an exception thrown with this constructor should re-
turn "ERROR: invalid password" when its getMessage() is invoked. The sec-
ond constructor takes a single String parameter. Exceptions thrown with this
constructor should return the constructor's argument when getMessage() is
invoked.

EXERCISE 10.17 Extend the IntField class so that it will constrain the integer
JTextField to an int between both a lower and upper bound. In other words, it
should throw an exception if the user types in a value lower than the lower bound
or greater than the upper bound.

EXERCISE 10.18 Design Issue: One of the preconditions for the Insertion-
Sort() method (Fig. 9.13) is that its array parameter not be null. Of course, this
precondition would fail if the array were passed a null array reference. In that
case, Java would throw a NullPointerException and terminate the program.
Is this an appropriate way to handle that exception?

EXERCISE 10.19 With respect to the previous exercise, suppose you decide that
it is more appropriate to handle the NullPointerException by presenting an
error dialog. Modify the method to accommodate this behavior.

EXERCISE 10.20 Design Issue: Another possible way to design the sequential-
Search() method (Fig. 9.16) would be to have it throw an exception when its key
is not found in the array. Is this a good design? Explain.
Chapter 11

Files and Streams:
Input/Output Techniques

OBJECTIVES

After studying this chapter, you will
 Be able to read and write text files.
 Know how to read and write binary files.
 Understand the use of InputStreams and OutputStreams.
 Be able to design methods for performing input and output.
 Know how to use the File class.
 Be able to use the JFileChooser class.

OUTLINE

11.1 Introduction
11.2 Streams and Files
11.3 Case Study: Reading and Writing Text Files
11.4 The File Class
11.5 Example: Reading and Writing Binary Files
11.6 Object Serialization: Reading and Writing Objects
11.7 From the Java Library: javax.swing.JFileChooser
11.8 Using File Data in Programs

         Special Topic: Databases and Personal Privacy
          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              499
                              500  CHAPTER 11  Files and Streams: Input/Output Techniques

                              11.1 Introduction

input and output              We have been using input and output in our programs since the very first
                              chapters of the book. In this chapter we will take a closer look at Java's
                              input and output elements.

                                 Input refers to information or data read from some external source into
                              a running program. We introduced you to working with input in Chap-
                              ter 4, when we developed the KeyboardReader class with methods for
                              reading data from the keyboard into the console window. We also dis-
                              cussed reading data from the keyboard into a JTextField in a GUI inter-
                              face, as well as reading data from a text file using methods in the Scanner
                              class during that chapter.

                                 Output refers to information or data written from the running program
                              to some external destination. Up to this point, whenever our programs
                              have produced output, it has been sent to either the Java console, to a text
                              area, or to some other GUI component. These destinations are transitory,
                              in the sense that they reside in the computer's primary memory and exist
                              only so long as the program is running.

                                 A file is a collection of data that's stored on a disk or on some other
                              relatively permanent storage medium. A file's existence does not depend
                              on a running program. In this chapter, we will learn how to create files
                              and how to perform input and output operations on their data using the
                              Java classes designed specifically for this purpose. Methods from these
                              classes allow us to write data to files and provide greater flexibility in the
                              way we read data from files than the Scanner class offers.

                              11.2 Streams and Files

I/O streams                   As was noted in Chapter 4, all input and output (I/O) in Java is accom-
                              plished through the use of input streams and output streams. You are
                              already familiar with input and output streams because we have rou-
                              tinely used the System.out output stream and and the System.in in-
                              put stream (Fig. 11.1) in this text's examples. Recall that System.out
                              usually connects your program (source) to the screen (destination) and
                              System.in usually connects the keyboard (source) to the running pro-
                              gram (destination). What you have learned about streams will also be a
                              key for connecting files to a program.

Figure 11.1: The System.out                                     Memory
output stream connects your                                     Program
program to the screen and
the System.in input stream         Screen          System.out
connects it to the keyboard.                     Output stream

                                                   System.in
                                                 Input stream

                                   Keyboard
SECTION 11.2  Streams and Files    501

11.2.1 The Data Hierarchy                                                                                 Database

Data, or information, are the contents that flow through Java streams or         chris martine            1999        File
stored in files. All data are comprised of binary digits or bits. A bit is       deborah mars             2000      10.1
simply a 0 or a 1, the electronic states that correspond to these values. As     william smith            2001      9.15
we learned in Chapter 5, a bit is the smallest unit of data.                                                        8.75

   However, it would be tedious if a program had to work with data in                                    Record
units as small as bits. Therefore, most operations involve various-sized         deborah mars 2000 9.15
aggregates of data such as an 8-bit byte, a 16-bit short, a 16-bit char, a
32-bit int, a 64-bit long, a 32-bit float, or a 64-bit double. As we know,                                   Field
these are Java's primitive numeric types. In addition to these aggregates,                      deborah mars
we can group together a sequence of char to form a String.
                                                                                       a
   It is also possible to group data of different types into objects. A record,           Byte
which corresponds closely to a Java object, can have fields that contain
different types of data. For example, a student record might contain fields      00110001
for the student's name and address represented by (Strings), expected
year of graduation (int), and current grade point average represented            0 Bit
by (double). Collections of these records are typically grouped into files.
For example, your registrar's office may have a separate file for each of        Figure 11.2: The data hierarchy.
its graduating classes. These are typically organized into a collection of
related files, which is called a database.

   Taken together, the different kinds of data that are processed by a com-
puter or stored in a file can be organized into a data hierarchy (Fig. 11.2).

   It's important to recognize that while we, the programmers, may
group data into various types of abstract entities, the information flowing
through an input or output stream is just a sequence of bits. There are no
natural boundaries that mark where one byte (or one int or one record)
ends and the next one begins. Therefore, it will be up to us to provide the
boundaries as we process the data.

11.2.2 Binary Files and Text Files

As we noted in chapter 4, there are two types of files in Java: binary files     Text files are portable
and text files. Both kinds store data as a sequence of bits--that is, a se-
quence of 0's and 1's. Thus, the difference between the two types of files
lies in the way they are interpreted by the programs that read and write
them. A binary file is processed as a sequence of bytes, whereas a text file is
processed as a sequence of characters.

   Text editors and other programs that process text files interpret the
file's sequence of bits as a sequence of characters--that is, as a string.
Your Java source programs (*.java) are text files, and so are the HTML
files that populate the World Wide Web. The big advantage of text files
is their portability. Because their data are represented in the ASCII code
(Table 5.13), they can be read and written by just about any text-processing
program. Thus, a text file created by a program on a Windows/Intel
computer can be read by a Macintosh program.

   In non-Java environments, data in binary files are stored as bytes, and
the representation used varies from computer to computer. The manner
in which a computer's memory stores binary data determines how it is
represented in a file. Thus, binary data are not very portable. For exam-
ple, a binary file of integers created on a Macintosh cannot be read by a
Windows/Intel program.
                                     502  CHAPTER 11  Files and Streams: Input/Output Techniques

Binary files are platform dependent     One reason for the lack of portability is that each type of computer uses
                                     its own definition for how an integer is defined. On some systems an
                                     integer might be 16 bits, and on others it might be 32 bits, so even if you
                                     know that a Macintosh binary file contains integers, that still won't make
                                     it readable by Windows/Intel programs. Another problem is that even
                                     if two computers use the same number of bits to represent an integer,
                                     they might use different representation schemes. For example, some com-
                                     puters might use 10000101 as the 8-bit representation of the number 133,
                                     whereas other computers might use the reverse, 10100001, to represent
                                     133.

                                        The good news for us is that Java's designers have made its binary files
                                     platform independent by carefully defining the exact size and representation
                                     that must be used for integers and all other primitive types. Thus, binary
                                     files created by Java programs can be interpreted by Java programs on any
                                     platform.

                                     JAVA LANGUAGE RULE Platform Independence. Java binary files
                                     are platform independent. They can be interpreted by any computer
                                     that supports Java.

I/O streams                          11.2.3 Input and Output Streams

                                     Java has a wide variety of streams for performing I/O. They are de-
                                     fined in the java.io package, which must be imported by any program
                                     that does I/O. They are generally organized into the hierarchy illustrated
                                     in Figure 11.3. We will cover only a small portion of the hierarchy in
                                     this text. Generally speaking, binary files are processed by subclasses
                                     of InputStream and OutputStream. Text files are processed by sub-
                                     classes of Reader and Writer, both of which are streams, despite their
                                     names.

                                        InputStream and OutputStream are abstract classes that serve as
                                     the root classes for reading and writing binary data. Their most commonly
                                     used subclasses are DataInputStream and DataOutputStream,
                                     which are used for processing String data and data of any of Java's prim-
                                     itive types--char, boolean, int, double, and so on. The analogues of
                                     these classes for processing text data are the Reader and Writer classes,
                                     which serve as the root classes for all text I/O.

                                      JAVA PROGRAMMING TIP Choosing a Stream. In choosing an
                                      appropriate stream for an I/O operation, DataInputStreams and
                                      DataOutputStreams normally are used for binary I/O. Reader and
                                      Writer streams normally are used for text I/O.

                                     The various subclasses of these root classes perform various specialized
                                     I/O operations. For example, FileInputStream and FileOutput-
                                     Stream are used for performing binary input and output on files. The
                                     PrintStream class contains methods for outputting various primitive
                                     data--integers, floats, and so forth--as text. The System.out stream,
                                     one of the most widely used output streams, is an object of this type. The
                                     PrintWriter class, which was introduced in JDK 1.1 contains the same
SECTION 11.2  Streams and Files                                          503
                                                                                  Figure 11.3: Java's stream hierar-
                 Object                                                           chy.

java.io                  ByteArrayInputStream   BufferedInputStream
    InputStream          FileInputStream        DataInputStream
                         FilterInputStream
                         ObjectInputStream
                         PipedInputStream

Reader                   BufferedReader         LineNumberReader
  File                   CharArrayReader         FileReader
                         InputStreamReader
                         PipedReader
                         StringReader

OutputStream             ByteArrayOutputStream

                         FileOutputStream       DataOutputStream

                         FilterOutputStream     BufferedOutputStream

                         ObjectOutputStream     FilterWriter

                         PipedOutputStream

Writer                   BufferedWriter
                         CharArrayWriter
                         OutputStreamWriter     FileWriter
                         PipedWriter
                         PrintWriter
                         StringWriter

methods as PrintStream but the methods are designed to support plat-
form independence and internationalized I/O--that is, I/O that works in
different languages and alphabets.
                                               504  CHAPTER 11  Files and Streams: Input/Output Techniques

                       Writer                      The various methods defined in PrintWriter are designed to output
                                               a particular type of primitive data (Fig. 11.4). As you would expect, there
                    PrintWriter                is both a print() and println() method for each kind of data that the
                                               programmer wants to output.
  +PrintWriter(in out : OutputStream)
  +PrintWriter(in out : Writer)                    Table 11.1 briefly describes Java's most commonly used input and out-
  +print(in i : int)                           put streams. In addition to the ones we've already mentioned, you are
  +print(in l : long)                          already familiar with methods from the BufferedReader and File
  +print(in f : float)                         classes, which were used in Chapter 4.
  +print(in d : double)
  +print(in s : String)                            Filtering refers to performing operations on data while the data are
  +print(in o : Object)                        being input or output. Methods in the FilterInputStream and
  +println(in i : int)                         FilterReader classes can be used to filter binary and text data dur-
  +println(in l : long)                        ing input. Methods in the FilterOutputStream and FilterWriter
  +println(in f : float)                       can be used to filter output data. These classes serve as the root classes
  +println(in d : double)                      for various filtering subclasses. They can also be subclassed to perform
  +println(in s : String)                      customized data filtering.
  +println(in o : Object)
                                                   One type of filtering is buffering, which is provided by several buffered
Figure 11.4: PrintWriter meth-                 streams, including BufferedInputStream and BufferedReader, for
ods print data of various types.               performing binary and text input, and BufferedOutputStream and
                                               BufferedWriter, for buffered output operations. As was discussed in
                                   TABLE 11.1
                                               Description of some of Java's important stream classes.

Class                                               Description

InputStream                                         Abstract root class of all binary input streams
FileInputStream                                     Provides methods for reading bytes from a binary file
FilterInputStream                                   Provides methods required to filter data
BufferedInputStream                                 Provides input data buffering for reading large files
ByteArrayInputStream                                Provides methods for reading an array as if it were a stream
DataInputStream                                     Provides methods for reading Java's primitive data types
PipedInputStream                                    Provides methods for reading piped data from another thread
OutputStream                                        Abstract root class of all binary output streams
FileOutputStream                                    Provides methods for writing bytes to a binary file
FilterOutputStream                                  Provides methods required to filter data
BufferedOutputStream                                Provides output data buffering for writing large files
ByteArrayOutputStream                               Provides methods for writing an array as if it were a stream
DataOutputStream                                    Provides methods for writing Java's primitive data types
PipedOutputStream                                   Provides methods for writing piped data to another thread
PrintStream                                         Provides methods for writing primitive data as text
Reader                                              Abstract root class for all text input streams
BufferedReader                                      Provides buffering for character input streams
CharArrayReader                                     Provides input operations on char arrays
FileReader                                          Provides methods for character input on files
FilterReader                                        Provides methods to filter character input
StringReader                                        Provides input operations on Strings
Writer                                              Abstract root class for all text output streams
BufferedWriter                                      Provides buffering for character output streams
CharArrayWriter                                     Provides output operations to char arrays
FileWriter                                          Provides methods for output to text files
FilterWriter                                        Provides methods to filter character output
PrintWriter                                         Provides methods for printing binary data as characters
StringWriter                                        Provides output operations to Strings
 SECTION 11.3  CASE STUDY: Reading and Writing Text Files 505

chapter 4, a buffer is a relatively large region of memory used to temporar-
ily store data while they are being input or output. When buffering is
used, a program will transfer a large number of bytes into the buffer from
the relatively slow input device and then transfer these to the program
as each read operation is performed. The transfer from the buffer to the
program's memory is very fast.

   Similarly, when buffering is used during output, data are transferred
directly to the buffer and then written to the disk when the buffer fills up
or when the flush() method is called.

 JAVA PROGRAMMING TIP Buffering. Buffered streams can
 improve a program's overall efficiency by reducing the amount of time
 it spends accessing relatively slow input or output devices.

You can also define your own data filtering subclasses to perform cus-        Buffering
tomized filtering. For example, suppose you want to add line numbers          Filtering data
to a text editor's printed output. To perform this task, you could define a
FilterWriter subclass and override its write() methods to perform
the desired filtering operation. Similarly, to remove the line numbers from
such a file during input, you could define a FilterReader subclass. In
that case, you would override its read() methods to suit your goals for
the program.

   There are several classes that provide I/O-like operations on various
internal memory structures. ByteArrayInputStream, ByteArray-
OutputStream, CharArrayReader, and CharArrayWriter are four
classes that take input from or send output to arrays in the program's
memory. Methods in these classes can be useful for performing vari-
ous operations on data during input or output. For example, suppose
a program reads an entire line of integer data from a binary file into a
ByteArray. It might then transform the data by, say, computing the
remainder modulo N of each value. The program now can read these
transformed data by treating the byte array as an input stream. A similar
example would apply for some kind of output transformation.

   The StringReader and StringWriter classes provide methods for
treating Strings and StringBuffers as I/O streams. These methods
can be useful for performing certain data conversions.

JAVA PROGRAMMING TIP Integer/String Conversion. An integer
can be converted to a String by writing it to a StringBuffer,
which can then be output as an entire line of text. StringReader
methods can be used to read integer data from an ordinary String
object.

11.3 CASE STUDY: Reading and Writing Text
        Files

Let's write a GUI application that will be able to read and write data to
and from a text file. To do this, we will need to develop a set of methods
to perform I/O on text files.
                                 506           CHAPTER 11  Files and Streams: Input/Output Techniques

GUI design                          The GUI for this application will contain a JTextArea, where text file
                                 data can be input and displayed, and a JTextField, where the user can
Figure 11.5: The GUI design for  enter the file's name. It will also contain two JButtons, one for read-
a program that reads and writes  ing a file into the JTextArea, and the other for writing the data in the
text files.                      JTextArea into a file (Fig. 11.5). Note that even this simple interface will
                                 let the user create new files and rename existing files.

                                                                                 BorderLayout

                                 JFrame JLabel JTextField            JButtons               north

                                      prompt:              ReadFile              WriteFile         Component Hierarchy

                                      JTextArea for displaying file                                JFrame
                                                            BorderLayout Center                        Controls JPanel
                                                                                                            Prompt JLabel
                                                                                                            Input JTextField
                                                                                                            ReadFile JButton
                                                                                                            WriteFile JButton
                                                                                                       Display JTextArea

                                 11.3.1 Text File Format

The end-of-file character        A text file consists of a sequence of characters divided into zero or more
Output stream                    lines and ending with a special end-of-file character. When you open a
                                 new file in a text editor, it contains zero lines and zero characters. After
                                 typing a single character, it would contain one character and one line. The
                                 following would be an example of a file with four lines of text:

                                                                                                                               

                                 one\ntwo\ nthree \ nfour \n\ eof                                                              
                                 

                                 Note the use of the end-of-line character, \n, to mark the end of each line,
                                 and the use of the end-of-file character, \eof, to mark the end of the file.
                                 As we'll see, the I/O methods for text files use these special characters to
                                 control reading and writing loops. Thus, when the file is read by appro-
                                 priate Java methods, such as the BufferedReader.readLine() and
                                 BufferedReader.read() methods, one or more characters will be read
                                 until either an end-of-line or end-of-file character is encountered. When a
                                 line of characters is written using println(), the end-of-line character is
                                 appended to the characters themselves.

                                 11.3.2 Writing to a Text File

                                 Let's see how to write to a text file. In this program we write the entire
                                 contents of the JTextArea() to the text file. In general, writing data to a
                                 file requires three steps:

                                 1. Connect an output stream to the file.
                                 2. Write text data into the stream, possibly using a loop.
                                 3. Close the stream.

                                 As Figure 11.1 shows, connecting a stream to a file looks like doing a bit
                                 of plumbing. The first step is to connect an output stream to the file. The
                                 output stream serves as a conduit between the program and a named file.
                                 The output stream opens the file and gets it ready to accept data from the
 SECTION 11.3  CASE STUDY: Reading and Writing Text Files 507

program. If the file already exists, then opening the file will destroy any
data it previously contained. If the file doesn't yet exist, then it will be
created from scratch.

   Once the file is open, the next step is to write the text to the stream,
which passes the text on to the file. This step might require a loop that
outputs one line of data on each iteration. Finally, once all the data have
been written to the file, the stream should be closed. This also has the
effect of closing the file itself.

 JAVA EFFECTIVE DESIGN Writing a File. Writing data to a file
 requires a three-step algorithm: (1) Connect an output stream to the
 file, (2) write the data, and (3) close the file.

Code Reuse: Designing an Output Method

Now let's see how these three steps are done in Java. Suppose the text we       Choosing an output stream
want to write is contained in a JTextArea. Thus, we want a method that         
will write the contents of a JTextArea to a named file.                        

   What output stream should we use for the task of writing a String to         Inheritance
a named file? To decide this, we need to use the information in Figure 11.3
and Table 11.1. As we pointed out earlier, because we're writing a text file,
we would use a Writer subclass. But which subclass should we use? The
only way to decide this is to consult the Java API documentation, using
links at

 

    h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/a p i/
 

to see what methods are available in the various subclasses. For I/O op-
erations you want to consult the classes in the java.io package. Ideally,
we would like to be able to create an output stream to a named file, and
we would like to be able to write a String to the file.

   One likely candidate is the FileWriter class (Fig. 11.6). Its name and
description (Table 11.1) suggest that it's designed for writing text files.
And indeed it contains the kind of constructor we need--that is, one that
takes the file name as a parameter. Note that by taking a boolean param-
eter, the second constructor allows us to append data to a file rather than
rewrite the entire file, which is the default case.

   However, FileWriter doesn't define a write() method. This
doesn't necessarily mean that it doesn't contain such a method. It might
have inherited one from its superclasses, OutputStreamWriter and
Writer. Indeed, the Writer class contains a method, write(), whose
signature suggests that it is ideally suited for our task (Fig. 11.6).
                                                 508  CHAPTER 11  Files and Streams: Input/Output Techniques
Figure 11.6: To find the right I/O
method, it is sometimes necessary                                                            Writer
to search the Java class hierarchy.                                               +write(in s : String)
This is easy to do with the online
documentation.                                                                     OutputStreamWriter

                                                                                    FileWriter

                                                      +FileWriter(in fileName : String)
                                                      +FileWriter(in fileName : String, in append :boolean)

   Having decided on a FileWriter stream, the rest of the task of de-
signing our method is simply a matter of using FileWriter methods in
an appropriate way:

                                                                                                                                            

private void writeTextFile ( JTextArea display ,
                                                                        String fileName ) {

                                                      // C r e a t e s t r e a m & open f i l e

                                                      F i l e W r i t e r outStream = new F i l e W r i t e r ( fileName ) ;

                                                      // W r i t e t h e e n t i r e d i s p l a y t e x t and c l o s e t h e s t r e a m

                                                      outStream . write ( display . getText ( ) ) ;

                                                      outStream . close ( ) ; // C l o s e t h e o u t p u t s t r e a m

}

                                                                                                                                            

We use the FileWriter() constructor to create an output stream to the
file whose name is stored in fileName. In this case, the task of writing
data to the file is handled by a single write() statement, which writes
the entire contents of the JTextArea in one operation.

   Finally, once we have finished writing the data, we close() the output
stream. This also has the effect of closing the file. The overall effect of this
method is that the text contained in display has been output to a file,
named fileName, which is stored on the disk.

JAVA PROGRAMMING TIP Closing a File. Even though Java will
close any apen files and streams when a program terminates normally,
it is good programming practice to close the file yourself with a
close() statement. It also reduces the chances of damaging the file if
the program terminates abnormally.

Because so many different things can go wrong during an I/O operation,
most I/O operations generate some kind of checked exception. Therefore, it
is necessary to embed the I/O operations within a try/catch statement.
In this example, the FileWriter() constructor, the write() method,
and the close() method may each throw an IOException. Therefore,
the entire body of this method should be embedded within a try/catch
block that catches the IOException (Fig. 11.7).
SECTION 11.3  CASE STUDY: Reading and Writing Text Files 509

                                                                                          

private void writeTextFile ( JTextArea display ,
                                                                     String fileName ) {

   try {
          F i l e W r i t e r outStream = new F i l e W r i t e r ( fileName ) ;
          outStream . write ( display . getText ( ) ) ;
          outStream . close ( ) ;

   } catch ( IOException e ) {
          d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;
          e . printStackTrace ();

   }

} // w r i t e T e x t F i l e ( )

                                                                                          

  Figure 11.7: A method to write a text file.

11.3.3 Code Reuse: Designing Text File Output                                                Method design

The writeTextFile() method provides a simple example of how to
write data to a text file. More importantly, its development illustrates
the kinds of choices necessary to design effective I/O methods. Two
important design questions we asked and answered were

 What methods do we need to perform the desired task?
 What streams contain the desired methods?

As in so many other examples we've considered, designing a method to
perform a task is often a matter of finding the appropriate methods in the
Java class hierarchy.

  JAVA EFFECTIVE DESIGN Code Reuse. Developing effective I/O
  routines is primarily a matter of choosing the right library methods.
  Start by asking yourself, "What methods do I need?" and then find a
  stream class that contains the appropriate methods.

As you might expect, there is more than one way to write data to a text
file. Suppose we decided that writing text to a file is like printing data to
System.out. And suppose we chose to use a PrintWriter object as
our first candidate for an output stream (Fig. 11.3 and Table 11.1). This
class (Fig. 11.4) contains a wide range of print() methods for writing
different types of data as text. So it has exactly the kind of method we
need: print(String). However, this stream does not contain a con-
structor method that allows us to create a stream from the name of a
file. Its constructors require either a Writer object or an OutputStream
object.

   This means that we can use a PrintWriter to print to a file, but only
if we can first construct either an OutputStream or a Writer object
to the file. So we must go back to searching Figure 11.3 and Table 11.1
for an appropriate candidate. Fortunately, the FileOutputStream class
(Fig. 11.8) has just the constructors we want. We now have an alterna-
tive way of coding the writeTextFile() method, this time using a
combination of PrintWriter and FileOutputStream:
                                                 510  CHAPTER 11  Files and Streams: Input/Output Techniques
Figure 11.8: The FileOutput-
Stream class.                                                                          OutputStream

                                                                                     FileOutputStream
                                                       +FileOutputStream(in filename : String)
                                                       +FileOutputStream(in filename : String, in append : boolean)

                                                                                                                        

                     // C r e a t e an o u t p u t s t r e a m and open t h e f i l e

                     PrintWriter outStream =

                                                      new P r i n t W r i t e r (new FileOutputStream ( fileName ) ) ;

                     // W r i t e t h e d i s p l a y ' s t e x t and c l o s e t h e s t r e a m

                     outStream . print ( display . getText () ) ;

                     outStream . close ( ) ;
                                                                                                                        

Parameter agreement  Note how the output stream is created in this case. First, we create a
                     FileOutputStream using the file name as its argument. Then we cre-
                     ate a PrintWriter using the FileOutputStream as its argument. The
                     reason we can do this is because the PrintWriter() constructor takes
                     a FileOutputStream parameter. This is what makes the connection
                     possible.

                        To use the plumbing analogy again, this is like connecting two sections
                     of pipe between the program and the file. The data will flow from the
                     program through PrintWriter, through the OutputStream, to the file.
                     Of course, you can't just arbitrarily connect one stream to another. They
                     have to "fit together," which means that their parameters have to match.

                     JAVA EFFECTIVE DESIGN Stream/Stream Connections. Two
                     different kinds of streams can be connected if a constructor for one
                     stream takes the second kind of stream as a parameter. This is often an
                     effective way to create the kind of object you need to perform an I/O
                     task.

java.sun.com/j2se/1.5.0/docs/api/ The important lesson here is that we found what we wanted by searching
                                   through the java.io.* hierarchy. This same approach can be used to
                                   help you to design I/O methods for other tasks.

                             SELF-STUDY EXERCISE

                                    EXERCISE 11.1 Is it possible to perform output to a text file using a
                                   PrintWriter and a FileWriter stream in combination? If so, write
                                   the Java code.

                             11.3.4 Reading from a Text File

                                   Let's now look at the problem of inputting data from an existing text file,
                                   a common operation that occurs whenever your email program opens an
                                   email message or your word processor opens a document. In general,
                                   there are three steps to reading data from a file:

                                   1. Connect an input stream to the file.
SECTION 11.3  CASE STUDY: Reading and Writing Text Files 511

2. Read the text data using a loop.
3. Close the stream.

As Figure 11.9 shows, the input stream serves as a kind of pipe between
the file and the program. The first step is to connect an input stream to the

Memory                  Text file                                                Figure 11.9: A stream serves as a
                                                                                 pipe through which data flow.
0100010
0100101   Input stream
1111111  Output stream
1111100
1100101
0111110
1111110

file. Of course, in order to read a file, the file must exist. The input stream
serves as a conduit between the program and the named file. It opens the
file and gets it ready for reading. Once the file is open, the next step is to
read the file's data. This will usually require a loop that reads data until
the end of the file is reached. Finally, once all the data are read, the stream
should be closed.

JAVA EFFECTIVE DESIGN Reading Data Reading data from a file
requires a three-step algorithm: (1) Connect an input stream to the file,
(2) read the data, and (3) close the file.

Now let's see how these three steps are done in Java. Suppose that we             Choosing an input stream
want to put the file's data into a JTextArea. Thus, we want a method
that will be given the name of a file and a reference to a JTextArea, and         What methods should we use?
it will read the data from the file into the JTextArea.
                                                                                 
   What input stream should we use for this task? Here again we need to          
use the information in Figure 11.3 and Table 11.1. Because we're reading
a text file, we should use a Reader subclass. A good candidate is the
FileReader, whose name and description suggest that it might contain
useful methods.

   What methods do we need? As in the previous example, we need a
constructor method that connects an input stream to a file when the con-
structor is given the name of the file. And, ideally, we'd like to have a
method that will read one line at a time from the text file.

   The FileReader class (Fig. 11.10) has the right kind of constructor.
However, it contains no readLine() methods itself, which would be
necessary for our purposes. Searching upward through its superclasses,
we find that InputStreamReader, its immediate parent class, has a
method that reads ints:

 

    public int read ( ) throws IOException ( ) ;
 

As shown in Figure 11.10, this read() method is an override of the
read() method defined in the Reader class, the root class for text file
input streams. Thus, there are no readLine() methods in the Reader
branch of the hierarchy. We have to look elsewhere for an appropriate
class.
                                                 512  CHAPTER 11  Files and Streams: Input/Output Techniques
Figure 11.10: FileReader's su-
perclasses contain read() meth-                                                    Reader
ods but no readLine() meth-                                                  +read() : int
ods.

                                                      InputStreamReader                  BufferedReader

                                                      +read() : int      +BufferedReader(in instream : Reader)
                                                                         +readLine() : String

                                                      FileReader

                                                      +FileReader(in fileName : String)

                                    One class that does contain a readLine() method is BufferedReader
                                 (Fig. 11.10). Can we somehow use it? Fortunately, the answer is yes.
                                 BufferedReader's constructor takes a Reader object as a parameter.
                                 But a FileReader is a Reader--that is, it is a descendant of the Reader
                                 class. So, to use our plumbing analogy again, to build an input stream to
                                 the file, we can join a BufferedReader and a FileReader

                                                                                                                      

                                 BufferedReader inStream

                                                      = new BufferedReader (new F i l e R e a d e r ( fileName ) ) ;  

Using the end-of-file character  Given this sort of connection to the file, the program can use Buffered-
                                 Reader.readLine() to read one line at a time from the file.

                                    So, we have found a method that reads one line at a time. Now we need
                                 an algorithm that will read the entire file. Of course, this will involve
                                 a loop, and the key will be to make sure we get the loop's termination
                                 condition correct.

                                    An important fact about readLine() is that it will return null as its
                                 value when it reaches the end of the file. Recall that text files have a special
                                 end-of-file character. When readLine() encounters this character, it will
                                 return null. Therefore, we can specify the following while loop:

                                                                                                                      

                                 String line = inStream . readLine ( ) ;

                                 while ( line != null ) {

                                                      display . append ( l i n e + "\n" ) ;

                                                      line = inStream . readLine ( ) ;

                                 }

                                                                                                                      

                                 We begin outside the loop by attempting to read a line from the file. If
                                 the file happens to be empty (which it might be), then line will be set to
                                 null; otherwise it will contain the String that was read. In this case, we
                                 append the line to a JTextArea. Note that readLine() does not return
 SECTION 11.3  CASE STUDY: Reading and Writing Text Files 513

the end-of-line character with its return value. That's why we add a \n
before we append the line to the JTextArea.

 JAVA PROGRAMMING TIP End of Line. Remember that
 readLine() does not return the end-of-line character as part of the
 text it returns. If you want to print the text on separate lines, you must
 append \n.

The last statement in the body of the loop attempts to read the next line
from the input stream. If the end of file has been reached, this attempt
will return null and the loop will terminate. Otherwise, the loop will
continue reading and displaying lines until the end of file is reached.
Taken together, these various design decisions lead to the definition for
readTextFile() shown in Figure 11.11.

                                                                                   

private void readTextFile ( JTextArea display ,

                                          String fileName ) {

  try {

  BufferedReader inStream // C r e a t e and open t h e s t r e a m

         = new BufferedReader (new F i l e R e a d e r ( fileName ) ) ;

  String line = inStream . readLine ( ) ; // Read one l i n e

  while ( line != null ) {                // While more t e x t

         display . append ( l i n e + "\n" ) ; // D i s p l a y a l i n e

         line = inStream . readLine ( ) ; // Read n e x t l i n e

  }

     inStream . close ( ) ;               // C l o s e t h e s t r e a m

  } catch ( FileNotFoundException e ) {

     d i s p l a y . s e t T e x t ( "IOERROR : "+ fileName +" NOT found\n" ) ;

     e . printStackTrace ();

  } catch ( IOException e ) {

     d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

     e . printStackTrace ();

  }

} // r e a d T e x t F i l e ( )

                                                                                   

         Figure 11.11: A method for reading a text file.

   Note that we must catch both the IOException, thrown by                            IOException
readLine() and close(), and the FileNotFoundException, thrown
by the FileReader() constructor. It's important to see that the read loop
has the following form:

                                                                                   

  try to read one l i n e of data

         and s t o r e i t in l i n e  // Loop i n i t i a l i z e r

  while ( line i s not null ) { // Loop e n t r y c o n d i t i o n

         process the data

         try to read one l i n e of data

         and s t o r e i t in l i n e // L o o p u p d a t e r

  }

                                                                                   
514        CHAPTER 11  Files and Streams: Input/Output Techniques

When it attempts to read the end-of-file character, readLine() will return
null.

  JAVA EFFECTIVE DESIGN Reading Text. In reading text files, the
  readLine() method will return null when it tries to read the
  end-of-file character. This provides a convenient way of testing for the
  end of file.

  JAVA EFFECTIVE DESIGN Reading an Empty File. Loops for
  reading text files are designed to work even if the file is empty.
  Therefore, the loop should attempt to read a line before testing the
  loop-entry condition. If the initial read returns null, that means the
  file is empty and the loop body will be skipped.

SELF-STUDY EXERCISE

EXERCISE 11.2 What's wrong with the following loop for reading a
text file and printing its output on the screen?

                                                                                    

     String line = null ;

     do {

           line = inStream . readLine ( ) ;

           System . out . println ( line ) ;

     } while ( line != null ) ;                                                     

11.3.5 Code Reuse: Designing Text File Input

Our last example used BufferedReader.readLine() to read an entire
line from the file in one operation. But this isn't the only way to do things.
For example, we could use the FileReader stream directly if we were
willing to do without the readLine() method. Let's design an algorithm
that works in this case.

   As we saw earlier, if you use a FileReader stream, then you must use
the InputStreamReader.read() method. This method reads bytes
from an input stream and translates them into Java Unicode characters.
The read() method, for example, returns a single Unicode character as
an int:

                                                                                    

  public int read ( ) throws IOException ( ) ;                                      


Of course, we can always convert this to a char and concatenate it to a
JTextArea, as the following algorithm illustrates:

                                                                                    

  int ch = inStream . read ( ) ; // I n i t : T ry t o r e a d a c h a r a c t e r

  while ( ch != -1) { // E n t r y - c o n d i t i o n : w h i l e mo re c h a r s

     display . append ( ( char ) ch + "" ) ; // Append t h e c h a r a c t e r

     ch = inStream . read ( ) ; // U p d a t e r : t r y t o r e a d

  }

                                                                                    
SECTION 11.3  CASE STUDY: Reading and Writing Text Files 515

Although the details are different, the structure of this loop is the same as
if we were reading one line at a time.

   The loop variable in this case is an int because InputStreamReader.-
read() returns the next character as an int, or it returns -1 if it encoun-
ters the end-of-file character. Because ch is an int, we must convert Data conversion
it to a char and then to a String in order to append() it to the display.

   A loop to read data from a file has the following basic form:

                                                                              

  try to read data into a variable // I n i t i a l i z e r

  while ( read was s u c c e s s f u l ) { // E n t r y c o n d i t i o n

      process the data

      try to read data into a variable // Updater

  }

                                                                              

  JAVA EFFECTIVE DESIGN Read Loop Structure. The read() and
  readLine() methods have different ways to indicate when a read
  attempt fails. These differences affect how the loop-entry condition is
  specified, but the structure of the read loop is the same.

  JAVA PROGRAMMING TIP Read Versus Readline. Unless it is
  necessary to manipulate each character in the text file, reading a line at
  a time is more efficient and, therefore, preferable.

It is worth noting again the point we made earlier: Designing effective       Reusing existing code
I/O routines is largely a matter of searching the java.io package for ap-
propriate classes and methods. The methods we've developed can serve
as suitable models for a wide variety of text I/O tasks, but if you find
that they aren't suitable for a particular task, you can design your own
method. Just think about what it is you want the program to accomplish,
then find the stream classes that contain methods you can use to perform
the desired task. Basic reading and writing algorithms will be pretty much
the same no matter which particular read or write method you use.

SELF-STUDY EXERCISE

EXERCISE 11.3 What's wrong with the following loop for reading a
text file and printing its output on the screen?

                                                                           

int ch ;

do {

      ch = inStream . read ( ) ;

      System . out . print ( ( char ) ch ) ;

} while ( ch != -1)
                                                                           
                                                516  CHAPTER 11  Files and Streams: Input/Output Techniques
Figure 11.12: The TextIO class.
                                                                    쳃nterface
                                                     JFrame       ActionListener

                                                             +actionPerformed()

                                                                                        TextIO

                                                     -display : JTextArea
                                                     -read : JButton
                                                     -nameField : JTextField
                                                     -prompt : JLabel
                                                     -commands : JPanel

                                                     +TextIO()
                                                     -readTextFile(in display : JTextArea, in fileName : String)
                                                     -writeTextFile(in display : JTextArea, in fileName : String)
                                                     +actionPerformed(in evt : ActionEvent)
                                                     +main(in args[] : String)

                                        11.3.6 The TextIO Application

                                                 Given the text I/O methods we wrote in the previous sections, we can
                                                 now specify the overall design of our TextIO class (Fig. 11.12). In order
                                                 to complete this application, we need only set up its GUI and write its
                                                 actionPerformed() method.
                                                 Setting up the GUI for this application is straightforward. Figure 11.13
                                                 shows how the finished product will look. The code is given in Fig-
                                                 ure 11.14. Pay particular attention to the actionPerformed() method,
                                                 which uses the methods we defined in the previous section.

Figure 11.13: An application that
performs simple text I/O.
SECTION 11.3  CASE STUDY: Reading and Writing Text Files 517

                                                                                                  

import     javax . swing .  ;        // Swing com ponen ts
import     java . awt .  ;
import     java . io .;
import     java . awt . event .  ;

public class TextIO extends JFrame implements ActionListener {
 p r i v a t e JTextArea d i s p l a y = new JTextArea ( ) ;
 p r i v a t e J B u t t o n read = new J B u t t o n ( "Read From F i l e " ) ,
                              w r i t e = new J B u t t o n ( " Write t o F i l e " ) ;
 p r i v a t e J T e x t F i e l d nameField = new J T e x t F i e l d ( 2 0 ) ;
 p r i v a t e J L a b e l prompt = new J L a b e l ( " Filename : " , J L a b e l . RIGHT ) ;
 p r i v a t e J P a n e l commands = new J P a n e l ( ) ;

  public TextIO ( ) {                         // C o n s t r u c t o r

  super ( " TextIO Demo" ) ;                  // S e t window t i t l e

  read . addActionListener ( this ) ;

  write . addActionListener ( this );

  commands . s e t L a y o u t ( new GridLayout ( 2 , 2 , 1 , 1 ) ) ; // C o n t r o l p a n e l

  commands . add ( prompt ) ;

  commands . add ( nameField ) ;

  commands . add ( read ) ;

  commands . add ( w r i t e ) ;

  display . setLineWrap ( true ) ;

  t h i s . getContentPane ( ) . s e t L a y o u t (new BorderLayout ( ) ) ;

  t h i s . getContentPane ( ) . add ( " North " , commands ) ;

  t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( d i s p l a y ) ) ;

  t h i s . getContentPane ( ) . add ( " Center " , display ) ;

} // T e x t I O

  private void writeTextFile ( JTextArea display , String fileName ) {

     try {

        F i l e W r i t e r outStream = new F i l e W r i t e r ( fileName ) ;

        outStream . write ( display . getText ( ) ) ;

        outStream . close ( ) ;

  } catch ( IOException e ) {

        d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

        e . printStackTrace ();

  }

} // w r i t e T e x t F i l e ( )

  private void readTextFile ( JTextArea display , String fileName ) {

     try {

        BufferedReader inStream // C r e a t e and open t h e s t r e a m

            = new BufferedReader (new F i l e R e a d e r ( fileName ) ) ;

        String line = inStream . readLine ( ) ; // Read one l i n e

        while ( line != null ) {              // While more t e x t

            display . append ( l i n e + "\n" ) ; // D i s p l a y a l i n e

            line = inStream . readLine ( ) ;   // Read n e x t l i n e

        }

            inStream . close ( ) ;     // C l o s e t h e s t r e a m

        } catch ( FileNotFoundException e ) {

            d i s p l a y . s e t T e x t ( "IOERROR : "+ fileName +" NOT found\n" ) ;

            e . printStackTrace ();

        } catch ( IOException e ) {

            d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

            e . printStackTrace ();

        }

} // r e a d T e x t F i l e

                                                                                                  

                  Figure 11.14: Part I of the TextIO class.
                                      518              CHAPTER 11  Files and Streams: Input/Output Techniques

                                                                                                                        

                                        public void actionPerformed ( ActionEvent evt ) {
                                           String fileName = nameField . getText ( ) ;
                                           i f ( e v t . g e t S o u r c e ( ) == read ) {
                                                  display . setText ("" ) ;
                                                   readTextFile ( display , fileName ) ;
                                           }

                                           else writeTextFile ( display , fileName ) ;
                                        } // a c t i o n P e r f o r m e d ( )

                                        public s t a t i c void main ( S t r i n g args [ ] ) {

                                           TextIO t i o = new TextIO ( ) ;

                                           tio . setSize (400 , 200);

                                           tio . setVisible ( true );

                                           t i o . addWindowListener (new WindowAdapter ( ) {

                                                public void windowClosing ( WindowEvent e ) {

                                                       System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

                                                }

                                           });

                                        } // main ( )

                                      }// T e x t I O

                                                                                                                        

                                                       Figure 11.14: (continued) The TextIO class, Part II.

            root                      11.4 The File Class

   home              java             As we've seen, an attempt to create a FileReader stream may throw a
index.html        examples            FileNotFoundException. The way this happens is if the user provides
                                      a name for a file that either doesn't exist or isn't located where its name
datafiles MyClass.java MyClass.class  says it should be located. The question that needs to be considered: Is
data.txt                              there any way we can detect these kinds of errors before attempting to
                                      read the file?
Figure 11.15: A simple hierarchy
of directories and files.                The java.io.File class provides methods that we can use for this
                                      task. The File class provides a representation of the computer's file and
The file hierarchy                    directory information in a platform-independent manner. As you know, a
                                      file is a collection of data, whereas a directory is a collection of files. (To be
                                      exact, a directory is a file that stores its files' names and attributes, not the
                                      files themselves.) In this section, we will provide details about the File
                                      class and how to use the methods available in the class.

                                      11.4.1 Names and Paths

                                      In order to correctly specify a file's location, it is necessary to know a little
                                      about how files are stored on your computer's disk drive. File systems
                                      are organized into a hierarchy. A path is a description of a file's loca-
                                      tion in the hierarchy. For example, consider the hierarchy of files in Fig-
                                      ure 11.15. Assume that your Java program is named MyClass.class.
                                      When a program is running, the program's directory is considered the
                                      current directory. Any files located in the current directory can be referred
                                      to by name alone--for example, MyClass.java. To refer to a file located
                                      in a subdirectory of the current directory, you need to provide the name
                                      of the subdirectory and the file: datafiles/data.txt. In this case, we
                                      are assuming a Unix file system, so we are using the / as the separator
SECTION 11.4  The File Class  519

between the name of the directory (datafiles) and the name of the file            Object            쳃nterface
(data.txt). This is an example of a relative path name, because we are                              Serializable
specifying a file in relation to the current directory.
                                                                               
   Alternatively, a file can be specified by its absolute path name. This
would be a name whose path starts at the root directory of the file system.                  File
For example,
                                                                                  +pathSeparator : String
 
                                                                                  +pathSeparatorChar : char
    /root/java/examples/datafiles/data . txt
                                                                                  +separator : String

would be the absolute path name for the file named data.txt on a Unix             +separatorChar : char
system. When you supply the name of a file to one of the stream construc-
tors, you are actually providing a path name. If the path consists of just a      +canRead() : boolean
name, such as data.txt, Java assumes that the file is located in the same         +canWrite() : boolean
directory as the program itself.                                                  +delete() : boolean
                                                                                  +exists() : boolean
11.4.2 Validating File Names                                                      +getName() : String
                                                                                  +getParent() : String
Before reading a file it is often necessary to determine that the file's name     +getPath() : String
is a valid one and that the file can be read. The File class (Fig. 11.16)         +isDirectory() : boolean
provides platform-independent methods for dealing with files and di-              +isFile() : boolean
rectories. It contains methods that list the contents of directories, de-         +lastModified() : long
termine a file's attributes, and rename and delete files. Note the sev-           +length() : long
eral static constants provided. These allow path names to be speci-               +list() : String[]
fied in a platform-independent way. For example, on a Unix system, the            +renameToFile(in f : File) : File
File.separator character will be the / and on a Windows system it
will be the \,backslash. File.separator will be initialized to the             Figure 11.16: The java.io.File
appropriate separator for the particular system being used.                    class.

JAVA PROGRAMMING TIP File Separators. To help make your
programs platform independent, use the File.separator constant
instead of a literal value whenever you are specifying a path name.

As an example of how you might use some of File's methods, let's write         Method design
a method that tests whether the file name entered by the user is the name
of a valid, readable file.

   A file might be unreadable for a number of reasons. It might be owned
by another user and readable only by that user. Or it might be designated
as not readable by its owner. We'll pass the method the name of the file
(a String), and the method will return true if a readable file with that
520  CHAPTER 11  Files and Streams: Input/Output Techniques

name exists. Otherwise, the method will throw an exception and return
false:

                                                                                       

private boolean isReadableFile ( String fileName ) {
   try {
       F i l e f i l e = new F i l e ( fileName ) ;
       if (! file . exists ())
              throw (new FileNotFoundException ( "No such F i l e : "
                                                                  + fileName ) ) ;
       i f ( ! f i l e . canRead ( ) )
              throw (new IOException ( " F i l e not r e a d a b l e : "
                                                                  + fileName ) ) ;
       return true ;
   } catch ( FileNotFoundException e ) {
       System . out . p r i n t l n ( "IOERROR : F i l e NOT Found : "
                                                    + fileName + "\n" ) ;
       return false ;
   } catch ( IOException e ) {
       System . out . p r i n t l n ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;
       return false ;
   }

} // i s R e a d a b l e F i l e

                                                                                       

The method simply creates a File instance and uses its exists() and
canRead() methods to check whether its name is valid. If either condi-
tion fails, an exception is thrown. The method handles its own exceptions,
printing an error message and returning false in each case.

   Before attempting to write data to a file, we might want to check that
the file has been given an appropriate name. For example, if the user
leaves the file name blank, we should not write data to the file. Also, a file
might be designated as unwriteable in order to protect it from being in-
advertently overwritten. We should check that the file is writeable before
attempting to write to it:

                                                                                       

  private boolean isWriteableFile ( String fileName ) {
     try {
         F i l e f i l e = new F i l e ( fileName ) ;
         i f ( fileName . l e n g t h ( ) == 0 )
                throw (new IOException ( " I n v a l i d f i l e name : "
                                                                    + fileName ) ) ;
         i f ( f i l e . e x i s t s ( ) && ! f i l e . canWrite ( ) )
                  throw (new IOException (
                       "IOERROR : F i l e not w r i t e a b l e : " + fileName ) ) ;
         return true ;
     } catch ( IOException e ) {
         d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;
         return false ;
     }

  } // i s W r i t e a b l e F i l e ( )

                                                                                       

The first check in this code tests that the user has not forgotten to pro-
vide a name for the output file. It is unlikely that the user wants to name
the file with the empty string. We use the exists() method to test
SECTION 11.5  Example: Reading and Writing Binary Files  521

whether the user is attempting to write to an existing file. If so, we use
the canWrite() method to test whether the file is writeable. Both kinds
of errors result in IOExceptions.

SELF-STUDY EXERCISE

EXERCISE 11.4 The other methods of the File class are just as easy to
use as the ones we have illustrated in this section. Write a method that
takes the name of a file as its single parameter and prints the following
information about the file: its absolute path, its length, and whether it is a
directory or a file.

11.5 Example: Reading and Writing Binary Files

Although text files are extremely useful and often employed, they can't
and shouldn't be used for every data-processing application. For exam-
ple, your college's administrative data system undoubtedly uses files to
store student records. Because your student record contains a variety of
different types of data--Strings, ints, doubles--it cannot be processed
as text. Similarly, a company's inventory files, which also include data of
a wide variety of types, cannot be processed as text. Files such as these
must be processed as binary data.

   Suppose you are asked to write an application that involves the use
of a company's employee records. Recall that a record is a structure that
combines different types of data into a single entity. It's like an object with
no methods, just instance variables.

   A binary file is a sequence of bytes. Unlike a text file, which is termi-
nated by a special end-of-file marker, a binary file consists of nothing but
data. A binary file doesn't have an end-of-file character because any such
character would be indistinguishable from a binary datum.

 JAVA DEBUGGING TIP End of Binary File. Because a binary file
 does not have an end-of-file character, it would be an error to use the
 same loop-entry conditions we used in the loops we designed for
 reading text files.

Generally speaking, the steps involved in reading and writing binary files       Generating binary data
are the same as for text files:

1. Connect a stream to the file.
2. Read or write the data, possibly using a loop.
3. Close the stream.

The difference between text and binary file I/O resides in the Java streams
that we use.

11.5.1 Writing Binary Data

Let's begin by designing a method that will output employee data to a
binary file. As the developer of this program, one thing you'll have to
do is build some sample data files. These can't easily be built by hand--
remember you can't use a text editor to create them--so you'll want to
                               522  CHAPTER 11  Files and Streams: Input/Output Techniques

                               develop a method that can generate some random data of the sort your
                               application will have to process.

                               JAVA EFFECTIVE DESIGN I/O Design. When designing file I/O
                               applications, it is good to design the input and the output methods
                               together. This is especially important for binary I/O.

                               The first thing we need to know is exactly what the data look like. Let's
                               assume that each record contains three individual pieces of data--the em-
                               ployee's name, age, and pay rate. For example, the data in a file containing
                               four records might look like this, once the data are interpreted:

                                                                                                             

                               Name0 24 1 5 . 0 6

                               Name1 25 5 . 0 9

                               Name2 40 1 1 . 4 5

                               Name3 52 9 . 2 5                                                              
                               

                               As you can see, these data look as if they were randomly generated, but
                               they resemble the real data in the important respects: They are of the
                               right type--String, int, double--and have the right kind of values. Of
                               course, when these data are stored in the file, or in the program's memory,
                               they just look like one long string of 0's and 1's.

                                  Our approach to designing this output method will be the same as the
                               approach we used in designing methods for text I/O. That is, we start
                               with two questions:

                                What stream classes should I use?
                                What methods can I use?

                               And we find the answers to these by searching through the java.io
                               package (Fig. 11.3 and Table 11.1).

                                  Because we are performing binary output, we need to use some sub-
                               class of OutputStream. Because we're outputting to a file, one likely
                               candidate is FileOutputStream (Fig. 11.17). This class has the right
                               kind of constructors, but it only contains write() methods for writing
                               ints and bytes, and we need to be able to write Strings and doubles
                               as well as ints.

Figure 11.17: The FileOutput-                      OutputStream
Stream class.

                                                                 FileOutputStream

                                    +FileOutputStream(in filename : String)
                                    +FileOutputStream(in filename : String, in append : boolean)
SECTION 11.5  Example: Reading and Writing Binary Files                      523

   These kinds of methods are found in DataOutputStream (Fig. 11.18),                              FilterOutputStream
which contains a write() method for each different type of data. As
you can see, there's one method for each primitive type. However, note                                      DataOutputStream
that the writeChar() takes an int parameter, which indicates that the
character is written in binary format rather than as a ASCII or Unicode                     +DataOutputStream(in s : OutputStream)
character. Although you can't tell by just reading its method signature,                    +flush()
the writeChars(String) method also writes its data in binary for-                           +writeBoolean(in b : Boolean)
mat rather than as a sequence of characters. This is the main difference                    +writeByte(in i : int)
between these write() methods and the ones defined in the Writer                            +writeBytes(in s : String)
branch of Java's I/O hierarchy.                                                             +writeChar(in c : int)
                                                                                            +writeChars(in s : String)
   Now that we've found the appropriate classes and methods, we need                        +writeDouble(in d : double)
to create a pipeline to write data to the file and develop an output al-                    +writeFloat(in f : float)
gorithm. To construct a stream to use in writing employee records, we                       +writeInt(in i : int)
want to join together a DataOutputStream and a FileOutputStream.                            +writeLong(in l : long)
The DataOutputStream gives us the output methods we need, and the                           +writeShort(in s : short)
FileOutputStream lets us use the file's name to create the stream:                          +writeUTF(in s : String)

                                                                                          

  DataOutputStream outStream                                                              쯊igure  11.18:              The
     = new DataOutputStream (new FileOutputStream ( fileName ) ) ;



This enables the program to write data to the DataOutputStream, which                     java.io.DataOutputStream
will pass them through the FileOutputStream to the file itself. That
settles the first question.                                                               class contains methods for writing

   To develop the output algorithm, we need some kind of loop that in-                    all types of data.
volves calls to the appropriate methods. In this case, because we are gen-
erating random data, we can use a simple for loop to generate, say, five
records of employee data. We need one write() statement for each of
the elements in the employee record: The name (String), age (int), and
pay rate (double):

                                                                                          
                                                                                          
for ( int k = 0; k < 5; k++) { // O u t p u t 5 d a t a r e c o r d s

     outStream . writeUTF ( "Name" + k ) ;  // Name

     outStream . w r i t e I n t ( ( i n t ) ( 2 0 + Math . random ( )  2 5 ) ) ; // Age

     outStream . writeDouble ( Math . random ( )  5 0 0 ) ; // P a y r a t e

  }


Within the loop body we have one output statement for each data element
in the record. The names of the methods reflect the type of data they write.
Thus, we use writeInt() to write an int and writeDouble() to write
a double. But why do we use writeUTF to write the employee's name,
a String?

The Unicode Text Format (UTF)                                                             ASCII vs. Unicode

There is no DataOutputStream.writeString() method. Instead,
Strings are written using the writeUTF() method. UTF stands for
Unicode Text Format, a coding scheme for Java's Unicode character set.
Recall that Java uses the Unicode character set instead of the ASCII set.
As a 16-bit code, Unicode can represent 8-bit ASCII characters plus a wide
variety of Asian and other international characters. However, Unicode is
not a very efficient coding scheme if you aren't writing an international
                                           524         CHAPTER 11  Files and Streams: Input/Output Techniques

                                           program. If your program just uses the standard ASCII characters, which
                                           can be stored in 1 byte, you would be wasting 1 byte per character if you
                                           stored them as straight Unicode characters. Therefore, for efficiency pur-
                                           poses, Java uses the UTF format. UTF encoding can still represent all of the
                                           Unicode characters, but it provides a more efficient way of representing
                                           the ASCII subset.

                                              It's now time to combine these separate elements into a single method
                                           (Fig. 11.19). The writeRecords() method takes a single String pa-
                                           rameter that specifies the name of the file. This is a void method. It
                                           will output data to a file, but it will not return anything to the calling
                                           method. The method follows the standard output algorithm: Create an
                                           output stream, write the data, close the stream. Note also that the method
                                           includes a try/catch block to handle any IOExceptions that might be
                                           thrown.

                                                                                                                              

                                        private void writeRecords ( String fileName ) {

                                        try {

                                           DataOutputStream outStream // Open s t r e a m

                                               = new DataOutputStream (new FileOutputStream ( fileName ) ) ;

                                           for ( int k = 0; k < 5; k++) { // O u t p u t 5 d a t a r e c o r d s

                                                S t r i n g name = "Name" + k ; // o f name , a g e , p a y r a t e

                                                outStream . writeUTF ( "Name" + k ) ;

                                                outStream . w r i t e I n t ( ( i n t ) ( 2 0 + Math . random ( )  2 5 ) ) ;

                                                outStream . writeDouble ( 5 . 0 0 + Math . random ( )  1 0 ) ;

                                           } // f o r

                                           outStream . close ( ) ;        // C l o s e t h e s t r e a m

                                        } catch ( IOException e ) {

                                           d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

                                        }

                                        } // w r i t e R e c o r d s ( )

                                                                                                                              

                                           Figure 11.19: A method to write a binary file consisting of five randomly
                                           constructed records.

        InputStream                        11.5.2 Reading Binary Data

                FileInputStream            The steps involved in reading data from a binary file are the same as for
+FileInputStream(in filename : String)     reading data from a text file: Create an input stream and open the file,
                                           read the data, close the file. The main difference lies in the way you check
Figure  11.20:       The                   for the end-of-file marker in a binary file.

java.io.FileInputStream                       Let's design a method to read the binary data that were output by the
                                           writeRecords() method. We'll call this method readRecords(). It,
class.                                     too, will consist of a single String parameter that provides the name of
                                           the file to be read, and it will be a void method. It will just display the
                                           data on System.out.

                                              The next questions we need to address are: What stream classes should
                                           we use, and what methods should we use? For binary input, we need
                                           an InputStream subclass (Fig. 11.3 and Table 11.1). As you've prob-
                                           ably come to expect, the FileInputStream class contains construc-
                                           tors that let us create a stream from a file name (Fig. 11.20). How-
                                           ever, it does not contain useful read() methods. Fortunately, the
SECTION 11.5  Example: Reading and Writing Binary Files  525

DataInputStream class contains the input counterparts of the meth-                 
ods we found in DataOutputStream (Fig. 11.21). Therefore, our input
stream for this method will be a combination of DataInputStream and                                  FilterInputStream
FileInputStream:
                                                                                   
 
                                                                                                      DataInputStream
    DataInputStream inStream
         = new DataInputStream (new F i l e I n p u t S t r e a m ( f i l e ) ) ;             +readBoolean() : boolean
                                                                                              +readByte() : byte
                                                                                              +readChar() : char
                                                                                              +readDouble() : double
Now that we have identified the classes and methods we'll use to read the                     +readFloat() : float
data, the most important remaining issue is designing a read loop that will                   +readInt() : int
terminate correctly. Unlike text files, binary files do not contain a special
end-of-file marker. Therefore, the read methods can't see anything in the           +readLong() : long +readShort() : short
file that tells them they're at the end of the file. Instead, when a binary read
method attempts to read past the end of the file, an end-of-file exception                    +readUTF() : String
EOFException is thrown. Thus, the binary loop is coded as an infinite
loop that's exited when the EOFException is raised: fig-distream                     FIGURE 11.21 The
                                                                                     java.io.DataInputStream class
                                                                                     contains methods for reading all
                                                                                     types of data.
    try {
       while ( true ) { // I n f i n i t e l o o p                                 
           S t r i n g name = inStream . readUTF ( ) ; // R e a d a r e c o r d
           int age = inStream . readInt ( ) ;                                       An expected exception
           double pay = inStream . readDouble ( ) ;
           d i s p l a y . append ( name + " " + age + " " + pay + "\n" ) ;
       } // w h i l e

    } catch ( EOFException e ) {} // U n t i l EOF e x c e p t i o n
 

The read loop is embedded within a try/catch statement. Note that the
catch clause for the EOFException does nothing. Recall that when an
exception is thrown in a try block, the block is exited for good, which is
precisely the action we want to take. That's why we needn't do anything
when we catch the EOFException. We have to catch the exception or
else Java will catch it and terminate the program. This is an example of an
expected exception.

JAVA EFFECTIVE DESIGN EOFException. An attempt to read
past the end of a binary file will cause an EOFException to be
thrown. Catching this exception is the standard way of terminating a
binary input loop.

Note also the read() statements within the loop are mirror opposites of
the write() statements in the method that created the data. This will
generally be true for binary I/O routines: The statements that read data
from a file should "match" those that wrote the data in the first place.

 JAVA EFFECTIVE DESIGN Matching Input to Output. The
 statements used to read binary data should match those that wrote the
 data. If a writeX() method were used to write the data, a readX()
 should be used to read it.

To complete the method, the only remaining task is to close() the stream
after the data are read. The complete definition is shown in Figure 11.22.
         526         CHAPTER 11  Files and Streams: Input/Output Techniques

                                                                                       

private void readRecords ( String fileName ) {

  try {

  DataInputStream inStream       // Open s t r e a m

     = new DataInputStream (new F i l e I n p u t S t r e a m ( fileName ) ) ;

  d i s p l a y . s e t T e x t ( "Name Age Pay\n" ) ;

  try {

     while ( true ) {            // I n f i n i t e l o o p

         S t r i n g name = inStream . readUTF ( ) ; // R e a d a r e c o r d

         int age = inStream . readInt ( ) ;

         double pay = inStream . readDouble ( ) ;

         d i s p l a y . append ( name + " " + age + " " + pay + "\n" ) ;

     } // w h i l e

  } catch ( EOFException e ) { // U n t i l EOF e x c e p t i o n

  } finally {

         inStream . close ( ) ;              // C l o s e t h e s t r e a m

  }

  } catch ( FileNotFoundException e ) {
       d i s p l a y . s e t T e x t ( "IOERROR : "+ fileName + " NOT Found : \n" ) ;

  } catch ( IOException e ) {
       d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

  }

} // r e a d R e c o r d s ( )

                                                                                       

                     Figure 11.22: A method for reading binary data.

            It's important that a close() statement be placed after the catch
         EOFException clause. If it were placed in the try block, it would
         never get executed. Note also that the entire method is embedded in an
         outer try block that catches the IOException, thrown by the various
         read() methods, and the FileNotFoundException, thrown by the
         FileInputStream() constructor. These make the method a bit longer,
         but conceptually they belong in this method.

         JAVA PROGRAMMING TIP The finally Block. In coding a
         binary read loop, the try block is exited as soon as the EOFException
         is raised. Therefore, the close() statement must be placed in the
         finally clause, which is executed after the catch clause.

         JAVA EFFECTIVE DESIGN Nested Try/Catch. Nested try blocks
         must be used to perform binary I/O correctly. The outer block
         encapsulates statements that throw IOExceptions. The inner block
         encapsulates the read loop and catches the EOFException. No
         particular action need be taken when the EOFException is caught.
SECTION 11.5  Example: Reading and Writing Binary Files  527

SELF-STUDY EXERCISE

EXERCISE 11.5 Identify the error in the following method, which is
supposed to read a binary file of ints from a DataInputStream:

                                                          

public void readIntegers ( DataInputStream inStream ) {

  try {

     while ( true ) {

         i n t num = inStream . r e a d I n t ( ) ;

         System . out . p r i n t l n (num ) ;

     }

     inStream . close ( ) ;

  } catch ( EOFException e ) {                                                 JFrame         쳃nterface
                                                                                            ActionListener
  } catch ( IOException e ) {
                                                                                       +actionPerformed()
  }

} // r e a d I n t e g e r s

                                                          

11.5.3 The BinaryIO Application                                                         BinaryIO

Given the methods we wrote in the previous section, we can now specify         -display : JTextArea
the overall design of the BinaryIO class (Fig. 11.23). The program sets        -read : JButton
up the same interface we used in the text file example (Fig. 11.24). It al-    -write : JButton
lows the user to specify the name of a data file to read or write. One button  -prompt : JLabel
allows the user to write random employee records to a binary file, and the
other allows the user to display the contents of a file in a JTextArea. The    +BinaryIO()
BinaryIO program in Figure 11.25 incorporates both readRecords()               -readRecords()
and writeRecords() into a complete Java program.                               -writeRecords()
                                                                               +actionPerformed()
   fig-binaryioscreen                                                          +main()

11.5.4 Abstracting Data from Files                                              Figure 11.23: Design of the
                                                                                BinaryIO class.
It's important to recognize that the method to read a binary file must ex-
actly match the order of the write and read statements of the method that      
wrote the binary file. For example, if the file contains records that consist
of a String followed by an int followed by a double, then they must            
be written by a sequence consisting of                                           FIGURE 11.24 A program to read

                                                                               쮉nd write binary files.

    writeUTF ( ) ;                                                             
    writeInt ():
    writeDouble ( ) ;                                                           Portability
 

And they must thereafter be read by the sequence of

 

    readUTF ( ) ;
    readInt ( ) :
    readDouble ( ) ;
 

Attempting to do otherwise would make it impossible to interpret the data
in the file.

   This point should make it evident why (non-Java) binary files are not
portable whereas text files are. With text files, each character consists of
8 bits, and each 8-bit chunk can be interpreted as an ASCII character. So
even though a text file consists of a long sequence of 0's and 1's, we know
                                  528      CHAPTER 11  Files and Streams: Input/Output Techniques
                                                                                                                             
  import  javax . swing .  ;
  import  java . awt .  ;                 // Swing com ponen ts
  import  java . io .;
  import  java . awt . event .  ;

public class BinaryIO extends JFrame implements ActionListener {
       p r i v a t e JTextArea d i s p l a y = new JTextArea ( ) ;
       p r i v a t e J B u t t o n read = new J B u t t o n ( "Read Records From F i l e " ) ,
                                    w r i t e = new J B u t t o n ( " Generate Random Records " ) ;
       p r i v a t e J T e x t F i e l d nameField = new J T e x t F i e l d ( 1 0 ) ;
       p r i v a t e J L a b e l prompt = new J L a b e l ( " Filename : " , J L a b e l . RIGHT ) ;
       p r i v a t e J P a n e l commands = new J P a n e l ( ) ;

  public BinaryIO () {

          super ( " BinaryIO Demo" ) ;                             // S e t window t i t l e

          read . addActionListener ( this ) ;

          write . addActionListener ( this );

          commands . s e t L a y o u t ( new GridLayout ( 2 , 2 , 1 , 1 ) ) ; // C o n t r o l p a n e l

          commands . add ( prompt ) ;

          commands . add ( nameField ) ;

          commands . add ( read ) ;

          commands . add ( w r i t e ) ;

          display . setLineWrap ( true ) ;

          t h i s . getContentPane ( ) . s e t L a y o u t (new BorderLayout ( ) ) ;

          t h i s . getContentPane ( ) . add ( " North " , commands ) ;

          t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( d i s p l a y ) ) ;

          t h i s . getContentPane ( ) . add ( " Center " , display ) ;

  } // B i n a r y I O ( )

  private void readRecords ( String fileName ) {

          try {

             DataInputStream inStream          // Open s t r e a m

                 = new DataInputStream (new F i l e I n p u t S t r e a m ( fileName ) ) ;

             d i s p l a y . s e t T e x t ( "Name Age Pay\n" ) ;

             try {

                 while ( true ) {                // I n f i n i t e l o o p

                            S t r i n g name = inStream . readUTF ( ) ; // R e a d a r e c o r d

                            int age = inStream . readInt ( ) ;

                            double pay = inStream . readDouble ( ) ;

                            d i s p l a y . append ( name + " " + age + " " + pay + "\n" ) ;

                 } // w h i l e

             } catch ( EOFException e ) { // U n t i l EOF e x c e p t i o n

             } finally {

                 inStream . close ( ) ;                            // C l o s e t h e s t r e a m

             }

          } catch ( FileNotFoundException e ) {

             d i s p l a y . s e t T e x t ( "IOERROR : F i l e NOT Found : " + fileName + "\n" ) ;

          } catch ( IOException e ) {

             d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

          }

  } // r e a d R e c o r d s ( )

                                                                                                          

                                  Figure 11.25: Part I of the BinaryIO class, which illustrates simple input
                                  and output from a binary file.
SECTION 11.5  Example: Reading and Writing Binary Files                  529

                                                                                           

  private void writeRecords ( String fileName ) {

  try {

     DataOutputStream outStream // Open s t r e a m

          = new DataOutputStream (new FileOutputStream ( fileName ) ) ;

     for ( int k = 0; k < 5; k++) { // O u t p u t 5 d a t a r e c o r d s

          S t r i n g name = "Name" + k ; // o f name , a g e , p a y r a t e

          outStream . writeUTF ( "Name" + k ) ;

          outStream . w r i t e I n t ( ( i n t ) ( 2 0 + Math . random ( )  2 5 ) ) ;

          outStream . writeDouble ( 5 . 0 0 + Math . random ( )  1 0 ) ;

     } // f o r

     outStream . close ( ) ;              // C l o s e t h e s t r e a m

  } catch ( IOException e ) {

     d i s p l a y . s e t T e x t ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

  }

} // w r i t e R e c o r d s ( )

public void actionPerformed ( ActionEvent evt ) {
       String fileName = nameField . getText ( ) ;
       i f ( e v t . g e t S o u r c e ( ) == read )
              readRecords ( fileName ) ;
         else
              writeRecords ( fileName ) ;

} // a c t i o n P e r f o r m e d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

     BinaryIO b i o = new BinaryIO ( ) ;

     bio . setSize (400 , 200);

     bio . setVisible ( true ) ;

     b i o . addWindowListener ( new WindowAdapter ( ) { // Q u i t

          public void windowClosing ( WindowEvent e ) {

               System . exit ( 0 ) ;

          }

     });

} // main ( )

} // B i n a r y I O

                                                                                           

             Figure 11.25: (continued) The BinaryIO class, Part II.

how to find the boundaries between each character. That's why any text
editor can read a text file, no matter what program created it.

   On the other hand, binary files are also just a long sequence of 0's and
1's, but we can't tell where one data element begins and another one ends.
For example, the 64-bit sequence

                                                                                        

     010100110011001001010100110011000

     010100110011001011010100110011000                                                  

could represent two 32-bit ints or two 32-bit floats or one 64-bit
double or four 16-bit chars or a single String of 8 ASCII characters.
                                     530  CHAPTER 11  Files and Streams: Input/Output Techniques

                                     We can't tell what data we have unless we know exactly how the data
                                     were written.

                                     JAVA DEBUGGING TIP Interpreting Binary Data. The fact that you
                                     can read the data in a binary file is no guarantee that you are
                                     interpreting it correctly. To interpret it correctly, you must read it the
                                     same way it was written.

                                     JAVA EFFECTIVE DESIGN Data Abstraction. Binary data are
                                     "raw." They have no inherent structure. It is only the programs that
                                     read and write the data that provide them with structure. A string of
                                     64 0's and 1's can be interpreted as two ints or one long or even as
                                     some kind of object, so an int, long or an object is an abstraction
                                     imposed upon the data by the program.

                  OutputStream       11.6 Object Serialization: Reading and Writing
              ObjectOutputStream
        +writeObject(in o : Object)          Objects

                    InputStream      The examples in the previous sections showed how to perform I/O op-
               ObjectInputStream     erations on simple binary data or text. The java.io package also pro-
           +readObject() : Object    vides methods for reading and writing objects, a process known as ob-
                                     ject serialization. Objects can be converted into a sequence of bytes, or
Figure 11.26: Classes used for per-  serialized, by using the ObjectOutputStream class, and they can be de-
forming I/O on objects.              serialized, or converted from bytes into a structured object, by using the
                                     ObjectInputStream class (Fig. 11.26). Despite the complexity of the
                                     serialization/deserialization processes, the methods in these classes make
                                     the task just as easy as reading and writing primitive data.

                                        To illustrate object serialization, let's begin by defining a Student class
                                     (Fig. 11.27). In order to serialize an object, it must be a member of a class
                                     that implements the Serializable interface. The Serializable inter-
                                     face is a marker interface, an interface that doesn't define any methods or
                                     constants but just serves to designate whether an object can be serialized
                                     or not.

                                        The Student class contains its own I/O methods, readFromFile()
                                     and writeToFile(). This is an appropriate object-oriented design. The
                                     Student class encapsulates all the relevant information needed to read
                                     and write its data.

                                     JAVA EFFECTIVE DESIGN I/O Design. If an object is going to be
                                     input and output to and from files, it should define its own I/O
                                     methods. An object contains all the relevant information needed to
                                     perform I/O correctly.

                                     Note the definition of the writeToFile() method, which performs
                                     the output task. This method's FileOutputStream parameter is used
                                     to create an ObjectOutputStream, whose writeObject() method

Object serialization
 SECTION 6  Object Serialization                                    531
                                                                                         

  import java . io .  ;

public class Student implements S e r i a l i z a b l e {
   p r i v a t e S t r i n g name ;
   private int year ;
   private double gpa ;

  public Student ( ) {}

  public Student ( S t r i n g nameIn , i n t yr , double gpaIn ) {
     name = nameIn ;
     year = yr ;
     gpa = gpaIn ;

  }

  public void writeToFile ( FileOutputStream outStream )
                                                                 throws IOException{

     ObjectOutputStream ooStream = new ObjectOutputStream ( outStream ) ;
     ooStream . writeObject ( this ) ;
     ooStream . flush ( ) ;
  } // w r i t e T o F i l e ( )

  public void readFromFile ( FileInputStream inStream )
                  throws IOException , ClassNotFoundException {

     O b j e c t I n p u t S t r e a m oiStream = new O b j e c t I n p u t S t r e a m ( inStream ) ;
     Student s = ( Student ) oiStream . readObject ( ) ;
     t h i s . name = s . name ;
     this . year = s . year ;
     t h is . gpa = s . gpa ;
  } // r e a d F r o m F i l e ( )

  public String toString () {

     r e t u r n name + "\ t " + year + "\ t " + gpa ;

  }

} // S t u d e n t

                                                                                                        

                    Figure 11.27: The serializable Student class.

writes the object into the file. To output a Student object, we merely
invoke the writeObject() method. This method writes out the current
values of all the object's public and private fields. In this case, the method
would write a String for the object's name, an int for the object's year,
and a double for the object's gpa.

   Although our example doesn't require it, the writeObject() method
can also handle fields that refer to other objects. For example, suppose our
Student object provided a field for courses that contained a reference
to an array of objects, each of which described a course the student has
taken. In that case, the writeObject() method would serialize the array
and all its objects (assuming they are serializable). Thus, when a complex
object is serialized, the result would be a complex structure that contains
all the data linked to that root object.
                        532  CHAPTER 11  Files and Streams: Input/Output Techniques

Object deserialization     Object deserialization, as shown in the readFromFile() method,
                        is simply the reverse of the serialization process. The readObject()
                        method reads one serialized object from the ObjectInputStream. Its
                        result type is Object, so it is necessary to cast the result into the proper
                        type. In our example we use a local Student variable to store the object
                        as it is input. We then copy each field of the local object to this object.

                           Note that the readFromFile() method throws both the IOException
                        and ClassNotFoundException. An IOException will be generated if
                        the file you are attempting to read does not contain serialized objects of the
                        correct type. Objects that can be input by readObject() are those that
                        were output by writeObject(). Thus, just as in the case of binary I/O,
                        it is best to design an object's input and output routines together so that
                        they are compatible. The ClassNotFoundException will be thrown if
                        the Student class cannot be found. This is needed to determine how to
                        deserialize the object.

                        JAVA PROGRAMMING TIP Object Serialization. Java's
                        serialization classes, ObjectOutputStream and
                        ObjectInputStream, should be used whenever an object needs to
                        be input or output from a stream.

                        11.6.1 The ObjectIO Class

                        Given the Student class, let's now write a user interface that can read
                        and write Student objects. We can use the same interface we used in the
                        BinaryIO program. The only things we need to change are the write-
                        Records() and readRecords() methods. Everything else about this
                        program will be exactly the same as in BinaryIO.

                           Figure 11.28 provides the full implementation of the ObjectIO class.
                        Note that the writeRecords() method will still write five random
                        records to the data file. The difference in this case is that we will call the
                        Student.writeToFile() method to take care of the actual output op-
                        erations. The revised algorithm will create a new Student object, using
                        randomly generated data for its name, year, and GPA and then invoke its
                        writeToFile() to output its data. Note how a FileOutputStream is
                        created and passed to the Student.writeToFile() method.

                           The readRecords() method (Fig. 11.28, Part II) will read data from
                        a file containing serialized Student objects. To do so, it first cre-
                        ates a Student object and then invokes its readFromFile() method,
                        passing it a FileInputStream. Note how the FileInputStream is
                        created and, unlike in BinaryIO, the inner try block is exited by an
                        IOException rather than an EOFException.
SECTION 6  Java Library : JFileChooser                                                  533
                                                                                                      


import  javax . swing .  ;                 // Swing  components
import  java . awt .  ;
import  java . io .;
import  java . awt . event .  ;

public class ObjectIO extends JFrame implements ActionListener {
   p r i v a t e JTextArea d i s p l a y = new JTextArea ( ) ;
   p r i v a t e J B u t t o n read = new J B u t t o n ( "Read From F i l e " ) ,
                                w r i t e = new J B u t t o n ( " Write t o F i l e " ) ;
   p r i v a t e J T e x t F i e l d nameField = new J T e x t F i e l d ( 1 0 ) ;
   p r i v a t e J L a b e l prompt = new J L a b e l ( " Filename : " , J L a b e l . RIGHT ) ;
   p r i v a t e J P a n e l commands = new J P a n e l ( ) ;

   public ObjectIO () {

   super ( " ObjectIO Demo" ) ;                      // S e t window t i t l e

   read . addActionListener ( this ) ;

   write . addActionListener ( this );

   commands . s e t L a y o u t (new GridLayout ( 2 , 2 , 1 , 1 ) ) ;

   commands . add ( prompt ) ;                       // C o n t r o l p a n e l

   commands . add ( nameField ) ;

   commands . add ( read ) ;

   commands . add ( w r i t e ) ;

   display . setLineWrap ( true ) ;

   t h i s . getContentPane ( ) . s e t L a y o u t (new BorderLayout ( ) ) ;

   t h i s . getContentPane ( ) . add ( " North " , commands ) ;

   t h i s . getContentPane ( ) . add ( new J S c r o l l P a n e ( d i s p l a y ) ) ;

   t h i s . getContentPane ( ) . add ( " Center " , display ) ;

   } // O b j e c t I O

   public void actionPerformed ( ActionEvent evt ) {

   String fileName = nameField . getText ( ) ;

   i f ( e v t . g e t S o u r c e ( ) == read )

         readRecords ( fileName ) ;

   else

         writeRecords ( fileName ) ;

   } // a c t i o n P e r f o r m e d ( )

                                                                                                  

Figure 11.28: Part I of the ObjectIO class, which provides an interface to
reading and writing files of Students.

SELF-STUDY EXERCISE

EXERCISE 11.6 Given the following definition, would a binary file con-
sisting of several SomeObjects be readable by either the BinaryIO or
the ObjectIO programs? Explain.

                                                                                         

public class SomeObject {

   private String str ;

   private short n1 ;

   private short n2 ;

   private long n3 ;

}

                                                                                         
                                    534     CHAPTER 11  Files and Streams: Input/Output Techniques

                                                                                                                            

  private void readRecords ( String fileName ) {

     try {

        F i l e I n p u t S t r e a m inStream = new F i l e I n p u t S t r e a m ( fileName ) ; // O p e n a s t r e a m

        d i s p l a y . s e t T e x t ( "Name\ t Y e a r \tGPA\n" ) ;

        try {

           while ( true ) {                                // I n f i n i t e l o o p

              Student s t u d e n t = new Student ( ) ;                // C r e a t e a s t u d e n t i n s t a n c e

              student . readFromFile ( inStream ) ;                    // and have i t r e a d an o b j e c t

              display . append ( student . t o S t r i n g ( ) + "\n" ) ; // and d i s p l a y i t

           }

        } catch ( IOException e ) {         // U n t i l I O E x c e p t i o n

        }

        inStream . close ( ) ;                                         // C l o s e t h e s t r e a m

     } catch ( FileNotFoundException e ) {

           d i s p l a y . append ( "IOERROR : F i l e NOT Found : " + fileName + "\n" ) ;

     } catch ( IOException e ) {

           d i s p l a y . append ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

     } catch ( ClassNotFoundException e ) {

           d i s p l a y . append ( "ERROR : C l a s s NOT found " + e . getMessage ( ) + "\n" ) ;

     }

  } // r e a d R e c o r d s ( )

  private void writeRecords ( String fileName ) {

  try {

        FileOutputStream outStream = new FileOutputStream ( fileName ) ; // O p e n s t r e a m

        for ( int k = 0; k < 5 ; k++) {                                // G e n e r a t e 5 random o b j e c t s

           S t r i n g name = "name" + k ;                                      // Name

           i n t year = ( i n t ) ( 2 0 0 0 + Math . random ( )  4 ) ; // C l a s s y e a r

           double gpa = Math . random ( )  1 2 ;                                // GPA

           S tu de nt s t u d e n t = new St ud en t ( name , year , gpa ) ; // C r e a t e t h e o b j e c t

           display . append ( "Output : "+ student . t o S t r i n g ( ) +"\n" ) ; // and d i s p l a y i t

           student . writeToFile ( outStream ) ;                       // and t e l l i t t o w r i t e d a t a

        } // f o r

        outStream . close ( ) ;

  } catch ( IOException e ) {

        d i s p l a y . append ( "IOERROR : " + e . getMessage ( ) + "\n" ) ;

  }

  } // w r i t e R e c o r d s ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  ObjectIO i o = new ObjectIO ( ) ;

  io . setSize ( 400 ,200);

  io . setVisible ( true );

  i o . addWindowListener (new WindowAdapter ( ) {

           public void windowClosing ( WindowEvent e ) {

               System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

               }

  });

  } // main ( )

} // O b j e c t I O

                                                                                                                            

                                         Figure 11.28: (continued) The ObjectIO class, Part II.
 SECTION 11.7  From the Java Libraryjavax.swing.JFileChooser 535

11.7 From the Java Library
        javax.swing.JFileChooser

THE javax.swing.JFileChooser class is useful for dealing with files                                        java.sun.com/j2se/1.5.0/docs/api/
and directories in a GUI environment. You are probably already familiar
with JFileChoosers, although you may not have known them by that                                           JComponent
name. A JFileChooser provides a dialog box that enables the user to
select a file and a directory when opening or saving a file. Figure 11.30                                             JFileChooser
shows an example.
                                                                                                   +APPROVE_OPTION : int
   A JFileChooser is designed primarily to be used in conjunction with                             +CANCEL_OPTION : int
menu-based programs. The JFileChooser class (Fig. 11.29) contains
methods that support the Open File and Save As options which often ap-                             +JFileChooser()
pear in GUI applications either in a menu or attached to buttons. In this                          +JFileChooser(in currentDirectory : File)
section we provide the basics for using a JFileChooser. Options for                                +JFileChooser(in path : String)
opening a file or saving a file can be added to the kind of GUI applications                       +getCurrentDirectory() : File
that we encountered earlier in the text by using buttons. In Chapter 13, we                        +getSelectedFile() : File
will discuss the use of JMenus which will provide a more natural means                             +getSelectedFiles() : File[]
of using the JFileChooser dialogs.                                                                 +showOpenDialog(in c : Component) : int
                                                                                                   +showSaveDialog(in c : Component) : int
   A JFileChooser is not itself the dialog window, but rather the object                           +setCurrentDirectory(in dir : File)
that manages the dialog. After creating a JFileChooser instance, its
showOpenDialog() or showSaveDialog() methods are used to open                                      
a dialog window. Note that these methods require a Component parame-
ter, usually a JFrame or a JApplet. Thus, JFileChoosers can be used                                Figure  11.29:      The
only in GUI applications and applets.
                                                                                                   javax.swing.JFileChooser
   To illustrate how to use a JFileChooser, let's consider the case where
the user has selected an Open File menu item or clicked a button labeled                           class.
Open File. In this case, executing the following code will cause an "Open
File" dialog to appear:                                                                            
                                                                                                    Opening a file
 

    J F i l e C h o o s e r chooser = new J F i l e C h o o s e r ( ) ;
    int r e s u l t = chooser . showOpenDialog ( this ) ;

    i f ( r e s u l t == J F i l e C h o o s e r . APPROVE OPTION) {
           File f i l e = chooser . getSelectedFile ( ) ;

              // I n s e r t code h e r e t o r e a d d a t a from f i l e

           S t r i n g fileName = f i l e . getName ( ) ;
           d i s p l a y . s e t T e x t ( "You s e l e c t e d " + fileName ) ;
    } else
           d i s p l a y . s e t T e x t ( "You c a n c e l l e d t h e f i l e d i a l o g " ) ;
 

We begin by creating a JFileChooser and then telling it to showOpen-
Dialog(). If we were saving a file rather than opening one, we would
tell it to showSaveDialog(). In either case, a dialog window will pop
up on the screen. The dialog assists the user in navigating through the file
system and selecting a file (Fig. 11.30).

   The dialog contains two buttons, one labeled Open and the other la-
beled Cancel. If the user selects a file, that choice will correspond to
APPROVE OPTION. If the user cancels the dialog, that will correspond to
CANCEL OPTION. After opening a dialog, the code should check which
option resulted. In this case, if the user opened a file, the code gets a
                                                 536  CHAPTER 11  Files and Streams: Input/Output Techniques
Figure 11.30: The Open File dialog
window.

                        reference to the file and then simply uses that to print the file's path name
                        to a text area named display. In an actual application, code would be
                        inserted at that spot which uses the file reference to read data from the
                        file.

                        11.8 Using File Data in Programs

modifying WordGuess     This chapter's examples have provided explicit details for several ways
New instance variables  of writing data to files and reading data from files. In actual programs,
                        deciding if and how files might be useful in the program are worked out
                        as part of the design process. Choosing between text files, binary files, and
                        reading and writing objects is part of this process.

                           To illustrate how we can apply what we've learned about file I/O, let's
                        modify the WordGuess class (which is listed in Fig. 8.27) so that it reads
                        a list of possible words for players to guess from a file. The Chapter 8
                        version of the class contains a method, getSecretWord(), which uses
                        a switch statement to randomly choose and return a word from a fixed
                        list of ten words. Reading the words from a text file would allow a user
                        to modify the list of possible words by adding or changing words without
                        needing to recompile the program.
                        Let's modify the WordGuess class in three ways:

                        1. adding two new instance variables, an array of type String and a
                           variable to store the size of the array;

                        2. adding code at the beginning of the class's constructor to read words
                           from the file and store them in the array;

                        3. rewrite the getSecretWord() method so that it randomly chooses
                           a word from the array.

                        Let us first choose descriptive names for declaring the two new instance
                        variables:

                                                                                                               

                                                      private String [ ] wordArray ;

                                                      private int arraySize ;                                  

                        Note that it will be useful to store the number of words in the file
                        in its first line so that this information can be used to allocate mem-
                        ory for the array. For example, let us assume the text file will be
SECTION 11.8  Using File Data in Programs                                537

named secretwords.txt, it will be located in the same directory as the                              Format for the text file
WordGuess class, it will have the number of words in the file as its first                         
line, and it will have a single word per line after that. Thus, a small file                       
might look like:
                                                                                                    Code to add to constructor
                                                                                                   

           3                                                                                       
           STREAMS
           CONDUIT
           DIALOGS
 

   We can use the body of the readTextFile() method of the TextIO
class as a model for the Java code that needs to be added to the
WordGuess constructor. Pseudocode for this code will look like:

 

           Use f i l e name t o open a BufferedReader stream
           Read f i r s t l i n e and convert to an i n t e g e r
           Store the integer as the size of the array
           A l l o c a t e memory f o r t h e a r r a y
           Read second l i n e of f i l e
           While a word i s read

                 S t o r e the word i n the next a r r a y element
                Read next l i n e of f i l e
           Close the BufferedReader stream
 

When this pseudocode is translated into Java and inserted into a
try-catch statement we get the code fragment in Figure 11.31.

                                                                                                   

  try{

        F i l e R e a d e r f r = new F i l e R e a d e r ( " s e c r e t w o r d s . t x t " ) ;

        BufferedReader inStream

        = new BufferedReader ( f r ) ;

        String line = inStream . readLine ( ) ;

        arraySize = Integer . parseInt ( line );

        wordArray = new S t r i n g [ a r r a y S i z e ] ;

        line = inStream . readLine ( ) ;

        int k = 0;

        while ( ( l i n e ! = n u l l ) && ( k < a r r a y S i z e ) ) {

        wordArray [ k ] = l i n e ;

        line = inStream . readLine ( ) ;

        k++;

        }// w h i l e

        inStream . close ( ) ;

  } catch ( FileNotFoundException e){

        e . printStackTrace ();

  } catch ( IOException e){

        e . printStackTrace ();

  } // c a t c h

                                                                                                   

Figure 11.31: Code added at beginning of the WordGuess constructor.

  The new getSecretWord() method merely needs to generate a ran- New code for getSecretWord
538  CHAPTER 11  Files and Streams: Input/Output Techniques

dom array index and return the corresponding array element:

                                                                               

     private String getSecretWord (){

     i n t num = ( i n t ) ( Math . random ( )  a r r a y S i z e ) ;

     r e t u r n wordArray [num ] ;

     } // g e t S e c r e t W o r d ( )

                                                                               

The only other modification that is needed for to complete new
WordGuess class is to add an initial import java.io.*; statement so
that the file IO classes can be accessed.

   The earlier examples in this chapter can be used as models to enhance
numerous practical applications. GUI applications that involve a user's
choice to load data from a file or save data in a file should make use of the
JFileChooser dialogs to initiate the file operations.

Special Topic: Databases and Personal Privacy

During a typical day we all come in contact with lots of electronic
databases that store information about us. If you use a supermarket dis-
count card, every purchase you make is logged against your name in the
supermarket's database. When you use your bank card at the ATM ma-
chine, your financial transaction is logged against your account. When
you charge gasoline or buy dinner, those transactions are logged against
your credit card account. If you visit the doctor or dentist, a detailed
record of your visit is transmitted to your medical insurance company's
database. If you receive a college loan, detailed financial information
about you is entered into several different credit service bureaus. And
so on.

   Should we be worried about how this information is used? Many pri-
vacy advocates say yes. With the computerization of medical records,
phone records, financial transactions, driving records, and many other
records, there is an enormous amount of personal information held in
databases. At the same time, there are pressures from a number of sources
for access to this information. Law-enforcement agencies want to use this
information to monitor individuals. Corporations want to use it to help
them market their products. Political organizations want to use it to help
them market their candidates.

   Recently there has been pressure from government and industry in the
United States to use the social security number (SSN) as a unique identi-
fier. Such an identifier would make it easy to match personal information
across different databases. Right now, the only thing your bank records,
medical records, and supermarket records may have in common is your
name, which is not a unique identifier. If all online databases were based
on your SSN, it would be much simpler to create a complete profile. While
this might improve services and reduce fraud and crime, it might also
pose a significant threat to our privacy.

   The development of online databases serve many useful purposes.
They help fight crime and reduce the cost of doing business. They help
improve government and commercial services on which we have come
to depend. On the other hand, databases can be and have been misused.
CHAPTER 11  Chapter Summary               539

They can be used by unauthorized individuals or agencies or in unautho-
rized ways. When they contain inaccurate information, they can cause
personal inconvenience or even harm.

   There are a number of organizations that have sprung up to address
the privacy issues raised by online databases. If you're interested in learn-
ing more about this issue, a good place to start would be the Web site
maintained by the Electronic Privacy Information Center (EPIC) at

                                                                                   

h t t p : //www. e p i c . org/                                                    


Technical Terms                                                                    CHAPTER SUMMARY

absolute path name  end-of-file character  output
binary file         field                  path
buffering           file                   record
database            filtering              relative path name
data hierarchy      input                  Unicode Text Format
directory           object serialization
                                              (UTF)

Summary of Important Points

 A file is a collection of data stored on a disk. A stream is an object that
   delivers data to and from other objects.

 An InputStream is a stream that delivers data to a program from an
   external source--such as the keyboard or a file. System.in is an exam-
   ple of an InputStream. An OutputStream is a stream that delivers
   data from a program to an external destination--such as the screen or
   a file. System.out is an example of an OutputStream.

 Data can be viewed as a hierarchy. From highest to lowest, a database
   is a collection of files. A file is a collection of records. A record is a
   collection of fields. A field is a collection of bytes. A byte is a collection
   of 8 bits. A bit is one binary digit, either 0 or 1.

 A binary file is a sequence of 0s and 1s that is interpreted as a sequence
   of bytes. A text file is a sequence of 0s and 1s that is interpreted as a
   sequence of characters. A text file can be read by any text editor, but
   a binary file cannot. InputStream and OutputStream are abstract
   classes that serve as the root classes for reading and writing binary data.
   Reader and Writer serve as root classes for text I/O.

 Buffering is a technique in which a buffer, a temporary region of mem-
   ory, is used to store data while they are being input or output.

 A text file contains a sequence of characters divided into lines by the
   \n character and ending with a special end-of-file character.

 The standard algorithm for performing I/O on a file consists of three
   steps: (1) Open a stream to the file, (2) perform the I/O, and (3) close
   the stream.
                      540  CHAPTER 11  Files and Streams: Input/Output Techniques

                       Designing effective I/O routines answers two questions: (1) What
                        streams should I use to perform the I/O? (2) What methods should I
                        use to do the reading or writing?

                       To prevent damage to files when a program terminates abnormally,
                        streams should be closed when they are no longer needed.

                       Most I/O operations generate an IOException that should be caught
                        in the I/O methods.

                       Text input uses a different technique to determine when the end of a
                        file has been reached. Text input methods return null or -1 when
                        they attempt to read the special end-of-file character. Binary files
                        don't contain an end-of-file character, so binary read methods throw
                        an EOFException when they attempt to read past the end of the file.

                       The java.io.File class provides methods that enable a program to
                        interact with a file system. Its methods can be used to check a file's
                        attributes, including its name, directory, and path.

                       Streams can be joined together to perform I/O. For example, a
                        DataOutputStream and a FileOutputStream can be joined to per-
                        form output to a binary file.

                       A binary file is "raw" in the sense that it contains no markers within it
                        that allow you to tell where one data element ends and another begins.
                        The interpretation of binary data is up to the program that reads or
                        writes the file.

                       Object serialization is the process of writing an object to an output
                        stream. Object deserialization is the reverse process of reading a serial-
                        ized object from an input stream. These processes use the java.io.-
                        ObjectOutputStream and java.io.ObjectInputStream classes.

                       The JFileChooser class provides a dialog box that enables the user
                        to select a file and directory when opening or saving a file.

SOLUTIONS TO          SOLUTION 11.1 Because FileWriter contains a constructor that takes a file
SELF-STUDY EXERCISES  name argument, FileWriter(String), it can be used with PrintWriter to
                      perform output to a text file:

                                                                                                                    

                      PrintWriter outStream =    // C r e a t e o u t p u t s t r e a m

                           new P r i n t W r i t e r ( new F i l e W r i t e r ( fileName ) ) ; // O p e n f i l e

                      outStream . print ( display . getText ( ) ) ; // D i s p l a y t e x t

                        outStream . close ( ) ;  // C l o s e o u t p u t s t r e a m
                      
                                                                                      

                      SOLUTION 11.2 An empty file doesn't affect this loop. If the file is empty, it
                      will print a null line. The test line != null, should come right after the
                      readLine(), as it does in the while loop.

                      SOLUTION 11.3 This loop won't work on an empty text file. In that case, ch
                      would be set to -1, and the attempt to cast it into a char would cause an error.
   CHAPTER 11  Exercises                                                  541
                                                                             
  SOLUTION 11.4
                                                                             

  public void getFileAttributes ( String fileName ) {
         F i l e f i l e = new F i l e ( fileName ) ;
         System . out . println ( filename ) ;
         System . out . println ( " absolute path : "
                      + fi le . getAbsolutePath ( ) ) ;
         System . out . println ( " length : " + f i l e . length ( ) ) ;
         if ( file . isDirectory ())
                System . out . println ( " Directory " ) ;
         else
                System . out . p r i n t l n ( "Not a Directory " ) ;

  } // g e t F i l e A t t r i b u t e s ( )


SOLUTION 11.5 The inStream.close() statement is misplaced in read-
Integers(). By placing it inside the same try/catch block as the read loop, it
will get skipped and the stream will not be closed. The EOFException should be
caught in a separate try/catch block from other exceptions, and it should just
cause the read loop to exit.

SOLUTION 11.6 Yes, a binary file containing several SomeObjects would be
"readable" by the BinaryIO program because the program will read a String
followed by 64 bytes. However, BinaryIO would misinterpret the data, be-
cause it will assume that n1 and n2 together comprise a single int, and n3
(64 bits) will be interpreted as a double. A file of SomeObjects could not be
read by the ObjectIO program, because SomeObject does not implement the
Serializable interface.

EXERCISE 11.1 Explain the difference between each of the following pairs of            EXERCISES

terms:                                                                                 Note: For programming exercises,
                                                                                       first draw a UML class diagram
a. System.in and System.out.         f. File and database.                             describing all classes and their
b. File and directory.               g. Record and field.                              inheritance relationships and/or
c. Buffering and filtering.          h. Binary file and text file.                     associations.
d. Absolute and relative path name.  i. Directory and database.
e. Input stream and output stream.

EXERCISE 11.2 Fill in the blanks.

a. Unlike text files, binary files do not have a special                   character.

b. In Java, the String array parameter in the main() method is used for

               .

c.             files are portable and platform independent.

d. A              file created on one computer can't be read by another

    computer.

EXERCISE 11.3 Arrange the following kinds of data into their correct hierar-
chical relationships: bit, field, byte, record, database, file, String,
char.
542  CHAPTER 11  Files and Streams: Input/Output Techniques

EXERCISE 11.4 In what different ways can the following string of 32 bits be
interpreted?

                                                                      

00010101111000110100000110011110                                      


EXERCISE 11.5 When reading a binary file, why is it necessary to use an infinite
loop that's exited only when an exception occurs?

EXERCISE 11.6 Is it possible to have a text file with 10 characters and 0 lines?
Explain.

EXERCISE 11.7 In reading a file, why is it necessary to attempt to read from the
file before entering the read loop?

EXERCISE 11.8 When designing binary I/O, why is it especially important to
design the input and output routines together?

EXERCISE 11.9 What's the difference between ASCII code and UTF code?

EXERCISE 11.10 Could the following string of bits possibly be a Java object?
Explain.

                                                                      

00010111000111101010101010000111001000100

11010010010101010010101001000001000000111                             


EXERCISE 11.11 Write a method that could be added to the TextIO program to
read a text file and print all lines containing a certain word. This should be a void
method that takes two parameters: The name of the file and the word to search
for. Lines not containing the word should not be printed.

EXERCISE 11.12 Write a program that reads a text file and reports the number
of characters and lines contained in the file.

EXERCISE 11.13 Modify the program in the previous exercise so that it also
counts the number of words in the file. (Hint: The StringTokenizer class might
be useful for this task.)

EXERCISE 11.14 Modify the ObjectIO program so that it allows the user to
designate a file and then input Student data with the help of a GUI. As the user
inputs data, each record should be written to the file.

EXERCISE 11.15 Write a program that will read a file of ints into memory, sort
them in ascending order, and output the sorted data to a second file.

EXERCISE 11.16 Write a program that will read two files of ints, which are
already sorted into ascending order, and merge their data. For example, if one file
contains 1, 3, 5, 7, 9, and the other contains 2, 4, 6, 8, 10, then the merged file should
contain 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

EXERCISE 11.17 Suppose you have a file of data for a geological survey. Each
record consists of a longitude, a latitude, and an amount of rainfall, all represented
by doubles. Write a method to read this file's data and print them on the screen,
one record per line. The method should be void and it should take the name of
the file as its only parameter.

EXERCISE 11.18 Suppose you have the same data as in the previous exercise.
Write a method that will generate 1,000 records of random data and write them to
a file. The method should be void and should take the file's name as its parameter.
Assume that longitudes have values in the range +/- 0 to 180 degrees, latitudes
have values in the range +/- 0 to 90 degrees, and rainfalls have values in the
range 0 to 20 inches.
CHAPTER 11  Exercises                543

EXERCISE 11.19 Design and write a file copy program that will work for either
text files or binary files. The program should prompt the user for the names of
each file and copy the data from the source file into the destination file. It should
not overwrite an existing file, however. (Hint: Read and write the file as a file of
byte.)

EXERCISE 11.20 Design a class, similar to Student, to represent an Address.
It should consist of street, city, state, and zip code and should contain its own
readFromFile() and writeToFile() methods.

EXERCISE 11.21 Using the class designed in the previous exercise, modify the
Student class so that it contains an Address field. Modify the ObjectIO pro-
gram to accommodate this new definition of Student and test your program.

EXERCISE 11.22 Write a program called Directory, which provides a listing
of any directory contained in the current directory. This program should prompt
the user for the name of the directory. It should then print a listing of that directory.
The listing should contain the following information: The full path name of the
directory, and then include the file name, length, and last modified date, and a
read/write code for each file. The read/write code should be an r if the file is
readable and a w if the file is writeable, in that order. Use a "-" to indicate not
readable or not writeable. For example, a file that is readable but not writable will
have the code r-. Here's an example listing:

                                      

Listing for directory : myfiles

  name          length modified code

  index . html  548  129098      rw

  index . gif   78   129190      rw

  me . html     682  128001      r-

  private . txt 1001 129000      --

                                      

Note that the File.lastModified() returns a long, which gives the modifi-
cation time of the file. This number can't easily be converted into a date, so just
report its value.

EXERCISE 11.23 Challenge: Modify the OneRowNimGUI class that is listed in
Chapter 4's Figure 4-25 so that the user can save the position of the game to a file
or open and read a game position from a file. You should add two new JButtons
to the GUI interface. Use the object serialization example as a model for your input
and output streams.

EXERCISE 11.24 Challenge: In Unix systems, there's a program named grep
that can list the lines in a text file containing a certain string. Write a Java version
of this program that prompts the user for the name of the file and the string to
search for.

EXERCISE 11.25 Challenge: Write a program in Java named Copy to copy
one file into another. The program should prompt the user for two file names,
filename1 and filename2. Both filename1 and filename2 must exist or
the program should throw a FileNotFoundException. Although filename1
must be the name of a file (not a directory), filename2 may be either a file or a
directory. If filename2 is a file, then the program should copy filename1 to
filename2. If filename2 is a directory, then the program should simply copy
filename1 into filename2. That is, it should create a new file with the name
filename1 inside the filename2 directory, copy the old file to the new file, and
then delete the old file.
544  CHAPTER 11  Files and Streams: Input/Output Techniques
Chapter 12

Recursive Problem Solving

OBJECTIVES

After studying this chapter, you will
 Understand the concept of recursion.
 Know how to use recursive programming techniques.
 Have a better understanding of recursion as a problem-solving technique.

OUTLINE
Outline

12.1 Introduction
12.2 Recursive Definition
12.3 Recursive String Methods
12.4 Recursive Array Processing
12.5 Example: Drawing (Recursive) Fractals
12.6 Object-Oriented Design: Tail Recursion
12.7 Object-Oriented Design: Recursion or Iteration?

         Special Topic: Exploring the Mandelbrot Set
12.8 From the Java Library: javax.swing.JComboBox

         Java Language Summary
          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              545
                                     546                             CHAPTER 12  Recursive Problem Solving

                                     12.1  Introduction

Figure 12.1: The Sierpinski gasket.  The pattern in Figure 12.1 is known as the Sierpinski gasket. Its overall
                                     shape is that of an equilateral triangle. But notice how inside the outer
                                     triangle there are three smaller triangles that are similar to the overall pat-
                                     tern. And inside each of those are three even smaller triangles, and so
                                     on. The Sierpinski gasket is known as a fractal because when you divide it
                                     up, you end up with a smaller version of the overall pattern. The overall
                                     gasket pattern is repeated over and over, at smaller and smaller scales,
                                     throughout the figure.

                                        How would you draw this pattern? If you try to use some kind of
                                     nested loop structure, you'll find that it is very challenging. It can be done
                                     using loops, but it isn't easy. On the other hand, if you use an approach
                                     known as recursion, this problem is much easier to solve. It's a little bit like
                                     the representation issue we discussed in Chapter 5. Your ability to solve
                                     a problem often depends on how you represent the problem. Recursion
                                     gives you another way to approach problems that involve repetition, such
                                     as the problem of drawing the Sierpinski gasket.

                                        The main goal of this chapter is to introduce recursion as both a
                                     problem-solving technique and as alternative to loops (which we dis-
                                     cussed in Chapter 6) for implementing repetition. We begin with the no-
                                     tion of a recursive definition, a concept used widely in mathematics and
                                     computer science. We then introduce the idea of a recursive method, which
                                     is the way recursion is implemented in a program.

                                        Recursion is a topic that is taken up in considerable detail in upper-
                                     level computer science courses, so our goal here is mainly to introduce
                                     the concept and give you some idea of its power as a problem-solving
                                     approach. To illustrate recursion, we use a number of simple examples
                                     throughout the chapter. One risk in using simple examples, though, is
                                     that you might be tempted to think that recursion is only good for "toy
                                     problems." Nothing could be further from the truth. Recursion is often
                                     used for some of the most difficult algorithms. Some of the exercises at
                                     the end of the chapter are examples of more challenging problems.

                                     12.1.1 Recursion as Repetition

Iterative method                     A recursive method is a method that calls itself. An iterative method is
Recursive method                     a method that uses a loop to repeat an action. In one sense, recursion is
                                     an alternative to the iterative (looping) control structures we studied in
                                     Chapter 6. In this sense, recursion is just another way to repeat an action.

                                        For example, consider the following iterative method for saying
                                     "Hello" N times:

                                                                                                                       

                                     public void h e l l o ( i n t N) {

                                           for ( int k = 0; k < N; k++)

                                           System . out . println ( "Hello" ) ;

                                     } // h e l l o ( )

                                                                                                                       

                                     A recursive version of this method would be defined as follows:
SECTION 12.1  Introduction                                                        547

                                                                                        
                                                                                        
public void h e l l o ( i n t N) {                                                      

  i f (N > 0 ) \ verb ! { !                                                             

  System . out . println ( "Hello" ) ;                                                   Computational overhead

  h e l l o (N - 1 ) ;                               // R e c u r s i v e c a l l

  } // h e l l o ( )


This method is recursive because it calls itself when N is greater than 0.
However, note that when it calls itself, it passes N - 1 as the value for its
parameter. If this method is initially called with N equal to 5, the follow-
ing is a trace of what happens. The indentations indicate each time the
method calls itself:



  hello (5)
         Print "Hello"
         hello (4)
                Print "Hello"
                hello (3)
                        Print "Hello"
                        hello (2)
                               Print "Hello"
                               hello (1)
                                      Print "Hello"
                                      hello (0)



Thus, "Hello" will be printed five times, just as it would be in the iterative
version of this method.

   So, in one sense, recursion is just an alternative to iteration. In fact,
there are some programming languages, such as the original versions of
LISP and PROLOG, that do not have loop structures. In these languages,
all repetition is done by recursion. In contrast, if a language contains
loop structures, it can do without recursion. Anything that can be done
iteratively can be done recursively, and vice versa.

   Moreover, it is much less efficient to call a method five times than to re-
peat a for loop five times. Method calls take up more memory than loops
and involve more computational overhead--for such tasks as passing pa-
rameters, allocating storage for the method's local variables, and return-
ing the method's results. Therefore, because of its reliance on repeated
method calls, recursion is often less efficient than iteration as a way to
code a particular algorithm.

JAVA EFFECTIVE DESIGN Efficiency. Iterative algorithms and
methods are generally more efficient than recursive algorithms that do
the same thing.
                 548                      CHAPTER 12  Recursive Problem Solving

                 SELF-STUDY EXERCISES

                 EXERCISE 12.1 What would be printed if we call the following method
                 with the expression mystery(0)?

                                                                                      

                 public void mystery ( i n t N) {

                      System . out . p r i n t (N + " " ) ;

                      i f (N <= 5 )

                      mystery (N + 1 ) ;

                 } // m y s t e r y ( )

                                                                                      

                 What about mystery(100)?

                 EXERCISE 12.2 What would be printed if we call the following method
                 with the expression mystery(5)?

                                                                                      

                 public void mystery ( i n t N) {

                      System . out . p r i n t (N + " " ) ;

                      i f (N <= 5 )

                      mystery (N - 1 ) ;

                 } // m y s t e r y ( )

                                                                                      

Subproblems      12.1.2 Recursion as a Problem-Solving Approach
Self-similarity
                 Given that recursion is not really necessary--if a programming language
                 has loops--and is not more efficient than loops, why is it so important?
                 The answer is that, in a broader sense, recursion is an effective approach
                 to problem solving. It is a way of viewing a problem. It is mostly in this
                 sense that we want to study recursion.

                    Recursion is based on two key problem-solving concepts: divide and
                 conquer and self-similarity. In recursive problem solving we use the
                 divide-and-conquer strategy repeatedly to break a big problem into a se-
                 quence of smaller and smaller problems until we arrive at a problem that
                 is practically trivial to solve.

                    What allows us to create this series of subproblems is that each sub-
                 problem is similar to the original problem--that is, each subproblem is
                 just a smaller version of the original problem. Look again at the task of
                 saying "Hello" N times. Solving this task involves solving the similar task
                 of saying "Hello" N -1 times, which can be divided into the similar task of
                 saying "Hello" N - 2 times. And so on.

                    The ability to see a problem as being composed of smaller, self-similar
                 problems is at the heart of the recursive approach. And although you
                 might not have thought about this before, a surprising number of pro-
                 gramming problems have this self-similarity characteristic. Let's illustrate
                 these ideas with some simple examples.

                   JAVA PROGRAMMING TIP Divide and Conquer. Many
                   programming problems can be solved by dividing them into smaller,
                   simpler problems. For recursive solutions, finding the key to the
                   subproblem often holds the solution to the original problem.
SECTION 12.2  Recursive Definition                           549

12.2 Recursive Definition

One place you might have already seen recursion is in mathematics. A
recursive definition consists of two parts: a recursive part in which the
nth value is defined in terms of the (n - 1)st value, and a nonrecursive,
boundary or base case, which defines a limiting condition.

12.2.1 Factorial: N!

For example, consider the problem of calculating the factorial of n--that
is, n! for n  0. As you may recall, n! is calculated as follows:

                                                                             

n ! = n  (n-1)  (n-2)  . . .  1 , for n > 0                                  


In addition, 0! is defined as 1. Let's now look at some examples for
different values of n:

                                                                             

4! = 4  3  2  1 = 24

3! = 3  2  1 = 6

2! = 2  1 = 2

1! = 1

0! = 1                                                                       


As these examples suggest, n! can always be calculated in terms of (n - 1)!
This relationship might be clearer if we rewrite the previous calculations
as follows:

                                                                             

4! = 4  3  2  1 = 4  3! = 24

3! = 3  2  1          = 3  2! = 6

2! = 2  1             = 2  1! = 2

1!                    = 1  0! = 1

0!                    =1                                                     


The only case in which we can't calculate n! in terms of (n - 1)! is when n
is 0. Otherwise, in each case we see that

                                                                             

n! = n  (n-1)!
                                                                             

This leads to the following recursive definition:

                                                                             

n! = 1          if n = 0  // Boundary ( or b a s e ) c a s e

n! = n  (n-1)! if n > 0   // R e c u r s i v e c a s e

                                                                             

Note that if we had omitted the base case, the recursion would have
continued to (-1)! and (-2)! and so on.

JAVA DEBUGGING TIP Bounding the Repetition. An infinite
repetition will result if a recursive definition is not properly bounded.

The recursive case uses divide and conquer to break the problem into a
smaller problem, but the smaller problem is just a smaller version of the
                                 550          CHAPTER 12  Recursive Problem Solving

                                 original problem. This combination of self-similarity and divide and con-
                                 quer is what characterizes recursion. The base case is used to stop or limit
                                 the recursion.

                                 JAVA EFFECTIVE DESIGN Recursive Definition. For recursive
                                 algorithms and definitions, the base case serves as the bound for the
                                 algorithm. The recursive case defines the nth case in terms of the
                                 (n - 1)st case.

                                 12.2.2 Drawing a Nested Pattern

                                 As another example, consider the problem of drawing the nested boxes
                                 pattern in Figure 12.2. The self-similarity occurs in the fact that for this
                                 pattern, its parts resemble the whole. The basic shape involved is a square,
                                 which is repeated over and over at an ever-smaller scale. A recursive
                                 definition for this pattern would be

                                                                                                               

                                 Base case :  i f s i d e < 5 do nothing

Figure 12.2: The nested squares  R e c u r s i v e c a s e : i f s i d e >= 5
pattern.
                                              draw a square

                                              decrease the s i d e and draw a s m a l l e r

                                                                               pattern inside the square       

                                 This definition uses the length of the square's side to help define the pat-
                                 tern. If the length of the side is greater than or equal to 5, draw a square
                                 with dimensions sideside. Then decrease the length of the side and draw
                                 a smaller version of the pattern inside that square. In this case, the side
                                 variable will decrease at each level of the drawing. When the length of the
                                 side becomes less than 5, the recursion stops. Thus, the length of the side
                                 serves as the limit or bound for this algorithm.

                                    You should note that the length of the side functions here like a param-
                                 eter in a method definition: It provides essential information for the defi-
                                 nition, just as a method parameter provides essential data to the method.
                                 Indeed, this is exactly the role that parameters play in recursive meth-
                                 ods. They provide essential information that determines the method's
                                 behavior.
SECTION 12.3  Recursive String Methods                           551

   Figure 12.3 illustrates how we would apply the definition. Suppose the                            20
side starts out at 20 and decreases by 5 at each level of recursion. Note that
as you move from top to bottom across the four patterns, each pattern                 20
contains the one below it. A nestedBoxes(20) can be drawn by first                          nestedBoxes(20)
drawing a 20  20 square and then drawing a nestedBoxes(15) pattern                                  15
inside it. Similarly, a nestedBoxes(15) can be drawn by first drawing a
15  15 square and then drawing a nestedBoxes(10) pattern inside it.                    15
And so on.                                                                                  nestedBoxes(15)

   These examples illustrate the power of recursion as a problem-solving
technique for situations that involve repetition. Like the iterative (looping)
control structures we studied in Chapter 6, recursion is used to implement
repetition within a bound. For recursive algorithms, the bound is defined
by the base case, whereas for loops, the bound is defined by the loop's
entry condition. In either case, repetition stops when the bound is reached.

SELF-STUDY EXERCISES                                                                            10
                                                                                      10
EXERCISE 12.3 You can calculate 2n by multiplying 2 by itself n times.                nestedBoxes(10)
For example, 23 is 2  2  2. Note also that 20 = 1. Given these facts, write
a recursive definition for 2n, for n  0.                                                        5

EXERCISE 12.4 Generalize your solution to the previous exercise by
giving a recursive definition for xn, where x and n are both integers  0.

EXERCISE 12.5 Is the recursive definition given earlier for the nested                    5
                                                                                      nestedBoxes(5)
boxes equivalent to the following recursive definition? Explain.

                                                                  

Draw a square .  // i n e v e r y c a s e

If side > 5                                                                           Figure 12.3: A trace of the nested
                                                                                      boxes definition starting with a
  draw a s m a l l e r nested boxes i n s i d e the square                           side of 20 and decreasing the side
                                                                                      by 5 each time.
In this case, the base case (side <= 5) is implicit.

EXERCISE 12.6 Write a recursive definition for the recursive pattern
shown in Figure 12.4.

  JAVA DEBUGGING TIP Infinite Recursion. An unbounded or
  incorrectly bounded recursive algorithm will lead to infinite
  repetition. Care must be taken to get the bound right.

12.3 Recursive String Methods

Remember that a recursive method is a method that calls itself. Like re-
cursive definitions, recursive methods are designed around the divide-
and-conquer and self-similarity principles. Defining a recursive method
involves a similar analysis to the one we used in designing recursive defi-
nitions. We identify a self-similar subproblem of the original problem plus
one or more limiting cases.

   The idea of a method calling itself seems a bit strange at first. It's per-
haps best understood in terms of a clone or a copy. When a method calls
itself, it really calls a copy of itself, one that has a slightly different internal

                                                                                      Figure 12.4: Write a recursive def-
                                                                                      inition for this pattern.
                               552                             CHAPTER 12  Recursive Problem Solving

How can a method call itself?  state. Usually the difference in state is the result of a difference in the
Head-and-tail algorithm        invoked method's parameters.

Recursive call                 12.3.1 Printing a String

                               To illustrate the concept of a recursive method, let's define a recursive
                               method for printing a string. This is not intended to be a practical
                               method--we already have the println() method for printing strings.
                               But pretend for a moment that you only have a version of println()
                               that works for characters, and your task is to write a version that can be
                               used to print an entire string of characters.

                                  A little terminology will help us describe the algorithm. Let's call the
                               first letter of a string the head of the string, and let's refer to all the remain-
                               ing letters in the string as the tail of the string. Then the problem of print-
                               ing a string can be solved using a head-and-tail algorithm, which consists
                               of two parts: printing the head of the string and recursively printing its
                               tail. The limiting case here is when a string has no characters in it. It's
                               trivial to print the empty string--there is nothing to print! This leads to
                               the method definition shown in Figure 12.5.

                                                                                                              

                                 / 

                                  printString () prints each character of the string s

                                  Pre : s i s i n i t i a l i z e d ( non - n u l l )

                                  Post : none

                                 /

                               public void printString ( String s ) {

                                     i f ( s . l e n g t h ( ) == 0 )

                                        return ;                       // B a s e c a s e : do n o t h i n g

                                     else {                    // R e c u r s i v e c a s e :

                                        System . out . print ( s . charAt ( 0 ) ) ; // P r i n t head

                                        printString ( s . substring ( 1 ) ) ; // P r i n t t a i l

                                     }

                               } // p r i n t S t r i n g ( )

                                                                                                              

                                        Figure 12.5: The recursive printString() method.

                                  The base case here provides a limit and bounds the recursion when the
                               length of s is 0--that is, when the string is empty. The recursive case solves
                               the problem of printing s by solving the smaller, self-similar problem of
                               printing a substring of s. Note that the recursive case makes progress to-
                               ward the limit. On each recursion, the tail will get smaller and smaller
                               until it becomes the empty string.

                                 JAVA EFFECTIVE DESIGN Recursive Progress. In a recursive
                                 algorithm, each recursive call must make progress toward the bound,
                                 or base case.

                               Let's now revisit the notion of a method calling itself. Obviously this is
                               what happens in the recursive case, but what does it mean--what actions
                               does this lead to in the program? Each recursive call to a method is really a
                               call to a copy of that method, and each copy has a slightly different internal
                               state. We can define printString()'s internal state completely in terms
SECTION 12.3  Recursive String Methods                   553

of its recursion parameter, s, which is the string that's being printed. A
recursion parameter is a parameter whose value is used to control the
progress of the recursion. In this case, if s differs in each copy, then so will
s.substring(1) and s.charAt(0).

JAVA EFFECTIVE DESIGN Recursion and Parameters. Recursive
methods use a recursion parameter to distinguish between self-similar
instances of the method call. The parameter controls the progress of
the recursion toward its bound.

   Figure 12.6 illustrates the sequence of recursive method calls and the
output that results when printString("hello") is invoked. Each box

 printString("hello")                    Output Produced                          Figure 12.6: A recursive method
                                                hello                             call invokes a copy of the method,
printString("hello")                                                              each with a slightly different in-
System.out.print('h');                                                            ternal state. As this is done re-
printString("ello");                                                              peatedly, a stack of method calls
                                                                                  is created.

printString("ello")

System.out.print('e');
printString("llo");

printString("llo")

System.out.print('l');
printString("lo");

printString("lo")

System.out.print('l');
printString("o");

printString("o")

System.out.print('o');
printString("");

Base  printString("")
case  return;

represents a separate instance of the printString() method, with its              Self-similar instances
own internal state. In this illustration, its state is represented by its pa-
rameter, s. Because each instance has a different parameter, behaviors
differ slightly. Each box shows the character that will be printed by that
                           554  CHAPTER 12  Recursive Problem Solving

                           instance (s.charAt(0)), and the string that will be passed on to the next
                           instance (s.substring(1)).

                           JAVA DEBUGGING TIP Off-by-One Error. The expressions
                           s.charAt(0) and s.substring(1) will generate exceptions if s is
                           the empty string.

Progress toward the bound  The arrows represent the method calls and returns. Note that the first
Self-similarity            return executed is the one in the base case. Each instance of the method
                           must wait for the instance it called to return before it can return. That's
                           why the instances "pile up" in a cascade-like structure. The arrowless
                           lines trace the order in which the output is produced.

                              Each instance of printString() is similar to the next in that each
                           will print one character and then pass on a substring, but each performs
                           its duties on a different string. Note how the string, the recursion param-
                           eter in this case, gets smaller in each instance of printString(). This
                           represents progress toward the method's base case s.length() == 0.
                           When the empty string is passed as an argument, the recursion will stop.
                           If the method does not make progress toward its bound in this way, the
                           result will be an infinite recursion.

                            JAVA EFFECTIVE DESIGN Bounding the Recursion. For recursive
                            algorithms, the recursion parameter is used to express the algorithm's
                            bound or base case. In order for the algorithm to terminate, each
                            recursive call should make progress toward the bound.

                           Note also the order in which things are done in this method. First
                           s.charAt(0) is printed, and then s.substring(1) is passed to
                           printString() in the recursion. This is a typical structure for a head-
                           and-tail algorithm. What makes this work is that the tail is a smaller,
                           self-similar version of the original structure.

                            JAVA EFFECTIVE DESIGN Head-and-Tail Algorithm. Many
                            recursive solutions involve breaking a sequential structure, such as a
                            string or an array, into its head and tail. An operation is performed on
                            the head, and the algorithm recurses on the tail.
SECTION 12.3  Recursive String Methods                                                               555

SELF-STUDY EXERCISE

EXERCISE 12.7 What would be printed by the following version of the
printString2() method, if it is called with printString2("hello")?

                                                                                                      

public void printString2 ( String s ) {                 // B a s e c a s e :
  i f ( s . l e n g t h ( ) == 1 )
     System . out . print ( s . charAt ( 0 ) ) ;
 else {

                                                          // P r i n t l a s t c h a r

  System . out . print ( s . charAt ( s . length ( ) - 1 ) ) ;

                                                          // P r i n t r e s t o f s t r i n g

   printString2 ( s . substring (0 , s . length () - 1));
}

} // p r i n t S t r i n g 2 ( )

                                                                                                      

12.3.2 Printing the String Backward

What do you suppose would happen if we reversed the order of the state-

ments in the printString() method? That is, what if the recursive call

came before s.charAt(0) is printed, as in the following method:

                                                                                                           

  / 

   printReverse () prints each character s in reverse order

   Pre : s i s i n i t i a l i z e d ( non - n u l l )

   Post : none

  /

  public void printReverse ( String s ) {

  if ( s . length () > 0) {         // R e c u r s i v e c a s e :

      printReverse ( s . substring ( 1 ) ) ; // P r i n t t a i l

      System . out . print ( s . charAt ( 0 ) ) ; // P r i n t f i r s t                        char

  }

  } // p r i n t R e v e r s e ( )

                                                                                                           

As its name suggests, this method will print the string in reverse                                         Last-in-first-out protocol
order. The trace in Figure 12.7 shows how this works. Before
printReverse("hello") can print h, it calls printReverse("ello")
and must wait for that call to complete its execution and return. But
printReverse("ello") calls printReverse("llo") and so must
wait for that call to complete its execution and return.

   This process continues until printReverse("") is called. While the
base case is executing, the other five instances of printReverse() must
each wait for the instance that they called to complete its execution. It
is only after the base case returns, that printReverse("o") can print
its first character and return. So the letter o will be printed first. After
printReverse("o") has returned, then printReverse("lo") can
print its first character. So the letter l will be printed next, and so on, until
the original call to printReverse("hello") is completed and returns.
Thus, the string will be printed in reverse order.

   Note that the method call and return structure in this example follows a
last-in-first-out (LIFO) protocol. That is, the last method called is always
                                   556                            CHAPTER 12  Recursive Problem Solving

Figure 12.7: A trace of print-             printReverse("hello")
Reverse(s), which prints its
string argument in reverse order.         printReverse("hello")
                                          printReverse("ello");
                                          System.out.print('h');

                                   printReverse("ello")

                                   printString("llo");
                                   System.out.print('e');

                                   printReverse("llo")

                                   printReverse("lo");
                                   System.out.print('l');

                                   printReverse("lo")

                                   printReverse("o");
                                   System.out.print('l');

                                   printReverse("o")

                                   printReverse("");
                                   System.out.print('o');

                                   Base  printReverse("")               olleh
                                   case  return;                  Output produced

Method call stack                  the first method to return. This is the protocol used by all method calls,
                                   recursive or otherwise.

                                    JAVA LANGUAGE RULE LIFO. All programming languages,
                                    including Java, use a last-in-first-out protocol for procedure call and
                                    return.

                                   For example, compare the order in which things happen in Figure 12.7
                                   with the method stack trace in Figure 10.12. The only real difference
                                   between the two figures is that here the method stack is represented as
                                   growing downward, whereas in Figure 10.12 it grows upward. As each
                                   method call is made, a representation of the method call is placed on the
                                   method call stack. When a method returns, its block is removed from the
                                   top of the stack. The only difference between recursive and nonrecursive
                                   method calls is that recursive methods call instances of the same method
                                   definition. Of course, as we've seen, the instances are all slightly different
                                   from each other.
SECTION 12.3  Recursive String Methods                           557

SELF-STUDY EXERCISES

EXERCISE 12.8 Write a recursive method called countDown() that
takes a single int parameter, N  0, and prints a countdown, such as
"5, 4, 3, 2, 1, blastoff." In this case, the method would be called with
countDown(5).

EXERCISE 12.9 Revise the method in the previous exercise so that
when it's called with countDown(10), it will print "10 8 6 4 2 blastoff";
if it's called with countDown(9), it prints "9 7 5 3 1 blastoff."

12.3.3 Counting Characters in a String

Suppose you're writing an encryption program and you need to count the         Problem statement
frequencies of the letters of the alphabet. Let's write a recursive method
for this task.

   This method will have two parameters: a String to store the string
that will be processed and a char to store the target character--the one
we want to count. The method should return an int, representing the
number of occurrences of the target character in the string:

                                                                               

  // Goal : c o u n t t h e o c c u r r e n c e s o f ch i n s

  public int countChar ( String s , char ch ) {

   ...

}

                                                                               

   Here again our analysis must identify a recursive step that breaks the      Base case
problem into smaller, self-similar versions of itself, plus a base case or     Recursive case
limiting case that defines the end of the recursive process. Because the
empty string will contain no target characters, we can use it as our base
case. So, if it is passed the empty string, countChar() should just return
0 as its result.

   For the recursive case, we can divide the string into its head and tail.
If the head is the target character, then the number of occurrences in the
string is (1 + the number of occurrences in its tail). If the head of the
string is not the target character, then the number of occurrences is (0 +
the number of occurrences in its tail). Of course, we'll use recursion to
calculate the number of occurrences in the tail.

   This analysis leads to the recursive method shown in Figure 12.8. Note
that for both recursive cases the same recursive call is used. In both cases
we pass the tail of the original string, plus the target character. Note also
how the return statement is evaluated:

                                                                               

return 1 + countChar ( s . substring ( 1 ) , ch ) ; // Head = ch
                                                                               

Before the method can return a value, it must receive the result of call-
ing countChar(s.substring(1),ch) and add it to 1. Only then can Evaluation order is crucial
                             558                                CHAPTER 12  Recursive Problem Solving
                                                                                                                         

                              / 

                               Pre : s i s a non - n u l l S t r i n g , ch i s any c h a r a c t e r

                               P o s t : c o u n t C h a r ( ) == t h e number o f o c c u r r e n c e s o f ch i n s t r

                              /

                            public int countChar ( String s , char ch ) {

                              i f ( s . l e n g t h ( ) == 0 )  // B a s e c a s e : empty s t r i n g

                                  return 0;

                              e l s e i f ( s . charAt ( 0 ) == ch ) // R e c u r s i v e c a s e 1

                                  return 1 + countChar ( s . substring ( 1 ) , ch ) ; // Head = ch

                              else                                   // R e c u r s i v e c a s e 2

                                  return 0 + countChar ( s . substring ( 1 ) , ch ) ; // Head ! = ch

                            } // c o u n t C h a r ( )

                                                                                                        

                                    Figure 12.8: The recursive countChar() method.

                            a result be returned to the calling method. This leads to the following
                            evaluation sequence for countChar("dad",'d'):

                                                                                                        

                              countChar ( "dad" , 'd ' ) ;

                              1 + countChar ( "ad" , 'd ' ) ;

                              1 + 0 + countChar ( "d" , 'd ' ) ;

                              1 + 0 + 1 + countChar ( "" , 'd ' ) ;

                              1+0+1+0=2                                  // F i n a l r e s u l t
                            
                                                                                                                      

                            In this way, the final result of calling countChar("dad",'d') is built
                            up recursively by adding together the partial results from each separate
                            instance of countChar(). The evaluation process is shown graphically
                            in Figure 12.9.

Figure 12.9: A trace of             countChar("dad",'d');                      Result
countChar("dad",'d'),                                                    1+ 0 + 1 + 0 = 2
which returns the value 2.
                                                                               0 + 1 + 0
                                    countChar("dad",'d');                           1 + 0
                                    return 1 + countChar("ad",'d');
                                                                                        0
                                    countChar("ad",'d');
                                    return 0 + countChar("d",'d');

                                          countChar("d",'d');
                                          return 1 + countChar("",'d');

                                    Base     countChar("",'d');
                                    case     return 0;
SECTION 12.3  Recursive String Methods                                 559

JAVA DEBUGGING TIP Return Type. A common error with
nonvoid recursive algorithms is forgetting to make sure that those
return statements that contain a recursive call yield the correct data
type.

SELF-STUDY EXERCISE

EXERCISE 12.10 Here's a numerical problem. Write a recursive
method to compute the sum of 1 to N, given N as a parameter.

12.3.4 Translating a String

A widely used string-processing task is to convert one string into another      Problem statement
string by replacing one character with a substitute throughout the string.     
For example, suppose we want to convert a Unix path name, which uses           
the forward slash "/" to separate one part of the path from another, into a
Windows path name, which uses the backslash character "\" as a separa-          Method design
tor. For example, we want a method that can translate the following two
strings into one another:                                                       Head-and-tail algorithm

 

    /unix system/myfolder/java
    \Windows system\myfolder\ java
 

   Thus, we want a method that takes three parameters: a String, on
which the conversion will be performed, and two char variables, the first
being the original character in the string and the second being its substi-
tute. The precondition for this method is simply that each of these three
parameters has been properly initialized with a value. The postcondi-
tion is that all occurrences of the first character have been replaced by the
second character.

   As in our previous string-processing methods, the limiting case in this
problem is the empty string, and the recursive case will divide the string
into its head and its tail. If the head is the character we want to replace,
we concatenate its substitute with the result we obtain by recursively
converting its tail.

   This analysis leads to the definition shown in Figure 12.10. This method
has more or less the same head and tail structure as the preceding exam-
ple. The difference is that here the operation we perform on the head of
the string is concatenation rather than addition.

   The base case is still the case in which str is the empty string. The
first recursive case occurs when the character being replaced is the head
of str. In that case, its substitute (ch2) is concatenated with the result
of converting the rest of the string and returned as the result. The second
recursive case occurs when the head of the string is not the character be-
ing replaced. In this case, the head of the string is simply concatenated
with the result of converting the rest of the string. Figure 12.11 shows an
example of its execution.
            560                                       CHAPTER 12  Recursive Problem Solving
                                                                                                               

  / 

   Pre : str , ch1 , ch2 have been i n i t i a l i z e d

   Post : the r e s u l t contains a ch2 everywhere that ch1

                          had occurred in s t r

  /

public s t a t i c String convert ( String str , char ch1 , char ch2 ) {

  i f ( s t r . l e n g t h ( ) == 0 )                         // B a s e c a s e : empty s t r i n g

    return str ;

  e l s e i f ( s t r . charAt ( 0 ) == ch1 ) // R e c u r s i v e 1 : c h 1 a t h e a d

                                                               // R e p l a c e ch1 w i t h ch2

    return ch2 + convert ( s t r . substring ( 1 ) , ch1 , ch2 ) ;

  else                                             // R e c u r s i v e 2 : ch1 n o t a t head

    return s t r . charAt ( 0 ) + convert ( s t r . substring ( 1 ) , ch1 , ch2 ) ;

} // c o n v e r t ( )

                                                                                                       

                          Figure 12.10: The convert() method replaces one character with another
                          in a string.

Figure 12.11: A trace of  convert("bad",'d','m');                              Result
convert("bad",'d','m'),   convert("bad",'d','m');              'b' + 'a' + 'm' + "" = "bam"
which returns "bam."

                          return 'b' + convert("ad",'d','m');

                                                               'a' + 'm' + ""

                          convert("ad",'d','m');
                          return 'a' + convert("d",'d','m');

                                                               'm' + ""

                          convert("d",'d','m');
                          return 'm' + convert("",'d','m');

                                                                    ""

                          Base  convert("",'d','m');
                          case  return "";

                          SELF-STUDY EXERCISE

                          EXERCISE 12.11 Write a recursive method that changes each blank
                          in a string into two consecutive blanks, leaving the rest of the string
                          unchanged.

                          12.3.5 Printing all Possible Outcomes when Tossing N
                                    Coins

                          Suppose that a student who is studying probability wishes to have a Java
                          program that, for any positive integer N, will print out a list of all possible
                          outcomes when N coins are tossed. For purposes of analyzing the prob-
                          lem, it is assumed that the coins are numbered 1 through N and that they
                          are tossed one at a time. An outcome will be represented by a string of
SECTION 12.3  Recursive String Methods  561

Hs and Ts corresponding to heads and tails. Thus, if N = 2, the string HT      A coin tossing experiment
represents a head on the first coin and a tail on the second coin. What we    
need is a method which, when given the number of coins, will print out        
all strings of this type. In case of two coins the output should be:
                                                                               Designing a recursive algorithm
 
                                                                              
   HH                                                                         
   HT
   TH                                                                         
    TT                                                                        
 

   Let's devise a strategy, given any positive integer N, for printing the
strings that correspond to all possible outcomes when tossing N coins.
Clearly, for N = 1, the method needs to print an H on one line and a T on
the next line. For an arbitrary number of coins N, one way to generate all
outcomes is to think of two kinds of strings--those that start with an H and
those that start with a T. The strings that start with H can be generated by
inserting an H in front of each of the outcomes that occur when N - 1 coins
are tossed. The strings beginning with T can be generated in a similar
manner. Thus, using the outcomes for two coins above, we know that the
outcomes for three coins for which the first coin is H are:

 

   HHH
   HHT
   HTH
   HTT
 

   Using an argument similar to the one above, we can generalize this to a
description of the recursive case for an algorithm. We want an algorithm
that generates all those outcomes for N coins where we are given a string
STR representing one particular outcome for all but the last K coins where
0 < K <= N. To print out all such outcomes, just print all outcomes with a
fixed outcome corresponding to STR + "H" for all but the last K - 1 coins
and then print all outcomes with the fixed outcome STR + "T" for all but
the last K - 1 coins. The base case is the special case K = 1 when you just
need STR + "H" on one line and STR + "T" on the next. If you start the
algorithm with STR = "" and K = N, this algorithm will print out all the
outcomes for tossing N coins.

   To translate this into Java code we can create a class called Coin-
Toss which has a single static method called printOutcomes(String
str,int N). The above recursive description easily translates into code
for the method in Figure 12.12.

   To print out all outcomes when tossing, say, seven coins, just make the
method call CoinToss.printOutcomes("",7). This particular call
would generate the desired output:

 

   HHHHHHH
   HHHHHHT
    .......
   TTTTTTH
    TTTTTTT
 
                             562                               CHAPTER 12  Recursive Problem Solving
                                                                                                                        

                              / 

                               printOutcomes ( str , N) prints out a l l possible outcomes

                               b e g i n n i n g with s t r when N more c o i n s a r e t o s s e d .

                               P r e : s t r i s a s t r i n g o f Hs and Ts .

                               Pre : N is a positive integer .

                               Post : none

                              /

                              public s t a t i c void printOutcomes ( S t r i n g s t r , i n t N) {
                                     i f (N == 1 ) { // T h e b a s e c a s e
                                            System . out . p r i n t l n ( s t r + "H" ) ;
                                            System . out . println ( s t r + "T" ) ;
                                     } else { // The r e c u r s i v e c a s e
                                            printOutcomes ( s t r + "H" , N - 1 ) ;
                                            printOutcomes ( s t r + "T" , N - 1 ) ;
                                     } // e l s e

                            }// p r i n t O u t c o m e s ( )

                                                                                                       

                            Figure 12.12: The method printOutcomes() prints all outcomes given
                            the results on some initial coins.

                            To better understand how the recursive method definition generates its
                            output, it might be helpful to trace the order of recursive calls and output
                            to System.out that occurs when executing printOutcomes("",3) as
                            shown in Figure 12.13.

                               Notice that the recursive case in the method implementation makes two
                            calls to itself and as a result it is not so clear how this method would be
                            written using a loop instead of recursion. This example is more typical of
                            the type of problem for which a recursive method is shorter and clearer
                            than a method that solves the same problem without using recursion.

Figure 12.13: The order in

which the recursive calls   SELF-STUDY EXERCISE

and output occur when

printOutcomes("",3)  is

executed.

                            EXERCISE 12.12 Modify the above printOutcomes() method so
                            that it will print out all possible outcomes when a chess player plays a
                            series of N games. The outcome of each game is to be represented by a W,
                            L, or D corresponding to the player winning, losing, or drawing the game.
SECTION 12.4  Recursive Array Processing                                       563

12.4 Recursive Array Processing

Like strings, arrays also have a recursive structure. Just as each substring            6 8 1 0 10 15 2 32 7 71
of a string is similar to the string as a whole, each portion of an array is
similar to the array as a whole. Similarly, just as a string can be divided          Head            Tail
into a head and a tail, an array can be divided into its head, the first ele-
ment, and its tail, the rest of its elements (Fig. 12.14). Because the tail of an    Figure 12.14: An array of int is
array is itself an array, it satisfies the self-similarity principle. Therefore,     a recursive structure whose tail is
arrays have all the appropriate characteristics that make them excellent             similar to the array as a whole.
candidates for recursive processing.

12.4.1 Recursive Sequential Search

Let's start by developing a recursive version of the sequential search al-            Method design
gorithm that we discussed in Chapter 9. Recall that the sequential search            
method takes two parameters: the array being searched and the key, or
target value, being searched for. If the key is found in the array, the
method returns its index. If the key is not found, the method returns
-1, thereby indicating that the key was not contained in the array. The
iterative version of this method has the following general form:

 

   / 

    Performs a s e q u e n t i a l s e a r c h of an i n t e g e r array

    @param a r r i s the a r r a y of i n t e g e r s

    @param key i s the element being s e a r c h e d f o r

    @return the key ' s index is returned i f the key is

    f o u n d o t h e r w i s e -1 i s r e t u r n e d

    Pre : arr is not null

    P o s t : e i t h e r -1 o r t h e k e y ' s i n d e x i s r e t u r n e d

   /

public int sequentialSearch ( int arr [ ] , int key ) {

       return -1;          // f a i l u r e i f t h i s i s r e a c h e d

}

                                                                                     

If we divide the array into its head and tail, then one way to describe a

recursive search algorithm is as follows:

                                                                                     

I f t h e a r r a y i s empty , r e t u r n -1

I f the array ' s head matches the key , return i t s index

I f the array ' s head doesn ' t match the key ,

   return the result of searching the tail of the array                              

This algorithm clearly resembles the approach we used in recursive string            How do we represent head and tail?
processing: Perform some operation on the head of the array and recurse
on the tail of the array.

   The challenge in developing this algorithm is not so much knowing
what to do but knowing how to represent concepts like the head and the
tail of the array. For strings, we had methods such as s.charAt(0) to
represent the head of the string and s.substring(1) to represent the
string's tail. For an array named arr, the expression arr[0] represents
the head of the array. Unfortunately, we have no method comparable to
                                  564              CHAPTER 12  Recursive Problem Solving

                                  the substring() method for strings that lets us represent the tail of the
                                  array.

                                     To help us out of this dilemma, we can use an integer parameter to rep-
                                  resent the head of the array. Let's have the int parameter, head, represent
                                  the current head of the array (Fig. 12.15). Then head +1 represents the start
                                  of the tail, and arr.length-1 represents the end of the tail. Our method
                                  will always be passed a reference to the whole array, but it will restrict the
                                  search to the portion of the array starting at head. If we let head vary from
                                  0 to arr.length on each recursive call, the method will recurse through
                                  the array in head/tail fashion, searching for the key. The method will stop
                                  when head = arr.length.

Figure 12.15: A parameter, head,       0                       N-1
can represent the head of some
portion of the array.                  6 8 1 0 10 15 2 32 7 71 First call

                                       Head        Tail

                                       6 8 1 0 10 15 2 32 7 71 Second call

                                          Head     Tail

                                       6 8 1 0 10 15 2 32 7 71 Third call

                                             Head        Tail

                                       0                       N-1

                                       6 8 1 0 10 15 2 32 7 71 Last call

                                                               Head

Recursion parameter                JAVA PROGRAMMING TIP Subarray Parameter. For methods that
                                   take an array argument, an int parameter can be used to designate
                                   the portion of the array that should be processed in the method.

                                     This leads to the definition for recursive search shown in Figure 12.16.
                                  Note that the recursive search method takes three parameters: the array
                                  to be searched, arr, the key being sought, and an integer head that gives
                                  the starting location for the search. The algorithm is bounded when head
                                  = arr.length. In effect, this is like saying the recursion should stop
                                  when we have reached a tail that contains 0 elements. This underscores
                                  the point we made earlier about the importance of parameters in design-
                                  ing recursive methods. Here the head parameter serves as the recursion
                                  parameter. It controls the progress of the recursion.

                                     Note also that for the search algorithm we need two base cases. One
                                  represents the successful case, where the key is found in the array. The
                                  other represents the unsuccessful case, which comes about after we have
                                  looked at every possible head in the array and not found the key. This
   SECTION 12.4  Recursive Array Processing                                             565
                                                                                           

   / 

    s e a r c h ( a r r , head , key )--- R e c u r s i v e l y s e a r c h a r r f o r key

    s t a r t i n g at head

    P r e : a r r ! = n u l l a n d 0 <= h e a d <= a r r . l e n g t h

    P o s t : i f a r r [ k ] = = k e y f o r k , 0 <= k < a r r . l e n g t h ,

         r e t u r n k e l s e r e t u r n -1

   /

private int search ( int arr [ ] , int head , int key ) {

   i f ( head == a r r . l e n g t h ) // B a s e : e m p t y l i s t - f a i l u r e

   return -1;

   e l s e i f ( a r r [ head ] == key ) // B a s e : k e y f o u n d --- s u c c e s s

   return head ;

   else           // R e c u r s i v e : s e a r c h t h e t a i l

   return search ( arr , head + 1 , key ) ;

}

                                                                                             

Figure 12.16: The recursive search method takes three parameters. The
head parameter points to the beginning of that portion of the array that is
being searched.

case will arise through exhaustion--that is, when we have exhausted all
possible locations for the key.

   JAVA DEBUGGING TIP Recursive Search. For the recursive search
   method to work properly, it must be called with the correct value for
   the head parameter.

12.4.2 Information Hiding                                                                       Design issue
                                                                                                Hide implementation details
Note that in order to use the search() method, you would have to know
that you must supply a value of 0 as the argument for the head parameter.
This is not only awkward but also impractical. After all, if we want to
search an array, we just want to pass two arguments, the array and the
key we're searching for. It's unreasonable to expect users of a method to
know that they also have to pass 0 as the head in order to get the recursion
started. This design is also prone to error, because it's quite easy for a
mistake to be made when the method is called.

   For this reason, it is customary to provide a nonrecursive interface to
the recursive method. The interface hides the fact that a recursive algo-
rithm is being used, but this is exactly the kind of implementation detail
that should be hidden from the user. This is an example of the principle
of information hiding that we introduced in Chapter 0. A more appropri-
ate design would make the recursive method a private method that's
called by the public method, as shown Figure 12.17 and implemented in
the Searcher class (Fig. 12.18).
                                                 566                  CHAPTER 12  Recursive Problem Solving
Figure 12.17: The public
search() method serves as                                                         Searcher
an interface to the private recur-
sive method, search(). Note                           +search(in arr[] : int, in key : int) : int
that the methods have different                       -search(in arr[] : int, in head : int, in key : int) : int
signatures.

                                                                                                                                        

public class Searcher {

  / 

   s e a r c h ( a r r , k e y ) -- s e a r c h e s a r r f o r k e y .

   P r e : a r r ! = n u l l a n d 0 <= h e a d <= a r r . l e n g t h

   P o s t : i f a r r [ k ] == k e y f o r k , 0 <= k < a r r . l e n g t h ,

                                                      r e t u r n k , e l s e r e t u r n -1

    /                                                                         key )           {          search

  public int search ( int arr [] , int                                        Call            recursive
     return search ( arr , 0 , key ) ; //

  }

  / 

   s e a r c h ( a r r , h e a d , k e y ) -- R e c u r s i v e l y s e a r c h a r r f o r k e y

   s t a r t i n g at head

   P r e : a r r ! = n u l l a n d 0 <= h e a d <= a r r . l e n g t h

   P o s t : i f a r r [ k ] == k e y f o r k , 0 <= k < a r r . l e n g t h , r e t u r n k

                                                      e l s e r e t u r n -1

  /

  private int search ( int arr [ ] , int head , int key ) {

    i f ( head == a r r . l e n g t h ) // B a s e c a s e : e m p t y l i s t - f a i l u r e

      return -1;

    e l s e i f ( a r r [ head ] == key ) // B a s e c a s e : k e y f o u n d -- s u c c e s s

      return head ;

    else                                                                      // R e c u r s i v e c a s e : s e a r c h t h e t a i l

          return search ( arr , head + 1 , key ) ;

  } // s e a r c h ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

    int numbers [ ] = {0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18};

    S e a r c h e r s e a r c h e r = new S e a r c h e r ( ) ;

    f o r ( i n t k = 0 ; k <= 2 0 ; k++) {

          i nt r e s u l t = searcher . search ( numbers , k ) ;

          i f ( r e s u l t != -1)

                                                      System . out . println ( k + " found at " + re su l t ) ;

          else

                                                      System . out . println (k + " i s not in the array " ) ;

    } // f o r

  } // main ( )

} // S e a r c h e r

                                                                                                                                        

      Figure 12.18: Information hiding principle: The public search()
      method calls the private, recursive search(), thereby hiding the fact
      that a recursive algorithm is used.

          JAVA EFFECTIVE DESIGN Information Hiding. Unnecessary
          implementation details, such as whether a method uses a recursive or
          iterative algorithm, should be hidden within the class. Users of a class
          or method should be shown only those details that they need to know.
SECTION 12.4  Recursive Array Processing                       567

SELF-STUDY EXERCISE                                                             Sorting a deck of cards

EXERCISE 12.13 Write a main() method for the Searcher class to
conduct the following test of search(). Create an int array of ten el-
ements, initialize its elements to the even numbers from 0 to 18, and then
use a for loop to search the array for each of the numbers from 0 to 20.

12.4.3 Recursive Selection Sort

Next we want you to think back to Chapter 9, where we introduced the
selection sort algorithm. To review the concept, suppose you have a deck
of 52 cards. Lay them out on a table, face up, one card next to the other.
Starting at the last card, look through the deck, from last to first, find the
largest card and exchange it with the last card. Then go through the deck
again starting at the next to the last card, find the next largest card, and
exchange it with the next to the last card. Go to the next card, and so on.
If you repeat this process 51 times, the deck will be completely sorted.

JAVA DEBUGGING TIP Off-by-One Error. Sorting algorithms are
particularly susceptible to an off-by-one error. To sort an array with N
elements, you generally need to make N - 1 passes.

   Let's design a recursive version of this algorithm. The algorithm we
just described is like a head-and-tail algorithm in reverse, where the last
card in the deck is like the head, and the cards before it are like the tail.
After each pass or recursion, the last card will be in its proper location,
and the cards before it will represent the unsorted portion of the deck. If
we use parameter to represent last, then it will be moved one card to the
left at each level of the recursion.

   Figure 12.19 illustrates this process for an array of integers. The base
case is reached when the last parameter is pointing to the first element in
the array. An array with one element in it is already sorted. It needs no re-
arranging. The recursive case involves searching an ever-smaller portion
of the array. This is represented in our design by moving last down one
element to the left.

6 8 1 0 10 15 2 32 7 71 After one                                               Figure 12.19: Selection sort: Us-
                                                         pass                   ing a head-and-tail algorithm in
                                                                                reverse to sort an integer array.

      Unsorted        Last

6 8 1 0 10 15 2 7 32 71 After two
                                                        passes

      Unsorted  Last

6 8 1 0 10 7 2 15 32 71 After three
                                                        passes

      Unsorted  Last

0 1 2 6 7 8 10 15 32 71 After last
                                                         pass

Last
                     568                                CHAPTER 12  Recursive Problem Solving
                                                                                                                 

                      / 

                        s e l e c t i o n S o r t ( arr , l a s t )-- R e c u r s i v e l y s o r t a r r s t a r t i n g

                              at last element

                        P r e : a r r ! = n u l l a n d 0 <= l a s t < a r r . l e n g t h

                        P o s t : a r r w i l l b e a r r a n g e d s o t h a t a r r [ j ] <= a r r [ k ] ,

                              for any j < k

                       /

                    private void selectionSort ( int arr [ ] , int l a s t ) {

                      if ( last > 0) {

                          i n t maxLoc = findMax ( arr , l a s t ) ; // F i n d t h e l a r g e s t

                          swap ( arr , l a s t , maxLoc ) ;  // Swap i t w i t h l a s t

                          selectionSort ( arr , last - 1);

                    // Move down t h e a r r a y

                    }

                    } // s e l e c t i o n S o r t ( )

                                                                                                                           

                    Figure 12.20: The selection- Sort() method uses the findMax() and
                    swap() methods to help it sort an array.

                       Figure 12.20 provides a partial implementation of selection sort for an

                    array of int. In this definition, the array is one parameter. The second

                    parameter, int last, defines that portion of the array, from right to
                    left, that is yet to be sorted. On the first call to this method, last will be

                    arr.length - 1. On the second, it will be arr.length - 2, and so
                    on. When last gets to be 0, the array will be sorted. Thus, in terms of the
                    card deck analogy, last represents the last card in the unsorted portion of

                    the deck.

                       Note how simply the selectionSort() method can be coded. Of

Task decomposition  course, this is because we have used separate methods to handle the tasks

                    of finding the largest element and swapping the last element and the

                    largest. This not only makes sense in terms of the divide-and-conquer

                    principle, but we also already defined a swap() method in Chapter 9. So

                    here is a good example of reusing code:

                                                                                                                           

                          / 

                           swap ( arr , e l 1 e l 2 ) swaps e l 1 and e l 2 in the array , a r r

                           P r e : a r r i s n o n n u l l , 0 <= e l 1 < a r r . l e n g t h ,

                                                             0 <= e l 2 < a r r . l e n g t h

                           Post : the l o c a t i o n s of e l 1 and e l 2 are swapped in a r r

                          /

                       p r i v a t e void swap ( i n t a r r [ ] , i n t el1 , i n t e l 2 ) {

                          i n t temp = a r r [ e l 1 ] ; // A s s i g n t h e f i r s t e l e m e n t t o t e m p

                          arr [ el1 ] = arr [ el2 ] ; // O v e r w r i t e f i r s t with second

                          a r r [ e l 2 ] = temp ;      // O v e r w r i t e s e c o n d w i t h f i r s t ( temp )

                       } // swap ( )

                                                                                                                           
SECTION 12.5  Example: Drawing (Recursive) Fractals                   569

The definition of the findMax() method is left as a self-study exercise.

JAVA PROGRAMMING TIP Method Decomposition. A task can be
simplified by breaking it up into simpler subtasks, especially if you
already have methods for solving one or more of the subtasks.

SELF-STUDY EXERCISES

EXERCISE 12.14 As in the case of the search() method, we need to
provide a public interface to the recursive selectionSort() method.
We want to enable the user to sort an array just by calling sort(arr),
where arr is the name of the array to be sorted. Define the sort()
method.

EXERCISE 12.15 Define an iterative version of the findMax(arr,N)
method that is used in selectionSort(). Its goal is to return the
location (index) of the largest integer between arr[0] and arr[N].

12.5 Example: Drawing (Recursive) Fractals

A fractal is a geometric shape that exhibits a recursive structure. When it      Fractal patterns
is divided into parts, each part is a smaller version of the whole. Fractal
patterns occur in many situations and places. For example, if you look
at a graph of the Dow Jones Industrial Average (DJIA) over the past year,
the graph for each day is similar to the graph of each month, which is
similar to the graph of each year, and so on. Each part is a reduced-scale
version of the whole. Fractals also occur throughout nature. If you look
at a coastline from an airplane, the shape of each part of the coastline, no
matter how small the scale, resembles the shape of the whole coastline. If
you look at a tree, each branch of the tree is similar in shape to the whole
tree.

   So, fractal patterns are all around us. Because of their self-similarity and
divisibility, fractals are well-suited for recursive programming. Drawing
recursive patterns is also an excellent way to illustrate how to use parame-
ters to create generality in method design. In this section, we will develop
two simple patterns and incorporate them into a GUI.

12.5.1 Nested Squares

Earlier in this chapter, we developed a recursive definition for drawing a
nested squares pattern (Fig. 12.2). Now let's develop a recursive method
that actually draws the pattern. For this pattern, the base case is the draw-
ing of the square. The recursive case, if more divisions are desired, is the
drawing of smaller patterns within the square:

                                                                                 

Draw a square .

I f more d i v i s i o n s are desired

  draw a s m a l l e r v e r s i o n of p a t t e r n within square .            

   An important consideration for this algorithm is to specify precisely
what we mean by "if more divisions are desired." In other words, how
                                     570                 CHAPTER 12  Recursive Problem Solving

Levels of recursion                  exactly do we control the recursion? In our earlier definition of the pattern,              How shoul
                                     we used the length of the side to control the algorithm. When side  5, we                   problem?
                       Level 0       recursed.
                       Level 1                                                                                                  
                       Level 4          Another more general way to do this is to describe the fractal structure                
                                     in terms of its levels. For nested squares, the level-zero pattern would be
                                     just the basic square shape (Fig. 12.21). A level-one pattern would be the
                                     basic square shape plus an inner square, and so on. The higher the level,
                                     the more subdividing we do. Therefore, one way to control the recursion
                                     is to use a level parameter as the recursion parameter--as the parameter that
                                     controls the recursion:

                                     

                                      Draw a square .                                              within  square .
                                       If the level is greater than 0 ,

                                              draw a s m a l l e r v e r s i o n of p a t t e r n
                                     

                                        What other parameters will we need for this method? If we're going to
                                     draw a rectangle, we'll need parameters for its x- and y-coordinates. We'll
                                     also need a parameter for the length of sides of the square. Another issue
                                     we need to decide is how much the length of the sides should change at
                                     each level. Should length change by a fixed amount, by a fixed ratio, or
                                     by some other factor? In order to allow this kind of flexibility, let's use
                                     another parameter for this value.

                                        These design considerations suggest the method shown in Figure 12.22.
                                     Note that we must also provide a Graphics parameter so the method
                                     can use the drawRect() method to draw the square. As we decided, the
                                     level parameter controls the recursion. Note that its value is decreased
                                     by 1 in the recursive call. This will ensure that level will eventually reach
                                     0, and recursion will stop.

                                                                                                                                

                                     / 

Figure 12.21: Levels 0, 1, and 4 of     d r a w B o x e s ()--- r e c u r s i v e l y draws p a t t e r n o f n e s t e d
the nested squares pattern.
                                        squares with top l e f t corner of outer square at

                                        ( locX , locY ) and dimensions of l e n g t h s i d e .

                                        l e v e l (>= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e : = 0 )

                                        delta is used to adjust the length of the side .

                                       /

                                     private void drawBoxes ( Graphics g , int level ,
                                                         int locX , int locY , int side , int delta ) {

                                        g . drawRect ( locX , locY , side , side ) ;
                                        if ( level > 0) {

                                            i n t newLocX = locX + d e l t a ; i n t newLocY = locY + d e l t a ;
                                            drawBoxes ( g , l e v e l - 1 , newLocX , newLocY ,

                                                                                                    side - 2  delta , delta );
                                        } // i f

                                     } // drawBoxes ( )

                                                                                                                                

                                          Figure 12.22: The drawBoxes() method.

                                        Finally, note the use of the delta parameter, which is used to change
                                     the length of the sides by a fixed amount, 2 * delta, at each level. It
                                     is also used to calculate the x- and y-coordinates for the location of the
SECTION 12.5  Example: Drawing (Recursive) Fractals                       571

next level of boxes (locX + delta, locY + delta). But delta's value remains
constant through all the levels. This will lead to a pattern where the "gap"
between nested squares is constant.

JAVA EFFECTIVE DESIGN Levels of Recursion. Many recursive
algorithms use a level parameter as the recursion parameter.

SELF-STUDY EXERCISES                                                              Figure 12.23: This version of
                                                                                  nested boxes can be drawn by us-
EXERCISE 12.16 Trace through the drawBoxes() method and draw                      ing delta as a fixed percentage of
the level-four and level-five versions of the nested boxes pattern. Assume        the length of the side.
that the initial values for side and delta are 100 and 5, respectively, and
the initial coordinates for (locX,locY) are (20,20).                              Figure 12.24: Levels 0, 1, and 7 of
                                                                                  the Sierpinski gasket fractal pat-
EXERCISE 12.17 The pattern shown in Figure 12.23 can be drawn by                  tern.
using delta as a fixed ratio of the length of the side, for example, 10
percent. Modify the drawBoxes() method to use delta in this way.

EXERCISE 12.18 Write an iterative version of the drawBoxes()
method. (Hint: On each iteration, you must change the x- and y-
coordinates of the square's location and the length of its side.)

12.5.2 The Sierpinski Gasket

Let's return now to the Sierpinski gasket pattern that we introduced at
the start of this chapter. This is a much more interesting fractal pattern
(Fig. 12.24). The overall shape of the pattern is that of a triangle, but notice
how the outer triangle is divided into three smaller triangles. Then each
of those triangles are divided into three smaller triangles. If you continue
this process of dividing and shrinking, you get the level-seven pattern
shown here.

   Let's develop a recursive method to draw this pattern. If we follow
the same strategy we used in the nested squares example, we get the
following algorithm:

                                                                                  

Base case :  Draw a t r i a n g l e .

Recursive Case : I f more d i v i s i o n s are desired ,

  draw t h r e e s m a l l e r g a s k e t s within the t r i a n g l e .         

For this pattern the base case is the drawing of the basic triangle. The
recursive cases, if more divisions are desired, are the drawing of smaller
gaskets within the triangle. Again we will use a level parameter to con-
trol the depth of the recursion. The higher the level, the more divisions
will be drawn.
                              572             CHAPTER 12  Recursive Problem Solving
                                                                                                       

                     / 

                        d r a w G a s k e t ()--- r e c u r s i v e l y draws t h e S i e r p i n s k i g a s k e t

                        p a t t e r n , w i t h p o i n t s ( p1X , p1Y ) , ( p2X , p2Y ) , ( p3X , p3Y )

                        representing the vertices of its enclosing triangle .

                        l e v e l (>= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e : = 0 )

                       /

                     p r i v a t e void drawGasket ( Graphics g , i n t lev , i n t p1X , i n t p1Y ,

                                              i n t p2X , i n t p2Y , i n t p3X , i n t p3Y ) {

                       g . drawLine ( p1X , p1Y , p2X , p2Y ) ; // Draw a t r i a n g l e

                       g . drawLine ( p2X , p2Y , p3X , p3Y ) ;

                       g . drawLine ( p3X , p3Y , p1X , p1Y ) ;

                       if ( lev > 0) { // I f more l e v e l s , draw 3 s m a l l e r g a s k e t s

                          i n t q1X = ( p1X + p2X ) / 2 ;        i n t q1Y = ( p1Y + p2Y ) / 2 ;

                          i n t q2X = ( p1X + p3X ) / 2 ;        i n t q2Y = ( p1Y + p3Y ) / 2 ;

                          i n t q3X = ( p2X + p3X ) / 2 ;        i n t q3Y = ( p2Y + p3Y ) / 2 ;

                          drawGasket ( g , l e v - 1 , p1X , p1Y , q1X , q1Y , q2X , q2Y ) ;

                          drawGasket ( g , l e v - 1 , p2X , p2Y , q1X , q1Y , q3X , q3Y ) ;

                          drawGasket ( g , l e v - 1 , p3X , p3Y , q2X , q2Y , q3X , q3Y ) ;

                       } // i f

                     } // dr aw Ga sk et ( )

                                                                                                                     

                                   Figure 12.25: The drawGasket() method.

Levels of recursion          If we're going to draw a triangle shape, we need the coordinates of its                  What other
Midpoint of a line        three vertices--that is, an x- and y-coordinate for each vertex. Taken to-
                          gether, these design considerations suggest the method definition shown                    
                          in Figure 12.25.                                                                           

                             As we described earlier, we use the level parameter as the recursion
                          parameter for this method, which controls the recursion. Note that each
                          of the three recursive calls decreases the level by 1. This will ensure that
                          eventually level will equal 0, and recursion will stop.

                             Note also how the three pairs of coordinates are used. Drawing a tri-
                          angle is simple. Just draw three lines from (p1X,p1Y) to (p2X,p2Y),
                          from (p2X,p2Y) to (p3X,p3Y), and from (p3X,p3Y) back to (p1X,
                          p1Y). The most complicated part of the method is calculating the vertices
                          for the three inner gaskets. If you look at Figure 12.24 again, you'll no-
                          tice that each of the inner triangles uses one of the vertices of the main
                          triangle, plus the midpoints of the two adjacent sides. Thus, the triangle
                          on the "left" uses the left vertex (p1X,p1Y), and the midpoints of the
                          other two lines from (p1X,p1Y) to (p2X,p2Y) and from (p1X,p1Y) to
                          (p3X,p3Y). As you might remember from high school math, the formula
                          for computing the midpoint of the line segment (x1, y1) to (x2, y2) is

                           

                              ( ( x1 + x2 ) / 2 , ( y1 + y2 ) / 2 )
                           

                          This formula is used repeatedly to calculate the vertices of the three
                          smaller gaskets.
SECTION 12.6  OBJECT-ORIENTED DESIGN: Tail Recursion 573

12.6 OBJECT-ORIENTED DESIGN:
        Tail Recursion

Although the drawBoxes() method is relatively simple to convert into              Tail recursion
an iterative version (see Self-Study Exercise 12.18), the same cannot be said    
for the drawGasket() method. It is clearly a case where the recursive            
approach makes the problem easier to solve.                                      
                                                                                 
   One difference between drawBoxes() and drawGasket() is that
drawBoxes() is an example of a tail-recursive method. A method is tail
recursive if all of its recursive calls occur as the last action performed in
the method. You have to be a bit careful about this definition. The recur-
sive call in a tail-recursive method has to be the last executed statement. It
needn't be the last statement appearing in the method's definition.

   For example, the following method will print "Hello" N times. This
method is tail recursive even though its last statement is not a recursive
call:



  public void p r i n t H e l l o ( i n t N) {          executed  statement
    i f (N > 1 ) {
       System . out . println ( "Hello" ) ;
       p r i n t H e l l o (N - 1 ) ; // T h e l a s t
   } else
       System . out . println ( "Hello" ) ;

  } // p r i n t H e l l o ( )


This method is tail recursive because the last statement that will be exe-
cuted, in its recursive cases, is the recursive call.

   A tail-recursive method is relatively easy to convert into an iterative
method. The basic idea is to make the recursion parameter into a loop
variable, taking care to make sure the bounds are equivalent. Thus, the
following iterative method will print "Hello" N times:



  public void p r i n t H e l l o I t e r a t i v e ( i n t N) {

         f o r ( i n t k = N; k > 0 ; k--)

                System . out . println ( "Hello" ) ;

  }


In this case, we use the parameter N to set the initial value of the loop vari-
able, k, and we decrement k on each iteration. This is equivalent to what
happens when we decrement the recursion parameter in the recursive call.

JAVA EFFECTIVE DESIGN Tail Recursion. Tail-recursive
algorithms are relatively simple to convert into iterative algorithms
that do the same thing.

   As you can see, recursive methods that are not tail recursive are much
more complex. Just compare the drawGasket() and drawBoxes()
methods. Yet it is precisely for these nontail-recursive algorithms that re-
cursion turns out to be most useful. As you might expect, if you can't
                      574  CHAPTER 12  Recursive Problem Solving

                      give a simple tail-recursive solution to a problem, the problem proba-
                      bly doesn't have a simple iterative solution either. Thus, the problems
                      where we most need recursion are those where we can't give a simple
                      tail-recursive or a simple iterative solution. And there are a lot of such
                      problems, especially when you get into nonlinear data structures such as
                      trees and graphs.

                         To gain some appreciation for this complexity, consider how difficult it
                      would be to draw the Sierpinski gasket using an iterative approach. We
                      could start by developing an outer for loop to account for the different
                      levels in the pattern:

                                                                                                   

                      f o r ( i n t k = l e v ; k > 0 ; k--) {

                           drawGasket ( g , l e v - 1 , p1X , p1Y , q1X , q1Y , q2X , q2Y ) ;

                           drawGasket ( g , l e v - 1 , p2X , p2Y , q1X , q1Y , q3X , q3Y ) ;

                           drawGasket ( g , l e v - 1 , p3X , p3Y , q2X , q2Y , q3X , q3Y ) ;

                      }

                                                                                                   

                      But now each of the method calls within the body of this loop would have
                      to be replaced by very complex loops. That would be a daunting task.
                      So the lesson to be drawn from this observation is that recursion is most
                      useful as a problem-solving technique for problems that don't yield to a
                      simple iterative solution.

                      JAVA EFFECTIVE DESIGN Recursion or Iteration. If you have
                      difficulty designing an iterative solution to a problem, try developing
                      a recursive solution to it.

Method call overhead  SELF-STUDY EXERCISES

                      EXERCISE 12.19 Trace the drawGasket() method for levels two and
                      three. Pick your own values for the three vertices.

                      EXERCISE 12.20 Is the printReverse() method, discussed earlier,
                      tail recursive? Explain.

                      EXERCISE 12.21 Is the countChar() method, discussed earlier, tail
                      recursive? Explain.

                      12.7 OBJECT-ORIENTED DESIGN:
                              Recursion or Iteration?

                      As we mentioned at the outset of this chapter, recursive algorithms require
                      more computational overhead than iterative algorithms. We're now in a
                      good position to appreciate why this is so.

                         A recursive algorithm incurs two kinds of overhead that are not in-
                      curred by an iterative algorithm: memory and CPU time. Both of these
                      are direct results of the fact that recursive algorithms do a lot of method
                      calling.

                         As we saw in our various traces, each time a method is called, a rep-
                      resentation of the method call is placed on the method call stack. These
SECTION 7  OOD: Recursion or Iteration       575

representations often take the form of a block of memory locations, which      Memory overhead
can be quite large. The block must contain space for the method's local
variables, including its parameters. Also, unless the method is void, the      Figure 12.26: A more detailed
block must contain space for the method's return value. In addition it         picture of the method call stack,
must contain a reference to the calling method, so it will know where to       showing two method blocks for
go when it is done. Figure 12.26 shows what the method call block would        search() after two levels of re-
look like for the search() method.                                             cursion.

      arr  search()  6 8 1 0 10 15 2 32 7 71
     key
   head       32
 calling       1
method
           search()
      arr
     key      32
   head        0
 calling
method

   In addition to the memory required, a method call also requires extra       CPU overhead
CPU time. Each time a method is called, Java must create a method call
block, copy the method call arguments to the parameters in the block,
create initial values for any local variables that are used by the method,
and fill in the return address of the calling method. All of this takes time,
and in the case of a recursive method, these steps are repeated at each
level of the recursion.

   Compare these memory and CPU requirements with what normally
transpires for an iterative algorithm--an algorithm involving a loop. The
loop structure usually occurs entirely within a method, so it doesn't incur
either the memory or CPU overhead involved in recursion. Therefore,
iterative algorithms are generally more efficient than recursive algorithms.
One useful guideline, then, is when runtime performance and efficiency
are of prime importance, you should use iteration instead of recursion.

JAVA EFFECTIVE DESIGN Iteration or Recursion. Use an iterative
algorithm instead of a recursive algorithm whenever efficiency and
memory usage are important design factors.

   On the other hand, recursive algorithms are much easier to design than      Efficiency of development
the corresponding iterative algorithms for many problems. We tried to
illustrate this point in our development of the Sierpinski gasket algorithm,
but there are many other examples that we could have used. Given that
programmer and designer time is the most expensive resource involved in
software development, a recursive solution may be easier to develop and
maintain than a corresponding iterative solution. And given the great cost
of software development, a less efficient solution that is easier to develop,
easier to understand, and easier to maintain may be preferable to a highly
                                   576  CHAPTER 12  Recursive Problem Solving

                                   efficient algorithm that's difficult to understand. For some problems then,
                                   such as the Sierpinski gasket, a recursive algorithm may provide the best
                                   solution.

                                   JAVA EFFECTIVE DESIGN Keep It Simple. When all other factors
                                   are equal, choose the algorithm (recursive or iterative) that is easiest to
                                   understand, develop, and maintain.

Optimizing compiler                   One final point that's worth making is that some optimizing compilers
                                   are able to convert recursive methods into iterative methods when they
                                   compile the program. The algorithms for doing this are well known. They
                                   are often subjects for study in a data structures course, so we won't go
                                   into them here. The resulting runtime programs will be just as efficient, in
                                   CPU time and memory, as if you had written iterative methods. The point
                                   is that if you have such a compiler, you really get the best of both worlds.
                                   You get the advantage of using recursion as a problem-solving and soft-
                                   ware development approach, and the compiler takes care of producing an
                                   efficient object program.

                                   Special Topic: Exploring the Mandelbrot Set

Figure 12.27: The Mandelbrot set.  The Mandelbrot set is one of the most fascinating fractals. It is named after
                                   its discover, IBM mathematician Benoit Mandelbrot. The Mandelbrot set
                                   itself is the black, heart-shaped image shown in Figure 12.27. What makes
                                   the Mandelbrot set so interesting is that with the help of a Java GUI you
                                   can explore the set as if you were taking a trip through outer space. The
                                   most interesting regions to explore are those just along the boundary of
                                   the set. For example, notice that the boundary contains numerous cir-
                                   cular shapes, each of which is itself studded with circular shapes. This
                                   is an example of the scaled self-similarity that we found to be so preva-
                                   lent in recursive structures. By continually expanding the regions around
                                   the boundary, you'll find an infinite recursion of fascinating images and
                                   shapes. In some regions of the set you'll even find miniature replications
                                   of the set itself.

                                      The Mandelbrot set is generated by an iterated function system. The
                                   mathematics underlying this fascinating object is quite accessible, and
                                   there are a number of online tutorials that explain how the set is generated
                                   and how the pictures are produced. Many of the Mandelbrot and fractal
                                   Web sites contain excellent Java applets that let you explore the Mandel-
                                   brot set as well as related sets. An excellent place to start your exploration
                                   would be David Joyce's award-winning Web site,

                                                                                                                   

                                   h t t p : //aleph0 . c l a r k u . edu /~ d j o y c e / j u l i a /
                                                                                                                   

                                   which contains references to a number of other good sites. For a tutorial
                                   on how the various Mandelbrot set-generating Java programs work, see

                                                                                                                   

                                   h t t p : //storm . shodor . org/mteach/                                        
                                   
 SECTION 12.8  From the Java Library: javax.swing.JComboBox 577

12.8 From the Java Library:
        javax.swing.JComboBox

 A JComboBox is a Swing component that combines a text field and               JComponent    쳃nterface
a drop-down list (Fig. 12.28). It lets the user either type in a selec-                    ItemSelectable
tion or choose a selection from a list that appears when the user re-
quests it--a JComboBox's drop-down behavior is somewhat similar to a                쳃nterface   쳃nterface
java.awt.Choice box.                                                              ActionListener  ItemListener

   A JComboBox can be used to represent a drop-down menu. When the                                JComboBox
user clicks on a JComboBox, a list of options drops down, and the user
can select a particular option that is stored in the box's internal state      +JComboBox()
(Fig. 12.29). The list of options associated with a JComboBox can be built     +JComboBox(in items[] : Object)
beforehand and inserted into the component in a constructor, or items can      +JComboBox(in items : Vector)
be inserted one at a time by repeatedly using its addItem() method.            +addActionListener(in l : ActionListener)
                                                                               +addItem(in item : Object)
   As Figure 12.28 shows, either an array or a vector of items can be passed   +addItemListener(in l : ItemListener)
to a constructor method to initialize the box's menu. The items stored in a    +getItemAt(in index : int) : Object
JComboBox box are references to Objects, most commonly Strings that            +getSelectedItem() : Object
represent the name of the menu item. They are stored in the (zero indexed)     +setSelectedIndex(in index : int)
order in which they are added. The addItem() method is used to add an          +setSelectedItem(in item : Object)
individual Object to a JComboBox. By default, the first item added to a
JComboBox will be the selected item until the user selects another item.       Figure 12.28: A JComboBox re-
                                                                               sponds to action events and item
   When the user makes a selection in a JComboBox, the item selected           events.
can be gotten either by its reference (getSelectedItem()) or by its po-
sition within the menu (getSelectedIndex()). There are also meth-
ods to setSelectedItem() and setSelectedIndex() that let you
select an individual item either by its reference or its position. The
addItemListener() method is used to designate some object as the
listener for the ItemEvents that are generated whenever the user selects
a menu option. Alternatively, the addActionListener() method lets
you handle action events, such as when the user types a value into the
box.

12.8.1 A JComboBox Example

As a simple example, let's design an graphical interface that can be used
to display the fractal patterns we developed earlier. We want an inter-
face that lets the user select from among the available patterns--we'll use
the Sierpinski gasket and nested boxes for starters. In addition, the user
should also be able to select different levels for the drawings, from 0 to 9.
We want to present these options in two menus, with one JComboBox for
each menu.

   The first step is to declare and instantiate the JComboBoxes as instance
variables:

                                                                               

private String items [] =

  {" Sierpinski Gasket" , "Nested Boxes" };

p r i v a t e JComboBox p a t t e r n s = new JComboBox ( items ) ;

p r i v a t e JComboBox l e v e l s = new JComboBox ( ) ;                      


Note that in this case we pass the constructor for the patterns menu
an entire array of items. If we hadn't done it this way, we would

                                                                               Figure 12.29: Using a JComboBox
                                                                               box.
578               CHAPTER 12  Recursive Problem Solving

add individual items to the combo box in the JFrame's constructor
RecursivePatterns(). In fact, that's how we'll initialize the levels
menu:

                                                                                                        

for ( int k=0; k < 10; k++) // Add 10 l e v e l s

     levels . addItem (k + "" ) ;

levels . setSelectedItem ( "4" ) ; // S e l e c t d e f a u l t l e v e l
                                                                                                        

This loop would be placed in the JFrame's constructor, RecursivePatterns().
It adds strings representing levels 0 to 9 to the menu and initializes the box
so that level four is showing as the default option.

   Our next step is to designate the JFrame as the ItemListener for
both menus--that is, the JFrame is named as the object that will handle
the events that occur in the JComboBoxes. Then we add the JComboBox
component to the JFrame:

                                                                                                        

c o n t r o l s . add ( l e v e l s ) ;      // C o n t r o l p a n e l f o r menus
c o n t r o l s . add ( p a t t e r n s ) ;

                                                                          // Add t h e c o n t r o l s

getContentPane ( ) . add ( c o n t r o l s , "North" ) ;

                                                               // And t h e d r a w i n g p a n e l

getContentPane ( ) . add ( canvas , " Center " ) ;

                  // R e g i s t e r t h e menus w i t h a l i s t e n e r

levels . addItemListener ( this ) ;

patterns . addItemListener ( this ) ;                                                                   


Note that we use a separate controls panel (a JPanel) for the two
menus and a canvas panel (another JPanel) for the drawings.

   The next step is to implement the itemStateChanged() method to
handle the user's selections. Whenever the user selects an item from a
JComboBox menu, an ItemEvent is generated. In order to handle these
events, the program must implement the ItemListener interface, which
consists of the single method itemStateChanged(). This method is
invoked automatically whenever the user selects an item from one of the
JComboBoxes:

                                                                                                        

public void itemStateChanged ( ItemEvent e ) {

     canvas . setPattern ( patterns . getSelectedIndex () ,

                                             levels . getSelectedIndex ( ) ) ;

     repaint ();

}

                                                                                                        

The itemStateChanged() method has the same general form as
the actionPerformed() method, except that its parameter is an
ItemEvent. For this example, the program uses the getSelected-
Index() method to get the selected pattern and the selected level by their
respective item numbers within the menus. It then passes these values
along to the canvas object, which takes care of the drawing. Finally,
the method invokes the repaint() method. Because the JFrame is a
container, this will cause all of its components to be repainted as well.
SECTION 12.8  From the Java Library: javax.swing.JComboBox 579

JVM        applet : ItemListener                                           Figure 12.30: This UML sequence
                                                                           diagram shows the interaction
     User  : JComboBox                         : Canvas                    between the various objects in-
                                    setPattern()                           cluded in the action of selecting an
                                                                           item from a JComboBox.

                     select
          SelectEvent
     itemStateChanged(e:ItemEvent)

   Figure 12.30 illustrates the sequence of events that occurs when an     Zero indexing
item is selected from a JComboBox. The complete implementation for
the program is given in Figure 12.31.

   The actual drawing of the fractal patterns is handled by the canvas
JPanel component, whose design is shown in Figure 12.32 and whose
implementation is given in Figure 12.33. All of the drawing is done
in the paintComponent() method. Because the canvas is contained
within the JFrame, the paintComponent() method is called automati-
cally whenever the JFrame repaints itself. Notice how the switch state-
ment uses the pattern that the user chose to call the corresponding draw-
ing method. You can see from this switch statement that a JComboBox's
items are zero indexed.
                    580                                          CHAPTER 12  Recursive Problem Solving

                                                                                                                             

                 import java . awt .  ;
                 import javax . swing .  ;
                 import java . awt . event .  ;

                 public class RecursivePatterns extends JFrame implements ItemListener {

                 private String choices [ ] = {" Sierpinski Gasket" , "Nested Boxes" };

                 p r i v a t e JComboBox p a t t e r n s = new JComboBox ( c h o i c e s ) ; // P a t t e r n c h o i c e s

                 p r i v a t e JComboBox l e v e l s = new JComboBox ( ) ;            // L e v e l c h o i c e s

                 p r i v a t e Canvas canvas = new Canvas ( ) ;                       // Drawing p a n e l

                 p r i v a t e J P a n e l c o n t r o l s = new J P a n e l ( ) ;

                 public RecursivePatterns () {

                    for ( int k=0; k < 10; k++)                                     // Add 1 0 l e v e l s

                    levels . addItem (k + "" ) ;

                    patterns . setSelectedItem ( choices [ 0 ] ) ; // I n i t i a l i z e menus

                    levels . setSelectedItem ("4" ) ;

                    canvas . setBorder ( BorderFactory . createT itledBord er ( "Drawing Canvas" ) ) ;

                    c o n t r o l s . add ( l e v e l s ) ;      // C o n t r o l p a n e l f o r menus

                    c o n t r o l s . add ( p a t t e r n s ) ;

                    getContentPane ( ) . add ( c o n t r o l s , "North" ) ; // Add c o n t r o l s

                    getContentPane ( ) . add ( canvas , " Center " ) ; // Add d r a w i n g p a n e l

                    levels . addItemListener ( this ) ; // R e g i s t e r menus with l i s t e n e r

                    patterns . addItemListener ( this ) ;

                    s e t S i z e ( canvas .WIDTH, canvas . HEIGHT+ c o n t r o l s . g e t S i z e ( ) . width ) ;

                 } // i n i t ( )

                 public void itemStateChanged ( ItemEvent e ) {

                    canvas . setPattern ( patterns . getSelectedIndex () ,

                                                                 levels . getSelectedIndex ( ) ) ;

                    repaint ();                                                     // R e p a i n t t h e J F r a m e

                 } // i t e m S t a t e C h a n g e d ( )

                 public s t a t i c void main ( S t r i n g args [ ] )

                 {

                    JFrame f = new R e c u r s i v e P a t t e r n s ( ) ;

                    f . setVisible ( true );

                 }

                 } // R e c u r s i v e P a t t e r n s

                                                                                                                             

                                   Figure 12.31: The RecursivePatterns program.

CHAPTER SUMMARY     Technical Terms

                    base case                                    iterative method     recursive case
                    computational                                last-in-first-out    recursive definition
                                                                                      recursive method
                       overhead                                     (LIFO)            self-similarity
                    head-and-tail                                method call stack    tail recursive
                                                                 recursion parameter
                       algorithm
                    CHAPTER 12  Chapter Summary                                                            581

esign of a drawing

                                                                                                            

import javax . swing .  ;
import java . awt .  ;

public class Canvas extends JPanel {

  p r i v a t e s t a t i c f i n a l i n t GASKET = 0 , BOXES = 1 ;

  public s t a t i c f i n a l i n t WIDTH=400 , HEIGHT= 4 0 0 ;

  p r i v a t e f i n a l i n t HBOX=10 , VBOX=50 , BOXSIDE=200 , BOXDELTA= 1 0 ;

  p r i v a t e f i n a l i n t gP1X = 1 0 ; p r i v a t e f i n a l i n t gP1Y = 2 8 0 ; // I n i t i a l

  p r i v a t e f i n a l i n t gP2X = 2 9 0 ; p r i v a t e f i n a l i n t gP2Y = 2 8 0 ; // g a s k e t

  p r i v a t e f i n a l i n t gP3X = 1 5 0 ; p r i v a t e f i n a l i n t gP3Y = 1 1 0 ; // p o i n t s

  private int pattern = 0 ;                                           // C u r r e n t p a t t e r n

  private int level = 4;                                              // C u r r e n t l e v e l

  public Canvas ( ) {
     s e t S i z e (WIDTH, HEIGHT ) ;

  }

  public void setPattern ( int pat , int lev ) {

     pattern = pat ;

     level = lev ;

  }

                                                                                                            

                           Figure 12.33: The Canvas class is a drawing panel, Part I.

                    Summary of Important Points

                     A recursive definition is one that defines the nth case of a concept in
                       terms of the (n - 1)st case plus a limiting condition. It is based on the
                       idea of breaking a problem up into smaller, self-similar problems.

                     A recursive method is one that calls itself. It is usually defined in terms of
                       a base case or limiting case, which stops the recursive process, and a re-
                       cursive case, which breaks the method into a smaller, self-similar copy
                       of itself. A recursion parameter is generally used to control the recursion.

                     An iterative algorithm is one that uses some kind of loop as its control
                       structure. Any algorithm that can be done iteratively can also be done
                       recursively, and vice versa.
582                           CHAPTER 12  Recursive Problem Solving



         public void paintComponent ( Graphics g) {
                g . setColor ( getBackground ( ) ) ; // Redraw t h e p a n e l ' s b a c k g r o u n d
                g . drawRect ( 0 , 0 , WIDTH, HEIGHT ) ;
                g . setColor ( getForeground ( ) ) ;
                switch ( pattern ) {
                c a s e GASKET :
                        drawGasket ( g , l e v e l , gP1X , gP1Y , gP2X , gP2Y , gP3X , gP3Y ) ;
                        break ;
                c a s e BOXES :
                       drawBoxes ( g , l e v e l , HBOX, VBOX, BOXSIDE , BOXDELTA ) ;
                        break ;
                } // s w i t c h

         } // p a i n t C o m p o n e n t ( )

     /  d r a w G a s k e t ()--- r e c u r s i v e l y draws t h e S i e r p i n s k i

      g a s k e t p a t t e r n , w i t h p o i n t s ( p1X , p1Y ) , ( p2X , p2Y ) , ( p3X , p3Y )

      representing the vertices of its enclosing triangle .

      l e v e l (>= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e c a s e : l e v e l 0 )

     /

     p r i v a t e void drawGasket ( Graphics g , i n t lev , i n t p1X , i n t p1Y ,

               i n t p2X , i n t p2Y , i n t p3X , i n t p3Y ) {

        g . drawLine ( p1X , p1Y , p2X , p2Y ) ; // Draw a t r i a n g l e

        g . drawLine ( p2X , p2Y , p3X , p3Y ) ;

        g . drawLine ( p3X , p3Y , p1X , p1Y ) ;

        if ( lev > 0) { // I f more l e v e l s , draw 3 s m a l l e r g a s k e t s

               i n t q1X = ( p1X + p2X ) / 2 ;    i n t q1Y = ( p1Y + p2Y ) / 2 ;

               i n t q2X = ( p1X + p3X ) / 2 ;    i n t q2Y = ( p1Y + p3Y ) / 2 ;

               i n t q3X = ( p2X + p3X ) / 2 ;    i n t q3Y = ( p2Y + p3Y ) / 2 ;

               drawGasket ( g , l e v - 1 , p1X , p1Y , q1X , q1Y , q2X , q2Y ) ;

               drawGasket ( g , l e v - 1 , p2X , p2Y , q1X , q1Y , q3X , q3Y ) ;

               drawGasket ( g , l e v - 1 , p3X , p3Y , q2X , q2Y , q3X , q3Y ) ;

        }

     } // dr aw Ga ske t ( )

     /  d r a w B o x e s ()--- r e c u r s i v e l y draws p a t t e r n o f n e s t e d s q u a r e s

      with ( locX , locY ) the top l e f t c o r n e r of outer the square and

      side being the length square ' s side .

      l e v e l (>= 0 ) i s t h e r e c u r s i o n p a r a m e t e r ( b a s e c a s e : l e v e l 0 )

      delta is used to adjust the length of the side .

     /

     private void drawBoxes ( Graphics g , int level ,
                 int locX , int locY , int side , int delta ) {

           g . drawRect ( locX , locY , side , side ) ;
            if ( level > 0) {

                   i n t newLocX = locX + d e l t a ; i n t newLocY = locY + d e l t a ;
                   drawBoxes ( g , l e v e l - 1 , newLocX , newLocY ,

                                                                          side - 2  delta , delta );
            }

     } // drawBoxes ( )

  } // Canvas


               Figure 12.33: The Canvas class, Part II.
CHAPTER 12  Solutions to Self-Study Exercises                                         583

 Because method calling is relatively costly both in terms of memory
  used and CPU time involved, a recursive algorithm is generally less
  efficient than an iterative one that does the same thing.

 In designing recursive algorithms, the base case defines a limit. Each
  level of recursion should make progress toward the limit, and the algo-
  rithm should eventually reach the limit. The limit is usually expressed
  in terms of the recursion parameter.

 A recursive method is tail recursive if and only if each of its recursive
  calls is the last action executed by the method.

 A Swing JComboBox component is used to represent a GUI drop-
  down menu.

SOLUTION 12.1 The output produced by mystery(0) would be 0 1 2 3 4 5 6.                        SOLUTIONS TO
The output produced by mystery(100) would be 100.                                              SELF-STUDY EXERCISES

SOLUTION 12.2 The output produced by mystery(5) would be: 5 4 3, and so
on. In other words, this is an infinite recursion.

SOLUTION 12.3

                                                                                       

D e f i n i t i o n : twoToN (N) , N >= 0

  1 , i f N == 0                              // B a s e c a s e

  2  twoToN (N - 1 ) , N > 0                  // R e c u r s i v e c a s e

                                                                                       

SOLUTION 12.4 The function xn is known as the power function:

                                                                                       

D e f i n i t i o n : power ( X ,N) , N >= 0

  1 , i f N == 0                              // B a s e c a s e

  X  power (X , N - 1 ) , N > 0               // R e c u r s i v e c a s e

                                                                                       

SOLUTION 12.5 Yes, the two definitions for nested boxes are equivalent. Sup-
pose the square starts out with a side of 20. The definition given in the exercise
will also draw squares with sides of 20, 15, 10, 5.

  SOLUTION 12.6 A recursive definition for the pattern in Figure 12.4:                      

                                                                                       case
 Draw a square with side , s .
  Inscribe a c i r c l e with diameter , s .                                                
  If s > 5,

     Draw a s m a l l e r v e r s i o n o f same p a t t e r n . // R e c u r s i v e


SOLUTION 12.7 The printString2("hello") method will print: "olleh."
584                           CHAPTER 12  Recursive Problem Solving

SOLUTION 12.8 A definition for countDown():

                                                                                

   / countDown (N) r e c u r s i v e l y p r i n t s a countdown

    beginning at N and ending at 1

    @ p a r a m N >= 1

    B a s e c a s e : N == 0

   /

void countDown ( i n t N) {

      i f (N == 0 )                        // B a s e c a s e

            System . out . println ( " b l a s t o f f " ) ;

      else {

            System . out . p r i n t (N + " , " ) ; // R e c u r s i v e  case

            countDown (N - 1 ) ;

      }

} // countDown ( )

                                                                                

  SOLUTION 12.9 A revised definition for countDown():                             

                                                                                ...
   / countDown (N) r e c u r s i v e l y p r i n t s a countdown
                                                                                  
    b e g i n n i n g at N, c o u n t i n g every o t h e r number , 10 8 6

    and ending at " b l a s t o f f "

    @ p a r a m N >= 1

    B a s e c a s e : N <= 0

   /

void countDown ( i n t N) {

      i f (N <= 0 )                        // B a s e c a s e

            System . out . println ( " b l a s t o f f " ) ;

      else {

            System . out . p r i n t (N + " , " ) ; // R e c u r s i v e  case

            countDown (N - 2 ) ;

      }

  } // countDown ( )


SOLUTION 12.10 A method to sum the numbers from 1 to N.

                                                                                

i n t sum ( i n t N) {

      i f (N == 0 )

            return 0;

      else

            r e t u r n N + sum (N- 1 ) ;

}

                                                                                
CHAPTER 12  Solutions to Self-Study Exercises                                    585

SOLUTION 12.11 A method to change each blank within a string to two blanks.

                                                                                  

String addBlanks ( String s ) {

   i f ( s . l e n g t h ( ) == 0 )

   return "" ;

   e l s e i f ( s . charAt ( 0 ) == ' ' )

   return ' ' + s . charAt (0) + addBlanks ( s . substring ( 1 ) ) ;

   else

   return s . charAt (0) + addBlanks ( s . substring ( 1 ) ) ;

}

                                                                                  

SOLUTION 12.12 A method to print out all possible outcomes for a chess player
playing N games. printOutcomes(str, N) will print all outcomes for the next
N games given that results for previous games are stored in the string named str.

                                                                                  

    public s t a t i c void printOutcomes ( S t r i n g s t r , i n t N) {        game
           i f (N = 1 ) { // B a s e c a s e : win , l o s e , o r d r a w o n e
                  System . out . p r i n t l n ( s t r + "W" ) ;                         
                  System . out . println ( s t r + "L" ) ;
                  System . out . p r i n t l n ( s t r + "D" ) ;
           } else { // R e c u r s i v e c a s e
                  printOutcomes ( s t r + "W" , N - 1 ) ;
                  printOutcomes ( s t r + "L" , N - 1 ) ;
                  printOutcomes ( s t r + "D" , N - 1 ) ;
           } // e l s e

   }// p r i n t O u t c o m e s ( )


SOLUTION 12.13

                                                                                  

public s t a t i c void main ( S t r i n g args [ ] ) {

   int numbers [ ] = {0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18};

   S e a r c h e r s e a r c h e r = new S e a r c h e r ( ) ;

   f o r ( i n t k = 0 ; k <= 2 0 ; k++) {

   i nt r e s u l t = searcher . search ( numbers , k ) ;

   i f ( r e s u l t != -1)

         System . out . println ( k + " found at " + re su l t ) ;

   else

         System . out . println (k + " i s not in the array " ) ;

   } // f o r

} // main ( )

                                                                                  
                                    586                         CHAPTER 12  Recursive Problem Solving

                                    SOLUTION 12.14 The sort() method is used as a public interface to the recur-

                                    sive selectionSort() method:

                                                                                                                            

                                    / s o r t ( a r r ) s o r t s t h e i n t array , a r r

                                        Pre : arr is not null

                                        P o s t : a r r w i l l b e a r r a n g e d s o t h a t a r r [ j ] <= a r r [ k ]

                                            for any j < k

                                       /

                                    public void sort ( int arr [ ] ) {
                                           selectionSort ( arr , arr . length - 1);

                                            // J u s t c a l l t h e r e c u r s i v e method

Level 4                             }

                                                                                                                            

                                    SOLUTION 12.15 An iterative version of findMax():

                                                                                                                            

                                       / findMax ( arr , N) r e t u r n s t h e i n d e x o f t h e l a r g e s t

                                          v a l u e b e t w e e n a r r [ 0 ] a n d a r r [ N ] , N >= 0 .

                                          P r e : 0 <= N <= a r r . l e n g t h -1

                                          Post : a r r [ findMax ()] >= a r r [ k ] f o r k between 0 and N.

                                         /

Level 5                             p r i v a t e i n t findMax ( i n t a r r [ ] , i n t N) {

                                            int maxSoFar = 0 ;

                                            f o r ( i n t k = 0 ; k <= N; k++)

Figure 12.34: Levels four and five                 i f ( arr [ k ] > arr [ maxSoFar ] )
of the nested boxes pattern.                              maxSoFar = k ;

                                            return maxSoFar ;

                                    } // findMax ( )

                                                                                                                            

                                    SOLUTION 12.16 Levels four and five of the nested boxes pattern are shown in
                                    Figure 12.34.

                                    SOLUTION 12.17 The following method will reduce the length of the side by
                                    delta percent at each level of recursion. The spacing between the boxes will vary
                                    by a constantly decreasing amount.

                                                                                                                            

                                    private void drawBoxes ( Graphics g , int level , int locX ,
                                                                      int locY , int side , int delta ) {

                                          g . drawRect ( locX , locY , side , side ) ;
                                           if ( level > 0) {

                                              int dside = side  delta / 100; // P e r c e n t d e l t a
                                              i n t newLocX = locX + dside ;
                                              i n t newLocY = locY + dside ;
                                              drawBoxes ( g , l e v e l - 1 , newLocX , newLocY ,

                                                                                 side - 2  dside , delta ) ;
                                           }

                                    } // drawBoxes ( )

                                                                                                                            
CHAPTER 12  Exercises                                                      587
                                                                                    Figure 12.35: Levels two and three
                                                                                    of the Sierpinski gasket.

SOLUTION 12.18

                                                                            

private void drawBoxesIterative ( Graphics g , int level ,

   int locX , int locY , int side , int delta ) {

  f o r ( i n t k = l e v e l ; k >= 0 ; k--) {

   g . drawRect ( locX , locY , side , side ) ; // Draw a s q u a r e

   locX += d e l t a ;        // C a l c u l a t e new l o c a t i o n

   locY += d e l t a ;

   s i d e -= 2  d e l t a ;  // C a l c u l a t e new s i d e l e n g t h

}

} // drawBoxes ( )

                                                                            

SOLUTION 12.19 The level two and three gaskets are shown in Figure 12.35.

SOLUTION 12.20 The printReverse() method is not tail recursive because
in that method the recursive call is not the last statement executed.

SOLUTION 12.21 The countChar() method is tail recursive. The recursive
calls are not the last statements in the method definition. However, each of the
recursive calls would be the last statement executed by the method.

EXERCISE 12.1 Explain the difference between the following pairs of terms:        EXERCISES
a. Iteration and recursion.
b. Recursive method and recursive definition.                                     Note: For programming exercises,
c. Base case and recursive case.                                                  first draw a UML class diagram
d. Head and tail.                                                                 describing all classes and their
e. Tail and nontail recursive.                                                    inheritance relationships and/or
                                                                                  associations.
EXERCISE 12.2 Describe how the method call stack is used during a method call
and return.

EXERCISE 12.3 Why is a recursive algorithm generally less efficient than an
iterative algorithm?

EXERCISE 12.4 A tree, such as a maple tree or pine tree, has a recursive struc-
ture. Describe how a tree's structure displays self-similarity and divisibility.

EXERCISE 12.5 Write a recursive method to print each element of an array of
double.

EXERCISE 12.6 Write a recursive method to print each element of an array of
double from the last to the first element.

EXERCISE 12.7 Write a recursive method that will concatenate the elements of
an array of String into a single String delimited by blanks.
588                      CHAPTER 12  Recursive Problem Solving

EXERCISE 12.8 Write a recursive method that is passed a single int parameter,
N  0, and prints all the odd numbers between 1 and N.

EXERCISE 12.9 Write a recursive method that takes a single int parameter
N  0 and prints the sequence of even numbers between N down to 0.

EXERCISE 12.10 Write a recursive method that takes a single int parameter
N  0 and prints the multiples of 10 between 0 and N.

  EXERCISE 12.11  Write a recursive method to print the following geometric
  pattern:                                                                                

                                                                                          
  #
  ##
  ###
  ####
  #####


EXERCISE 12.12 Write recursive methods to print each of the following
patterns.

                               

########             ########

  #######            #######

     ######          ######

     #####           #####

     ####            ####

     ###             ###

     ##              ##

                  #  #         

EXERCISE 12.13 Write a recursive method to print all multiples of M up to
M * N.

EXERCISE 12.14 Write a recursive method to compute the sum of grades stored
in an array.

EXERCISE 12.15 Write a recursive method to count the occurrences of a sub-
string within a string.

EXERCISE 12.16 Write a recursive method to remove the HTML tags from a
string.

EXERCISE 12.17 Implement a recursive version of the Caesar.decode()
method from Chapter 8.

EXERCISE 12.18 The Fibonacci sequence (named after the Italian mathemati-
cian Leonardo of Pisa, ca. 1200) consists of the numbers 0,1,1,2,3,5,8,13,...
in which each number (except for the first two) is the sum of the two preced-
ing numbers. Write a recursive method fibonacci(N) that prints the first N
Fibonacci numbers.

EXERCISE 12.19 Write a recursive method to rotate a String by N characters
to the right. For example, rotateR("hello", 3) should return "llohe."

EXERCISE 12.20 Write a recursive method to rotate a String by N characters
to the left. For example, rotateL("hello", 3) should return "lohel."
CHAPTER 12  Exercises         589

EXERCISE 12.21 Write a recursive method to convert a String representing a
binary number to its decimal equivalent. For example, binTodecimal("101011")
should return the int value 43.

EXERCISE 12.22 A palindrome is a string that is equal to its reverse--"mom,"
"i," "radar" and "able was i ere i saw elba." Write a recursive boolean method
that determines whether its String parameter is a palindrome.

EXERCISE 12.23 Challenge: Incorporate a drawBinaryTree() method into               Figure 12.36: A level-four binary
the RecursivePatterns program. A level-one binary tree has two branches.           tree pattern.
At each subsequent level, two smaller branches are grown from the endpoints of
every existing branch. The geometry is easier if you use 45-degree angles for the
branches. Figure 12.36 shows a level-four binary tree drawn upside down.

EXERCISE 12.24 Challenge: Towers of Hanoi. According to legend, some Bud-          A  B  C
dhist monks were given the task of moving 64 golden disks from one diamond
needle to another needle, using a third needle as a backup. To begin with, the
disks were stacked one on top of the other from largest to smallest (Fig. 12.37).
The rules were that only one disk can be moved at a time and that a larger disk
can never go on top of a smaller one. The end of the world was supposed to occur
when the monks finished the task!

    Write a recursive method, move(int N, char A, char B, char C), that
will print out directions the monks can use to solve the towers of Hanoi problem.
For example, here's what it should output for the three-disk case, move(3, "A",
"B", "C"):

                               

Move 1 d i s k from A t o B .                                                      Figure 12.37: The towers of Hanoi
                                                                                   problem. Move all the disks from
Move 1 d i s k from A t o C .                                                      needle A to needle B. Only one
                                                                                   disk can be moved at a time, and
Move 1 d i s k from B t o C .                                                      a larger disk can never go on top
                                                                                   of a smaller one.
Move 1 d i s k from A t o B .

Move 1 d i s k from C t o A.

Move 1 d i s k from C t o B .

Move 1 d i s k from A t o B .
                               
590  CHAPTER 12  Recursive Problem Solving
Chapter 13

Graphical User Interfaces

OBJECTIVES

After studying this chapter, you will
 Gain more experience with the Swing component set.
 Understand the relationship between the AWT and Swing.
 Learn more about Java's event model.
 Be able to design and build useful Graphical User Interfaces (GUIs).
 Appreciate how object-oriented design principles were used to extend Java's GUI capabilities.

OUTLINE

13.1 Introduction
13.2 Java GUIs: From AWT to Swing
13.3 The Swing Component Set
13.4 Object-Oriented Design: Model-View-Controller Architecture
13.5 The Java Event Model
13.6 Case Study: Designing a Basic GUI
13.7 Containers and Layout Managers
13.8 Checkboxes, Radio Buttons, and Borders
13.9 Menus and Scroll Panes

         Special Topic: Are Computers Intelligent?
          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              591
                                   592                               CHAPTER 13  Graphical User Interfaces

                                   13.1  Introduction

                                   As we have seen, a Graphical User Interface (GUI) creates a certain way of
                                   interacting with a program. It is what gives a program its look and feel.
                                   In preceding chapters, we have already used the basic components from
                                   which GUIs are created, including buttons, text fields, labels, and text
                                   areas. Throughout this chapter, we will focus on designing and build-
                                   ing GUIs that are easy for users to navigate. However, Java's GUI li-
                                   braries are so large that we will concentrate on only a handful of addi-
                                   tional components, including containers, check boxes, radio buttons, and
                                   menus.

                                      We will try to identify design principles that can be applied to the de-
                                   sign of more advanced interfaces. Also, because Java's GUI classes pro-
                                   vide an excellent example of object-oriented design, we will highlight
                                   some of the important design decisions and principles that have influ-
                                   enced the development of Java's GUI classes in both the AWT and Swing.
                                   Let's begin with a brief history Java's GUI libraries.

                                   13.2 Java GUIs: From AWT to Swing

java.sun.com/j2se/1.5.0/docs/api/  EVER SINCE THE RELEASE of version 1.2 of the Java Development Kit
                                   (JDK) in 2000, Java has contained two distinct libraries of GUI compo-
                                   nents. The Abstract Windowing Toolkit (AWT) has been part of Java since
                                   the original 1.0 version of the JDK 1.0. The more advanced Swing compo-
                                   nent set was first introduced in JDK 1.1 and was extensively revised in JDK
                                   1.2.

                                      Although the original version of the AWT was suitable for developing
                                   Java applets, it wasn't powerful enough to support full-fledged applica-
                                   tions. Commonly used programs, such as word processors and spread-
                                   sheets, have GUI requirements that were just too much for the original
                                   AWT. The main problem was that the AWT was dependent on the under-
                                   lying operating system. That meant that Java GUI programs were forced
                                   to rely on GUI elements that were part of the underlying operating system.
                                   A Java GUI program running on a Windows platform had to depend on
                                   Windows code for implementations of its buttons and text fields. A Java
                                   program running on Unix depended upon underlying Unix code for its
                                   GUI components. Such dependence on the underlying operating system
                                   made the AWT less portable and less efficient.

                                      In contrast, the Swing GUI components are part of the Java Foundation
                                   Classes (JFC), a collection of classes that do not depend as much on the
                                   underlying platform. The Swing library makes it possible to write GUI
                                   programs entirely in Java. Because they are rendered entirely by Java
                                   code, Swing components make it possible to design GUIs that are truly
                                   platform independent. Such programs are much more portable than those
                                   which rely on AWT components and the underlying platform. A program
                                   that uses Swing components will have the same look and feel on a Mac,
                                   Windows, or Unix platform.
SECTION 13.2  Java GUIs: From AWT to Swing                593
                                                                   Figure 13.1: Swing classes, part
         java.lang                                                 1: Relationship between the AWT
                     Object                                        and the top-level Swing win-
                                                                   dows. REVISION: JWindow ex-
                                                                   tends Window.

java.awt                          Frame      javax.swing
        Component                 Dialog          JFrame
                                                  JDialog
         Container
                         Window               JWindow
                           Panel

java.applet                                  JApplet
               Applet

13.2.1 Heavyweight Versus Lightweight Components                               The AWT peer model
                                                                               Lightweight components
AWT components are based on the peer model, a design in which every
AWT component has a corresponding class (a peer) written in the underly-
ing system's code. For example, the java.awt.Button class has a peer
named java.awt.peer.Button. The peer class serves as the interface
between the Java code and the computer's underlying windowing system.
The methods in the peer class are written in so-called native code-that is,
the non-Java code of the underlying operating system. Therefore, AWT
components are inherently platform dependent.

   AWT components are called heavyweight because they depend on the
native (peer) system for their drawing and rendering. Since every AWT
component has an associated peer component, a Java AWT component
would look just like the peer component. This is why an AWT button on
a Windows platform looks just like a Windows button. In effect, the AWT
button, via its peer, creates and uses a Windows button. When you change
the Java button's label, it must call a method in the peer class that changes
the label of the peer button. This interaction between Java and the native
windowing system requires a good deal of overhead, thereby affecting the
overall efficiency of the system.

   By contrast, a lightweight component is one that is written entirely
in Java. Instead of depending on a native component for its rendering,
a lightweight component is drawn and rendered entirely by Java code.
Because they do not depend on underlying system code, Swing com-
ponents are more efficient and more portable than corresponding AWT
components.

   Figures 13.1 and 13.2 show the relationship between AWT and Swing
classes. The top-level Swing classes--the JApplet, JDialog, JFrame,
and JWindow--are direct subclasses of their corresponding AWT coun-
terparts. These are the top-level GUI windows. The remaining Swing
Figure 13.2: Swing classes, part  594                             CHAPTER 13  Graphical User Interfaces
2: Swing GUI components are de-
rived from the JComponent class.       java.lang     java.awt
                                             Object   Component

                                                                 Container  JToggleButton   JCheckbox
                                                                              JButton      JRadioButton
                                  javax.swing
                                            JComponent                      JMenuItem         JMenu

                                                         AbstractButton      JTextArea     JPasswordField
                                                              JList          JTextField

                                                         JOptionPane
                                                         JPopupMenu
                                                         JTextComponent
                                                          JMenuBar
                                                         JScrollPane

                                                             JLabel
                                                             JPanel

                                  components (Fig. 13.2) are subclasses of java.awt.Component and
                                  java.awt.Container. As you can see, the names of Swing and AWT
                                  components are very similar. Swing components that have corresponding
                                  AWT components have names that begin with "J."

                                     One might think that because Swing components are superior to their
                                  AWT counterparts, the AWT package will eventually be dropped. How-
                                  ever, this is not likely. Even if a Java program uses Swing components
                                  exclusively, that will still not break the dependence on the AWT.

                                     There are several reasons for this dependence. First, Swing's top-level
                                  window classes--JApplet, JDialog, JFrame, and JWindow--are de-
                                  fined as extensions to their AWT counterparts. This means that Swing-
                                  based GUIs are still dependent on the AWT. Java programs need to have
                                  some way to map their windows to the windowing system used on the
                                  native (Windows, Unix, or Macintosh) platform. The AWT's top-level
                                  windows--Window, Frame, Dialog, and Panel--provide that map-
                                  ping.

                                     Second, the JComponent class, which is the basis for all Swing com-
                                  ponents, is derived from java.awt.Container. There are many more
                                  such dependencies. Fundamentally, Swing components are based on the
                                  AWT.

                                     Finally, all GUI applications and applets use layout managers (java.-
                                  awt.FlowLayout), fonts (java.awt.Font), colors ( java.awt.Color),
                                  and other non-component classes that are defined in the AWT. There is
                                  just no way to design a GUI without using AWT classes. Therefore, the
SECTION 13.3  The Swing Component Set                              595

programs presented in this and subsequent chapters will use Swing com-
ponents instead of corresponding AWT components, but they also will
use layouts and other elements from the AWT.

JAVA PROGRAMMING TIP Swing Documentation. Complete
documentation of the Swing classes is available for downloading or
browsing on Sun's Web site at

http://java.sun.com/reference/api/index.html

13.3 The Swing Component Set

Java's Swing components are defined in a collection of packages named
javax.swing.*, which is imported by the code shown in this and sub-
sequent chapters. Swing packages include the following:

                                                                             

javax . swing . event .

javax . swing . text .

javax . swing . plaf .
                                                                             

The javax.swing.event package defines the various Swing events and           Look and feel
their listeners, such as the MenuEvent and the MenuListener. (In the
AWT, the AWT events and listeners were defined in java.awt.event.)

   The javax.swing.text package contains the classes for JTextField
and JTextComponent. The Swing text components are more complex
than their AWT counterparts. For example, one of their important features
is the ability to undo changes made to the text they contain. This feature
is crucial for building sophisticated word-processing applications.

   The javax.swing.plaf package contains Swing's look-and-feel
classes. The term plaf is an acronym for pluggable look and feel. It refers
to the fact that changing an application's look and feel is a simple matter
of "plugging in" a different plaf model. Changing how a program looks
does not change what it does.

   Swing's platform-independent look and feel is achieved by placing all
the code responsible for drawing a component in a class that is separate
from the component itself. For example, in addition to JButton, the class
that defines the button control, there will be a separate class responsible
for drawing the button on the screen. The drawing class will control the
button's color, shape, and other characteristics of its appearance.

   There are several look-and-feel packages built into Swing. For exam-
ple, the javax.swing.plaf.motif package contains the classes that
implement the Motif interface, a common Unix-based interface. The
javax.swing.plaf.windows packages contains classes that support a
Windows look and feel, and the javax.swing.plaf.metal package
provides classes that support the Metal interface, a Java look and feel.
These classes know how to draw each component and how to react to
mouse, keyboard, and other events associated with these components.
                                                 596                                             CHAPTER 13  Graphical User Interfaces
Figure 13.3: The model-view- con-
troller architecture.                                                             User Interface (UI)         View    Look
                                                                                                                       and
                                                                        Mouse        Controller            Outward     feel
                                                                        Keyboard                          appearance
                                                                        Events        Behavior
                                                                                      monitor
                                                                        Java
                                                                        Method    Change           State
                                                                        Calls      state         changed

                                                                                        Model     event

                                                                                       Internal
                                                                                         state

View        13.4 OBJECT-ORIENTED DESIGN:
Model
Controller          Model-View-Controller Architecture

            Java's Swing components have been implemented using an object-
            oriented design known as the model-view-controller (MVC) model. Any
            Swing component can be considered in terms of three independent as-
            pects: what state it's in (its model), how it looks (its view), and what it
            does (its controller).

               For example, a button's role is to appear on the interface waiting to
            be clicked. When it is clicked, the button's appearance changes. It looks
            pushed in or it changes color briefly, and then it changes back to its orig-
            inal (unclicked) appearance. In the MVC model, this aspect of the button
            is its view. If you were designing an interface for a button, you would
            need visual representations for both the clicked and the unclicked button
            (as well as other possible states).

               When you click a button, its internal state changes from pressed to un-
            pressed. You've also probably seen buttons that were disabled--that is,
            in a state where they just ignore your clicks. Whether a button is enabled
            or disabled and whether it is pressed or not are properties of its internal
            state. Taken together, such properties constitute the button's model. Of
            course, a button's view--how it looks--depends on its model. When a
            button is pressed, it has one appearance, and when it is disabled, it has
            another.

               Because a button's state will change when it is clicked or when it is
            enabled by the program, some object needs to keep track of these changes.
            That part of the component is its controller.

               Figure 13.3 shows how the button's model, view, and controller inter-
            act with each other. Suppose the user clicks the button. This action is
            detected by the controller. Whenever the mouse button is pressed, the
            controller tells the model to change into the pressed state. The model, in
            turn, generates an event that is passed to the view. The event tells the view
            that the button needs to be redrawn to reflect its change in state.

               When the mouse button is released, a similar sequence of events occurs.
            The model is told to change to the unpressed state. It in turn generates an
            event, handled by the view, which changes the button's appearance.
SECTION 13.4  OBJECT-ORIENTED DESIGN:Model-View-Controller Architecture 597

   A change in the button's appearance does not necessarily depend on di-
rect action by the user. For example, the program itself could call a method
that disables the button. In this case, the program issues a command
directly to the model, which in turn generates an event that causes the
view to change the object's appearance.

   For some Swing components, such as the text components, this three-
part model is implemented almost exactly as we just described. For others,
such as JButton, one class is used to implement both the view and the
controller. The JButton model is defined in the DefaultButtonModel
class, and its view and controller are defined in the BasicButtonUI class
(The UI acronym stands for User Interface). The point is that for some
components, Swing has organized the view and control--the look and the
feel--into a single class.

13.4.1 Pluggable Look and Feel

The MVC model uses a clear division of labor to implement a GUI com-
ponent. The main advantage of this design is the independence between
the model, the view, and the controller. If you want to give a button a
different look and feel, you can redefine its view and its controller.

   By combining the view and controller into a single class, Swing makes
it even easier to change a component's look and feel. For example, to
design your own look and feel for a JButton, you would define a class
that implemented all of the methods in the BasicButtonUI. Of course,
this is a job for an experienced software developer.

   However, if you just want to set your program to use one of the pre-
defined look and feel models, you can simply use the UIManager.set-
LookAndFeel() method:

                                                                              

public s t a t i c void main ( S t r i n g args [ ] ) {
   try{
        UIManager . setLookAndFeel (
              " javax . swing . plaf . metal . MetalLookAndFeel" ) ;
   }catch ( Exception e) {
        System . out . err ( "Exception : " + e . getMessage ( ) ) ;
   }

}// main ( )

                                                                              

   Java's default, the Metal look and feel, has been designed specifically for
Java applications. For a Windows look, you can use the following argu-
ment: com.sun.java.swing.plaf.windows.WindowsLookAndFeel.

Figure 13.4 shows how the simple application would appear under the
three different look-and-feel styles.

SELF-STUDY EXERCISE                                                             Figure 13.4: The same Java appli-
                                                                                cation using the Motif, Windows,
EXERCISE 13.1 The MVC architecture is a model of object-oriented de-            and Metal look and feel.
sign. But if a JButton is really composed of three separate parts, how can
we still call it a component? Isn't it really three things?
                                                598                               CHAPTER 13  Graphical User Interfaces

                                                13.5  The Java Event Model

                                                As we saw in Chapter 4, whatever happens while the computer is running
                                                is classified as an event. Every keystroke and mouse click, every time a
                                                disk is inserted into a disk drive, an event is generated. The handling of
                                                events are an important element of GUI programming. Therefore, before
                                                we begin discussing how to design GUIs, it will be useful to review the
                                                main concepts of Java's event model.

                                                   When a Java program is running, events generated by the hardware
                                                are passed up through the operating system (and through the browser, for
                                                applets) to the program. Those events that belong to the program must
                                                be handled by the program (refer to Fig. 4.18 in Chapter 4). For example,
                                                if you click your browser's menu bar, that event will be handled by the
                                                browser itself. If you click a button contained in the Java program, that
                                                event should be handled by the program.

                                                   In Java, whenever something happens within a GUI component, an
                                                event object is generated and passed to the event listener that has been
                                                registered to handle that component's events. You've seen numerous ex-
                                                amples of this process in earlier chapters, but we've included a simple
                                                example to serve as a reminder.

                                                   Suppose you create a JButton in a GUI as follows:

                                                                                                                                 

                                                p r i v a t e J B u t t o n c l i c k m e = new J B u t t o n ( " ClickMe " ) ;
                                                                                                                                 

                                                Whenever the user clicks the JButton, an ActionEvent is generated.
                                                In order to handle these events, the GUI must register the JButton with
                                                a listener object that listens for action events. This can be done in an ap-
                                                plet's init() method or in an application's constructor method, as in this
                                                example:

                                                                                                                                 

                                                public MyGUI ( ) {

                                                   // Add c l i c k m e t o t h e GUI and a s s i g n i t a l i s t e n e r

                            > Listener             add ( clickme ) ;
  clickme : JButton
                                                   clickme . addActionListener ( this ) ;
                                    : MyApplet
                                                }
Figure 13.5: The GUI listens for
action events on the JButton.                                                                                                    

                                                In this case, we have designated the GUI itself (this) as an ActionListener
                                                for clickme (Fig. 13.5). A listener is any object that implements a listener
                                                interface, which is one of the interfaces derived from java.util.Event-
                                                Listener. An ActionListener is an object that listens for and receives
                                                ActionEvents.
SECTION 13.5  The Java Event Model                                                     599

   In order to complete the event-handling code, the GUI must imple-
ment the ActionListener interface. As Figure 13.6 shows, implement-
ing an interface is a matter of declaring the interface in the class heading
and implementing the methods contained in the interface, in this case the
actionPerformed() method.

                                                                                        

import javax . swing .  ;
import java . awt . event .  ;

public c l a s s MyGUI extends JFrame
                                                      implements ActionListener {

       p r i v a t e J B u t t o n c l i c k m e = new J B u t t o n ( " ClickMe " ) ;

  public MyGUI ( ) {

     // Add c l i c k m e t o t h e GUI and a s s i g n i t a l i s t e n e r

     getContentPane ( ) . add ( clickme ) ;

     clickme . addActionListener ( this ) ;

     setSize (200 ,200);

     setVisible ( true );

  } // i n i t ( )

  public void actionPerformed ( ActionEvent e ) {

     i f ( e . g e t S o u r c e ( ) == c l i c k m e ) {

            clickme . setText ( clickme . getText ()+"" ) ;

     }

  } // a c t i o n P e r f o r m e d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

     MyGUI gui = new MyGUI ( ) ;

  }

} // MyGUI

                                                                                        

Figure 13.6: A simple GUI application that handles action events on a
JButton.

   Now that we have implemented the code in Figure 13.6, whenever the
user clicks clickme, that action is encapsulated within an ActionEvent
object and passed to the actionPerformed() method. This method
contains Java code that will handle the user's action in an appropriate
way. For this example, it modifies the button's label by appending an
asterisk to it each time it is clicked. Figure 13.7 depicts the sequence of
actions and events that occur when the the user clicks a button.
Figure 13.7: A UML depiction of      600                           CHAPTER 13  Graphical User Interfaces
the sequence of actions and events
that take place when a button is                clickMe : JButton   : ActionEvent
clicked. The vertical lines repre-
sent time lines, with time running     User                        jvm : JVM  Object1 : MyApplet
from top to bottom. The arrows              Click
between lines represent messages
passing between objects.                           ClickEvent
                                                                        create()

                                                                  actionPerformed(e:ActionEvent)

                                                                                                  showStatus(s:String)

                   EventObject          The methods used to handle the ActionEvent are derived from the
                                     java.util.EventObject class, the root class for all events (Fig. 13.8).
      +EventObject(in src : Object)  Our example (Fig. 13.6) uses the getSource() method to get a reference
      +getSource() : Object          to the object that generated the event. To see what information is con-
      +toString() : String           tained in an event object, we can use the toString() method to print
                                     a string representation of the event that was generated. Here's what it
Figure 13.8: An EventObject.         displays:
The getSource() method is
used to get the object that caused                                                                                      
the event.
                                     j a v a . awt . event . ActionEvent [ACTION PERFORMED, cmd=ClickMe ]

                                       on javax . swing . JButton [ , 5 8 , 5 , 8 3 x27 ,

                                       layout=javax . swing . OverlayLayout ]                                           

                                     As you can see, the event generated was an ACTION PERFORMED event,
                                     in response to the ClickMe command. The source of the event was the
                                     JButton.

                                     13.5.1 Event Classes

                                     Although the event model is the same for both AWT and Swing classes,
                                     the Swing package introduces many additional events. Table 13.1 lists
                                     the events that are generated by both AWT and Swing components. You
                                     already have worked with some of these. We have written GUIs that
                                     handled ActionEvents for JButtons and JTextFields in preceding
                                     chapters.

                                        In viewing Table 13.1, it's important to remember that the classes listed
                                     there are arranged in a hierarchy. This will affect the events that a par-
                                     ticular object can generate. For example, a JButton is a JComponent
                                     (Fig. 13.2), so in addition to generating ActionEvents when the user
                                     clicks on it, it can also generate MouseEvents when the user moves the
                                     mouse over it. Similarly, because a JTextField is also a JComponent, it
                                     can generate KeyEvents as well as ActionEvents.

                                        Note that the more generic events, such as those that involve moving,
                                     focusing, or resizing a component, are associated with the more generic
                                     components. For example, the JComponent class contains methods that
                                     are used to manage ComponentEvents. Because they are subclasses
                                     of JComponent, JButtons and JTextFields can also use these meth-
SECTION 13.5  The Java Event Model                                   601

TABLE 13.1 Java's AWTEvents for each Component type (Original source: David Flanagan,
            Java in a Nutshell, 2d ed., O'Reilly Associates, 1997. Modified for Swing components.)

Components                             Events                         Description

Button, JButton                        ActionEvent                    User clicked button
CheckBox, JCheckBox                    ItemEvent                      User toggled a checkbox
CheckboxMenuItem, JCheckboxMenuItem    ItemEvent                      User toggled a checkbox
Choice, JPopupMenu                     ItemEvent                      User selected a choice
Component, JComponent                  ComponentEvent                 Component was moved or resized
                                       FocusEvent                     Component acquired or lost focus
Container, JContainer                  KeyEvent                       User typed a key
List, JList                            MouseEvent                     User manipulated the mouse
                                       ContainerEvent                 Component added/removed from container
Menu, JMenu                            ActionEvent                    User double-clicked a list item
Scrollbar, JScrollbar                  ItemEvent                      User clicked a list item
TextComponent, JTextComponent          ActionEvent                    User selected menu item
TextField, JTextField                  AdjustmentEvent                User moved scrollbar
Window, JWindow                        TextEvent                      User edited text
                                       ActionEvent                    User typed Enter key
                                       WindowEvent                    User manipulated window

ods. Defining the more generic methods in the JComponent superclass is
another example of the effective use of inheritance.

 JAVA EFFECTIVE DESIGN Inheritance. The higher a method is
 defined in the inheritance hierarchy, the broader is its use.

   Table 13.2 lists events that are new with the Swing classes. Some of
the events apply to new components. For example, JTable and JTree
do not have AWT counterparts. Other events provide Swing components
with capabilities that are not available in their AWT counterparts. For ex-
ample, a CaretEvent allows the programmer to have control over mouse
clicks that occur within a text component.

TABLE 13.2 Some of the events that are defined in the Swing library.

Component       Events                 Description
JPopupMenu
JComponent      PopupMenuEvent         User selected a choice
JList           AncestorEvent          An event occurred in an ancestor
                ListSelectionEvent     User double-clicked a list item
JMenu           ListDataEvent          List's contents were changed
JTextComponent  MenuEvent              User selected menu item
                CaretEvent             Mouse clicked in text
JTable          UndoableEditEvent      An undoable edit has occurred
                TableModelEvent        Items added/removed from table
JTree           TableColumnModelEvent  A table column was moved
                TreeModelEvent         Items added/removed from tree
JWindow         TreeSelectionEvent     User selected a tree node
                TreeExpansionEvent     User expanded or collapsed a tree node
                WindowEvent            User manipulated window
602  CHAPTER 13  Graphical User Interfaces

   Tables 13.1 and 13.2 provide only a brief summary of these classes and
Swing components. For further details you should consult the JDK online
documentation at

                                                                            

h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/a p i/
                                                                            

SELF-STUDY EXERCISES

EXERCISE 13.2 Is it possible to register a component with more than
one listener?

EXERCISE 13.3 Is it possible for a component to have two different
kinds of listeners?

13.6 CASE STUDY: Designing a Basic GUI

What elements make up a basic user interface? If you think about all of
the various interfaces you've encountered--and don't just limit yourself
to computers--they all have the following elements:

 Some way to provide help/guidance to the user.
 Some way to allow input of information.
 Some way to allow output of information.
 Some way to control the interaction between the user and the device.

Think about the interface on a beverage machine. Printed text on the ma-
chine will tell you what choices you have, where to put your money, and
what to do if something goes wrong. The coin slot is used to input money.
There's often some kind of display to tell you how much money you've
inserted. And there's usually a bunch of buttons and levers that let you
control the interaction with the machine.

   These same kinds of elements make up the basic computer interface.
Designing a Graphical User Interface is primarily a process of choos-
ing components that can effectively perform the tasks of input, output,
control, and guidance.

 JAVA EFFECTIVE DESIGN User Interface. A user interface must
 effectively perform the tasks of input, output, control, and guidance.

   In the programs we designed in the earlier chapters, we used two dif-
ferent kinds of interfaces. In the command-line interface, we used printed
prompts to inform the user, typed commands for data entry and user
control, and printed output to report results. Our GUI interfaces used
JLabels to guide and prompt the user, JTextFields and JTextAreas
as basic input and output devices, and either JButtons or JTextFields
for user control.

   Let's begin by building a basic GUI in the form of a Java applica-
tion. To keep the example as close as possible to the GUIs we've already
used, we will build it out of the following Swing components: JLabel,
JTextField, JTextArea, and JButton.
SECTION 13.6  CASE STUDY: Designing a Basic GUI  603

13.6.1 The Metric Converter Application

Suppose the coach of the cross-country team asks you to write a Java ap-                     MetricConverter
plication that can be used to convert miles to kilometers. The program        +milesToKm(in mi : double) : double
should let the user input a distance in miles, and the program should
report the equivalent distance in kilometers.                                 Figure  13.9:                 The

   Before we design the interface for this, let's first define a Metric-      MetricConverter class has
Converter class that can be used to perform the conversions (Fig. 13.9).
For now at least, this class's only task will be to convert miles to kilo-     a single method to convert miles
meters, for which it will use the formula that 1 kilometer equals 0.62        쮝o kilometers.
miles:
                                                                              
 
                                                                              
    public class MetricConverter {                                            
           public s t a t i c double milesToKm ( double miles ) {
                  return miles / 0.62;
           }

    }
 

Note that the method takes a double as input and returns a double.
Also, by declaring the method static, we make it a class method, so it
can be invoked simply by

 

    MetricConverter . milesToKm ( 1 0 ) ;
 

Choosing the Components                                                       Which components do we need?

Let's now design a GUI to handle the interaction with the user. First, let's
choose Swing components for each of the four interface tasks of input,
output, control, and guidance. For each component, it might be useful to
refer back to Figure 13.2 to note its location in the Swing hierarchy.

 A JLabel is a display area for a short string of text, an image, or both.
  Its AWT counterpart, the Label, cannot display images. A JLabel
  does not react to input. Therefore, it is used primarily to display a
  graphic or small amounts of static text. It is perfectly suited to serve
  as a prompt, which is what we will use it for in this interface.

 A JTextField is a component that allows the user to edit a single line
  of text. It is identical to its AWT counterpart, the TextField. By using
  its getText() and setText() methods, a JTextField can be used
  for either input or output, or both. For this problem, we'll use it to
  perform the interface's input task.

 A JTextArea is a multiline text area that can be used for either input or
  output. It is almost identical to the AWT TextArea component. One
  difference, however, is that a JTextArea does not contain scrollbars
  by default. For this program, we'll use the JTextArea for displaying
  the results of conversions. Because it is used solely for output in this
  program, we'll make it uneditable to prevent the user from typing in it.

 Let's use a JButton as our main control for this interface. By im-
  plementing the ActionListener interface we will handle the user's
  action events.
                                    604  CHAPTER 13  Graphical User Interfaces

                                    Choosing the Top-Level Window

What top-level window to use?       The next issue we must decide is what kind of top-level window to use for
                                    this interface. For applet interfaces, the top-level component would be a
                                    JApplet. For Java applications, you would typically use a JFrame as the
                                    top-level window. Both of these classes are subclasses of Container, so
                                    they are suitable for holding the components that make up the interface
                                    (Fig. 13.1).

                                       Also, as noted earlier, JApplets and JFrames are both examples of
                                    heavyweight components, so they both have windows associated with
                                    them. To display a JFrame we just have to give it a size and make it visi-
                                    ble. Because a frame runs as a stand-alone window, not within a browser
                                    context, it should also be able to exit the application when the user closes
                                    the frame.

How should the components be        Designing a Layout
arranged?
                                    The next step in designing the interface is deciding how to arrange the
                                    components so that they will be visually appealing and comprehensible,
                                    as well as easy to use.

                                       Figure 13.10 shows a design for the layout. The largest component is the
                                    output text area, which occupies the center of the JFrame. The prompt,
                                    input text field, and control button are arranged in a row above the text
                                    area. This is a simple and straightforward layout.

                                       Figure 13.10 also provides a containment hierarchy, also called a wid-
                                    get hierarchy, which shows the containment relationships among the var-
                                    ious components. Although it might not seem so for this simple layout,
                                    the containment hierarchy plays an important role in showing how the
                                    various components are grouped in the interface. For this design, we have
                                    a relatively simple hierarchy, with only one level of containment. All of
                                    the components are contained directly in the JFrame.

Figure 13.10: A design and layout        JFrame JLabel JTextField               JButton  Containment Hierarchy
for the Metric Converter GUI. The              prompt:                     Convert
containment hierarchy (also called                                                       JFrame
a widget hierarchy) shows the con-          JTextArea for displaying file                       Prompt JLabel
tainment relationships among the                                                                Input JTextField
components.                                                                                     Display JTextArea
                                                                                                Convert JButton
SECTION 13.6  CASE STUDY: Designing a Basic GUI                                           605

   Figure 13.11 shows the design of the Converter class, which extends                          JFrame         쳃nterface
the JFrame class and implements the ActionListener interface. As a                                           ActionListener
JFrame subclass, a Converter can contain GUI components. As an im-
plementor of the ActionListener interface, it also will be able to handle                               +actionPerformed()
action events through the actionPerformed() method.
                                                                                                        Converter
   Figure 13.12 gives the implementation of the Converter class. Note
the three packages that are imported. The first contains definitions of the                     -prompt : JLabel
Swing classes, and the other two contain definitions of AWT events and                          -input : JTextField
layout managers that are used in the program.                                                   -display : JTextArea
                                                                                                -convert : JButton
             javax . swing .  ;                                                   
             java . awt .  ;                                                                    +Converter()
  import     java . awt . event .  ;      // P a c k a g e s used                               +actionPerformed()
  import                                                                                        +main()
  import

public class Converter extends JFrame                                                           Figure 13.11: The Converter
                                                  implements ActionListener {                   class is a subclass of
                                                                                                JFrame and implements the
   private JLabel prompt =                                                                      ActionListener interface.
                                new J L a b e l ( " D i s t a n c e i n m i l e s : " ) ;

   p r i v a t e J T e x t F i e l d input = new J T e x t F i e l d ( 6 ) ;
   p r i v a t e JTextArea d i s p l a y = new JTextArea ( 1 0 , 2 0 ) ;
   p r i v a t e J B u t t o n c o n v e r t = new J B u t t o n ( " Convert ! " ) ;

  public Converter () {
     getContentPane ( ) . s e t L a y o u t (new FlowLayout ( ) ) ;
     getContentPane ( ) . add ( prompt ) ;
     getContentPane ( ) . add ( input ) ;
     getContentPane ( ) . add ( convert ) ;
     getContentPane ( ) . add ( display ) ;
     display . setLineWrap ( true ) ;
     display . setEditable ( false );
     convert . addActionListener ( this );

  } // C o n v e r t e r ( )

  public void actionPerformed ( ActionEvent e ) {

  double miles =

             Double . valueOf ( input . getText ( ) ) . doubleValue ( ) ;

  double km = M e t r i c C o n v e r t e r . milesToKm ( m i l e s ) ;

  display . append ( miles + " miles equals " +

                        km + " k i l o m e t e r s \n" ) ;

  } // a c t i o n P e r f o r m e d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  Converter f = new Converter ( ) ;

  f . setSize (400 , 300);

  f . setVisible ( true );

  f . addWindowListener (new WindowAdapter ( ) {

          public void windowClosing ( WindowEvent e ) {

             System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

          }

  });

  } // main ( )

} // C o n v e r t e r

                                                                                           

Figure 13.12: The Converter class implements a simple GUI interface.
606            CHAPTER 13  Graphical User Interfaces

   We have to do all initializing tasks in the constructor. First, we have to
set the JFrame's layout to FlowLayout. A layout manager is the object
that is responsible for sizing and arranging the components in a container
so that the elements are organized in the best possible manner. A flow
layout is the simplest arrangement: The components are arranged left to
right in the window, wrapping around to the next "row" if necessary.

   Second, note the statements used to set the layout and to add compo-
nents directly to the JFrame. Instead of adding components directly to
the JFrame, we must add them to its content pane:

                                                                                            

getContentPane ( ) . add ( input ) ;
                                                                                            

A content pane is a JPanel that serves as the working area of the
JFrame. It contains all of the frame's components. Java will raise an
exception if you attempt to add a component directly to a JFrame.

JAVA DEBUGGING TIP Content Pane A JFrame cannot directly
contain GUI elements. Instead, they must be added to its content pane,
which can be retrieved using the getContentPane() method.

The JFrame and all the other top-level Swing windows have an inter-
nal structure made up of several distinct objects that can be manipulated
by the program. Because of this structure, GUI elements can be orga-
nized into different layers within the window to create many types of
sophisticated layouts. Also, one layer of the structure makes it possible
to associate a menu with the frame.

   Finally, note how the Converter frame is instantiated, made visible,
and eventually exited in the application's main() method:

                                                                                            

public s t a t i c void main ( S t r i n g args [ ] ) {
     Converter f = new Converter ( ) ;
     f . setSize (400 , 300);
     f . setVisible ( true );
     f . addWindowListener (new WindowAdapter ( ) {

                                                    // Q u i t t h e a p p l i c a t i o n

          public void windowClosing ( WindowEvent e ) {
                 System . exit ( 0 ) ;

          }

     });

} // main ( )

                                                                                            

It is necessary to set both the size and visibility of the frame, since these
are not set by default. Because we are using a FlowLayout, it is especially
important to give the frame an appropriate size. Failure to do so can cause
the components to be arranged in a confusing way and might even cause
some components to not appear in the window. These are limitations we
will fix when we learn how to use some of the other layout managers.

13.6.2 Inner Classes and Adapter Classes

In this section we introduce two new language features, inner classes and
adapter classes, which are used in the main() method shown above to
SECTION 13.6  CASE STUDY: Designing a Basic GUI  607

handle the closing of the Converter application's window when the              
program is exited:
                                                                               
                                                                                Inner classes

      f . addWindowListener (new WindowAdapter ( ) {
                 public void windowClosing ( WindowEvent e ) {
                        System . exit ( 0 ) ;
                }

      });
 

This code segment provides a listener that listens for window closing
events. When such an event occurs, it exits the application by calling
System.exit().

   The syntax used here is an example of an anonymous inner class. An
inner class is a class defined within another class. The syntax is some-
what ugly, because it places the class definition right where a reference
to a window listener object would go. In effect what the code is doing is
defining a subclass of WindowAdapter and creating an instance of it to
serve as a listener for window closing events.

   Anonymous inner classes provide a useful way of creating classes and
objects on the fly to handle just this kind of listener task. The syntax used
actually enables us to write one expression that both defines a class and
creates an instance of it to listen for window closing events. The new
subclass has local scope limited here to the main() method. It is anony-
mous, meaning we aren't even giving it a name, so you can't create other
instances of it in the program. Note that the body of the class definition is
placed right after the new keyword, which takes the place of the argument
to the addWindowListener() method. For more details on the inner
and anonymous classes, see Appendix F.

JAVA LANGUAGE RULE Inner Class. An inner class is a class de-
fined within another class. Inner classes are mostly used to handle a
task that supports the work of the containing class.

   An adapter class is a wrapper class that implements trivial versions of      Adapter class
the abstract methods that make up a particular interface. (Remember from
Chapter 4 that a wrapper class contains methods for converting primitive       
data into objects and for converting data from one type to another.)           

   The WindowAdapter class implements the methods of the Window-
Listener interface. When you implement an interface, such as
ActionListener, you must implement all the abstract methods de-
fined in the interface. For ActionListener there's just one method, the
actionPerformed() method, so we can implement it as part of our ap-
plet or frame class. However, we want to use only one of the seven meth-
ods available in the WindowListener interface, the windowClosing()
method, which is the method implemented in the anonymous inner class:

 

    public void windowClosing ( WindowEvent e ) {
           System . exit ( 0 ) ;

    }
 
608  CHAPTER 13  Graphical User Interfaces

The WindowAdapter is defined simply as

                                                                            

public a b s t r a c t c l a s s WindowAdapter
                                               implements WindowListener {

       public void windowActivated ( WindowEvent e ) {}
       public void windowClosed ( WindowEvent e ) {}
       ...

     // F i v e o t h e r window l i s t e n e r methods

}

                                                                            

Note that each method is given a trivial implementation (). To create a
subclass of WindowAdapter, you must override at least one of its trivially
implemented methods.

   Another way to manage the application's window closing event is to
define a subclass of WindowAdapter:

                                                                            

import javax . swing .  ;
import java . awt .  ;
import java . awt . event .  ;
public c l a s s WindowCloser extends WindowAdapter {

       public void windowClosing ( WindowEvent e ) {
              System . exit ( 0 ) ;

       }

}

                                                                            

Given this class, we can then place the following statement in
Converter's main() method:

                                                                            

f . addWindowListener (new WindowCloser ( ) ) ;                             


This is somewhat more familiar looking than the inner class construct. If
you prefer this way of handling things, you can use this method in place
of the inner classes here and in other examples.

JAVA EFFECTIVE DESIGN Anonymous Adapter
Classes. Anonymous adapter classes provide a useful way of creating
an object to handle one particular kind of event within a program.
SECTION 13.6  CASE STUDY: Designing a Basic GUI                  609

13.6.3 GUI Design Critique

Figure 13.13 shows the converter interface. Although our basic GUI de-
sign satisfies the demands of input, output, control, and guidance, it has a
few significant design flaws.

   First, it forces the user to manually clear the input field after each con-
version. Unless it is important that the user's input value remain dis-
played until another value is entered, this is just an inconvenience to the
user. In this case, the user's input value is displayed along with the result
in the JTextArea, so there's no reason not to clear the input text field:

                                                                                

input . setText ( "" ) ; // C l e a r t h e i n p u t f i e l d
                                                                                

                                                                                Figure 13.13: The first version of
                                                                                the metric converter GUI.

JAVA EFFECTIVE DESIGN Reduce the User's Burden. A GUI
should aim to minimize the responsibility placed on the user. In
general, the program should perform any task that it can perform,
unless, of course, there is a compelling reason that the user should do
the task.

   A second problem with our design is that it forces the user to switch be-
tween the keyboard (for input) and the mouse (for control). Experienced
users will find this annoying. An easy way to fix this problem is to make
both the JTextField and the JButton serve as controls. That way, to
get the program to do the conversion, the user can just press the Enter key
after typing a number into the text field.

   To give the interface this type of control, we only need to add an
ActionListener to the JTextField during the initialization step:

                                                                                

input . addActionListener ( this ) ;
                                                                                

A JTextField generates an ActionEvent whenever the Enter key
is pressed. We don't even need to modify the actionPerformed()
method, since both controls will generate the same action event. This will
allow users who prefer the keyboard to use just the keyboard.

JAVA EFFECTIVE DESIGN User Interface. A GUI should aim to
minimize the number of different input devices (mouse, keyboard)
that the user has to manipulate to perform a particular task.

Given that the user can now interact with the interface with just the key-
board, a question arises over whether we should keep the button at all.
In this case, it seems justifiable to keep both the button and the text field
controls. Some users dislike typing and prefer to use the mouse. Also,
having two independent sets of controls is a desirable form of redundancy.
                              610  CHAPTER 13  Graphical User Interfaces

                              You see it frequently in menu-based systems that allow menu items to be
                              selected either by mouse or by special control keys.

                              JAVA EFFECTIVE DESIGN Desirable Redundancy. Certain forms of
                              redundancy in an interface, such as two sets of independent controls
                              (mouse and keyboard), make it a more flexible or more widely usable
                              program.

What components do we need?   SELF-STUDY EXERCISES

How should the components be  EXERCISE 13.4 Another deficiency in the converter interface is that it
organized?                    doesn't round off its result, leading sometimes to numbers with 20 or so
                              digits. Develop Java code to fix this problem.

                              EXERCISE 13.5 Give an example of desirable redundancy in automo-
                              bile design.

                              13.6.4 Extending the Basic GUI: Button Array

                              Suppose the coach likes our program but complains that some of the folks
                              in the office are terrible typists and would prefer not to have to use the
                              keyboard at all. Is there some way we could modify the interface to
                              accommodate these users?

                                 This gets back to the point we were just making about incorporating
                              redundancy into the interface. One way to satisfy this requirement would
                              be to implement a numeric keypad for input, similar to a calculator key-
                              pad. Regular JButtons can be used as the keypad's keys. As a user clicks
                              keypad buttons, their face values--0 through 9--are inserted into the text
                              field. The keypad will also need a button to clear the text field and one to
                              serve as a decimal point.

                                 This new feature will add 12 new JButton components to our inter-
                              face. Instead of inserting them into the JFrame individually, it will be
                              better to organize them into a separate panel and to insert the entire panel
                              into the frame as a single unit. This will help reduce the complexity of
                              the display, especially if the keypad buttons can be grouped together vi-
                              sually. Instead of having to deal with 16 separate components, the user
                              will see the keypad as a single unit with a unified function. This is an
                              example of the abstraction principle, similar to the way we break long
                              strings of numbers (1-888-889-1999) into subgroups to make them easier
                              to remember.

                               JAVA EFFECTIVE DESIGN Reducing Complexity. Organizing
                               elements into distinct groups by function helps to reduce the GUI's
                               complexity.

                              Figure 13.14 shows the revised converter interface design. The contain-
                              ment hierarchy shows that the 12 keypad JButtons are contained within
                              a JPanel. In the frame's layout, the entire panel is inserted just after the
                              text area.

                                 Incorporating the keypad into the interface requires several changes
                              in the program's design. Because the keypad has such a clearly de-
                              fined role, let's make it into a separate object by defining a KeyPad class
SECTION 13.6  CASE STUDY: Designing a Basic GUI                                              611

  JFrame JLabel JTextField  JButton KeyPad JPanel                                                  Figure 13.14: A widget hierarchy
                                                                                                   showing the containment rela-
                                                                                                   tionships among the components.

    prompt:                  Convert  Containment Hierarchy

  JTextArea for             123       JFrame
  displaying file           456            Prompt JLabel
                            789            Input JTextField
                            C0 .           Display JTextArea
                                           Convert JButton
                                           KeyPad JPanel

                                                  12 JButtons

(Fig. 13.15). The KeyPad will be a subclass of JPanel and will han-                                   JPanel         쳃nterface
dle its own ActionEvents. As we saw in Chapter 4, a JPanel is a                                                    ActionListener
generic container. It is a subclass of Container via the JComponent
class (Fig. 13.2). Its main purpose is to contain and organize components                                     +actionPerformed()
that appear together on an interface.
                                                                                                                KeyPad
   In this case, we will use a JPanel to hold the keypad buttons. As you
might recall from Chapter 4, to add elements to a JPanel, you use the                                 -NBUTTONS : int
add() method, which is inherited from Container. (A JApplet is also                                   -buttons[] : JButton
a subclass of Container via the Panel class.)                                                         -labels[] : String
                                                                                                      -kpc : KeyPadClient
   As a subclass of JPanel, the KeyPad will take care of holding and
organizing the JButtons in the visual display. We also need some way to                               +KeyPad()
organize and manage the 12 keypad buttons within the program's mem-                                   +actionPerformed()
ory. Clearly, this is a good job for an array. Actually, two arrays would be
even better, one for the buttons and one for their labels:                                          Figure 13.15: A KeyPad is a
                                                                                                   

                                                                                                    JPanel of JButtons that han-
  private JButton buttons [ ] ;                                                                     dles its own action events.
  private String l a b e l s [ ] = // An a r r a y o f b u t t o n l a b e l s
                                                                                                   
                       { "1" ,"2" ,"3" ,                                                           
                           "4" ,"5" ,"6" ,
                           "7" ,"8" ,"9" ,
                           "C" , "0" , " . " } ;



The label array stores the strings that we will use as the buttons' labels.
The main advantage of the array is that we can use a loop to instantiate
the buttons:



b u t t o n s = new J B u t t o n [NBUTTONS ] ; // C r e a t e t h e a r r a y

                            // For e a c h l a b e l e d b u t t o n

for ( int k = 0; k < buttons . length ; k++) {

  b u t t o n s [ k ] = new J B u t t o n ( l a b e l s [ k ] ) ; // C r e a t e b u t t o n

  buttons [k ] . addActionListener ( this ) ; // and a l i s t e n e r

add ( buttons [ k ] ) ;     // and add i t t o t h e p a n e l

  } // f o r                                                                                       
                                                                                                    Algorithm design

This code should be placed in the KeyPad() constructor. It begins by
instantiating the array itself. It then uses a for loop, bounded by the size
of the array, to instantiate each individual button and insert it into the
array. Note how the loop variable here, k, plays a dual role. It serves as
the index into both the button array (buttons) and the array of strings
                                     612                        CHAPTER 13  Graphical User Interfaces

                                     that serves as the buttons' labels (labels). In that way the labels are as-
                                     signed to the appropriate buttons. Note also how each button is assigned
                                     an ActionListener and added to the panel:

                                                                                                                   

                                     buttons [ k ] . addActionListener ( this ) ; // Add l i s t e n e r

                                       add ( buttons [ k ] ) ;              // Add b u t t o n t o p a n e l
                                     
                                                                                                                              

Callback design                      An important design issue for our KeyPad object concerns how it will in-
                                     teract with the Converter that contains it. When the user clicks a keypad
                                     button, the key's label has to be displayed in the Converter's text area.
                                     But because the text area is private to the converter, the KeyPad does not
                                     have direct access to it. To address this problem, we will use a Java inter-
                                     face to implement a callback design. In this design, whenever a KeyPad
                                     button is pressed, the KeyPad object calls a method in the Converter
                                     that displays the key's label in the text area.

                                        Figure 13.16 provides a summary of the callback design. Note that
                                     the association between the Converter and the KeyPad is bi-directional.
                                     This means that each object has a reference to the other and can invoke the
                                     other's public methods. This will be effected by having the Converter
                                     pass a reference to itself when it constructs the KeyPad:

                                                                                                                   

                                     p r i v a t e KeyPad keypad = new KeyPad ( t h i s ) ;                        
                                     

                                     Another important design issue is that the KeyPad needs to know the
                                     name of the callback method and the Converter needs to have an imple-
                                     mentation of that method. This is a perfect job for an abstract interface:

                                                                                                                   

                                     public abstract interface KeyPadClient {

                                          public void keypressCallback ( String s ) ;

                                     }

                                                                                                                   

Figure 13.16: In a callback design,

the Converter implements the                             쳃nterface
                                                       KeyPadClient
KeyPadClient interface. It
                                          +keypressCallback(in s : String)
passes a reference to itself when

it creates the KeyPad object. The                                      쳃nterface
                                                                    ActionListener
KeyPad object can then invoke             JFrame
                                                                +actionPerformed()
the  keypressCallback()

method whenever a keypad

button is pressed, and the

Converter can display the result

of the keypress.                                          Converter

                                          -prompt : JLabel                  Creates N        KeyPad
                                          -input : JTextField
                                          -display : JTextArea                         -kpc : KeyPadClient
                                          -convert : JButton

                                          +Converter()
                                          +actionPerformed()
                                          +keypressCallback(in s : String)
                                          +main()
SECTION 13.6  CASE STUDY: Designing a Basic GUI                                 613

The KeyPad can interact with any class that implements the Key-
PadClient interface. Note that the KeyPad has a reference to the
KeyPadClient, which it will use to invoke the keypressCallback()
method.

   The implementation of KeyPad is shown in Figure 13.17. Note that
its constructor takes a reference to a KeyPadClient and saves it in an
instance variable. Its actionPerformed() method then passes the key's
label to the KeyPadClient's callback method.

                                                                                                

import java . awt .  ;
import java . awt . event .  ;
import javax . swing .  ;

public c l a s s KeyPad extends JPanel implements A c t i o n L i s t e n e r {

  private  f i n a l s t a t i c i n t NBUTTONS = 1 2 ;
  private  KeyPadClient kpc ; // Owner o f t h e KeyPad
  private  JButton buttons [ ] ;
  private  String l a b e l s [ ] = // An a r r a y o f b u t t o n l a b e l s

                     { "1" ,"2" ,"3" ,
                         "4" ,"5" ,"6" ,
                         "7" ,"8" ,"9" ,
                         "C" , "0" , " . " } ;

  public KeyPad ( KeyPadClient kpc ) {

  this . kpc = kpc ;

  b u t t o n s = new J B u t t o n [NBUTTONS ] ;  // C r e a t e t h e a r r a y

  for ( int k = 0; k < buttons . length ; k++) { // F o r e a c h b u t t o n

  b u t t o n s [ k ] = new J B u t t o n ( l a b e l s [ k ] ) ; // C r e a t e a b u t t o n

  buttons [k ]. addActionListener ( this ) ;       // and a l i s t e n e r

  add ( buttons [ k ] ) ;                          // and add i t t o p a n e l

  } // f o r

  } // KeyPad ( )

  public void actionPerformed ( ActionEvent e ) {

  String keylabel = (( JButton )e . getSource ( ) ) . getText ( ) ;

  kpc . keypressCallback ( keylabel ) ;

  } // a c t i o n P e r f o r m e d ( )

} // KeyPad

                                                                                                

Figure 13.17: The KeyPad object implements a 12-key keypad in a
JPanel. It has a reference to the KeyPadClient that contains the key-
pad.

   Given the KeyPad design, we need to revise our design of the
Converter class (Fig. 13.16). The Converter will now implement the
                                    614                                   CHAPTER 13  Graphical User Interfaces

                                    KeyPadClient interface, which means it must provide an implementa-
                                    tion of the keypressCallback() method:

                                                                                                                  

                                    public void keypressCallback ( String s ) {

                                         i f ( s . e q u a l s ( "C" ) )

                                               input . setText ("" ) ;

                                         else

                                               input . setText ( input . getText () + s ) ;

                                    }

                                                                                                                  

                                    Recall that whenever the KeyPad object calls the keypressCallback()
                                    method, it passes the label of the button that was pressed. The
                                    Converter object simply appends the key's label to the input text field,
                                    just as if the user typed the key in the text field.

                                       The complete implementation of this revised version of the interface is
                                    shown in Figure 13.18 on the next page. The appearance of the interface
                                    itself is shown in Figure 3.19.

                                    13.6.5 GUI Design Critique

Figure 13.19: The second version    Figure 3.19 shows that despite our efforts to group the keypad into a rect-
of the metric converter GUI uses    angular array, it doesn't appear as a single entity in the interface itself,
a set of keypad buttons for in-     which indicates a layout problem. The default layout for our KeyPad
put, but they are not properly ar-  (which is a JPanel) is FlowLayout, which is not appropriate for a nu-
ranged.                             meric keypad that needs to be arranged into a two-dimensional grid pat-
                                    tern, which is the kind of layout our design called for (Fig. 13.14).

                                       Fortunately, this flaw can easily be fixed by using an appropriate layout
                                    manager from the AWT. In the next version of the program, we employ the
                                    java.awt.GridLayout, which is perfectly suited for a two-dimensional
                                    keypad layout (Section 13.7.2).

                                       The lesson to be learned from this example is that screen layout is an
                                    important element of an effective GUI. If not done well, it can undermine
                                    the GUI's effort to guide the user toward the appointed tasks. If done
                                    poorly enough, it can even keep the user from doing the task at all.

                                    JAVA EFFECTIVE DESIGN Layout Design. The appropriate layout
                                    and management of GUI elements is an important part of interface
                                    design. It contributes to the interface's ability to guide the user's
                                    action toward the interface's goals.

                   Container        13.7 Containers and Layout Managers

+add(in c : Component) : Component  A Container is a component that can contain other components. Be-
+remove(in index : int)             cause containers can contain other containers, it is possible to create a
+remove(in c : Component)           hierarchical arrangement of components, as we did in the second ver-
+removeAll()                        sion of our Converter interface. In its present form, the hierarchy for
                                    Converter consists of a JFrame as the top-level container (Fig. 13.14).
                                    Contained within the frame is a KeyPad (subclass of JPanel), which con-
                                    tains 12 JButtons. Most GUIs will have a similar kind of containment
                                    hierarchy.

Figure 13.20: A Container con-
tains Components.
SECTION 13.7  Containers and Layout Managers                               615
                                                                                  


import javax . swing .  ;       // P a c k a g e s used
import java . awt .  ;
import java . awt . event .  ;

public class Converter extends JFrame // V e r s i o n 2
                              implements ActionListener , KeyPadClient {

  p r i v a t e J L a b e l prompt = new J L a b e l ( " D i s t a n c e i n m i l e s : " ) ;
  p r i v a t e J T e x t F i e l d input = new J T e x t F i e l d ( 6 ) ;
  p r i v a t e JTextArea d i s p l a y = new JTextArea ( 1 0 , 2 0 ) ;
  p r i v a t e J B u t t o n c o n v e r t = new J B u t t o n ( " Convert ! " ) ;
  p r i v a t e KeyPad keypad = new KeyPad ( t h i s ) ;

  public Converter () {
     getContentPane ( ) . s e t L a y o u t (new FlowLayout ( ) ) ;
     getContentPane ( ) . add ( prompt ) ;
     getContentPane ( ) . add ( input ) ;
     getContentPane ( ) . add ( convert ) ;
     getContentPane ( ) . add ( display ) ;
     getContentPane ( ) . add ( keypad ) ;
     display . setLineWrap ( true ) ;
     display . setEditable ( false );
     convert . addActionListener ( this );
     input . addActionListener ( this ) ;

  } // C o n v e r t e r ( )

  public void actionPerformed ( ActionEvent e ) {
     double miles =
         Double . valueOf ( input . getText ( ) ) . doubleValue ( ) ;
     double km = M e t r i c C o n v e r t e r . milesToKm ( m i l e s ) ;
     display . append ( miles + " miles equals " +
                                km + " k i l o m e t e r s \n" ) ;
     input . setText ("" ) ;

  } // a c t i o n P e r f o r m e d ( )

  public void keypressCallback ( String            s) {
     i f ( s . e q u a l s ( "C" ) )               + s);
             input . setText ("" ) ;
       else
             input . setText ( input . getText ()

  }

  public s t a t i c void main ( S t r i n g args [ ] ) {

  Converter f = new Converter ( ) ;

  f . setSize (400 , 300);

  f . setVisible ( true );

  f . addWindowListener (new WindowAdapter ( ) {

  public void windowClosing ( WindowEvent e ) {

       System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

  }

  });

  } // main ( )

} // C o n v e r t e r

                                                                                                

Figure 13.18: The second version of the Converter class, which imple-
ments the GUI shown in Figure 13.19.
         616                           CHAPTER 13  Graphical User Interfaces

            A Container is a relatively simple object whose main task is primarily
         to hold its components in a particular order. It has methods to add and
         remove components (Fig. 13.20). As you can see from these methods, a
         container keeps track of the order of its elements, and it is possible to refer
         to a component by its index order.

         13.7.1 Layout Managers

         The hard work of organizing and managing the elements within a con-
         tainer is the task of the layout manager. Among other tasks, the layout
         manager determines

          The overall size of the container.
          The size of each element in the container.
          The spacing between elements.
          The positioning of the elements.

         Although it is possible to manage your own layouts, it is not easy to do.
         For most applications you are much better off by learning to use one
         of the AWT's built-in layouts. Table 13.3 gives a brief summary of the
         available layouts. We will show examples of FlowLayout, GridLayout,
         and BorderLayout. Some of the widely used Swing containers have a
         default layout manager assigned to them (Table 13.4).

            To override the default layout for any of the JApplet, JDialog,
         JFrame, and JWindow containers, you must remember to use the
         getContentPane(). The correct statement is

                                                                                                 

         getContentPane ( ) . s e t L a y o u t (new FlowLayout ( ) ) ;
                                                                                                 

         JAVA DEBUGGING TIP Content Pane. Attempting to add a
         component directly to a JApplet or a JFrame will cause an
         exception. For these top-level containers, components must be added
         to their content panes.

         13.7.2 The GridLayout Manager

         It is simple to remedy the layout problem that affected the keypad
         in the most recent version of the Converter program. The problem

TABLE 13.3 Some of Java's AWT and Swing layout managers.

Manager                   Description

java.awt.BorderLayout     Arranges elements along the north, south, east, west,
                          and in the center of the container.
java.swing.BoxLayout      Arranges elements in a single row or single column.
java.awt.CardLayout       Arranges elements like a stack of cards, with one visible at a time.
java.awt.FlowLayout       Arranges elements left to right across the container.
java.awt.GridBagLayout    Arranges elements in a grid of variably sized cells (complicated).
java.awt.GridLayout       Arranges elements into a two-dimensional grid of equally sized cells.
java.swing.OverlayLayout  Arranges elements on top of each other.
SECTION 13.7  Containers and Layout Managers      617

TABLE 13.4 Default layouts for some of the common
Swing containers.

Container Layout Manager

JApplet  BorderLayout (on its content pane)
JBox     BoxLayout
JDialog  BorderLayout (on its content pane)
JFrame   BorderLayout (on its content pane)
JPanel   FlowLayout
JWindow  BorderLayout (on its content pane)

was caused by the fact that as a subclass of JPanel, the KeyPad uses             
a default FlowLayout, which causes its buttons to be arranged in a               
row. A more appropriate layout for a numeric keypad would be a two-
dimensional grid, which is exactly the kind of layout supplied by the             Figure 13.21: This version of the
java.awt.GridLayout. Therefore, to fix this problem, we need only                 metric converter GUI uses a key-
set the keypad's layout to a GridLayout. This takes a single statement,           pad for mouse-based input. It has
which should be added to the beginning of the KeyPad() constructor:               an attractive overall layout.

 

    s e t L a y o u t (new GridLayout ( 4 , 3 , 1 , 1 ) ) ;
 

This statement creates a GridLayout object and assigns it as the layout
manager for the keypad. It will ensure that the keypad will have four rows
and three columns of buttons (Fig. 13.21). The last two arguments in the
constructor affect the relative spacing between the rows and the columns.
The higher the number, the larger the spacing. As components are added
to the keypad, they will automatically be arranged by the manager into a
4  3 grid.

   Note that for a JPanel, the setLayout() method applies to the panel
itself. Unlike the top-level containers, such as JFrame, other containers
don't have content panes. The same point would apply when adding
components to a JPanel: They are added directly to the panel, not to
a content pane. Confusion over this point could be the source of bugs in
your programs.

JAVA DEBUGGING TIP Content Pane. Top-level containers, such as
JFrame, are the only ones that use a content pane. For other
containers, such as JPanel, components are added directly to the
container itself.

As its name suggests, the GridLayout layout manager arranges com-
ponents in a two-dimensional grid. When components are added to the
container, the layout manager starts inserting elements into the grid at the
first cell in the first row and continues left to right across row 1, then row
2, and so on. If there are not enough components to fill all cells of the grid,
the remaining cells are left blank. If an attempt is made to add too many
components to the grid, the layout manager will try to extend the grid in
some reasonable way in order to accommodate the components. How-
                                     618                        CHAPTER 13  Graphical User Interfaces

                                     ever, despite its effort in such cases, it usually fails to achieve a completely
                                     appropriate layout.

                                     JAVA PROGRAMMING TIP Grid Layouts. Make sure the number
                                     of components added to a GridLayout is equal to the number of
                                     rows times the number of columns.

                                     13.7.3 GUI Design Critique

      North                          Although the layout in Figure 13.21 is much improved, there are still some
                                     deficiencies. One problem is that the convert button seems to be mis-
                                     placed. It would seem to make more sense if it were grouped with the
                                     keypad rather than with the input text field.

                                        A more serious problem results from the fact that we are still using a
                                     FlowLayout for the program's main window, the JFrame. Among all of
                                     Java's layouts, FlowLayout gives you the least amount of control over
                                     the arrangement of the components. Also, FlowLayout is most sensitive
                                     to changes in the size and shape of its container.

West  Center           East

                                     13.7.4 The BorderLayout Manager

      South                          One way to fix these problems is to use a BorderLayout to divide the
                                     frame into five areas: north, south, east, west, and center, as shown in
                                     Figure 13.22. The BorderLayout class contains two constructors:

                                                                                                                       

                                     public BorderLayout ( ) ;

Figure 13.22: Arrangement of         public BorderLayout ( i n t hgap , i n t vgap ) ;
components in a border layout.                                                                                         
The relative size of the areas will
vary.                                The two parameters in the second version of the constructor allow you to
                                     insert spacing between the areas.

                                        Components are added to a BorderLayout by using the add(Compo-
                                     nent, String) method found in the Container class. For example, to
                                     set the application window to a border layout and to add the keypad to
                                     its east area, we would use the following statements:

                                                                                                                       

                                     getContentPane ( ) . s e t L a y o u t (new BorderLayout ( 2 , 2 ) ) ;

                                     getContentPane ( ) . add ( keypad , " East " ) ;                                  
                                     

Containment hierarchy                In this version of the add() method, the second parameter must be a cap-
                                     italized String with one of the names, "North," "South," "East," "West,"
                                     or "Center." The order in which components are added does not matter.

                                        One limitation of the BorderLayout is that only one component can
                                     be added to each area. That means that if you want to add several compo-
                                     nents to an area, you must first enclose them within a JPanel and then
SECTION 13.7  Containers and Layout Managers                                          619

add the entire panel to the area. For example, let's create a panel to contain
the prompt and the text field and place it at the north edge of the frame:

                                                                                            

J P a n e l i n p u t P a n e l = new J P a n e l ( ) ; // C r e a t e p a n e l

inputPanel . add ( prompt ) ;                 // Add l a b e l

inputPanel . add ( input ) ;                // Add t e x t f i e l d

                     // Add t h e p a n e l t o t h e f r a m e

getContentPane ( ) . add ( inputPanel , "North" ) ;                                         


   The same point would apply if we want to group the keypad with the
convert button and place them at the east edge. There are several ways
these elements could be grouped. In this example, we give the panel a
border layout and put the keypad in the center and the convert button at
the south edge:

                                                                                            

J P a n e l c o n t r o l P a n e l = new J P a n e l (new BorderLayout ( 0 , 0 ) ) ;
c o n t r o l P a n e l . add ( keypad , " Center " ) ;
c o n t r o l P a n e l . add ( convert , " South " ) ;

                     // Add t h e p a n e l t o t h e f r a m e

getContentPane . add ( controlPanel , " East " ) ;
                                                                                            

   Given these details about the BorderLayout, a more appropriate de-
sign for the converter application is shown in Figure 13.23. Notice that the
border layout for the top-level JFrame uses only the center, north, and
east areas. Similarly, the border layout for the control panel uses just the
center and south areas.

Input   JLabel       JTextField     KeyPad JPanel                                           Figure 13.23: A border layout de-
JPanel                                                                                      sign for the metric converter pro-
                                                                                            gram. The dotted lines show the
                                              Containment Hierarchy                         panels.

N prompt:                     E 123           JFrame(Border)
                                    456            Input JPanel(Flow)
 JTextArea for                      789                 Prompt JLabel
 displaying file at                C0 .                 Input JTextField
 center of border                                  Control JPanel(Border)
 layout                            Convert              KeyPad JPanel(Grid)
                                                              12 Button
C                                                       Convert JButton
                                                   Display JTextArea

JFrame               Control panel  JButtons

   In a BorderLayout, when one (or more) border area is not used, then
one or more of the other areas will be extended to fill the unused area.
For example, if West is not used, then North, South, and Center will
extend to the left edge of the Container. If North is not used, then West,
East, and Center will extend to the top edge. This is true for all areas
except Center. If Center is unused, it is left blank.
                                620                         CHAPTER 13  Graphical User Interfaces

                                   Figure 13.24 shows the results we get when we incorporate these
                                changes into the program. The only changes to the program itself occur in
                                the constructor method, which in its revised form is defined as follows:

                                                                                                                                           

                                public Converter () {
                                   getContentPane ( ) . s e t L a y o u t (new BorderLayout ( ) ) ;
                                   keypad = new KeyPad ( t h i s ) ;

                                     J P a n e l i n p u t P a n e l = new J P a n e l ( ) ; // I n p u t  panel
                                     inputPanel . add ( prompt ) ;
                                     inputPanel . add ( input ) ;
                                     getContentPane ( ) . add ( inputPanel , "North" ) ;

Figure 13.24: The metric con-        J P a n e l c o n t r o l P a n e l = new J P a n e l (new BorderLayout ( 0 , 0 ) ) ;
verter, showing its appearance
when a border design is used.                                                                                  // C o n t r o l p a n e l

                                     c o n t r o l P a n e l . add ( keypad , " Center " ) ;
                                     c o n t r o l P a n e l . add ( convert , " South " ) ;
                                     getContentPane ( ) . add ( controlPanel , " East " ) ;

                                                                                                             // Output d i s p l a y

                                     getContentPane ( ) . add ( display , " Center " ) ;
                                     display . setLineWrap ( true ) ;
                                     display . setEditable ( false );

                                     convert . addActionListener ( this );

                                     input . addActionListener ( this ) ;

                                } // C o n v e r t e r ( )

                                                                                                                                           

                                This layout divides the interface into three main panels, an input panel,
                                display panel, and control panel, and gives each panel its own layout. In
                                addition, the control panel contains the keypad panel. Thus, the contain-
                                ment hierarchy for this design is much more complex than in our original
                                design.

                                SELF-STUDY EXERCISES

                                EXERCISE 13.6 The border layout for the top window uses the north,
                                center, and east regions. What other combinations of areas might be used
                                for these three components?

                                EXERCISE 13.7 Why wouldn't a flow layout be appropriate for the
                                control panel?

Problem statement               13.8 Checkboxes, Radio Buttons, and Borders

                                Suppose you are the software developer for your own software business
                                specializing in computer games. You want to develop an applet-based
                                order form that customers can use to order software over the Web. At the
                                moment you have three software titles--a chess game, a checkers game,
                                and a crossword puzzle game. The assumption is that the user will choose
                                one or more of these titles from some kind of menu. The user must also
                                indicate a payment option--either E-cash, credit card, or debit card. These
                                options are mutually exclusive--the user can choose one and only one.
SECTION 13.8  Checkboxes, Radio Buttons, and Borders  621

   Let's design an applet interface for this program. Unlike the previous                 Interface design
problem where the input was a numeric value, in this problem the input                    What components do we need?
will be the user's selection from some kind of menu. The result will be the
creation of an order. Let's suppose that this part of the task happens be-                What top-level windows do we use?
hind the scenes--that is, we don't have to worry about creating an actual
order. The output the user sees will simply be an acknowledgment that
the order was successfully submitted.

   There are several kinds of controls needed for this interface. First, a
conventional way to have users indicate their purchase decisions is to
have them click a Submit button. They should also have the option to
cancel the transaction at any time.

   In addition to these button controls, a couple of menus must be pre-
sented, one for the software titles, and one for the payment choices. Swing
and AWT libraries provide many options for building menus.

   One key requirement for this interface is the mutually exclusive pay-
ment options. A conventional way to handle this kind of selection is with
a JRadioButton--a button that belongs to a group of mutually exclu-
sive alternatives. Only one button from the group may be selected at one
time. The selection of software titles could be handled by a collection of
checkboxes. A JCheckbox is a button that can be selected and deselected
and that always displays its current state to the user. Using a checkbox
will make it obvious to the user exactly what software has been selected.

   To complete the design, let's use a JTextArea again to serve as some-
thing of a printed order form. It will confirm the user's order and display
other messages needed during the transaction.

   Given these decisions, we arrive at the design shown in Figure 13.25.
In this case, our design uses a JPanel as the main container, instead of
using the top window itself. The reason for this decision is that we want to
use Swing Borders around the various JPanels to enhance the overall
visual appeal of the design. The borders will have titles that help explain
the purpose of the various panels.

   Note that the top-level window in this case is a JApplet. By default
it will have a border layout. For the main JPanel we are using a 3  1
GridLayout. The components in the main panel are the JTextArea

JApplet                                 Main Panel                                        Figure 13.25: A design for an on-
                                                                                          line order form interface.
          JTextArea for displaying the               Containment Hierarchy
          user's order
                                                     JApplet(Border)
Chess      E-cash
Checkers   Credit                                          Main JPanel(Grid)
Crossword  Debit                                                Display JTextArea
                                                                Center JPanel(Flow)
Cancel     Submit                                                    Choice JPanel(Box)
                                                                          3 Checkboxes
                                                                     Options JPanel(Box)
                                                                          3 RadioButtons
                                                                Button JPanel(Flow)
                                                                     Submit JButton
                                                                     Cancel JButton

         Checkboxes Button panel Options panel
Choice panel RadioButtons
                                     622  CHAPTER 13  Graphical User Interfaces

Component layout                     and two other JPanels. The GridLayout will take care of sizing these
Containment hierarchy                so they are all of equal size.
What data structures do we need?
                                        The center panel, which uses a flow layout, contains panels for the
FIGURE 13.26 Borders around          checkboxes and the radio buttons. These elements are grouped within
containers help make them stand out  their own panels. Again, we can put a border around them in the final
more.                                implementation (Fig. 13.26). The button panels use a BoxLayout, which
                                     we will discuss later. This design leads to the most complex containment
                                     hierarchy thus far.

                                     13.8.1 Checkbox and Radio Button Arrays

                                     Because we will need three checkboxes, one for each title, and three radio
                                     buttons, one for each payment option, it will be useful again to use arrays
                                     to store both the buttons and their titles:

                                                                                                                      

                                     p r i v a t e ButtonGroup optGroup = new ButtonGroup ( ) ;

                                     p r i v a t e JCheckBox t i t l e s [ ] = new JCheckBox [ NTITLES ] ;

                                     p r i v a t e JRadioButton o p t i o n s [ ] = new JRadioButton [NOPTIONS ] ;

                                     private String titleLabels [] =

                                          {"Chess Master - $59 .95 " , "Checkers Pro - $39 .95 " ,

                                          "Crossword Maker - $19 . 9 5 " } ;

                                     private String optionLabels [ ] = {" Credit Card" ,

                                          " Debit Card" , "E-cash " } ;                                               

                                     Again, the advantage of this design is that it simplifies the instantiation
                                     and initialization of the buttons: fig-acmescreen

                                                                                                                      

                                     for ( int k = 0; k < t i t l e s . length ; k++) {

                                          t i t l e s [ k ] = new JCheckBox ( t i t l e L a b e l s [ k ] ) ;

                                          t i t l e s [k ] . addItemListener ( this ) ;

                                          choicePanel . add ( t i t l e s [ k ] ) ;

                                     }

                                                                                                                      

                                     The only difference between this array of checkboxes and the keypad ar-
                                     ray of buttons that we used in the Converter program is that checkboxes
                                     generate ItemEvents instead ActionEvents. Therefore, each checkbox
                                     must be registered with an ItemListener (and, of course, the applet
                                     itself must implement the ItemListener interface). We'll show how
                                     ItemEvents are handled later.

                                        The code for instantiating and initializing the radio buttons is almost
                                     the same:

                                                                                                                      

                                     for ( int k = 0; k < options . length ; k++) {

                                          o p t i o n s [ k ] = new JRadioButton ( o p t i o n L a b e l s [ k ] ) ;

                                          options [k ] . addItemListener ( this ) ;

                                          optionPanel . add ( options [ k ] ) ;

                                          optGroup . add ( options [ k ] ) ;

                                     }

                                     options [ 0 ] . setSelected ( true ) ; // S e t f i r s t b u t t o n ' on '     
                                     

                                     Radio buttons also generate ItemEvents, so they too must be registered
                                     with an ItemListener. Note that the first button is set on, which repre-
                                     sents a default payment option for the user.
SECTION 13.8  Checkboxes, Radio Buttons, and Borders         623

   The difference between checkboxes and radio buttons is that radio but-
tons must be added to a ButtonGroup--here named optGroup--in or-
der to enforce mutual exclusion among them. A ButtonGroup is an ob-
ject whose sole task is to enforce mutual exclusion among its members.
Whenever you click one radio button, the ButtonGroup will automati-
cally be notified of this event and will turn off whatever other button was
turned on. As Figure 13.27 illustrates, radio buttons are monitored by
two different objects, a ButtonGroup, which manages the radio buttons'
states, and an ItemListener, which listens for clicks on the buttons and
takes appropriate actions.

                  Contains N : JRadioButton        > Listens                     Figure 13.27: The ButtonGroup
                                                                                 object tracks each radio button's
: ButtonGroup                                                    : ItemListener  state, ensuring that only one
                                                              1                  is selected at a time. The
               1  1..*                       1..*                                ItemListener listens for events
                                                                                 on each button.

   Note the effective division of labor in the design of the various objects     Divide and conquer
to which a radio button belongs. The optionPanel is a GUI compo-
nent (a JPanel) that contains the button within the visual interface. Its
role is to help manage the graphical aspects of the button's behavior. The
ButtonGroup is just an Object, not a GUI component. Its task is to
monitor the button's relationship to the other buttons in the group. Each
object has a clearly delineated task.

   This division of labor is a key feature of object-oriented design. It is
clearly preferable to giving one object broad responsibilities. For example,
a less effective design might have given the task of managing a group of
buttons to the JPanel that contains them. However, this would lead to all
kinds of problems, not least of which is the fact that not everything in the
container belongs to the same button group. So a clear division of labor is
a much preferable design.

JAVA EFFECTIVE DESIGN Division of Labor. In good
object-oriented design, objects are specialists (experts) for very narrow,
clearly defined tasks. If there's a new task that needs doing, design a
new object to do it.

13.8.2 Swing Borders

The Swing Border and BorderFactory classes can place borders
around virtually any GUI element. Using borders is an effective way to
make the grouping of components more apparent. Borders can have titles,
which enhance the GUI's ability to guide and inform the user. They can
also have a wide range of styles and colors, thereby helping to improve
the GUI's overall appearance.

   A border occupies some space around the edge of a JComponent. For
the Acme Software Titles interface, we place titled borders around four of
the panels (Fig. 13.26). The border on the main panel serves to identify
the company again. The one around the button panel serves to group the
                                 624                        CHAPTER 13  Graphical User Interfaces

                                 two control buttons. The borders around both the checkbox and the radio
                                 button menus help to set them apart from other elements of the display
                                 and help identify the purpose of the buttons.

                                    Attaching a titled border to a component--in this case to a JPanel--is
                                 very simple. It takes one statement:

                                                                                                                    

                                 choicePanel . setBorder (

                                      BorderFactory . createTitledBorder (" Titles " ) ) ;                          

                                 The setBorder() method is defined in JComponent, is inherited by all
                                 Swing components, and takes a Border argument. In this case, we use
                                 the BorderFactory class to create a border and assign it a title. There
                                 are several versions of the static createTitledBorder() method. This
                                 version lets us specify the border's title. It uses default values for type
                                 of border (etched), the title's position (sitting on the top line), justification
                                 (left), and for font's type and color.

                                    As you would expect, the Border and BorderFactory classes con-
                                 tain methods that let you exert significant control over the border's look
                                 and feel. You can even design and create your own custom borders.

                                 13.8.3 The BoxLayout Manager

                                 Another type of layout to use is the BoxLayout. This can be associated
                                 with any container, and it comes as the default with the Swing Box con-
                                 tainer. We use it in this example to arrange the checkboxes and radio
                                 buttons (Fig. 13.25).

                                    A BoxLayout is like a one-dimensional grid layout. It allows multi-
                                 ple components to be arranged either vertically or horizontally in a row.
                                 The layout will not wrap around, as does the FlowLayout. Unlike the
                                 GridLayout, the BoxLayout does not force all its components to be
                                 the same size. Instead, it tries to use each component's preferred width
                                 (or height) in arranging them horizontally (or vertically). (Every Swing
                                 component has a preferred size that is used by the various layout man-
                                 agers in determining the component's actual size in the interface.) The
                                 BoxLayout manager also tries to align its components' heights (for hori-
                                 zontal layouts) or widths (for vertical layouts).

                                    Once again, to set the layout manager for a container you use the
                                 setLayout() method:

                                                                                                                    

                                 c h o i c e P a n e l . s e t L a y o u t (new

                                      BoxLayout ( choicePanel , BoxLayout . Y AXIS ) ) ;                            

Panel0   Panel2                  The BoxLayout() constructor has two parameters. The first is a refer-
 Panel1     C5                   ence to the container that's being managed, and the second is a constant
     C1     C6                   that determines whether horizontal (x-axis) or vertical (y-axis) alignment
     C2     C7                   is used.
     C3     C8
     C4                             One nice feature of the BoxLayout is that it can be used in combina-
                                 tions to imitate the look of the very complicated GridBoxLayout. For
                                 example, Figure 13.28 shows an example with two panels (Panel1 and
                                 Panel2) arranged horizontally within an outer box (Panel0), each con-
                                 taining four components arranged vertically. The three panels all use the
                                 BoxLayout.

Figure 13.28: Complex layouts
can be achieved by nesting con-
tainers that use the BoxLayout.
SECTION 13.8  Checkboxes, Radio Buttons, and Borders                625

13.8.4 The ItemListener Interface

In this section, we will describe how to handle menu selections. When-
ever the user makes a menu selection, or clicks a check box or radio
button, an ItemEvent is generated. ItemEvents are associated with
items that make up menus, including JPopupMenus, JCheckboxes,
JRadioButtons, and other types of menus. Item events are handled
by the ItemListener interface, which consists of a single method, the
itemStateChanged() method:

                                                                             

public void itemStateChanged ( ItemEvent e ) {

  display . setText ( "Your order so f a r ( Payment by : " ) ;

  f o r ( i n t k = 0 ; k < o p t i o n s . l e n g t h ; k++ )

  if ( options [k ]. isSelected ())

  display . append ( options [ k ] . getText ( ) + " )\n" ) ;

  f o r ( i n t k = 0 ; k < t i t l e s . l e n g t h ; k++ )

  if ( titles [k]. isSelected ())

  display . append ( "\ t " + t i t l e s [ k ] . getText ( ) + "\n" ) ;

} // i t e m S t a t e C h a n g e d ( )

                                                                             

This version of the method handles item changes for both the checkbox                   쳃nterface
menu and the radio buttons menu. The code uses two consecutive for                     ItemListener
loops. The first iterates through the options menu (radio buttons) to
determine what payment option the user has selected. Since only one             +itemStateChanged()
option can be selected, only one title will be appended to the display. The
second loop iterates through the titles menu (checkboxes) and appends           JApplet         쳃nterface
each title the user selected to the display. This way the complete status                     ActionListener
of the user's order is displayed after every selection. The isSelected()
method is used to determine if a checkbox or radio button is selected or                 +actionPerformed()
not.
                                                                                                  OrderApplet
   In this example, we have no real need to identify the item that caused
the event. No matter what item the user selected, we want to display           -NTITLES : int
the entire state of the order. However, like the ActionEvent class, the        -NOPTIONS : int
ItemEvent class contains methods that can retrieve the item that caused
the event:                                                                   -mainPanel : JPanel

                                                                               -centerPanel : JPanel
                                                                               -choicePanel : JPanel
  getItem ( ) ;  // R e t u r n s a menu i t e m w i t h i n a menu
                                                                             -optionPanel : JPanel

The getItem() method is the ItemListener's analogue to the                     -buttonPanel : JPanel
ActionEvent's getSource() method. It enables you to obtain the ob-             -optGroup : ButtonGroup
ject that generated the event but returns a representation of the item that    -titles[] : JCheckBox
was selected or deselected.                                                    -options[] : JRadioButton
                                                                               -titleLabels[] : String
13.8.5 The OrderApplet                                                         -optionLabels[] : String
                                                                               -display : JTextArea
The design of the OrderApplet is summarized in Figure 13.29 and its            -submit : JButton
complete implementation is given in Figure 13.30. There are several im-        -cancel : JButton
portant points to make about this program. First, five JPanels are used to
organize the components into logical and visual groupings. This conforms       +init()
to the design shown in Figure 13.25.                                           -initChoices()
                                                                               -initOptions()
   Second, note the use of titled borders around the four internal panels.     +actionPerformed(in e : ActionEvent)
These help reinforce that the components within the border are related by      +itemStateChanged(in e : ItemEvent)
function.
                                                                             Figure 13.29: The OrderApplet
                                                                             makes extensive use of GUI com-
                                                                             ponents.
626                       CHAPTER 13  Graphical User Interfaces

                                                                                                      

import  javax . swing .  ;
import  javax . swing . border .  ;
import  java . awt .  ;
import  java . awt . event .  ;

public class OrderApplet extends JApplet
                                      implements ItemListener , ActionListener {

   p r i v a t e f i n a l i n t NTITLES = 3 , NOPTIONS = 3 ;
   p r i v a t e J P a n e l mainPanel = new J P a n e l ( ) ,

                              c e n t e r P a n e l = new J P a n e l ( ) ,
                              c h o i c e P a n e l = new J P a n e l ( ) ,
                              o p t i o n P a n e l = new J P a n e l ( ) ,
                              b ut t on P an e l = new J P a n e l ( ) ;
   p r i v a t e ButtonGroup optGroup = new ButtonGroup ( ) ;
   p r i v a t e JCheckBox t i t l e s [ ] = new JCheckBox [ NTITLES ] ;
   p r i v a t e JRadioButton o p t i o n s [ ] = new JRadioButton [NOPTIONS ] ;
   private String titleLabels [] =
       {"Chess Master - $59 .95 " , "Checkers Pro - $39 .95 " ,

                                                          "Crossword Maker - $19 . 9 5 " } ;
   private String optionLabels [ ] = {" Credit Card" ,

                                                                 " Debit Card" , "E-cash " } ;
   p r i v a t e JTextArea d i s p l a y = new JTextArea ( 7 , 2 5 ) ;
   p r i v a t e J B u t t o n submit = new J B u t t o n ( " Submit Order " ) ,

                                c a n c e l = new J B u t t o n ( " Cancel " ) ;

  public void i n i t ( ) {
     mainPanel . setBorder ( BorderFactory . createTitledBorder (
                                                             "Acme Software T i t l e s " ) ) ;
     mainPanel . s e t L a y o u t (new GridLayout ( 3 , 1 , 1 , 1 ) ) ;
     cancel . addActionListener ( this );
     submit . addActionListener ( this ) ;
     initChoices ();
     initOptions ();
     buttonPanel . setBorder ( BorderFactory . createTitledBorder (
                                                                                 "Order Today" ) ) ;
     buttonPanel . add ( c a n c e l ) ;
     buttonPanel . add ( submit ) ;
     c e n t e r P a n e l . add ( choicePanel ) ;
     c e n t e r P a n e l . add ( optionPanel ) ;

     mainPanel . add ( display ) ;

     mainPanel . add ( c e n t e r P a n e l ) ;

     mainPanel . add ( buttonPanel ) ;

     getContentPane ( ) . add ( mainPanel ) ;

     setSize (400 ,400);

  } // i n i t ( )

                                                                                                      

        Figure 13.30: The OrderApplet class, Part I.
              SECTION 13.8  Checkboxes, Radio Buttons, and Borders                             627
                                                                                                  


      private void initChoices ( ) {
         choicePanel . setBorder (
                         BorderFactory . createTitledBorder (" Titles " ) ) ;
         choicePanel . setLayout (
                       new BoxLayout ( c h o i c e P a n e l , BoxLayout . Y AXIS ) ) ;
         for ( int k = 0; k < t i t l e s . length ; k++) {
             t i t l e s [ k ] = new JCheckBox ( t i t l e L a b e l s [ k ] ) ;
             t i t l e s [k ] . addItemListener ( this ) ;
             choicePanel . add ( t i t l e s [ k ] ) ;
         }

     } // i n i t C h o i c e s ( )

  private void initOptions ( ) {
     optionPanel . setBorder (
                      BorderFactory . c r e a t e T i t l e d B o r d e r ( "Payment By" ) ) ;
     optionPanel . setLayout (
                     new BoxLayout ( optionPanel , BoxLayout . Y AXIS ) ) ;
     for ( int k = 0; k < options . length ; k++) {
         o p t i o n s [ k ] = new JRadioButton ( o p t i o n L a b e l s [ k ] ) ;
         options [k ] . addItemListener ( this ) ;
         optionPanel . add ( options [ k ] ) ;
         optGroup . add ( options [ k ] ) ;
     }

     options [0]. setSelected ( true );
  } // i n i t O p t i o n s ( )

  public void itemStateChanged ( ItemEvent e ) {
     display . setText ( "Your order so f a r ( Payment by : " ) ;
     f o r ( i n t k = 0 ; k < o p t i o n s . l e n g t h ; k++ )
         if ( options [k ]. isSelected ())
             display . append ( options [ k ] . getText ( ) + " )\n" ) ;
     f o r ( i n t k = 0 ; k < t i t l e s . l e n g t h ; k++ )
         if ( titles [k]. isSelected ())
             display . append ( "\ t " + t i t l e s [ k ] . getText ( ) + "\n" ) ;

  } // i t e m S t a t e C h a n g e d ( )

  public void actionPerformed ( ActionEvent e ){

  String label = submit . getText ( ) ;

  i f ( e . g e t S o u r c e ( ) == submit ) {

  i f ( label . equals ( "Submit Order" ) ) {

     display . append (

     "Thank you . Press ' Confirm ' to submit your order ! \ n" ) ;

     submit . setText ( "Confirm Order" ) ;

  } else {

     display . append (

     "Thank you . You w i l l r e c e i v e your order tomorrow ! \ n" ) ;

     submit . setText ( "Submit Order" ) ;

  }

  } else

  display . setText (

     "Thank you . Maybe we can s e r v e you next time ! \ n" ) ;

  } // a c t i o n P e r f o r m e d ( )

} // O r d e r A p p l e t

                                                                                                

          Figure 13.30: (continued) The OrderApplet class, Part II.
628  CHAPTER 13  Graphical User Interfaces

   The applet init() method is used to initialize the interface. This in-
volves setting the layouts for the various containers and filling the con-
tainers with their components. Because their initializations are relatively
long, the checkboxes and radio buttons are initialized in separate meth-
ods, the initChoices() and initOptions() methods, respectively.

   Finally, note how the actionPerformed() method creates a mock
order form in the display area. This allows the user to review the order
before it is submitted. Also note that the algorithm used for submittal
requires the user to confirm an order before it is actually submitted. The
first time the user clicks the Submit button, the button's label is changed
to, "Confirm Order," and the user is prompted in the display area to click
the Confirm button to submit the order. This design allows the interface
to catch inadvertent button clicks.

   A user interface should anticipate errors by the user. When a program
involves an action that can't be undone--such as placing an order--the
program should make sure the user really wants to take the action before
carrying it out.

JAVA EFFECTIVE DESIGN Anticipate the User. A well-designed
interface should make it difficult for the user to make errors and
should make it easy to recover from mistakes when they do happen.

SELF-STUDY EXERCISE

EXERCISE 13.8 What's your favorite interface horror story? How
would you have remedied the problem? The interface needn't be a com-
puter interface.
SECTION 13.9  Menus and Scroll Panes                               629

13.9 Menus and Scroll Panes

Pop-up and pull-down menus allow an application or applet to grow in
complexity and functionality without cluttering its interface. Menus are
hierarchical in nature. A particular menu is divided into a number of
menu items, which can themselves be further subdivided. Java makes
it simple to implement menus.

   A JMenuBar is an implementation of a menu bar--a horizontal list of
names that appears at the top of a window (Fig. 13.31).

                Simple Text Editor                                            Figure 13.31: An application with
                                                                              a menu bar that is showing its edit
  File Edit                                       Menubar                     menu. The edit menu contains a
                                                                              cascading drop-down menu that
  This is a simple text editor writtin in Swing.  Menu                        can show recent cuts.
                                                  Separator
  All it d Cut  te.cut and paste.cut ar           MenuItem
  d paste Copy                                    Submenu

  Paste

  Select All

  Recent Cuts   simple text editor
                cut and paste

   Almost all applications have a menu bar. To construct a menu, you add
JMenu objects to a JMenuBar. A JMenu is essentially a clickable area on
a menu bar that is associated with a JPopupMenu, a small window that
pops up and displays the menu's JMenuItems. A menu can also contain
JSeparators, which are dividers that can be placed between menu items
to organize them into logical groupings.

13.9.1 Adding a Menu Bar to an Application

It is easy to create menus in Swing. The process involves three steps,
although you needn't perform them in this order:

1. Create the individual JMenuItems.
2. Create a JMenu and add the JMenuItems to it.
3. Create a JMenuBar and add the JMenus to it.

   For example, suppose you're building the interface for a text editor. A
text editor typically contains at least two standard menus. The file menu is
used to create new documents, open and close files, save your document,
and so on. The edit menu is used to cut and paste selected text from the
document.

   Here's how you would create the file menu for this program. First, you
create a menu bar and make it the menu bar for the application's JFrame
or for the JApplet. This is usually done in the application's constructor
or in the applet's init() method:

                                                                              

JMenuBar mBar = new JMenuBar ( ) ; // C r e a t e menu b a r

t h i s . setMenuBar ( mBar ) ; // Add i t t o t h i s w i n d o w            


The next step involves creating and adding menus and menu items to
the menu bar. This is also usually done in the constructor or the init()
630                               CHAPTER 13  Graphical User Interfaces

method. If the menu is large, you should break this task into subtasks and
define a method for each subtask.

JAVA EFFECTIVE DESIGN Method Size. A method that gets longer
than 20 to 25 lines is probably trying to do too much and should be
divided into separate methods, each with a clearly defined task.

Here's the definition of the file menu for our simple text editor:

                                                                              

private void initFileMenu ( ) {

     fileMenu = new JMenu ( " F i l e " ) ; // C r e a t e menu

     mBar . add ( fileMenu ) ;      // Add i t t o menu b a r

     openItem = new JMenuItem ( "Open" ) ; //        Open  item
     openItem . addActionListener ( this ) ;
     openItem . setEnabled ( false ) ;
     fileMenu . add ( openItem ) ;

     saveItem = new JMenuItem ( " Save " ) ; //      Save item
     saveItem . addActionListener ( this ) ;         separator
     saveItem . setEnabled ( false ) ;
     fileMenu . add ( saveItem ) ;
     fileMenu . addSeparator ( ) ; // L o g i c a l

     q u i t I t e m = new JMenuItem ( " Quit " ) ; // Q u i t i t e m

     quitItem . addActionListener ( this );

     fileMenu . add ( quitItem ) ;

} // i n i t F i l e M e n u ( )

                                                                              

The first two statements in the method create the file menu and add it
to the menu bar. The rest of the statements create the individual menu
items that make up the file menu. Note the use of a separator item after the
save item. This has the effect of grouping the file-handling items (open
and save) into one logical category and distinguishing them from the quit
item. A separator is represented as a line in the menu (Fig. 13.31).

JAVA EFFECTIVE DESIGN Logical Design. In designing interfaces,
an effort should be made to use visual cues, such as menu item
separators and borders, to group items that are logically related. This
will help to orient the user.

Note that each menu item is given an ActionListener. As we'll see
shortly, action events for menu items are handled the same way as action
events for buttons. Finally, note how the setEnabled() method is used
to disable both the open and save menu items. Implementation of these
actions is left as an exercise.

13.9.2 Menu Hierarchies

Menus can be added to other menus to create a hierarchy. For example,
the edit menu will include the standard cut, copy, and paste menu items.
Some edit menus also contain an "Undo" item, which can be used to undo
SECTION 13.9  Menus and Scroll Panes                                             631

the last editing operation that was performed. In other words, if you cut
a piece of text, you can undo that operation and get that cut back. Many
editors seem to allow just a single undo. If you cut two pieces of text, the
first piece is lost to the user to undo. This can be an issue, especially if you
didn't mean to do the first cut.

   To help remedy this type of situation, let's add a feature to our editor
that will keep track of cuts by storing them in a Vector. This function
will be like an "Unlimited Undo" operation for cuts. For this example,
we won't place any limit on the size of the vector. Every cut the user
makes will be inserted at the beginning of the vector. To go along with this
feature we need a menu that can grow dynamically during the program.
Each time the user makes a cut, the string that was cut will be added to
the menu.

   This kind of menu should occur within the edit menu, but it will have
its own items. This is a menu within a menu (Fig. 13.31), an example of
a cascading drop-down menu. The edit menu itself drops down from the
menu bar, and the recent cuts menu drops down and to the right of where
its arrow points. The following method was used to create the edit menu:

                                                                                       

private void initEditMenu ( ) {             // C r e a t e e d i t menu
   editMenu = new JMenu ( " E d i t " ) ;     // Add t o menu b a r
   mBar . add ( editMenu ) ;

  c u t Item = new JMenuItem ( "Cut" ) ;    // Cut i t e m

  cutItem . addActionListener ( this ) ;

  editMenu . add ( cutItem ) ;

  copyItem = new JMenuItem ( "Copy" ) ;     // Copy i t e m

  copyItem . addActionListener ( this ) ;

  editMenu . add ( copyItem ) ;

  p a s t e I t e m = new JMenuItem ( " P a s t e " ) ; // P a s t e i t e m

  pasteItem . addActionListener ( this ) ;

  editMenu . add ( pasteItem ) ;

  editMenu . addSeparator ( ) ;

  s e l e c t I t e m = new JMenuItem ( " S e l e c t A l l " ) ; // S e l e c t

  selectItem . addActionListener ( this );

  editMenu . add ( s e l e c t I t e m ) ;

  editMenu . addSeparator ( ) ;

  cutsMenu = new JMenu ( " Recent Cuts " ) ; // C u t s s u b m e n u

  editMenu . add ( cutsMenu ) ;

} // i n i t E d i t M e n u ( )

                                                                                       

The main difference between this method and the one used to create the
file menu is that here we insert an entire submenu as one of the items in
the edit menu. The cutsMenu will be used to hold the strings that are cut
from the document. Initially, it will be empty.

13.9.3 Handling Menu Actions

Handling JMenuItem actions is no different from handling JButton
actions. Whenever a user makes a menu selection, an ActionEvent
is generated. Programs that use menus must implement the action-
Performed() method of the ActionListener interface. In the text ed-
itor example, there are a total of six enabled menu items, including the
                           632                                 CHAPTER 13  Graphical User Interfaces

                           recent cuts menu. This translates into a large if-else structure, with each
                           clause handling a single menu item.

                              The following actionPerformed() method is used to handle the
                           menu selections for the text editor:

                                                                                                                               

               public void actionPerformed ( ActionEvent e ) {

                 JMenuItem m = ( JMenuItem ) e . getSource ( ) ; // G e t s e l e c t e d menu i t e m

                 i f ( m == q u i t I t e m ) {                   // Q u i t

                    dispose ();}

                 } e l s e i f (m == cut Item ) {                 // Cut t h e s e l e c t e d t e x t

                    scratchPad = display . getSelectedText ( ) ; // Copy t e x t to s c r a t c h p a d

                    display . replaceRange ("" ,                  // and d e l e t e

                    display . getSelectionStart ( ) , // from t h e s t a r t of s e l e c t i o n

                    display . getSelectionEnd ( ) ) ;          // t o t h e end

                    addRecentCut ( scratchPad ) ;              // Add t e x t t o t h e c u t s menu

                 } e l s e i f (m == copyItem )                // Copy t e x t t o s c r a t c h p a d

                    scratchPad = display . getSelectedText ( ) ;

                 } e l s e i f (m == p a s t e I t e m ) { // P a s t e s c r a t c h p a d t o d o c u m e n t a t c a r e t

                    display . insert ( scratchPad , display . getCaretPosition ( ) ) ; // p o s i t i o n

                 } e l s e i f ( m == s e l e c t I t e m ) {

                    display . selectAll ( ) ;                  // S e l e c t t h e e n t i r e document

                 } else {

                    JMenuItem item = ( JMenuItem ) e . getSource ( ) ; // D e f a u l t i s c u t s M e n u

                    scratchPad = item . getActionCommand ( ) ; // P u t c u t b a c k i n s c r a t c h p a d

                 }

               } // a c t i o n P e r f o r m e d ( )

                                                                                                                               

Default logic              The method begins by getting the source of the ActionEvent and cast-
                           ing it into a JMenuItem. It then checks each case of the if-else structure.
                           Because the actions taken by this program are fairly short, they are mostly
                           coded within the actionPerformed() method itself. However, for most
                           programs it will be necessary to write a separate method corresponding to
                           each menu item and then call the methods from actionPerformed().

                              Our text editor's main task is to implement the cut/copy/paste func-
                           tions, which are simple to do in Java. The text that's being edited is stored
                           in a JTextArea, which contains instance methods that make it very easy
                           to select, insert, and replace text. To copy a piece of text, the program
                           need only get the text from the JTextArea (getSelectedText()) and
                           assign it to the scratchpad, which is represented as a String. To paste
                           a piece of text, the program inserts the contents of the scratchpad into
                           the JTextArea at the location marked by the caret, a cursor-like character
                           in the document that marks the next insertion point.

                              The structure of this if-else statement is significant. Note how the de-
                           fault case of the if-else is designed. We are using the last else clause as a
                           "catch all" condition to catch and handle selections from the cutsMenu.
                           All of the other menu items can be referred to by name. However, the
                           menu items in the cutsMenu are just snippets of a string that the user has
                           previously cut from the text, so they can't be referenced by name. Luckily,
                           we don't really need to. For any JMenuItem, the getActionCommand()
SECTION 13.9  Menus and Scroll Panes  633

method returns its text, which in this case is the previously cut text. So we
just assign the cut text from the menu to the scratchpad.

JAVA PROGRAMMING TIP Default Cases. Although the order of
the clauses in an if-else structure is usually not important, the default
clause can sometimes be used to handle cases that can't be referenced
by name.

Handling Previously Cut Text

The most difficult function in our program is the cut operation. Not only                Algorithm design
must the selected text be removed from the document and stored in the
scratchpad, but it must also be inserted into the vector that is storing                                      쳃nterface
all the previous cuts. The addRecentCut() method takes care of this                                         ActionListener
last task. The basic idea here is to take the cut string and insert it at the
beginning of the vector, so that cuts will be maintained in a last-in-first-               +actionPerformed(in e : ActionEvent)
out order. Then the cutsMenu must be completely rebuilt by reading its
entries out of the vector, from first to last. That way the most recent cut              JFrame
will appear first in the menu:
                                                                                                          SimpleTextEditor
 
                                                                                           -mBar : JMenuBar
    private void addRecentCut ( String cut ) {                                             -fileMenu : JMenu
        recentCuts . insertElementAt ( cut , 0 ) ;                                         -editMenu : JMenu
       cutsMenu . removeAll ( ) ;                                                          -cutsMenu : JMenu
        for ( int k = 0; k < recentCuts . size ( ) ; k++) {                                -cutItem : JMenuItem
           JMenuItem item =                                                                -copyItem : JMenuItem
             new JMenuItem ( ( S t r i n g ) r e c e n t C u t s . elementAt ( k ) ) ;     -pasteItem : JMenuItem
           cutsMenu . add ( item ) ;                                                       -selectItem : JMenuItem
           item . addActionListener ( this ) ;                                             -recentCutItem : JMenuItem
       }
                                                                                        -quitItem : JMenuItem
    } // a d d R e c e n t C u t ( )
                                                                                           -openItem : JMenuItem
                                                                                           -saveItem : JMenuItem
The recentCuts Vector stores the cut strings. Note the use of the                          -display : JTextArea
insertElementAt() method to insert strings into the vector and the                         -scratchPad : String
elementAt() method to get strings from the vector. (You may find it                        -recentCuts : Vector
helpful to review the section on vectors in Chapter 9.)                                    +SimpleTextEditor()
                                                                                           -initEditMenu()
   Note also how menu items are removed and inserted in menus. The                         -initFileMenu()
cutsMenu is reinitialized, using the removeAll() method. Then the for                      -addRecentCut(in s : String)
loop iterates through the strings stored in the vector, making new menu                    +actionPerformed(in e : ActionEvent)
items from them, which are then inserted into the cutsMenu. In this way,                   +main()
the cutsMenu is changed dynamically each time the user cuts a piece of
text from the document.

13.9.4 Adding Scrollbars to a Text Area                                                 Figure 13.32: Design of the
                                                                                        SimpleTextEditor.
The design of the SimpleTextEditor class is summarized in Fig-
ure 13.32 and its complete implementation is shown in Figure 13.33.
                                      634                        CHAPTER 13  Graphical User Interfaces
                                                                                                                        
  import  javax . swing .  ;
  import  java . awt .  ;
  import  java . awt . event .  ;
  import  java . util . Vector ;

public class SimpleTextEditor extends JFrame implements ActionListener {

  p r i v a t e JMenuBar mBar = new JMenuBar ( ) ;               // C r e a t e t h e menu b a r

  p r i v a t e JMenu fileMenu , editMenu , cutsMenu ; // Menu r e f e r e n c e s a n d i t e m s

  private JMenuItem cutItem , copyItem , pasteItem , selectItem , recentcutItem ;

  private JMenuItem quitItem , openItem , saveItem ;                                   // F i l e i t e m s

  p r i v a t e J T e x t A r e a d i s p l a y = new J T e x t A r e a ( ) ; // H e r e ' s w h e r e t h e e d i t i n g o c c u r s

  private String scratchPad = "" ;                             // S c r a t c h pad f o r c u t / p a s t e

  p r i v a t e Vector r e c e n t C u t s = new Vector ( ) ;

  public SimpleTextEditor () {

  super ( "Simple Text Editor" ) ;          // S e t t h e window t i t l e

  t h i s . getContentPane ( ) . s e t L a y o u t (new BorderLayout ( ) ) ;

  t h i s . getContentPane ( ) . add ( " Center " , display ) ;

  t h i s . getContentPane ( ) . add (new J S c r o l l P a n e ( d i s p l a y ) ) ;

  display . setLineWrap ( true ) ;

  t h i s . setJMenuBar ( mBar ) ;          // S e t t h i s program ' s menu b a r

  initFileMenu ( ) ;                        // C r e a t e t h e menus

  initEditMenu ( ) ;

  } // S i m p l e T e x t E d i t e r ( )

  private void initEditMenu ( ) {

  editMenu = new JMenu ( " E d i t " ) ;    // C r e a t e t h e e d i t menu

  mBar . add ( editMenu ) ;                 // and add i t t o menu b a r

  cu tIte m = new JMenuItem ( "Cut" ) ;                        // Cut i t e m

  cutItem . addActionListener ( this ) ;

  editMenu . add ( cutItem ) ;

  copyItem = new JMenuItem ( "Copy" ) ;                        // Copy i t e m

  copyItem . addActionListener ( this ) ;

  editMenu . add ( copyItem ) ;

  p a s t e I t e m = new JMenuItem ( " P a s t e " ) ;        // P a s t e i t e m

  pasteItem . addActionListener ( this ) ;

  editMenu . add ( pasteItem ) ;

  editMenu . addSeparator ( ) ;

  s e l e c t I t e m = new JMenuItem ( " S e l e c t A l l " ) ; // S e l e c t i t e m

  selectItem . addActionListener ( this );

  editMenu . add ( s e l e c t I t e m ) ;

  editMenu . addSeparator ( ) ;

  cutsMenu = new JMenu ( " Recent Cuts " ) ;                   // R e c e n t c u t s submenu

  editMenu . add ( cutsMenu ) ;

  } // i n i t E d i t M e n u ( )

  private void initFileMenu ( ) {

  fileMenu = new JMenu ( " F i l e " ) ;                 // C r e a t e t h e f i l e menu

  mBar . add ( fileMenu ) ;                              // and add i t t o t h e menu b a r

  openItem = new JMenuItem ( "Open" ) ; // O p e n i t e m

  openItem . addActionListener ( this ) ;

  openItem . setEnabled ( false ) ;

  fileMenu . add ( openItem ) ;

  saveItem = new JMenuItem ( " Save " ) ; // S a v e i t e m                                                                            

                                            Figure 13.33: A menu-based SimpleTextEditor application, Part I.
SECTION 13.9  Menus and Scroll Panes                                              635

                                                                                                                            

  saveItem . addActionListener ( this ) ;

  saveItem . setEnabled ( false ) ;

  fileMenu . add ( saveItem ) ;

  fileMenu . addSeparator ( ) ;           // L o g i c a l s e p a r a t o r

  q u i t I t e m = new JMenuItem ( " Quit " ) ; // Q u i t i t e m

  quitItem . addActionListener ( this );

  fileMenu . add ( quitItem ) ;

  } // i n i t F i l e M e n u ( )

  public void actionPerformed ( ActionEvent e ) {

  JMenuItem m = ( JMenuItem ) e . getSource ( ) ; // G e t s e l e c t e d menu i t e m

  i f ( m == q u i t I t e m ) {                           // Q u i t

     dispose ( ) ;

  } e l s e i f (m == c u t I t e m ) { // C u t t h e s e l e c t e d t e x t

     scratchPad = display . getSelectedText ( ) ; // Copy t e x t to s c r a t c h p a d

     display . replaceRange ("" ,               // and d e l e t e

        display . getSelectionStart ( ) , // from t h e s t a r t of t h e s e l e c t i o n

        display . getSelectionEnd ( ) ) ; // to t h e end

     addRecentCut ( scratchPad ) ; // Add t h e c u t t e x t t o t h e c u t s menu

  } e l s e i f (m == copyItem ) { // C o p y t h e s e l e c t e d t e x t t o t h e s c r a t c h p a d

     scratchPad = display . getSelectedText ( ) ;

  } e l s e i f (m == p a s t e I t e m ) { // P a s t e t h e s c r a t c h p a d t o t h e d o c u m e n t a t c a r e t

     display . insert ( scratchPad , display . getCaretPosition ( ) ) ; // p o s i t i o n

  } e l s e i f ( m == s e l e c t I t e m ) {

     display . selectAll ( ) ;            // S e l e c t t h e e n t i r e document

  } else {

     JMenuItem item = ( JMenuItem ) e . getSource ( ) ; // D e f a u l t i s c u t s M e n u

     scratchPad = item . getActionCommand ( ) ; // P u t c u t b a c k i n t h e s c r a t c h p a d

  }

  } // a c t i o n P e r f o r m e d ( )

  private void addRecentCut ( String cut ) {

  recentCuts . insertElementAt ( cut , 0 ) ;

  cutsMenu . removeAll ( ) ;

  for ( int k = 0; k < recentCuts . size ( ) ; k++) {

     JMenuItem item =

        new JMenuItem ( ( S t r i n g ) r e c e n t C u t s . elementAt ( k ) ) ;

     cutsMenu . add ( item ) ;

     item . addActionListener ( this ) ;

  }

  } // a d d R e c e n t C u t ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  S i m p l e T e x t E d i t o r f = new S i m p l e T e x t E d i t o r ( ) ;

  f . setSize (300 , 200);

  f . setVisible ( true );

  f . addWindowListener (new WindowAdapter ( ) {

     public void windowClosing ( WindowEvent e ) {

        System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

     }

  });

  } // main ( )

} // S i m p l e T e x t E d i t o r

                                                                                                                            

     Figure 13.33: (continued) The SimpleTextEditor, Part II.
                                     636  CHAPTER 13  Graphical User Interfaces

Scrollbars                           It uses a BorderLayout, with the JTextArea placed at the center. Note
                                     how simple it is to add scrollbars to the text area:

                                                                                                                          

                                     t h i s . getContentPane ( ) . add (new J S c r o l l P a n e ( d i s p l a y ) ) ;  
                                     

                                     This statement creates a JScrollPane and adds it to the application's
                                     container. A JScrollPane is one of Swing's scrollbar classes. Its function
                                     is to manage the viewing and scrolling of a scrollable component, such as
                                     a JTextArea. A JScrollPane is actually a container, which is why it
                                     takes the display as an argument. The display is being added to the
                                     JScrollPane.

                                        Just about any Component can be added to a JScrollPane. Once a
                                     component is added, the scroll pane will manage the scrolling functions
                                     for the component. The default constructor used in this example takes a
                                     single Component parameter. This refers to the scrollable component, in
                                     this case to the JTextArea. Another constructor that you might use takes
                                     the following form:

                                                                                                                          

                                     public J S c r o l l P a n e ( Component comp , i n t v s b P o l i c y ,

                                          int hsbPolicy );                                                                

                                     The two integers refer to the vertical and horizontal scrolling policies.
                                     These cover properties such as whether the scrollbars are always present
                                     or just as needed. The default policy is to attach scrollbars to the compo-
                                     nent only when needed. Thus, to see the scrollbars in the SimpleText
                                     Editor, you would have to shrink the window to the point where all of
                                     the text cannot be viewed (Fig. 13.34). Because the text area in this example
                                     is wrapping the text, the horizontal scrollbar will never be needed.

Figure 13.34: The scrollbars ap-     SELF-STUDY EXERCISES
pear on the text area only when
they are needed. In this case, only  EXERCISE 13.9 Modify the addRecentCut() method so it limits the
a vertical scrollbar is necessary.   cuts stored in the vector to the last ten cuts.

                                     EXERCISE 13.10 Modify the addRecentCut() method so that it
                                     doesn't duplicate cuts already stored in the vector. (Hint: Use the
                                     indexOf(String) method in the Vector class.)

                                     Special Topic: Are Computers Intelligent?

                                     Contemporary computer interfaces are largely visual and graphical, and
                                     many things we use a computer for, such as word processing, still require
                                     us to type. Will there come a day when instead of typing a letter or e-
                                     mail message, we'll be able to dictate it to our computer? Will comput-
                                     ers eventually have the same kind of interface we have--that is, will we
                                     someday be able to carry on conversations with our computers? Clearly,
                                     a "conversational interface" would require substantial intelligence on the
                                     part of the computer. Do computers have any chance of acquiring such
                                     intelligence?

                                        The question of machine intelligence or artificial intelligence (AI) has
SECTION 13.9  Menus and Scroll Panes  637

been the subject of controversy since the very first computers were de-
veloped. In 1950, in an article in the journal Mind, Alan Turing proposed
the following test to settle the question of whether computers could be in-
telligent. Suppose you put a person and a computer in another room, and
you let a human interrogate both with any kind of question whatsoever.
The interrogator could ask them to parse a Shakespearian sonnet, or solve
an arithmetic problem, or tell a joke. The computer's task would be to
try to fool the interrogator into thinking that it was the human. And the
(hidden) human's task would be to try to help the interrogator see that he
or she was the human.

   Turing argued that someday computers would be able to play this
game so well that interrogators would have no better than a 50/50 chance
of telling which was which. When that day came, he argued, we would
have to conclude that computers were intelligent.

   This so-called Turing test has been the subject of controversy ever since.
Many of the founders of AI and many of its current practitioners believe
that computation and human thinking are basically the same kind of pro-
cess and that eventually computers will develop enough capability that
we'll have to call them intelligent. Skeptics argue that even if computers
could mimic our intelligence, there's no way they will be self-conscious
and, therefore, they can never be truly intelligent. According to the skep-
tics, merely executing programs, no matter how clever the programs are,
will never add up to intelligence.

   Computers have made some dramatic strides lately. In 1997, an IBM
computer named Deep Blue beat world chess champion Gary Kasparov
in a seven-game chess match. In 1998, a computer at Los Alamos National
Laboratory proved a mathematical theorem that some of the best mathe-
maticians were unable to prove for the past 40 years.

   However, despite these achievements, most observers would agree that
computers are not yet capable of passing the Turing test. One area where
computers fall short is in natural language understanding. Although com-
puters are good at understanding Java and other computer languages,
human languages are still too complex and require too much common
sense knowledge for computers to understand them perfectly. Another
area where computers still fall somewhat short is in speech recognition.
However, an American company recently demonstrated a telephone that
could translate between English and German (as well as some other lan-
guages) in real time. The device's only limitation was that its discourse
was limited to the travel domain. As computer processing speeds im-
prove, this limitation is expected to be only temporary. Thus, we may be
closer than we think to having our "conversational user interface."

   Natural language understanding, speech recognition, learning, percep-
tion, chess playing, and problem solving are the kinds of problems ad-
dressed in AI, one of the major applied areas of computer science. Almost
every major research group in AI has a Web site that describes its work.
To find some of these, just do a search for "artificial intelligence" and then
browse through the links that are returned.
                 638              CHAPTER 13  Graphical User Interfaces

CHAPTER SUMMARY  Technical Terms

                 adapter class    layout manager  peer model
                 callback design  lightweight     pluggable look and
                 content pane
                 containment         component       feel
                                  listener        view
                    hierarchy     model           widget hierarchy
                 controller       model-view-
                 event model
                 inner class         controller
                                     (MVC)

                 Summary of Important Points

                  Java provides two sets of Graphical User Interface (GUI) components,
                    the Abstract Windowing Toolkit (AWT), which was part of Java 1.0 and
                    the Swing component set, the GUI part of the Java Foundation Classes
                    (JFC), introduced in JDK 1.1.

                  Unlike their AWT counterparts, Swing components are written en-
                    tirely in Java. This allows programs written in Swing to have a
                    platform-independent look and feel. There are three built-in look-and-
                    feel packages in Swing: a Windows style, a Unix-like Motif style, and a
                    purely Java Metal style.

                  Swing components are based on the model-view-controller (MVC) archi-
                    tecture, in which the component is divided into three separate objects:
                    how it looks (view), what state it's in (model), and what it does (con-
                    troller). The view and controller parts are sometimes combined into a
                    single user interface class, which can be changed to create a customized
                    look and feel.

                  AWT components are based on the peer model, in which every AWT
                    component has a peer in the native windowing system. This model is
                    less efficient and more platform dependent than the MVC model.

                  Java's event model is based on event listeners. When a GUI component is
                    created, it is registered with an appropriate event listener, which takes
                    responsibility for handling the component's events.

                  A user interface combines four functions: guidance/information for
                    the user, input, output, and control.

                  Components in a GUI are organized into a containment hierarchy that
                    is rooted at the top-level window. JPanels and other Containers
                    can be used to organize the components into a hierarchy according to
                    function or some other criterion.

                  The top-level Swing classes--JApplet, JDialog, JFrame, and
                    JWindow--use a content pane as their component container.

                  A GUI should minimize the number of input devices the user needs
                    to manipulate, as well as the complexity the user needs to deal with.
                    Certain forms of redundancy--such as two independent but complete
                    sets of controls--are desirable because they make the interface more
                    flexible and more widely applicable.
CHAPTER 13  Solutions to Self-Study Exercises                      639
                                                                            Figure 13.35: A JButton has
hasa                               JButton      hasa                        internal model-view-controller
                                                                            components that interact with
                                   hasa                                     each other to produce the button's
                                                                            overall behavior.

Controller SetsState N                      DeterminesLook N

        HandlesEvents N            Model                      View
                            Event
                                   Responds N

                                               JavaMethodCall

 A layout manager is an object that manages the size and arrangement of
  the components in a container. The AWT and Swing provide a number
  of built-in layouts, including flow, border, grid, and box layouts.

 A radio button is a toggle button that belongs to a group in which only
  one button from the group may be selected at the same time. A checkbox
  is a toggle button that always displays its state.

 A well-designed interface should reduce the chance of user error and
  should make it as easy as possible to recover from errors when they do
  occur.

SOLUTION 13.1 How can a button still be considered a component under the               SOLUTIONS TO
MVC model? This is a good question. The JButton class acts as a wrapper class          SELF-STUDY EXERCISES
and hides the model-view-controller details (Fig. 13.35). When you instantiate a
JButton, you still get a single instance. Think of it this way: Your body consists of
several systems that interact (internally) among themselves, but it's still one body
that other bodies interact with as a single object.

SOLUTION 13.2 A component can indeed be registered with more than one lis-
tener. For example, the ToggleButton that we defined in Chapter 4 has two
listeners. The first is the button itself, which takes care of toggling the button's
label. The second is the frame in which the button is used, which takes care of
handling whatever action the button is associated with.

SOLUTION 13.3 Some components can have two different kinds of listeners.
For example, imagine a "sticky button" that works like this. When you click and
release the button, it causes some action to take place, just like a normal button.
When you click and hold the mouse button down, the button "sticks" to the cursor
and you can then move it to a new location. This button would need listeners for
ActionEvents, MouseEvents, and MouseMotionEvents.

SOLUTION 13.4 To round a double you could use the Math.round() method.
For example, suppose the number you want to round is d. Then the expression
Math.round(100 * d)/100.0 will round to two decimal places. Alternatively,
you could use the java.text.NumberFormat class. Both of these approaches
were covered in Chapter 5.

SOLUTION 13.5 Many cars today have cruise control as a alternative way to
control the accelerator. Push buttons, usually located on the steering wheel, are
used to speed up and slow down, so you can drive with your foot or your hand.
640                                   CHAPTER 13  Graphical User Interfaces

SOLUTION 13.6 As an alternative, a north-west-center border layout for the
top-level window in the Converter might work. So might center-south-east and
center-south-west. What makes these possible is the fact that the layout manager
will use up space in any edge area that is not assigned a component.

SOLUTION 13.7 A flow layout would not be appropriate for the control panel
because you would have little control of where the convert button would be
placed relative to the keypad.

SOLUTION 13.8 Interface design disaster: My car uses the same kind of on/off
switch for the headlights and the windshield wipers. One is a stem on the left side
of the steering wheel, and the other is on a stem on the right side of the steering
wheel. On more than one occasion, I've managed to turn off the headlights when
I intended to turn on the wipers.

SOLUTION 13.9 Modify the addRecentCut() method so it limits the cuts
stored in the vector to the last ten cuts. Solution: Check the size of the vector
after inserting the cut. If it exceeds ten, remove the last element in the vector.

                                                                                            

private void addRecentCut ( String cut ) {
   recentCuts . insertElementAt ( cut , 0);
   if ( recentCuts . size ( ) > 10) { // I f more than 10 c u t s
       recentCuts . removeElementAt ( 1 0 ) ; // remove o l d e s t c u t
   }

  cutsMenu . removeAll ( ) ;
  for ( int k = 0; k < recentCuts . size ( ) ; k++) {

     JMenuItem item =
         new JMenuItem ( ( S t r i n g ) r e c e n t C u t s . elementAt ( k ) ) ;

     cutsMenu . add ( item ) ;
     item . addActionListener ( this ) ;
  }

} // a d d R e c e n t C u t ( )

                                                                                            

SOLUTION 13.10 Modify the addRecentCut() method so that it doesn't du-
plicate cuts stored in the vector. Solution: Use the indexOf() method to search
for the cut in the vector. If it's already there, don't insert the cut.

                                                                                            

private void addRecentCut ( String cut ) {
   i f ( r e c e n t C u t s . indexOf ( c u t ) == -1) { // I f n o t a l r e a d y c u t
       recentCuts . insertElementAt ( cut , 0 ) ;
       if ( recentCuts . size ( ) > 10) { // I f more than 10 c u t s
              recentCuts . removeElementAt ( 1 0 ) ; // remove o l d e s t
       }

     cutsMenu . removeAll ( ) ;
     for ( int k = 0; k < recentCuts . size ( ) ; k++) {

            JMenuItem item =
               new JMenuItem ( ( S t r i n g ) r e c e n t C u t s . elementAt ( k ) ) ;

            cutsMenu . add ( item ) ;
            item . addActionListener ( this ) ;
     }

  } // i f n o t a l r e a d y c u t

} // a d d R e c e n t C u t ( )

                                                                                            
CHAPTER 13  Exercises                                             641

EXERCISE 13.1 Explain the difference between the following pairs of terms:               EXERCISES

a. A model and a view.                                                                   Note: For programming exercises,
b. A view and a controller.                                                              first draw a UML class diagram
c. A lightweight and heavyweight component.                                              describing all classes and their
d. A JButton and a Button.                                                               inheritance relationships and/or
e. A layout manager and a container.                                                     associations.
f. A containment hierarchy and an inheritance hierarchy.
g. A content pane and a JFrame.

EXERCISE 13.2 Fill in the blanks.

a. A GUI component that is written entirely in Java is known as a

component.

b. The AWT is not platform independent because it uses the         model to

implement its GUI components.

c. The visual elements of a GUI are arranged in a        .

d. A        is an object that takes responsibility for arranging the components

in a container.

e. The default layout manager for a JPanel is      .

f. The default layout manager for a JApplet is        .

EXERCISE 13.3 Describe in general terms what you would have to do to change
the standard look and feel of a Swing JButton.

EXERCISE 13.4 Explain the differences between the model-view-controller de-
sign of a JButton and the design of an AWT Button. Why is MVC superior?

EXERCISE 13.5 Suppose you have a GUI that contains a JButton and a
JLabel. Each time the button is clicked, the GUI rearranges the letters in the
label. Using Java's event model as a basis, explain the sequence of events that
happens in order for this action to take place.

EXERCISE 13.6 Draw a containment hierarchy for the most recent GUI version
of the OneRowNim program.

EXERCISE 13.7 Create a GUI design, similar to the one shown in Figure 13.25,
for a program that would be used to buy tickets online for a rock concert.

EXERCISE 13.8 Create a GUI design, similar to the one shown in Figure 13.25,
for an online program that would be used to play musical recordings.

EXERCISE 13.9 Design and implement a GUI for the CDInterest program
(Fig. 5.18). This program should let the user input the interest rate, principal, and
period and should accumulate the value of the investment.

EXERCISE 13.10 Design and implement a GUI for the Temperature class
(Fig. 5.5). One challenge of this design is to find a good way for the user to indicate
whether a Fahrenheit or Celsius value is being input. This should also determine
the order of the conversion: F to C or C to F.

EXERCISE 13.11 Design an interface for a 16-button integer calculator that sup-
ports addition, subtraction, multiplication, and division. Implement the interface
so that the label of the button is displayed in the calculator's display--that is, it
doesn't actually do the math.
                                642  CHAPTER 13  Graphical User Interfaces

                                EXERCISE 13.12 Challenge: Design and implement a Calculator class to go
                                along with the interface you developed in the previous exercise. It should function
                                the same way as a hand calculator except it only handles integers.

                                EXERCISE 13.13 Modify the Converter application so that it can convert in
                                either direction: from miles to kilometers or from kilometers to miles. Use radio
                                buttons in your design to let the user select one or the other alternative.

                                EXERCISE 13.14 Here's a design problem for you. A biologist needs an inter-
                                active program that calculates the average of some field data represented as real
                                numbers. Any real number could be a data value, so you can't use a sentinel
                                value, such as 9999, to indicate the end of the input. Design and implement a
                                suitable interface for this problem.

                                EXERCISE 13.15 Challenge: A dialog box is a window associated with an ap-
                                plication that appears only when needed. Dialog boxes have many uses. An error
                                dialog is used to report an error message. A file dialog is used to help the user
                                search for and open a file. Creating a basic error dialog is very simple in Swing.
                                The JOptionPane class has class methods that can be used to create the kind
                                of dialog shown in Figure 13.36. Such a dialog box can be created with a single
                                statement:

                                                                                     

                                JOptionPane . showMessageDialog ( this ,

Figure 13.36: A basic JOption-       " Sorry , your number i s out of range . " ) ;  
Pane error dialog.

                                Convert the Validate program (Fig. 6.12 from Chapter 6) to a GUI interface and
                                use the JOptionPane dialog to report errors.

                                EXERCISE 13.16 Challenge: Design and implement a version of the game Mem-
                                ory. In this game you are given a two-dimensional grid of boxes that contains pairs
                                of matching images or strings. The object is to find the matching pairs. When you
                                click a box, its contents are revealed. You then click another box. If its contents
                                match the first one, their contents are left visible. If not, the boxes are closed up
                                again. The user should be able to play multiple games without getting the same
                                arrangement every time.

                                EXERCISE 13.17 Challenge: Extend the SimpleTextEditor program by
                                adding methods to handle the opening, closing and saving of text files.
Chapter 14

Threads and Concurrent
Programming

OBJECTIVES

After studying this chapter, you will
 Understand the concept of a thread.
 Know how to design and write multithreaded programs.
 Be able to use the Thread class and the Runnable interface.
 Understand the life cycle of a thread.
 Know how to synchronize threads.

OUTLINE

14.1 Introduction
14.2 What Is a Thread?
14.3 From the Java Library: java.lang.Thread
14.4 Thread States and Life Cycle
14.5 Using Threads to Improve Interface Responsiveness
14.6 Case Study: Cooperating Threads
14.7 Case Study: The Game of Pong

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              643
                      644  CHAPTER 14  Threads and Concurrent Programming

                      14.1 Introduction

                      This chapter is about doing more than one thing at a time. Doing more
                      than one thing at once is commonplace in our everyday lives. For exam-
                      ple, let's say your breakfast today consists of cereal, toast, and a cup of
                      java. You have to do three things at once to have breakfast: eat cereal, eat
                      toast, and drink coffee.

                         Actually, you do these things "at the same time" by alternating among
                      them: You take a spoonful of cereal, then a bite of toast, and then sip some
                      coffee. Then you have another bite of toast, or another spoonful of cereal,
                      more coffee, and so on, until breakfast is finished. If the phone rings while
                      you're having breakfast, you will probably answer it--and continue to
                      have breakfast, or at least to sip the coffee. This means you're doing even
                      more "at the same time." Everyday life is full of examples where we do
                      more than one task at the same time.

                         The computer programs we have written so far have performed one
                      task at a time. But there are plenty of applications where a program needs
                      to do several things at once, or concurrently. For example, if you wrote
                      an Internet chat program, it would let several users take part in a dis-
                      cussion group. The program would have to read messages from several
                      users at the same time and broadcast them to the other participants in
                      the group. The reading and broadcasting tasks would have to take place
                      concurrently. In Java, concurrent programming is handled by threads, the
                      topic of this chapter.

Visualizing a thread  14.2 What Is a Thread?

                      A thread (or a thread of execution or a thread of control) is a single sequence of
                      executable statements within a program. For Java applications, the flow of
                      control begins at the first statement in main() and continues sequentially
                      through the program statements. For Java applets, the flow of control
                      begins with the first statement in init(). Loops within a program cause
                      a certain block of statements to be repeated. If-else structures cause certain
                      statements to be selected and others to be skipped. Method calls cause the
                      flow of execution to jump to another part of the program, from which it
                      returns after the method's statements are executed. Thus, within a single
                      thread, you can trace the sequential flow of execution from one statement
                      to the next.

                         One way to visualize a thread is to imagine that you could make a list
                      of the program's statements as they are executed by the computer's cen-
                      tral processing unit (CPU). Thus, for a particular execution of a program
                      with loops, method calls, and selection statements, you could list each
                      instruction that was executed, beginning at the first, and continuing until
                      the program stopped, as a single sequence of executed statements. That's
                      a thread!

                         Now imagine that we break a program up into two or more indepen-
                      dent threads. Each thread will have its own sequence of instructions.
                      Within a single thread, the statements are executed one after the other, as
                      usual. However, by alternately executing the statements from one thread
                      and another, the computer can run several threads concurrently. Even
SECTION 14.2  What Is a Thread?  645

though the CPU executes one instruction at at time, it can run multiple
threads concurrently by rapidly alternating among them. The main ad-
vantage of concurrency is that it allows the computer to do more than
one task at a time. For example, the CPU could alternate between down-
loading an image from the Internet and running a spreadsheet calcula-
tion. This is the same way you ate toast and cereal and drank coffee in
our earlier breakfast example. From our perspective, it might look as if
the computer had several CPUs working in parallel, but that's just the
illusion created by an effectively scheduling threads.

JAVA LANGUAGE RULE JVM Threads. The Java Virtual Machine
(JVM) is itself an example of a multithreaded program. JVM threads
perform tasks that are essential to the successful execution of Java
programs.

JAVA LANGUAGE RULE Garbage Collector Thread. One of the
JVM threads, the garbage collector thread, automatically reclaims mem-
ory taken up by objects that are not used in your programs. This
happens at the same time that the JVM is interpreting your program.

14.2.1 Concurrent Execution of Threads                                          Multitasking
                                                                                CPUs are sequential
The technique of concurrently executing several tasks within a program is
known as multitasking. A task in this sense is a computer operation of
some sort, such as reading or saving a file, compiling a program, or dis-
playing an image on the screen. Multitasking requires the use of a separate
thread for each of the tasks. The methods available in the Java Thread
class make it possible (and quite simple) to implement multithreaded
programs.

   Most computers, including personal computers, are sequential machines
that consist of a single CPU, which is capable of executing one machine in-
struction at a time. In contrast, parallel computers, used primarily for large
scale scientific and engineering applications, are made up of multiple
CPUs working in tandem.

   Today's personal computers, running at clock speeds over 1 gigahertz--
1 gigahertz equals 1 billion cycles per second--are capable of executing
millions of machine instructions per second. Despite its great speed,
however, a single CPU can process only one instruction at a time.

   Each CPU uses a fetch-execute cycle to retrieve the next instruction
from memory and execute it. Since CPUs can execute only one instruc-
tion at a time, multithreaded programs are made possible by dividing
the CPU's time and sharing it among the threads. The CPU's schedule
is managed by a scheduling algorithm, which is an algorithm that sched-
ules threads for execution on the CPU. The choice of a scheduling algo-
rithm depends on the platform on which the program is running. Thus,
thread scheduling might be handled differently on Unix, Windows, and
Macintosh systems.

   One common scheduling technique is known as time slicing, in which
                                                 646  CHAPTER 14  Threads and Concurrent Programming
Figure 14.1: Each thread gets a
slice of the CPU's time.                                                                                               Thread 1
                                                                                                                       Thread 2

                                                      CPU time

                                                                Quantum

Time slicing                       each thread alternatively gets a slice of the CPU's time. For example, sup-
Priority scheduling                pose we have a program that consists of two threads. Using this tech-
                                   nique, the system would give each thread a small quantum of CPU time--
                                   say, one thousandth of a second (one millisecond)--to execute its instruc-
                                   tions. When its quantum expires, the thread would be preempted and the
                                   other thread would be given a chance to run. The algorithm would then
                                   alternate in this round-robin fashion between one thread and the other
                                   (Fig. 14.1). During each millisecond on a 300-megahertz CPU, a thread
                                   can execute 300,000 machine instructions. One megahertz equals 1 mil-
                                   lion cycles per second. Thus, within each second of real time, each thread
                                   will receive 500 time slices and will be able to execute something like 150
                                   million machine instructions.

                                      Under priority scheduling, threads of higher priority are allowed to
                                   run to completion before lower-priority threads are given a chance. An
                                   example of a high-priority thread would be one that is processing key-
                                   board input or any other kind of interactive input from the user. If such
                                   tasks were given low priority, users would experience noticeable delays
                                   in their interaction, which would be quite unacceptable.

                                      The only way a high-priority thread can be preempted is if a thread
                                   of still higher priority becomes available to run. In many cases, higher-
                                   priority threads are those that can complete their task within a few mil-
                                   liseconds, so they can be allowed to run to completion without starving
                                   the lower-priority threads. An example would be processing a user's
                                   keystroke, a task that can begin as soon as the key is struck and can be
                                   completed very quickly. Starvation occurs when one thread is repeatedly
                                   preempted by other threads.

Thread                             JAVA LANGUAGE RULE Thread Support. Depending on the hard-
                                   ware platform, Java threads can be supported by assigning different
                                   threads to different processors, by time slicing a single processor, or by
                                   time slicing many hardware processors.

                  +run()           14.2.2 Multithreaded Numbers

                  NumberThread     Let's consider a simple example of a threaded program. Suppose we give
        +NumberThread(in n : int)  every individual thread a unique ID number, and each time it runs, it
        +run()                     prints its ID ten times. For example, when the thread with ID 1 runs the
                                   output produced would just be a sequence of ten 1's: 1111111111.
Figure 14.2: The NumberThread
class overrides the inherited         As shown in Figure 14.2, the NumberThread class is defined
run() method.                         as a subclass of Thread and overrides the run() method. To set the
                                   thread's ID number, the constructor takes a single parameter that is used
SECTION 14.2  What Is a Thread?                            647
                                                                    Figure 14.3: The Numbers ob-
                                  thread1 : NumberThread            ject creates several instances of
                                                                    NumberThread and tells each
             start()ates                                            one to start().
               Cre

             start()

  : Numbers               Creates  thread2 : NumberThread

             Crestart a ( t ) es

                                  thread3 : NumberThread

to set the thread's ID number. In the run() method, the thread simply
executes a loop that prints its own number ten times:

                                                                          

public c l a s s NumberThread extends Thread {
       i n t num ;

  public NumberThread ( i n t n ) {
        num = n ;

  }

           public void run ( ) {                                          
                  for ( int k=0; k < 10; k++) {                            Thread subclass
                          System . out . p r i n t (num ) ;
                  } // f o r

           } // run ( )
    } // NumberThread
 

Now let's define another class whose task will be to create many
NumberThreads and get them all running at the same time (Fig. 14.3). For
each NumberThread, we want to call its constructor and then start()
it:

                                                                                            

public c l a s s Numbers {
   public s t a t i c void main ( S t r i n g args [ ] ) {

                                                                        // 5 t h r e a d s

  NumberThread number1 , number2 , number3 , number4 , number5 ;

                 // C r e a t e and s t a r t e a c h t h r e a d          
                                                                          Starting a thread
           number1 = new NumberThread ( 1 ) ; number1 . s t a r t ( ) ;
           number2 = new NumberThread ( 2 ) ; number2 . s t a r t ( ) ;
           number3 = new NumberThread ( 3 ) ; number3 . s t a r t ( ) ;
           number4 = new NumberThread ( 4 ) ; number4 . s t a r t ( ) ;
           number5 = new NumberThread ( 5 ) ; number5 . s t a r t ( ) ;
       } // main ( )
    } // Numbers
 

When a thread is started by calling its start() method, it automati-
cally calls its run() method. The output generated by this version of
                                      648  CHAPTER 14  Threads and Concurrent Programming

                                      the Numbers application is as follows:

                                                                                                                   

                                      11111111112222222222333333333344444444445555555555
                                                                                                                   

                                      From this output, it appears that the individual threads were run in the
                                      order in which they were created. In this case, each thread was able to run
                                      to completion before the next thread started running.

                                         What if we increase the number of iterations that each thread per-
                                      forms? Will each thread still run to completion? The following output
                                      was generated for 200 iterations per thread:

                                                                                                                   

              쳃nterface             111111111111111111111111111111111111111111111111111111111111111111111
               Runnable
           +run()                     111111111111111111111111111111111111111111111111111111111111111111111

                 Thread               111111111111111111111111111111111111111111111111111111111111112222222

+Thread()                             222222222222222222222222222222222222222222222222222222222222222222222
+Thread(in target : Runnable)
+Thread(in name : String)             222222222222222222222222222222222222222222222222222222222222222222222
+getName() : String
+getPriority() : int                  222222222222222222222222222222222222222222223333333333333333333333333
+run()
+setName(in s : String)               333333333333333333333333333333333333333333333333333333333333333333333
+setPriority(in priority : int)
+start()                              333333333333333333333333333444444444444444444444444444444444444444444
+stop()
                                      444444444444444444444444444444444444444444444444444444444444444444444

                                      444444444455555555555555555555555555555555555555555555555555555555555

                                      555555555555555555555555555555555555555555555555555555555555552222222

                                      222233333333333333333333333333333333333333333333333333333333333333333

                                      333333333333334444444444444444444444444444445555555555555555555555555

                                      555555555555555555555555555555555555555555555555555555444444444444444

                                      4444444444444444444444444444444444
                                                                                                                   

                                      In this case, only thread 1 managed to run to completion. Threads 2, 3,
                                      4, and 5 did not. As this example illustrates, the order and timing of a
                                      thread's execution are highly unpredictable. This example also serves to
                                      illustrate one way of creating a multithreaded program:

Figure    14.4:                  The   Create a subclass of the Thread class.
                                       Within the subclass, implement a method with the signature void
java.lang.Thread  class.
                                        run() that contains the statements to be executed by that thread.
NOTE: NEEDS REVISION TO                Create several instances of the subclass and start each thread by invok-

                                        ing the start() method on each instance.

ADD PRIORITY, YIELD() and

SLEEP().                              JAVA LANGUAGE RULE Thread Creation. One way to create a
                                      thread in Java is to define a subclass of Thread and override the default
                                      run() method.

                                      14.3 From the Java Library: java.lang.Thread

                                      The java.lang.Thread class contains the public methods shown in Fig-
                                      ure 14.4 (the figure contains only a partial list). Note that Thread im-
                                      plements the Runnable interface, which consists simply of the run()
                                      method. As we will now see, another way to create a thread is to instan-
                                      tiate a Thread object and pass it a Runnable object that will become its
                                      body. This approach allows you to turn an existing class into a separate
                                      thread.

                                         A Runnable object is any object that implements the Runnable
                                      interface--that is, any object that implements the run() method
SECTION 14.3  From the Java Library: java.lang.Thread 649

(Fig. 14.5). The following example provides an alternative way to imple-                     쳃nterface
ment the NumberThread program:                                                                Runnable
                                                                                          +run()
                                                                              
                                                                                          NumberPrinter
public class NumberPrinter implements Runnable {                                 -num : int
       i n t num ;                                                               +NumberPrinter(in n : int)
                                                                                 +run()
  public NumberPrinter ( int n) {
        num = n ;

  }

         public void run ( ) {                                                 Figure 14.5: Any object that im-
                for ( int k=0; k < 10; k++)                                    plements the Runnable interface
                        System . out . p r i n t (num ) ;                     쯢an be run as a separate thread.

         } // run ( )

  } // N u m b e r P r i n t e r


Given this definition, we would then pass instances of this class to the
individual threads as we create them:

                                                                                 

public c l a s s Numbers {
   public s t a t i c void main ( S t r i n g args [ ] ) {

  Thread number1 , number2 , number3 , number4 , number5 ;

  // C r e a t e and s t a r t e a c h t h r e a d

  number1 = new Thread (new NumberPrinter ( 1 ) ) ; number1 . s t a r t ( ) ;

  number2 = new Thread (new NumberPrinter ( 2 ) ) ; number2 . s t a r t ( ) ;

  number3 = new Thread (new NumberPrinter ( 3 ) ) ; number3 . s t a r t ( ) ;

  number4 = new Thread (new NumberPrinter ( 4 ) ) ; number4 . s t a r t ( ) ;

  number5 = new Thread (new NumberPrinter ( 5 ) ) ; number5 . s t a r t ( ) ;

  } // main ( )

} // Numbers

                                                                                 

The NumberPrinter class implements Runnable by defining exactly
the same run() that was used previously in the NumberThread class.
We then pass instances of NumberPrinter when we create the individ-
ual threads. Doing things this way gives exactly the same output as earlier.
This example serves to illustrate another way of creating a multithreaded
program:

 Implement the Runnable interface for an existing class by implement-
  ing the void run() method, which contains the statements to be exe-
  cuted by that thread.

 Create several Thread instances by first creating instances of the
  Runnable class and passing each instance as an argument to the
  Thread() constructor.

 For each thread instance, start it by invoking the start() method on
  it.

JAVA LANGUAGE RULE Thread Creation. A thread can be created
by passing a Runnable object to a new Thread instance. The object's
run() method will be invoked automatically as soon as the thread's
start() method is called.
                     650     CHAPTER 14  Threads and Concurrent Programming

                       JAVA EFFECTIVE DESIGN Converting a Class to a Thread. Using
                       the Runnable interface to create threads enables you to turn an
                       existing class into a thread. For most applications, using the
                       Runnable interface is preferable to redefining the class as a Thread
                       subclass.

                     SELF-STUDY EXERCISE

                     EXERCISE 14.1 Use the Runnable interface to convert the following
                     class into a thread. You want the thread to print all the odd numbers up
                     to its bound:

                                                                                             

                     public class PrintOdds {
                            p r i v a t e i n t bound ;
                            public PrintOdds ( int b) {
                                   bound = b ;
                            }

                          public void print ( ) {

                             i f ( i n t k = 1 ; k < bound ; k+=2)

                             System . out . println (k ) ;

                          }

                     } // P r i n t O d d s

                                                                                             

Controlling threads  14.3.1 Thread Control

                     The various methods in the Thread class (Fig. 14.4) can be used to ex-
                     ert some control over a thread's execution. The start() and stop()
                     methods play the obvious roles of starting and stopping a thread. These
                     methods will sometimes be called automatically. For example, an applet
                     is treated as a thread by the browser, or appletviewer, which is responsible
                     for starting and stopping it.

                        As we saw in the NumberThread example, the run() method encap-
                     sulates the thread's basic algorithm. It is usually not called directly. In-
                     stead, it is called by the thread's start() method, which handles any
                     system-dependent initialization tasks before calling run().

                     14.3.2 Thread Priority

                     The setPriority(int) method lets you set a thread's priority to an in-
                     teger value between Thread.MIN PRIORITY and Thread.MAX PRIOR-
                     ITY, the bounds defined as constants in the Thread class. Using set-
                     Priority() gives you some control over a thread's execution. In gen-
 SECTION 14.3  From the Java Library: java.lang.Thread 651

eral, higher-priority threads get to run before, and longer than, lower-
priority threads.

 JAVA LANGUAGE RULE Preemption. A higher-priority thread
 that wants to run will preempt any threads of lower priority.

To see how setPriority() works, suppose we change NumberThread's
constructor to the following:

                                                                               

public NumberThread ( i n t n ) {

   num = n ;

   setPriority (n);

}

                                                                               

In this case, each thread sets its priority to its ID number. So, thread five  Thread priority
will have priority five, a higher priority than all the other threads. Sup-
pose we now run 2 million iterations of each of these threads. Because 2
million iterations will take a long time if we print the thread's ID on each
iteration, let's modify the run() method, so that the ID is printed every 1
million iterations:

                                                                               

for ( int k = 0; k < 10; k++)

   i f ( k % 1000000 == 0 )

   System . out . p r i n t (num ) ;                                           

Given this modification, we get the following output when we run
Numbers:

                                                                               

5544332211                                                                     


It appears from this output that the threads ran to completion in priority
order. Thus, thread five completed 2 million iterations before thread four
started to run, and so on. This shows that, on my system at least, the Java
Virtual Machine (JVM) supports priority scheduling.

JAVA PROGRAMMING TIP Platform Dependence. Thread
implementation in Java is platform dependent. Adequate testing is
necessary to ensure that a program will perform correctly on a given
platform.

JAVA EFFECTIVE DESIGN Thread Coordination. One way to
coordinate the behavior of two threads is to give one thread higher
priority than another.

JAVA DEBUGGING TIP Starvation. A high-priority thread that
never gives up the CPU can starve lower-priority threads by
preventing them from accessing the CPU.
                    652           CHAPTER 14  Threads and Concurrent Programming

Sleep versus yield  14.3.3 Forcing Threads to Sleep

                    The Thread.sleep() and Thread.yield() methods also provide
                    some control over a thread's behavior. When executed by a thread, the
                    yield() method causes the thread to yield the CPU, allowing the thread
                    scheduler to choose another thread. The sleep() method causes the
                    thread to yield and not to be scheduled until a certain amount of real time
                    has passed.

                    JAVA LANGUAGE RULE Sleep Versus Yield. Both the yield()
                    and sleep() methods yield the CPU, but the sleep() method keeps
                    the thread from being rescheduled for a fixed amount of real time.

                    The sleep() method can halt a running thread for a given number of mil-
                    liseconds, allowing other waiting threads to run. The sleep() method
                    throws an InterruptedException, which is a checked exception. This
                    means that the sleep() call must be embedded within a try/catch
                    block or the method it's in must throw an InterruptedException.
                    Try/catch blocks were covered in Chapter 10.

                                                                                                      

                    try {

                         sleep (100);

                    } catch ( InterruptedException e) {

                         System . out . println ( e . getMessage ( ) ) ;

                    }

                                                                                                      

                    For example, consider the following version of the NumberPrinter.run():

                                                                                                      

                    public void run ( ) {                                                    1000));
                           for ( int k=0; k < 10; k++) {
                                  try {
                                         Thread . s l e e p ( ( long ) ( Math . random ( ) 
                                  } catch ( InterruptedException e) {
                                         System . out . println ( e . getMessage ( ) ) ;
                                  }

                           System . out . p r i n t (num ) ;

                         } // f o r

                    } // run ( )

                                                                                                      

                    In this example, each thread is forced to sleep for a random number of
                    milliseconds between 0 and 1,000. When a thread sleeps, it gives up the
                    CPU, which allows one of the other waiting threads to run. As you would
                    expect, the output we get from this example will reflect the randomness
                    in the amount of time that each thread sleeps:

                                                                                                      

                    14522314532143154232152423541243235415523113435451                                
                    

                    As we will see, the sleep() method provides a rudimentary form of
                    thread synchronization, in which one thread yields control to another.
SECTION 14.3  From the Java Library: java.lang.Thread 653

SELF-STUDY EXERCISES

EXERCISE 14.2 What happens if you run five NumberThreads of
equal priority through 2 million iterations each? Run this experiment and
note the output. Don't print after every iteration! What sort of scheduling
algorithm (round-robin, priority scheduling, or something else) was used
to schedule threads of equal priority on your system?

EXERCISE 14.3 Try the following experiment and note the output. Let
each thread sleep for 50 milliseconds (rather than a random number of
milliseconds). How does this affect the scheduling of the threads? To
make things easier to see, print each thread's ID after every 100,000 itera-
tions.

EXERCISE 14.4 The purpose of the Java garbage collector is to recap-
ture memory that was used by objects that are no longer being used by
your program. Should its thread have higher or lower priority than your
program?

14.3.4 The Asynchronous Nature of Threaded Programs

Threads are asynchronous. This means that the order of execution and            Thread preemptions are unpredictable
the timing of a set of threads are unpredictable, at least from the pro-
grammer's point of view. Threads are executed under the control of the         
scheduling algorithm used by the operating system and the Java Virtual         
Machine. In general, unless threads are explicitly synchronized, it is im-
possible for the programmer to predict when and for how long an indi-           An arithmetic operation can be
vidual thread will run. In some systems, under some circumstances, a            interrupted
thread might run to completion before any other thread can run. In other
systems, or under different circumstances, a thread might run for a short      
time and then be suspended while another thread runs. Of course, when          
a thread is preempted by the system, its state is saved so that its execution
can be resumed without losing any information.

   One implication of a thread's asynchronicity is that it is not generally
possible to determine where in its source code an individual thread might
be preempted. You can't even assume that a thread will be able to com-
plete a simple Java arithmetic operation once it has started it. For example,
suppose a thread had to execute the following operation:

 

    int N = 5 + 3;
 

This operation computes the sum of 5 and 3 and assigns the result to N. It
would be tempting to think that once the thread started this operation, it
would be able to complete it, but that is not necessarily so. You have to
remember that Java code is compiled into a rudimentary bytecode, which
is translated still further into the computer's machine language. In ma-
chine language, this operation would break down into something like the
following three steps:

 

    F e t c h 5 from memory and s t o r e i t i n r e g i s t e r A.
   Add 3 t o r e g i s t e r A.
    Assign the value in r e g i s t e r A to N.
 
                               654            CHAPTER 14  Threads and Concurrent Programming

Threads are asynchronous       Although none of the individual machine instructions can be preempted,
                               the thread could be interrupted between any two machine instructions.
                               The point here is that not even a single Java language instruction can be
                               assumed to be indivisible or unpreemptible. Therefore, it is impossible to
                               make any assumptions about when a particular thread will run and when
                               it will give up the CPU. This suggests the following important principle
                               of multithreaded programs:

                               JAVA LANGUAGE RULE Asynchronous Thread Principle. Unless
                               they are explicitly prioritized or synchronized, threads behave in a
                               completely asynchronous fashion.

                               JAVA PROGRAMMING TIP Thread Timing. Unless they are
                               explicitly synchronized, you cannot make any assumptions about
                               when, or in what order, individual threads will execute, or where a
                               thread might be interrupted or preempted during its execution.

                               As we will see, this principle plays a large role in the design of multi-
                               threaded programs.

                               14.4 Thread States and Life Cycle

Ready, running, and sleeping   Each thread has a life cycle that consists of several different states, which
Controlling a thread           are summarized in Figure 14.6 and Table 14.1. Thread states are rep-
                               resented by labeled ovals, and the transitions between states are repre-
                               sented by labeled arrows. Much of a thread's life cycle is under the
                               control of the operating system and the Java Virtual Machine. Those
                               transitions represented by method names--such as start(), stop(),
                               wait(), sleep(), notify()--can be controlled by the program. Of
                               these methods, the stop() method has been deprecated in JDK 1.2 be-
                               cause it is inherently unsafe to stop a thread in the middle of its execution.
                               Other transitions--such as dispatch, I/O request, I/O done, time expired, done
                               sleeping--are under the control of the CPU scheduler. When first created
                               a thread is in the ready state, which means that it is ready to run. In the

Figure 14.6: A depiction of a                          start()
thread's life cycle.

                                    I/O done           Ready                    notify()
                                                                                          notifyAll()
                                               Time           Dispatch
                                              Expires                      Done
                                                                              sleeping
                                                   Running sleep()
                                                                          Sleeping

                                    I/O requested                 wait()
                                                       stop()

                                    Blocked                               Waiting

                                                       Dead
SECTION 14.4  Thread States and Life Cycle                    655

TABLE 14.1 A summary of the different thread states.

State     Description

Ready     The thread is ready to run and waiting for the CPU.
Running   The thread is executing on the CPU.
Waiting   The thread is waiting for some event to happen.
Sleeping  The thread has been told to sleep for a time.
Blocked   The thread is waiting for I/O to finish.
Dead      The thread is terminated.

ready state, a thread is waiting, perhaps with other threads, in the ready      The ready queue
queue, for its turn on the CPU. A queue is like a waiting line. When the        CPU scheduler
CPU becomes available, the first thread in the ready queue will be dis-
patched--that is, it will be given the CPU. It will then be in the running      Threads can give up the CPU
state.                                                                          Threads block on I/O operations

   Transitions between the ready and running states happen under the
control of the CPU scheduler, a fundamental part of the Java runtime sys-
tem. The job of scheduling many threads in a fair and efficient manner
is a little like sharing a single bicycle among several children. Children
who are ready to ride the bike wait in line for their turn. The grown up
(scheduler) lets the first child (thread) ride for a period of time before the
bike is taken away and given to the next child in line. In round-robin
scheduling, each child (thread) gets an equal amount of time on the bike
(CPU).

   When a thread calls the sleep() method, it voluntarily gives up the
CPU, and when the sleep period is over, it goes back into the ready queue.
This would be like one of the children deciding to rest for a moment dur-
ing his or her turn. When the rest was over, the child would get back in
line.

   When a thread calls the wait() method, it voluntarily gives up the
CPU, but this time it won't be ready to run again until it is notified by
some other thread.

   This would be like one child giving his or her turn to another child.
When the second child's turn is up, it would notify the first child, who
would then get back in line.

   The system also manages transitions between the blocked and ready
states. A thread is put into a blocked state when it does some kind of I/O
operation. I/O devices, such as disk drives, modems, and keyboards, are
very slow compared to the CPU. Therefore, I/O operations are handled
by separate processors known as controllers. For example, when a thread
wants to read data from a disk drive, the system will give this task to the
disk controller, telling it where to place the data. Because the thread can't
do anything until the data are read, it is blocked, and another thread is
allowed to run. When the disk controller completes the I/O operation,
the blocked thread is unblocked and placed back in the ready queue.

   In terms of the bicycle analogy, blocking a thread would be like giving
the bicycle to another child when the rider has to stop to tie his or her
shoe. Instead of letting the bicycle just sit there, we let another child ride
it. When the shoe is tied, the child is ready to ride again and goes back
                                 656  CHAPTER 14  Threads and Concurrent Programming

                                 into the ready line. Letting other threads run while one thread is waiting
                                 for an I/O operation to complete improves the overall utilization of the
                                 CPU.

                                 SELF-STUDY EXERCISE

                                 EXERCISE 14.5 Round-robin scheduling isn't always the best idea.
                                 Sometimes priority scheduling leads to a better system. Can you think
                                 of ways that priority scheduling--higher-priority threads go to the head
                                 of the line--can be used to improve the responsiveness of an interactive
                                 program?

                                 14.5 Using Threads to Improve
                                                Interface Responsiveness

Figure 14.7: Random dots are     One good use for a multithreaded program is to help make a more respon-
drawn until the user clicks the  sive user interface. In a single-threaded program, a program that is ex-
Clear button.                    ecuting statements in a long (perhaps even infinite) loop remains unre-
                                 sponsive to the user's actions until the loop is exited. Thus, the user will
Problem specification            experience a noticeable and sometimes frustrating delay between the time
                                 an action is initiated and the time it is actually handled by the program.

                                 14.5.1 Single-Threaded Design

                                 It's always a good idea that the interface be responsive to user input, but
                                 sometimes it is crucial to an application. For example, suppose a psy-
                                 chology experiment is trying to measure how quickly a user responds to
                                 a certain stimulus presented by a program. Obviously, for this kind of
                                 application, the program should take action as soon as the user clicks a
                                 button to indicate a response to the stimulus. Let's work through an ap-
                                 propriate program design for the experiment. First, we will formally state
                                 the situation and describe what the program should do. Then, we will
                                 examine the components that would make up an effective program.

                                 Problem Statement

                                 A psychologist is conducting a psychometric experiment to measure user
                                 response to a visual cue and asks you to create the following program.
                                 The program should have two buttons. When the Draw button is clicked,
                                 the program begins drawing thousands of black dots at random locations
                                 within a rectangular region of the screen (Fig. 14.7). After a random time
                                 interval, the program begins drawing red dots. This change corresponds
                                 to the presentation of the stimulus. As soon as the stimulus is presented
                                 the user is supposed to click on a Clear button, which clears the drawing
                                 area. To provide a measure of the user's reaction time, the program should
                                 report how many red dots were drawn before the user clicked the Clear
                                 button.
SECTION 13.4  Using Threads to Improve Interface Responsiveness657

JFrame        JButtons                                                      Figure 14.8: GUI design for the
                                                                            dot-drawing program.
                        Controls      Component Hierarchy
        Draw  Clear      JPanel
                                      JFrame
Drawing                 BorderLayout         Controls JPanel
 JPanel                       north               Draw JButton
                                                  Clear JButton
                        BorderLayout         Drawing JPanel
                             center

   Figure 14.8 shows a design for this program's GUI. It contains a con-    GUI design
trol JPanel that contains the two JButtons. The dots are drawn on a
JPanel, which is positioned in the center of a BorderLayout design.

Problem Decomposition

This program should be decomposed into two classes, a GUI to handle         Interface class and drawing class
the user interface and a drawing class to manage the drawing. The main
features of its classes are as follows:                                                    RandomDotGUI

 RandomDotGUI Class: This class manages the user interface, respond-        +NDOTS : int=10000
   ing to user actions by calling methods of the Dotty class (Fig. 14.9).    -dotty : Dotty
                                                                             -controls : JPanel
 Dotty Class: This class contains draw() and clear() methods for            -canvas : JPanel
   drawing on the GUI's drawing panel (Fig. 14.10).                          -draw : JButton
                                                                             -clear : JButton
The RandomDotGUI Class
                                                                             +init()
The implementation of RandomDotGUI is shown in Figure 14.11. The GUI         +actionPerformed(in e : ActionEvent)
arranges the control and drawing panels in a BorderLayout and listens
for action events on its JButtons. When the user clicks the Draw but-       Figure 14.9: The RandomDotGUI.
ton, the GUI's actionPerformed() method will create a new Dotty
instance and call its draw() method:                                                        Dotty

                                                                               +HREF : int final=20

    d o t t y = new Dotty ( canvas , NDOTS ) ;                                 +VREF : int final=20
    dotty . draw ( ) ;
                                                                                  +LEN : int final=200

Note that Dotty is passed a reference to the drawing canvas as well as       -canvas : JPanel
the number of dots to be drawn. When the user clicks the Clear button, the
GUI should call the dotty.clear() method. Of course, the important             -nDots : int
question is, how responsive will the GUI be to the user's action?
                                                                               -nDrawn : int
The Dotty Class
                                                                               -firstRed : int=0

                                                                               +Dotty(in canv : JPanel, in n : int)

                                                                               +draw()

                                                                               +clear()

The purpose of the Dotty class will be to draw the dots and to report       Figure 14.10: The Dotty class
how many red dots were drawn before the canvas was cleared. Because         manages the drawing actions.
it will be passed a reference to the drawing panel and the number of dots
to draw, the Dotty class will need instance variables to store these two
values. It will also need a variable to keep track of how many dots were
drawn. Finally, since it will be drawing within a fixed rectangle on the
panel, the reference coordinates and dimensions of the drawing area are
declared as class constants.

   The Dotty() constructor method will be passed a reference to a draw-
ing panel as well as the number of dots to be drawn and will merely assign
these parameters to its instance variables. In addition to its constructor
 658                CHAPTER 14             Threads and Concurrent Programming
                                                                                              
          java . awt .  ;
  import  javax . swing .  ;
  import  java . awt . event .  ;
  import

public c l a s s RandomDotGUI extends JFrame

                                            implements ActionListener {

  public f i n a l i n t NDOTS = 1 0 0 0 0 ;

  private Dotty dotty ;                     // The drawing c l a s s

  p r i v a t e J P a n e l c o n t r o l s = new J P a n e l ( ) ;

  p r i v a t e J P a n e l canvas = new J P a n e l ( ) ;

  p r i v a t e J B u t t o n draw = new J B u t t o n ( "Draw" ) ;

  p r i v a t e J B u t t o n c l e a r = new J B u t t o n ( " C l e a r " ) ;

  public RandomDotGUI ( ) {

     getContentPane ( ) . s e t L a y o u t (new BorderLayout ( ) ) ;

     draw . addActionListener ( t h i s ) ;

     clear . addActionListener ( this );

     c o n t r o l s . add ( draw ) ;

     c o n t r o l s . add ( c l e a r ) ;

     canvas . setBorder (

          BorderFactory . cr eateTitle dBorder ( "Drawing Canvas" ) ) ;

     getContentPane ( ) . add ( "North" , c o n t r o l s ) ;

     getContentPane ( ) . add ( " Center " , canvas ) ;

     getContentPane ( ) . setSize (400 , 400);

  }

  public void actionPerformed ( ActionEvent e ) {

     i f ( e . g e t S o u r c e ( ) == draw ) {

          d o t t y = new Dotty ( canvas , NDOTS ) ;

          dotty . draw ( ) ;

     } else {

          dotty . clear ( ) ;

     }

  } // a c t i o n P e r f o r m e d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

     RandomDotGUI gui = new RandomDotGUI ( ) ;

     gui . setSize (400 ,400);

     gui . setVisible ( true ) ;

  }

} // RandomDotGUI

                                                                                 

               Figure 14.11: The RandomDotGUI class.

method, the Dotty class will have public draw() and clear() meth-
ods, which will be called from the GUI. The draw() method will use a
loop to draw random dots. The clear() will clear the canvas and report
the number of dots drawn.

   The complete implementation of Dotty is shown in Figure 14.12. Note
how its draw() method is designed. The drawing loop is bounded by
the number of dots to be drawn. On each iteration, the draw() method
picks a random location within the rectangle defined by the coordinates
(HREF,VREF) and (HREF+LEN, VREF+LEN), and draws a dot there. On
each iteration it also generates a random number. If the random number
                   SECTION 13.4  Using Threads to Improve Interface Responsiveness659

                                                                                                             

                   import java . awt .  ;          // I m p o r t Swing c l a s s e s
                   import javax . swing .  ;

                   public class Dotty {

                                                       // C o o r d i n a t e s

                     p r i v a t e s t a t i c f i n a l i n t HREF = 2 0 , VREF = 2 0 , LEN =   200;

                     private JPanel canvas ;                                                     dot

                     private int nDots ;               // Number o f d o t s t o draw

                     p r i v a t e i n t nDrawn ;      // Number o f d o t s drawn

                     private int firstRed = 0; // Number of t h e f i r s t red

                     public Dotty ( JPanel canv , int dots ) {

                        canvas = canv ;

                        nDots = dots ;

                     }

                     public void draw ( ) {

                        Graphics g = canvas . getGraphics ( ) ;

                        f o r ( nDrawn = 0 ; nDrawn < nDots ; nDrawn++) {

                        i n t x = HREF + ( i n t ) ( Math . random ( )  LEN ) ;

                        i n t y = VREF + ( i n t ) ( Math . random ( )  LEN ) ;

                        g. fillOval (x, y, 3, 3);                      // Draw a dot

                        i f ( ( Math . random ( ) < 0 . 0 0 1 ) && ( f i r s t R e d == 0 ) ) {

                           g . setColor ( Color . red ) ; // Change c o l o r t o red

                           f i r s t R e d = nDrawn ;

                        }

                        } // f o r

                     } // draw ( )

                     public void clear ( ) { // C l e a r s c r e e n and r e p o r t r e s u l t

                        Graphics g = canvas . getGraphics ( ) ;

                        g . setColor ( canvas . getBackground ( ) ) ;

                        g . f i l l R e c t (HREF, VREF , LEN + 3 , LEN + 3 ) ;

                        System . out . println (

                        "Number o f dots drawn s i n c e f i r s t red = " + ( nDrawn-f i r s t R e d ) ) ;

                     } // c l e a r ( )

                   } // D o t t y

                                                                                                             

                           Figure 14.12: The Dotty class, single-threaded version.

                   is less than 0.001, it changes the drawing color to red and keeps track of
                   the number of dots drawn up to that point.

                      The problem with this design is that as long as the draw() method
                   is executing, the program will be unable to respond to the GUI's Clear
                   button. In a single-threaded design, both the GUI and dotty are com-
                   bined into a single thread of execution (Fig. 14.13). When the user clicks

A single-threaded       Draw button                Clear button                  10,000 dots
dom dot drawing.

                                                                                 dotty.clear()

                   applet.init() dotty.draw()                                          actionPerformed()
                                     660  CHAPTER 14  Threads and Concurrent Programming

                                     the Draw button, the GUI's actionPerformed() method is invoked.
                                     It then invokes Dotty's draw() method, which must run to completion
                                     before anything else can be done. If the user clicks the Clear button while
                                     the dots are being drawn, the GUI won't be able to get to this until all the
                                     dots are drawn.

                                        If you run this program with nDots set to 10,000, the program will not
                                     clear the drawing panel until all 10,000 dots are drawn, no matter when
                                     the Clear button is pressed. Therefore, the values reported for the user's
                                     reaction time will be wrong. Obviously, since it is so unresponsive to user
                                     input, this design completely fails to satisfy the program's specifications.

  쳃nterface                        JAVA LANGUAGE RULE Single-Threaded Loop. In a
   Runnable                          single-threaded design, a loop that requires lots of iterations will
                                     completely dominate the CPU during its execution, which forces other
+run()                               tasks, including user I/O tasks, to wait.

                        Dotty        SELF-STUDY EXERCISE

                 +run()              EXERCISE 14.6 Suppose the Java Virtual Machine (JVM) was single
                                     threaded and your program got stuck in an infinite loop. Would you be
Figure 14.14: In a multithreaded     able to break out of the loop by typing some special command (such as
design, the Dotty class imple-       Control-C) from the keyboard?
ments Runnable.
                                     14.5.2 Multithreaded Drawing: The Dotty Thread
Multithreaded design: Interrupt the
drawing loop                         One way to remedy this problem is to create a second thread (in addition
                                     to the GUI itself) to do the drawing. The drawing thread will be responsi-
                                     ble just for drawing, while the GUI thread will be responsible for handling
                                     user actions in the interface. The trick to making the user interface more
                                     responsive will be to interrupt the drawing thread periodically so that the
                                     GUI thread has a chance to handle any events that have occurred.

                                        As Figure 14.14 illustrates, the easiest way to convert Dotty into a
                                     thread is to have it implement the Runnable interface:

                                                                                                                   

                                     public class Dotty implements Runnable {

                                          // E v e r y t h i n g e l s e r e m a i n s t h e same

                                          public void run ( ) {
                                                 draw ( ) ;

                                          }

                                     }

                                                                                                                   

                                     This version of Dotty will perform the same task as before except that
                                     it will now run as a separate thread of execution. Note that its run()
                                     method just calls the draw() method that we defined in the previous ver-
                                     sion. When the Dotty thread is started by the RandomDotGUI, we will
                                     have a multithreaded program.

                                        However, just because this program has two threads doesn't necessarily
                                     mean that it will be any more responsive to the user. There's no guarantee
                                     that the drawing thread will stop as soon as the Clear button is clicked. On
SECTION 13.4  Using Threads to Improve Interface Responsiveness661

most systems, if both threads have equal priority, the GUI thread won't
run until the drawing thread finishes drawing all N dots.

 JAVA DEBUGGING TIP Thread Control. Just breaking a program
 into two separate threads won't necessarily give you the desired
 performance. It might be necessary to coordinate the threads.

Therefore, we have to modify our design in order to guarantee that the        Using sleep() to interrupt the
GUI thread will get a chance to handle the user's actions. One good way       drawing
to do this is to have Dotty sleep for a short instance after it draws each
dot. When a thread sleeps, any other threads that are waiting their turn
will get a chance to run. If the GUI thread is waiting to handle the user's
click on Clear, it will now be able to call Dotty's clear() method.

   The new version of draw() is shown in Figure 14.15. In this version of
draw(), the thread sleeps for 1 millisecond on each iteration of the loop.
This will make it possible for the GUI to run on every iteration, so it will
handle user actions immediately.

   Another necessary change is that once the clear() method is called,
the Dotty thread should stop running (drawing). The correct way to stop
a thread is to use some variable whose value will cause the run loop (or
in this case the drawing loop) to exit, so the new version of Dotty uses
the boolean variable isCleared to control when drawing is stopped.
Note that the variable is initialized to false and then set to true in the
clear() method. The for loop in draw() will exit when isCleared
becomes true. This causes the draw() method to return, which causes
the run() method to return, which causes the thread to stop in an orderly
fashion.

JAVA EFFECTIVE DESIGN Threaded GUIs. Designing a
multithreaded GUI involves creating a secondary thread that will run
concurrently with the main GUI thread. The GUI thread handles the
user interface, while the secondary thread performs CPU-intensive
calculations.

 JAVA PROGRAMMING TIP Threading an GUI. Creating a second
 thread within a GUI requires three steps: (1) Define the secondary
 thread to implement the Runnable interface, (2) override its run()
 method, and (3) incorporate some mechanism, such as a sleep()
 state, into the thread's run algorithm so that the GUI thread will have
 a chance to run periodically.

Modifications to RandomDotGUI

We don't need to make many changes in RandomDotGUI to get it to
work with the new version of Dotty. The primary change comes in the
actionPerformed() method. Each time the Draw button was clicked
in the original version of this method, we created a dotty instance and
then called its draw() method. In the revised version we must create a
                 662            CHAPTER 14  Threads and Concurrent Programming

                                                                                            

import java . awt .  ;              // I m p o r t Swing c l a s s e s
import javax . swing .  ;

public class Dotty implements Runnable {

                                    // C o o r d i n a t e s

  p r i v a t e s t a t i c f i n a l i n t HREF = 2 0 , VREF = 2 0 , LEN = 2 0 0 ;

  private JPanel canvas ;

  private int nDots ;               // Number o f d o t s t o draw

  p r i v a t e i n t nDrawn ;      // Number o f d o t s drawn

  private int firstRed = 0;         // Number o f t h e f i r s t red dot

  private boolean isCleared = false ; // P a n e l i s c l e a r e d

  public void run ( ) {

     draw ( ) ;

  }

  public Dotty ( JPanel canv , int dots ) {

     canvas = canv ;

     nDots = dots ;

  }

  public void draw ( ) {

     Graphics g = canvas . getGraphics ( ) ;

     f o r ( nDrawn = 0 ; ! i s C l e a r e d && nDrawn < nDots ; nDrawn++) {

     i n t x = HREF + ( i n t ) ( Math . random ( )  LEN ) ;

     i n t y = VREF + ( i n t ) ( Math . random ( )  LEN ) ;

     g. fillOval (x, y, 3, 3);                            // Draw a dot

     i f ( Math . random ( ) < 0 . 0 0 1 && f i r s t R e d == 0 ) {

        g . setColor ( Color . red ) ; // Change c o l o r t o red

        f i r s t R e d = nDrawn ;

     }

     try {

        Thread . sleep ( 1 ) ;      // S l e e p f o r an i n s t a n t

     } catch ( InterruptedException e) {

        System . out . println ( e . getMessage ( ) ) ;

     }

     } // f o r

  } // draw ( )

  public void clear ( ) {

     isCleared = true ;

     Graphics g = canvas . getGraphics ( ) ;

     g . setColor ( canvas . getBackground ( ) ) ;

     g . f i l l R e c t (HREF, VREF , LEN+3 ,LEN+ 3 ) ;

     System . out . p r i n t l n ( "Number o f dots drawn s i n c e f i r s t red = "

                                                          + ( nDrawn-f i r s t R e d ) ) ;

  } // c l e a r ( )

} // D o t t y

                                                                                            

                 Figure 14.15: By implementing the Runnable interface, this version of
                 Dotty can run as a separate thread.
SECTION 13.4  Using Threads to Improve Interface Responsiveness663

new Thread and pass it an instance of Dotty, which will then run as a          Starting the drawing thread
separate thread:                                                              

                                                                              

    public void actionPerformed ( ActionEvent e ) {
           i f ( e . g e t S o u r c e ( ) == draw ) {
                  d o t t y = new Dotty ( canvas , NDOTS ) ;
                  dottyThread = new Thread ( d o t t y ) ;
                  dottyThread . start ( ) ;
           } else {
                  dotty . clear ( ) ;
           }

    } // a c t i o n P e r f o r m e d ( )
 

Note that in addition to a reference to dotty we also have a reference to a
Thread named dottyThread. This additional variable must be declared
within the GUI.

   Remember that when you call the start() method, it automatically
calls the thread's run() method. When dottyThread starts to run, it
will immediately call the draw() method and start drawing dots. After
each dot is drawn, dottyThread will sleep for an instant.

   Notice how the GUI stops the drawing thread. In the new version,
Dotty.clear() will set the isCleared variable, which will cause the
drawing loop to terminate. Once again, this is the proper way to stop a
thread. Thus, as soon as the user clicks the Clear button, the Dotty thread
will stop drawing and report its result.

JAVA DEBUGGING TIP Stopping a Thread. The best way to stop a
thread is to use a boolean control variable whose value can be set to
true or false to exit the run() loop.

14.5.3 Advantages of Multithreaded Design                                     Divide and conquer!
                                                                              Trade-off: speed vs. responsiveness
By creating a separate thread for Dotty, we have turned a single-threaded
program into a multithreaded program. One thread, the GUI, handles the
user interface. The second thread handles the drawing task. By forcing
the drawing to sleep on each iteration, we guarantee that the GUI thread
will remain responsive to the user's actions. Figure 14.16 illustrates the
difference between the single- and multithreaded designs. Note that the
GUI thread starts and stops the drawing thread, and the GUI thread exe-
cutes dotty.clear(). The drawing thread simply executes its draw()
method. In the single-threaded version, all of these actions are done by
one thread.

   The trade-off involved in this design is that it will take longer to draw
N random dots, since dottyThread.draw() will sleep for an instant on
each iteration. However, the extra time is hardly noticeable. By breaking
the program into two separate threads of control, one to handle the draw-
                               664               CHAPTER 14  Threads and Concurrent Programming

Figure 14.16: Two independent       Draw button     Clear button
threads: one for drawing, the
other for the GUI.                  init()          actionPerformed()

                                                                       Applet thread

                                                                       Dotty thread

                                            draw()  clear()

                               ing task and one to handle the user interface, the result is a much more
                               responsive program.

                                JAVA EFFECTIVE DESIGN Responsive Interfaces. In order to give a
                                program a more responsive user interface, divide it into separate
                                threads of control. Let one thread handle interactive tasks, such as user
                                input, and let the second thread handle CPU-intensive computations.

Producer and consumer threads  SELF-STUDY EXERCISES

                               EXERCISE 14.7 Someone might argue that because the Java Virtual Ma-
                               chine uses a round-robin scheduling algorithm, it's redundant to use the
                               sleep() method, since the GUI thread will get its chance to run. What's
                               wrong with this argument for interface responsiveness?

                               EXERCISE 14.8 Instead of sleeping on each iteration, another way to
                               make the interface more responsive would be to set the threaded Dotty's
                               priority to a low number, such as 1. Make this change, and experiment
                               with its effect on the program's responsiveness. Is it more or less respon-
                               sive than sleeping on each iteration? Why?

                               14.6 CASE STUDY: Cooperating Threads

                               For some applications it is necessary to synchronize and coordinate the
                               behavior of threads to enable them to carry out a cooperative task. Many
                               cooperative applications are based on the producer/consumer model. Ac-
                               cording to this model, two threads cooperate at producing and consuming
                               a particular resource or piece of data. The producer thread creates some
                               message or result, and the consumer thread reads or uses the result. The
                               consumer has to wait for a result to be produced, and the producer has to
                               take care not to overwrite a result that hasn't yet been consumed. Many
                               types of coordination problems fit the producer/consumer model.

                                  One example of an application for this model would be to control the
                               display of data that is read by your browser. As information arrives from
                               the Internet, it is written to a buffer by the producer thread. A sepa-
                               rate consumer thread reads information from the buffer and displays it
                               in your browser window. Obviously, the two threads must be carefully
                               synchronized.
SECTION 14.6  CASE STUDY: Cooperating Threads                       665

14.6.1 Problem Statement                                                     Simulating a waiting line

To illustrate how to address the sorts of problems that can arise when you   What classes do we need?
try to synchronize threads, let's consider a simple application in which     Figure 14.17: The Bakery creates
several threads use a shared resource. You're familiar with those take-      the Customer and Clerk threads
a-number devices that are used in bakeries to manage a waiting line.         and the TakeANumber gadget.
Customers take a number when they arrive, and the clerk announces            Then Customers request and re-
who's next by looking at the device. As customers are called, the clerk      ceive waiting numbers and the
increments the "next customer" counter by one.                               Clerk requests and receives the
                                                                             number of the next customer to
   There are some obvious potential coordination problems here. The de-      serve.
vice must keep proper count and can't skip customers. Nor can it give
the same number to two different customers. Nor can it allow the clerk to
serve nonexistent customers.

   Our task is to build a multithreaded simulation that uses a model of a
take-a-number device to coordinate the behavior of customers and a (sin-
gle) clerk in a bakery waiting line. To help illustrate the various issues
involved in trying to coordinate threads, we will develop more than one
version of the program.

Problem Decomposition

This simulation will use four classes of objects. Figure 14.17 pro-
vides a UML representation of the interactions among the objects. The

: TakeANumber                joe : Customer

                             mary : Customer

: Bakery  alicia : Clerk                 pete : Customer

create()

          create()                           Each customer gets
                   create()                  a different number.

          create()

          create()

                    nextNumber()             The clerk serves the
                        nextNumber()         next customer in line.
                           nextNumber()

          nextCustomer()

TakeANumber object will serve as a model of a take-a-number device.
This is the resource that will be shared by the threads, but it is not a
thread itself. The Customer class, a subclass of Thread, will model the
behavior of a customer who arrives on line and takes a number from the
TakeANumber device. There will be several Customer threads created
that then compete for a space in line. The Clerk thread, which simulates
the behavior of the store clerk, should use the TakeANumber device to
determine who the next customer is and should serve that customer. Fi-
nally, there will be a main program that will have the task of creating and
                                        666  CHAPTER 14  Threads and Concurrent Programming

                                        starting the various threads. Let's call this the Bakery class, which gives
                                        us the following list of classes:

                                         Bakery--creates the threads and starts the simulation.
                                         TakeANumber--represents the gadget that keeps track of the next cus-

                                          tomer to be served.
                                         Clerk--uses the TakeANumber to determine the next customer and

                                          will serve the customer.
                                         Customer--represents the customers who will use the TakeANumber

                                          to take their place in line.

                                        14.6.2 Design: The TakeANumber Class

                  TakeANumber           The TakeANumber class must track two things: Which customer will
            -next : int                 be served next, and which waiting number the next customer will be
            -serving : int              given. This suggests that it should have at least two public methods:
            +nextNumber() : int         nextNumber(), which will be used by customers to get their waiting
            +nextCustomer() : int       numbers, and nextCustomer(), which will be used by the clerk to de-
                                        termine who should be served (Fig. 14.18). Each of these methods will
Figure 14.18: The TakeANumber           simply retrieve the values of the instance
object keeps track of numbers and
customers.                                 variables, next and serving, which keep track of these two values.
                                        As part of the object's state, these variables should be private.
Passing a reference to a shared object
                                           How should we make this TakeANumber object accessible to all of
                                        the other objects--that is, to all of the customers and to the clerk? The
                                        easiest way to do that is to have the main program pass a reference to
                                        the TakeANumber when it constructs the Customers and the Clerk.
                                        They can each store the reference as an instance variable. In this way,
                                        all the objects in the simulation can share a TakeANumber object as a
                                        common resource. Our design considerations lead to the definition of the
                                        TakeANumber class shown in Figure 14.19.

                                                                                                                

                                        c l a s s TakeANumber {          // Next p l a c e i n l i n e
                                               private int next = 0;     // Next c u s t o m e r t o s e r v e
                                               private int serving = 0;

                                             public synchronized int nextNumber ( ) {
                                                    next = next + 1;
                                                    return next ;

                                             } // nextNumber ( )

                                             public int nextCustomer ( ) {
                                                    ++ s e r v i n g ;
                                                    return serving ;

                                             } // n e x t C u s t o m e r ( )

                                        } // TakeANumber

                                                                                                                

                                             Figure 14.19: Definition of the TakeANumber class, Version 1.

                                           Note that the nextNumber() method is declared synchronized. As
                                        we will discuss in more detail, this ensures that only one customer at a
                                        time can take a number. Once a thread begins executing a synchronized
                                        method, no other thread can execute that method until the first thread
SECTION 14.6  CASE STUDY: Cooperating Threads                        667

finishes. This is important because, otherwise, several Customers could        Synchronized methods
call the nextNumber method at the same time. It's important that the
customer threads have access only one at a time, also called mutually ex-
clusive access to the TakeANumber object. This form of mutual exclusion
is important for the correctness of the simulation.

SELF-STUDY EXERCISE

EXERCISE 14.9 What is the analogue to mutual exclusion in the real-
world bakery situation?

14.6.3 Java Monitors and Mutual Exclusion

An object that contains synchronized methods has a monitor associated          The monitor concept
with it. A monitor is a widely used synchronization mechanism that en-
sures that only one thread at a time can execute a synchronized method.        Mutually exclusive access to a shared
When a synchronized method is called, a lock is acquired on that object.       object
For example, if one of the Customer threads calls nextNumber(), a lock
will be placed on that TakeANumber object. While an object is locked, no
other synchronized method can run in that object. Other threads must
wait for the lock to be released before they can execute a synchronized
method.

   While one Customer is executing nextNumber(), all other Customers
will be forced to wait until the first Customer is finished. When the
synchronized method is exited, the lock on the object is released, al-
lowing other Customer threads to access their synchronized meth-
ods. In effect, a synchronized method can be used to guarantee mu-
tually exclusive access to the TakeANumber object among the competing
customers.

JAVA LANGUAGE RULE synchronized. Once a thread begins
to execute a synchronized method in an object, the object is locked so
that no other thread can gain access to that object's synchronized
methods.

JAVA EFFECTIVE DESIGN Synchronization. In order to restrict
access of a method or set of methods to one object at a time (mutual
exclusion), declare the methods synchronized.

One cautionary note here is that although a synchronized method blocks                               Thread
access to other synchronized methods, it does not block access to nonsyn-
chronized methods. This could cause problems. We will return to this                            +run()
issue in the next part of our case study when we discuss the testing of our
program.                                                                                           Customer
                                                                               -number : int=10000
14.6.4 The Customer Class                                                      -id : int
                                                                               -takeANumber : TakeANumber
A Customer thread should model the behavior of taking a number from            +Customer(in gadget : TakeANumber)
the TakeANumber gadget. For the sake of this simulation, let's suppose         +run()
that after taking a number, the Customer object just prints it out. This will
serve as a simple model of "waiting on line." What about the Customer's
state? To help distinguish one customer

                                                                               Figure 14.20:  The Customer
                                                                               thread.
                          668             CHAPTER 14  Threads and Concurrent Programming

                             from another, let's give each customer a unique ID number starting at
                          10001, which will be set in the constructor method. Also, as we noted ear-
                          lier, each Customer needs a reference to the TakeANumber object, which
                          is passed as a constructor parameter (Fig. 14.20). This leads to the defini-
                          tion of Customer shown in Figure 14.21. Note that before taking a num-
                          ber the customer sleeps for a random interval of up to 1,000 milliseconds.
                          This will introduce a bit of randomness into the simulation.

                                                                                                                   

                          public class Customer extends Thread {

                            p r i v a t e s t a t i c i n t number = 1 0 0 0 0 ; // I n i t i a l I D n u m b e r
                            private int id ;
                            p r i v a t e TakeANumber takeANumber ;

                            public Customer ( TakeANumber gadget ) {
                               id = ++number ;
                               takeANumber = gadget ;

                            }

                            public void run ( ) {

                               try {

                                  s l e e p ( ( i n t ) ( Math . random ( )  1000 ) ) ;

                                  System . out . println ( "Customer " + id +

                                  " t a k e s t i c k e t " + takeANumber . nextNumber ( ) ) ;

                               } catch ( InterruptedException e) {

                                  System . out . println ( "Exception " + e . getMessage ( ) ) ;

                               }

                            } // run ( )

                          } // Customer

                                                                                                                   

                                  Figure 14.21: Definition of the Customer class, Version 1.

Static (class) variables     Another important feature of this definition is the use of the static
                          variable number to assign each customer a unique ID number. Remem-
                          ber that a static variable belongs to the class itself, not to its instances.
                          Therefore, each Customer that is created can share this variable. By
                          incrementing it and assigning its new value as the Customer's ID, we
                          guarantee that each customer has a unique ID number.

                            JAVA LANGUAGE RULE Static (Class) Variables. Static variables
                            are associated with the class itself and not with its instances.

                            JAVA EFFECTIVE DESIGN Unique IDs. Static variables are often
                            used to assign a unique ID number or a unique initial value to each
                            instance of a class.
SECTION 14.6  CASE STUDY: Cooperating Threads                 669

14.6.5 The Clerk Class                                                          Thread

 The Clerk thread should simulate the behavior of serving the                                    +run()
 next customer in line, so the Clerk thread will repeatedly access
 TakeANumber.nextCustomer() and then serve that customer. For                                           Clerk
 the sake of this simulation, we'll just print a message to indicate which         -takeANumber : TakeANumber
 customer is being served. Because there's only one clerk in this simu-            +Clerk(in gadget : TakeANumber)
 lation, the only variable in its internal state will be a reference to the        +run()
 TakeANumber object (Fig. 14.22). In addition to the constructor, all we
 really need to define for this class is the run() method. This                Figure 14.22: The Clerk thread.
                                                                             
     leads to the definition of Clerk shown in Figure 14.23. In this case,
 the sleep() method is necessary to allow the Customer threads to run.
 The Clerk will sit in an infinite loop serving the next customer on each
 iteration.



  public class Clerk extends Thread {
      p r i v a t e TakeANumber takeANumber ;

  public Clerk ( TakeANumber gadget ) {
     takeANumber = gadget ;

  }

  public void run ( ) {

  while ( true ) {

  try {

     s l e e p ( ( i n t ) ( Math . random ( )  5 0 ) ) ;

     System . out . println ( "Clerk serving t i c k e t " +

                         takeANumber . nextCustomer ( ) ) ;

  } catch ( InterruptedException e) {

     System . out . println ( "Exception " + e . getMessage ( ) ) ;

  }

  } // w h i l e

  } // run ( )

} // C l e r k

                                                                             

                Figure 14.23: Definition of Clerk, Version 1.

14.6.6 The Bakery Class                                                      The main program

Finally, Bakery is the simplest class to design. It contains the main()
method, which gets the whole simulation started. As we said, its role will
be to create one Clerk thread and several Customer threads, and get
them all started (Fig. 14.24). Notice that the Customers and the Clerk
are each passed a reference to the shared TakeANumber gadget.

Problem: Nonexistent Customers

Now that we have designed and implemented the classes, let's run sev-
eral experiments to test that everything works as intended. Except for
the synchronized nextNumber() method, we've made little attempt
to make sure that the Customer and Clerk threads will work together
cooperatively, without violating the real-world constraints that should be
satisfied by the simulation. If we run the simulation as it is presently
                                   670  CHAPTER 14  Threads and Concurrent Programming

                                                                                              

public class Bakery {
   public s t a t i c void main ( S t r i n g args [ ] ) {
       System . out . p r i n t l n ( " S t a r t i n g c l e r k and customer threads " ) ;
      TakeANumber numberGadget = new TakeANumber ( ) ;
       Clerk c l e r k = new Clerk ( numberGadget ) ;
       clerk . start ();
       for ( int k = 0; k < 5; k++) {
          Customer customer = new Customer ( numberGadget ) ;
          customer . start ( ) ;
       }

  } // main ( )

} // B a k e r y

                                                                                              

                                        Figure 14.24: Definition of the Bakery class.

Testing and debugging              coded, it will generate five customers and the clerk will serve all of them.
                                   But we get something like the following output:
Problem: The clerk thread doesn't
wait for customer threads                                                                                        
The clerk checks the line
                                   S t a r t i n g c l e r k and customer threads

                                        Clerk serving ticket 1

                                        Clerk serving ticket 2

                                        Clerk serving ticket 3

                                        Clerk serving ticket 4

                                        Clerk serving ticket 5

                                   Customer 10004 takes t i c k e t 1

                                   Customer 10002 takes t i c k e t 2

                                        Clerk serving ticket 6

                                   Customer 10005 takes t i c k e t 3

                                        Clerk serving ticket 7

                                        Clerk serving ticket 8

                                        Clerk serving ticket 9

                                        Clerk serving t i c k e t 10

                                   Customer 10001 takes t i c k e t 4

                                   Customer 10003 takes t i c k e t 5                                            
                                   

                                   Our current solution violates an important real-world constraint: You
                                   can't serve customers before they enter the line! How can we ensure
                                   that the clerk doesn't serve a customer unless there's actually a customer
                                   waiting?

                                      The wrong way to address this issue would be to increase the amount
                                   of sleeping that the Clerk does between serving customers. Indeed, this
                                   would allow more customer threads to run, so it might appear to have
                                   the desired effect, but it doesn't truly address the main problem: A clerk
                                   cannot serve a customer if no customer is waiting.

                                      The correct way to solve this problem is to have the clerk check that
                                   there are customers waiting before taking the next customer. One way
                                   to model this would be to add a customerWaiting() method to our
                                   TakeANumber object. This method would return true whenever next
                                   is greater than serving. That will correspond to the real-world situation
                                   in which the clerk can see customers waiting in line. We can make the
SECTION 14.6  CASE STUDY: Cooperating Threads                     671

following modification to Clerk.run():                                         

                                                                               

    public void run ( ) {                                                        TakeANumber
       while ( true ) {
           try {                                                                  -next : int
               s l e e p ( ( i n t ) ( Math . random ( )  5 0 ) ) ;
               i f ( takeANumber . customerWaiting ( ) )                          -serving : int
                  System . out . println ( "Clerk serving t i c k e t "
                                        + takeANumber . nextCustomer ( ) ) ;            +nextNumber() : int
           } catch ( InterruptedException e) {
               System . out . println ( "Exception " + e . getMessage ( ) ) ;   +customerWaiting() : boolean +nextCustomer() : int
           }
       } // w h i l e

    } // run ( )
 

And we add the following method to TakeANumber (Fig. 14.25):

 

    public boolean customerWaiting ( ) {
           return next > serving ;

    }
 

In other words, the Clerk won't serve a customer unless there are cus-          Figure 14.25: The        revised
tomers waiting--that is, unless next is greater than serving. Given             TakeANumber class.
these changes, we get the following type of output when we run the             
simulation:
                                                                               


  S t a r t i n g c l e r k and customer  threads
  Customer 10003 takes t i c k e t        1
                                          2
     Clerk serving ticket 1               3
  Customer 10005 takes t i c k e t        4
                                          5
     Clerk serving ticket 2
  Customer 10001 takes t i c k e t

     Clerk serving ticket 3
  Customer 10004 takes t i c k e t

     Clerk serving ticket 4
  Customer 10002 takes t i c k e t

     Clerk serving ticket 5


This example illustrates that when application design involves cooperat-
ing threads, the algorithm used must ensure the proper cooperation and
coordination among the threads.

JAVA EFFECTIVE DESIGN Thread Coordination. When two or
more threads must behave cooperatively, their interaction must be
carefully coordinated by the algorithm.

14.6.7 Problem: Critical Sections                                              Thread interruptions are
                                                                               unpredictable
It is easy to forget that thread behavior is asynchronous. You can't pre-
dict when a thread might be interrupted or might have to give up the
                                     672           CHAPTER 14  Threads and Concurrent Programming

                                     CPU to another thread. In designing applications that involve cooperat-
                                     ing threads, it's important that the design incorporates features to guard
                                     against problems caused by asynchronicity. To illustrate this problem,
                                     consider the following statement from the Customer.run() method:

                                                                                                                      

                                     System . out . println ( "Customer " + id +

                                          " t a k e s t i c k e t " + takeANumber . nextNumber ( ) ) ;                

                                     Even though this is a single Java statement, it breaks up into several Java
                                     bytecode statements. A Customer thread could certainly be interrupted
                                     between getting the next number back from TakeANumber and printing it
                                     out. We can simulate this by breaking the println() into two statements
                                     and putting a sleep() in their midst:

                                                                                                                      

                                     public void run ( ) {
                                        try {
                                            i n t myturn = takeANumber . nextNumber ( ) ;
                                            s l e e p ( ( i n t ) ( Math . random ( )  1000 ) ) ;
                                            System . out . println ( "Customer " + id +
                                                                       " takes t i c k e t " + myturn ) ;
                                        } catch ( InterruptedException e) {
                                            System . out . println ( "Exception " + e . getMessage ( ) ) ;
                                        }

                                     } // run ( )

                                                                                                                      

                                     If this change is made in the simulation, you might get the following
                                     output:

                                                                                                                      

                                     S t a r t i n g c l e r k and customer threads

                                          Clerk serving ticket 1

                                          Clerk serving ticket 2

                                          Clerk serving ticket 3

                                     Customer 10004 takes t i c k e t 4

                                          Clerk serving ticket 4

                                          Clerk serving ticket 5

                                     Customer 10001 takes t i c k e t 1

                                     Customer 10002 takes t i c k e t 2

                                     Customer 10003 takes t i c k e t 3

                                     Customer 10005 takes t i c k e t 5                                               
                                     

Problem: An interrupt in a critical  Because the Customer threads are now interrupted in between taking a
section                              number and reporting their number, it looks as if they are being served in
                                     the wrong order. Actually, they are being served in the correct order. It's
                                     their reporting of their numbers that is wrong!

                                        The problem here is that the Customer.run() method is being in-
                                     terrupted in such a way that it invalidates the simulation's output. A
                                     method that displays the simulation's state should be designed so that
                                     once a thread begins reporting its state, that thread will be allowed to fin-
                                     ish reporting before another thread can start reporting its state. Accurate
                                     reporting of a thread's state is a critical element of the simulation's overall
                                     integrity.
SECTION 14.6  CASE STUDY: Cooperating Threads                                                  673

   A critical section is any section of a thread that should not be inter-
rupted during its execution. In the bakery simulation, all of the statements
that report the simulation's progress are critical sections. Even though
the chances are small that a thread will be interrupted in the midst of
a println() statement, the faithful reporting of the simulation's state
should not be left to chance. Therefore, we must design an algorithm that
prevents the interruption of critical sections.

Creating a Critical Section

The correct way to address this problem is to treat the reporting of the cus-                          Making a critical section
tomer's state as a critical section. As we saw earlier when we discussed                               uninterruptible
the concept of a monitor, a synchronized method within a shared ob-
ject ensures that once a thread starts the method, it will be allowed to
finish it before any other thread can start it. Therefore, one way out of
this dilemma is to redesign the nextNumber() and nextCustomer()
methods in the TakeANumber class so that they report which customer
receives a ticket and which customer is being served (Fig. 14.26). In this
version all of the methods are synchronized, so all the actions of the
TakeANumber object are treated as critical sections.

                                                                                                

public c l a s s TakeANumber {  // Next p l a c e i n l i n e
   private int next = 0;        // Next c u s t o m e r t o s e r v e
   private int serving = 0;

     public synchronized int nextNumber ( int custId ) {                                        );
         next = next + 1;                                                                       );
         System . out . println ( "Customer " + custId + "
                                                                takes ticket " + next               
         return next ;

     } // nextNumber ( )

     public synchronized int nextCustomer ( ) {
         ++ s e r v i n g ;
         System . out . println ( " Clerk serving t i c k e t "
                                                                                     + serving
         return serving ;

     } // n e x t C u s t o m e r ( )

     public synchronized boolean customerWaiting ( ) {
         return next > serving ;

     } // c u s t o m e r W a i t i n g ( )

  } // TakeANumber


  Figure 14.26: Definition of the TakeANumber class, Version 2.

   Note that the reporting of both the next number and the next customer
to be served are now handled by TakeANumber in Figure 14.26 . Because
the methods that handle these actions are synchronized, they cannot be
interrupted by any threads involved in the simulation. This guarantees
that the simulation's output will faithfully report the simulation's state.
                                   674           CHAPTER 14  Threads and Concurrent Programming

                                      Given these changes to TakeANumber, we must remove the println()
                                   statements from the run() methods in Customer:

                                                                                                                    

                                   public void run ( ) {
                                      try {
                                          s l e e p ( ( i n t ) ( Math . random ( )  2 0 0 0 ) ) ;
                                          takeANumber . nextNumber ( id ) ;
                                      } catch ( InterruptedException e) {
                                          System . out . println ( " Exception : "+ e . getMessage ( ) ) ;
                                      }

                                   } // run ( )

                                                                                                                    

                                   and from the run() method in Clerk:

                                                                                                                    

                                   public void run ( ) {
                                      while ( true ) {
                                          try {
                                             s l e e p ( ( i n t ) ( Math . random ( )  1 0 0 0 ) ) ;
                                              i f ( takeANumber . customerWaiting ( ) )
                                                 takeANumber . nextCustomer ( ) ;
                                          } catch ( InterruptedException e) {
                                             System . out . println ( " Exception : "+e . getMessage ( ) ) ;
                                          }

                                        } // w h i l e

                                   } // run ( )

                                                                                                                    

                                   Rather than printing their numbers, these methods now just call the ap-
                                   propriate methods in TakeANumber. Given these design changes, our
                                   simulation now produces the following correct output:

                                                                                                                    

                                   S t a r t i n g c l e r k and customer threads

                                   Customer 10001 takes t i c k e t 1

                                        Clerk serving ticket 1

                                   Customer 10003 takes t i c k e t 2

                                   Customer 10002 takes t i c k e t 3

                                        Clerk serving ticket 2

                                   Customer 10005 takes t i c k e t 4

                                   Customer 10004 takes t i c k e t 5

                                        Clerk serving ticket 3

                                        Clerk serving ticket 4

                                        Clerk serving ticket 5                                                      

Preventing undesirable interrupts  The lesson to be learned from this is that in designing multithreaded pro-
                                   grams, it is important to assume that if a thread can be interrupted at a
                                   certain point, it will be interrupted at that point. The fact that an interrupt
SECTION 14.6  CASE STUDY: Cooperating Threads  675

is unlikely to occur is no substitute for the use of a critical section. This is
something like "Murphy's Law of Thread Coordination."

JAVA EFFECTIVE DESIGN The Thread Coordination Principle. Use
critical sections to coordinate the behavior of cooperating threads. By
designating certain methods as synchronized, you can ensure their
mutually exclusive access. Once a thread starts a synchronized
method, no other thread will be able to execute the method until the
first thread is finished.

In a multithreaded application, the classes and methods should be de-
signed so that undesirable interrupts will not affect the correctness of the
algorithm.

 JAVA PROGRAMMING TIP Critical Sections. Java's monitor
 mechanism will ensure that while one thread is executing a
 synchronized method, no other thread can gain access to it. Even if the
 first thread is interrupted, when it resumes execution again it will be
 allowed to finish the synchronized method before other threads can
 access synchronized methods in that object.

SELF-STUDY EXERCISE                                                               Busy waiting

EXERCISE 14.10 Given the changes we've described, the bakery sim-
ulation should now run correctly regardless of how slow or fast the
Customer and Clerk threads run. Verify this by placing different-sized
sleep intervals in their run() methods. (Note: You don't want to put a
sleep() in the synchronized methods because that would undermine
the whole purpose of making them synchronized in the first place.)

14.6.8 Using wait/notify to Coordinate Threads

The examples in the previous sections were designed to illustrate the is-
sue of thread asynchronicity and the principles of mutual exclusion and
critical sections. Through the careful design of the algorithm and the ap-
propriate use of the synchronized qualifier, we have managed to design
a program that correctly coordinates the behavior of the Customers and
Clerk in this bakery simulation.

The Busy-Waiting Problem

One problem with our current design of the Bakery algorithm is that it
uses busy waiting on the part of the Clerk thread. Busy waiting occurs
when a thread, while waiting for some condition to change, executes a
loop instead of giving up the CPU. Because busy waiting is wasteful of
CPU time, we should modify the algorithm.
                   676           CHAPTER 14  Threads and Concurrent Programming

                      As it is presently designed, the Clerk thread sits in a loop that repeat-
                   edly checks whether there's a customer to serve:

                                                                                                 

                   public void run ( ) {
                      while ( true ) {
                          try {
                             s l e e p ( ( i n t ) ( Math . random ( )  1 0 0 0 ) ) ;
                              i f ( takeANumber . customerWaiting ( ) )
                                 takeANumber . nextCustomer ( ) ;
                          } catch ( InterruptedException e) {
                             System . out . println ( "Exception : " + e . getMessage ( ) ) ;
                          }

                        } // w h i l e

                   } // run ( )

                                                                                                 

Producer/consumer     A far better solution would be to force the Clerk thread to wait un-
                   til a customer arrives without using the CPU. Under such a design, the
                   Clerk thread can be notified and enabled to run as soon as a Customer
                   becomes available. Note that this description views the customer/clerk
                   relationship as one-half of the producer/consumer relationship. When a
                   customer takes a number, it produces a customer in line that must be served
                   (that is, consumed) by the clerk.

                      This is only half the producer/consumer relationship because we
                   haven't placed any constraint on the size of the waiting line. There's no
                   real limit to how many customers can be produced. If we did limit the
                   line size, customers might be forced to wait before taking a number if, say,
                   the tickets ran out, or the bakery filled up. In that case, customers would
                   have to wait until the line resource became available and we would have
                   a full-fledged producer/consumer relationship.

                   The wait/notify Mechanism

                   So, let's use Java's wait/notify mechanism to eliminate busy waiting
                   from our simulation. As noted in Figure 14.6, the wait() method puts
                   a thread into a waiting state, and notify() takes a thread out of wait-
                   ing and places it back in the ready queue. To use these methods in this
                   program we need to modify the nextNumber() and nextCustomer()
                   methods. If there is no customer in line when the Clerk calls the
                   nextCustomer() method, the Clerk should be made to wait():

                                                                                                 

                   public synchronized int nextCustomer ( )          {
                      try {
                          while ( next <= s e r v i n g )            e . getMessage ( ) ) ;
                             wait ( ) ;                              ticket " + serving );
                      } catch ( InterruptedException e) {
                          System . out . println ( "Exception : " +
                      } finally {
                         ++ s e r v i n g ;
                          System . out . println ( " Clerk serving
                          return serving ;
                      }

                   }

                                                                                                 
SECTION 14.6  CASE STUDY: Cooperating Threads  677

Note that the Clerk still checks whether there are customers waiting. If          A waiting thread gives up the CPU
there are none, the Clerk calls the wait() method. This removes the
Clerk from the CPU until some other thread notifies it, at which point           
it will be ready to run again. When it runs again, it should check that
there is in fact a customer waiting before proceeding. That's why we use a       
while loop here. In effect, the Clerk will wait until there's a customer to
serve. This is not busy waiting because the Clerk thread loses the CPU           
and must be notified each time a customer becomes available.
                                                                                 
   When and how will the Clerk be notified? Clearly, the Clerk should
be notified as soon as a customer takes a number. Therefore, we put a                                 TakeANumber
notify() in the nextNumber() method, which is the method called by                 -next : int
each Customer as it gets in line:                                                  -serving : int
                                                                                   +nextNumber() : int<<synchronized>>
                                                                                   +nextCustomer() : int<<synchronized>>

    public synchronized int nextNumber ( int custId ) {
       next = next + 1;
       System . out . println ( "Customer " + custId +
                                          " takes ticket " + next ) ;
        notify ();
        return next ;

    }
 

Thus, as soon as a Customer thread executes the nextNumber()
method, the Clerk will be notified and allowed to proceed.

   What happens if more than one Customer has executed a wait()? In
that case, the JVM will maintain a queue of waiting Customer threads.
Then, each time a notify() is executed, the JVM will take the first
Customer out of the queue and allow it to proceed.

   If we use this model of thread coordination, we no longer need to test
customerWaiting() in the Clerk.run() method. It is to be tested in
the TakeANumber.nextCustomer(). Thus, the Clerk.run() can be
simplified to

 

    public void run ( ) {
       while ( true ) {
           try {
               s l e e p ( ( i n t ) ( Math . random ( )  1 0 0 0 ) ) ;
               takeANumber . nextCustomer ( ) ;
           } catch ( InterruptedException e) {
               System . out . println ( " Exception : "+ e . getMessage ( ) ) ;
           }
       } // w h i l e

    } // run ( )
 

The Clerk thread may be forced to wait when it calls the nextCustomer
method.

   Because we no longer need the customerWaiting() method, we end
up with the new definition of TakeANumber shown in

   Figures 14.27 and 14.28.

                                                                                 Figure 14.27: In the final design
                                                                                 of TakeANumber, its methods are
                                                                                 synchronized.
678         CHAPTER 14             Threads and Concurrent Programming
                                                                                      


public c l a s s TakeANumber {
   private int next = 0;
   private int serving = 0;

  public synchronized int nextNumber ( int custId ) {
     next = next + 1;
     System . out . println ( "Customer " + custId +
                                          " takes ticket " + next ) ;
     notify ();
     return next ;

  } // nextNumber ( )

  public synchronized int nextCustomer ( ) {

     try {

        while ( next <= s e r v i n g ) {

           System . out . println ( " Clerk waiting " ) ;

           wait ( ) ;

        }

     } catch ( InterruptedException e) {

           System . out . println ( "Exception " + e . getMessage ( ) ) ;

     } finally {

           ++ s e r v i n g ;

           System . out . println ( " Clerk serving t i c k e t "

                                                  + serving );

           return serving ;

     }

  } // n e x t C u s t o m e r ( )

} // TakeANumber

                                                                           

            Figure 14.28: The TakeANumber class, Version 3.

Given this version of the program, the following kind of output will be
generated:

                                                                           

  S t a r t i n g c l e r k and customer threads

  Customer 10004 takes t i c k e t 1

  Customer 10002 takes t i c k e t 2

     Clerk serving ticket 1

     Clerk serving ticket 2

  Customer 10005 takes t i c k e t 3

  Customer 10003 takes t i c k e t 4

     Clerk serving ticket 3

  Customer 10001 takes t i c k e t 5

     Clerk serving ticket 4

     Clerk serving ticket 5

     Clerk waiting                                                         

  JAVA PROGRAMMING TIP Busy Waiting. Java's wait/notify
  mechanism can be used effectively to eliminate busy waiting from a
  multithreaded application.

 JAVA EFFECTIVE DESIGN Producer / Consumer. The
 producer/consumer model is a useful design for coordinating the
 wait/notify interaction.

SELF-STUDY EXERCISE
SECTION 14.7  CASE STUDY: The Game of Pong                   679

EXERCISE 14.11 An interesting experiment to try is to make the Clerk         Wait/notify go into synchronized
a little slower by making it sleep for up to 2,000 milliseconds. Take a      methods
guess at what would happen if you ran this experiment. Then run the
experiment and observe the results.

The wait/notify Mechanism

There are a number of important restrictions that must be observed when
using the wait/notify mechanism:

 Both wait() and notify() are methods of the Object class, not the
   Thread class. This enables them to lock objects, which is the essential
   feature of Java's monitor mechanism.

 A wait() method can be used within a synchronized method. The
   method doesn't have to be part of a Thread.

 You can only use wait() and notify() within synchronized
   methods. If you use them in other methods, you will cause
   an IllegalMonitorStateException with the message "current
   thread not owner."

 When a wait()--or a sleep()--is used within a synchronized
   method, the lock on that object is released so that other methods can
   access the object's synchronized methods.

JAVA DEBUGGING TIP Wait/Notify. It's easy to forget that the
wait() and notify() methods can only be used within
synchronized methods.

14.7 CASE STUDY: The Game of Pong

The game of Pong was one of the first computer video games and was all
the rage in the 1970s. The game consists of a ball that moves horizontally
and vertically within a rectangular region, and a single paddle, which is
located at the right edge of the region that can be moved up and down by
the user. When the ball hits the top, left, or bottom walls or the paddle,
it bounces off in the opposite direction. If the ball misses the paddle, it
passes through the right wall and re-emerges at the left wall. Each time
the ball bounces off a wall or paddle, it emits a pong sound.

14.7.1 A Multithreaded Design

Let's develop a multithreaded GUI to play the game of Pong.
   Figure 14.29 shows how the game's GUI should appear. There are three

objects involved in this program: the frame, which serves as the GUI, the
ball, which is represented as a blue circle in the program, and the paddle,
which is represented by a red rectangle along the right edge of the frame.
What cannot be seen in this figure is that the ball moves autonomously,
bouncing off the walls and paddle. The paddle's motion is controlled by
the user by pressing the up- and down-arrow keys on the keyboard.

   We will develop class definitions for the ball, paddle, and the frame.
Following the example of our dot-drawing program earlier in the Chapter,
we will employ two independent threads, one for the GUI and one for the

                                                                             Figure 14.29: The UI for Pong.
                                  680  CHAPTER 14  Threads and Concurrent Programming

                                  ball. Because the user will control the movements of the paddle, the frame
                                  will employ a listener object to listen for and respond to the user's key
                                  presses.

                                     Figure 14.30 provides an overview of the object-oriented design of the
                                  Pong program. The PongFrame class is the main class. It uses instances
                                  of the Ball and Paddle classes. PongFrame is a subclass of JFrame
                                  and implements the KeyListener interface. This is another of the sev-

Figure 14.30: Design of the Pong
program.

                                  eral event handlers provided in the java.awt library. This one han-
                                  dles KeyEvents and the KeyListener interface consists of three ab-
                                  stract methods: keyPressed(), keyTyped(), and keyReleased(), all
                                  of which are associated with the act of pressing a key on the keyboard.
                                  All three of these methods are implemented in the PongFrame class. A
                                  key-typed event occurs when a key is pressed down. A key-release event
                                  occurs when a key that has been pressed down is released. A key-press
                                  event is a combination of both of these events.

                                     The Ball class is a Thread subclass. Its data and methods are de-
                                  signed mainly to keep track of its motion within the program's drawing
                                  panel. The design strategy employed here leaves the drawing of the ball
                                  up to the frame. The Ball thread itself just handles the movement within
                                  the program's drawing panel. Note that the Ball() constructor takes a
                                  reference to the PongFrame. As we will see, the Ball uses this reference
                                  to set the dimensions of the frame's drawing panel. Also, as the Ball
SECTION 14.7  CASE STUDY: The Game of Pong  681

moves, it will repeatedly call the frame's repaint() method to draw the
ball.

   The Paddle class is responsible for moving the paddle up and down
along the drawing panel's right edge. Its public methods, moveUP() and
moveDown(), will be called by the frame in response to the user pressing
the up and down arrows on the keyboard. Because the frame needs to
know where to draw the paddle, the paddle class contains several public
methods, getX(), getY(), and resetLocation(), whose tasks are to
report the paddle's location or to adjust its location in case the frame is
resized.

   The PongFrame controls the overall activity of the program. Note in
particular its ballHitsPaddle() method. This method has the task
of determining when the ball and paddle come in contact as the ball
continuously moves around in the frame's drawing panel. As in the
ThreadedDotty example earlier in the chapter, it is necessary for the
Ball and the the frame to be implemented as separated threads so that
the frame can be responsive to the user's key presses.

14.7.2 Implementation of the Pong Program

We begin our discussion of the program's implementation with the
Paddle class implementation (Fig. 14.31).

   Class constants, HEIGHT and WIDTH are used to define the size of the
Paddle, which is represented on the frame as a simple rectangle. The
frame will use the Graphics.fillRect() method to draw the paddle:

                                                                                            

g . f i l l R e c t ( pad . getX ( ) , pad . getY ( ) , Paddle .WIDTH, Paddle . HEIGHT ) ;  


Note how the frame uses the paddle's getX() and getY() methods to
get the paddle's current location.

   The class constants DELTA and BORDER are used to control the paddle's
movement. DELTA represents the number of pixels that the paddle moves
on each move up or down, and BORDER is used with gameAreaHeight
to keep the paddle within the drawing area. The moveUp() and
moveDown() methods are called by the frame each time the user presses
an up- or down-arrow key. They simply change the paddle's location by
DELTA pixels up or down.
682               CHAPTER 14  Threads and Concurrent Programming

                                                                                                       

public class Paddle {
       p u b li c s t a t i c f i n a l i n t HEIGHT = 5 0 ; // P a d d l e s i z e
       public s t a t i c f i n a l i n t WIDTH = 1 0 ;
       p r i v a t e s t a t i c f i n a l i n t DELTA = HEIGHT/ 2 ; // Move s i z e
       p r i v a t e s t a t i c f i n a l i n t BORDER = 0 ;
       private int gameAreaHeight ;
       private int locationX , locationY ;
       private PongFrame frame ;

     public Paddle ( PongFrame f ) {

        frame = f ;

        gameAreaHeight = f . getHeight ( ) ;

        l o c a t i o n X = f . getWidth () -WIDTH;

        locationY = gameAreaHeight /2;

     } // P a d d l e ( )

     public void resetLocation ( ) {

        gameAreaHeight = frame . getHeight ( ) ;

        l o c a t i o n X = frame . getWidth () -WIDTH;

     }

     public int getX ( ) {

        return locationX ;

     }

     public int getY ( ) {

        return locationY ;

     }

     public void moveUp ( ) {

        i f ( l o c a t i o n Y > BORDER )

                  l o c a t i o n Y -= DELTA ;

     } // moveUp ( )

     public void moveDown ( ) {

        i f ( l o c a t i o n Y + HEIGHT < gameAreaHeight - BORDER)

                  l o c a t i o n Y += DELTA ;

     } // moveDown ( )

} // P a d d l e

                                                                                                       

                  Figure 14.31: Definition of the Paddle class.

   The Ball class (Fig. 14.32) uses the class constant SIZE to determine
the size of the oval that represents the ball, drawn by the frame as follows:

                                                                                                       

  g . f i l l O v a l ( b a l l . getX ( ) , b a l l . getY ( ) , b a l l . SIZE , b a l l . SIZE ) ;  


As with the paddle, the frame uses the ball's getX() and getY() method
to determine the ball's current location.

   Unlike the paddle, however, the ball moves autonomously. Its run()
method, which is inherited from its Thread superclass, repeatedly moves
the ball, draws the ball, and then sleeps for a brief interval (to slow down
the speed of the ball's apparent motion). The run() method itself is quite
simple because it consists of a short loop. We will deal with the details of
how the ball is painted on the frame when we discuss the frame itself.
SECTION 14.7  CASE STUDY: The Game of Pong                   683

                                                                                                                

import javax . swing .  ;
import java . awt . Toolkit ;

public class Ball extends Thread {

  public s t a t i c final int SIZE = 10; // D i a m e t e r o f t h e b a l l

  private PongFrame frame ;                       // R e f e r e n c e t o t h e f r a m e

  private int topWall , bottomWall , leftWall , rightWall ; // B o u n d a r i e s

  private int locationX , locationY ;                       // C u r r e n t l o c a t i o n o f t h e b a l l

  private int directionX = 1 , directionY = 1; //x- and y- d i r e c t i o n ( 1 or -1)

  private Toolkit kit = Toolkit . getDefaultToolkit ( ) ; // For beep ( ) method

  public B a l l ( PongFrame f ) {                              // S e t i n i t i a l l o c a t i o n
     frame = f ;
     locationX = leftWall + 1;                              // D e f i n e b o u n c i n g r e g i o n
     locationY = bottomWall /2;                               // And l o c a t i o n o f w a l l s

  } // B a l l ( )                                          C a l c u l a t e a new l o c a t i o n
  public int getX ( ) {

     return locationX ;
  } // getX ( )
  public int getY ( ) {

     return locationY ;
  } // getY ( )
  public void move ( ) {

     rightWall = frame . getWidth ( ) - SIZE ;
     leftWall = topWall = 0;
     bottomWall = frame . getHeight ( ) - SIZE ;
     locationX = locationX + directionX ; //
     locationY = locationY + directionY ;

  if ( frame . ballHitsPaddle ( ) ) {

  directionX = -1; // move t o w a r d l e f t w a l l

  k it . beep ( ) ;

  } // i f b a l l h i t s p a d d l e

  i f ( l o c a t i o n X <= l e f t W a l l ) {

  directionX = + 1; // move toward r i g h t w a l l

  k it . beep ( ) ;

  } // i f b a l l h i t s l e f t w a l l

  i f ( l o c a t i o n Y + SIZE >= bottomWall | | l o c a t i o n Y <= topWall ) {

  directionY = -directionY ;                      // r e v e r s e d i r e c t i o n

  k it . beep ( ) ;

  } // i f b a l l h i t s top or bottom w a l l s

  i f ( l o c a t i o n X >= r i g h t W a l l + SIZE ) {

  locationX = leftWall + 1; // jump back to l e f t w a l l

  } // i f b a l l g o e s t h r o u g h r i g h t w a l l

  } // move ( )

  public void run ( ) {

  while ( true ) {

  move ( ) ;                            // Move

  frame . repaint ( ) ;

  try { sleep (15);

  } catch ( InterruptedException e ) {}

  } // w h i l e

  } // run ( )

} // B a l l

                                                                                                                

                 Figure 14.32: Definition of the Ball class.
684  CHAPTER 14  Threads and Concurrent Programming

   The most complex method in the Ball class is the move() method.
This is the method that controls the ball's movement within the bound-
aries of the frame's drawing area. This method begins by moving the
ball by one pixel left, right, up, or down by adjusting the values of its
locationX and locationY coordinates:

                                                                             

locationX = locationX + directionX ; // C a l c u l a t e l o c a t i o n

locationY = locationY + directionY ;                                         


The directionX and directionY variables are set to either +1 or -1,
depending on whether the ball is moving left or right, up or down. After
the ball is moved, the method uses a sequence of if statements to check
whether the ball is touching one of the walls or the paddle. If the ball is
in contact with the top, left, or bottom walls or the paddle, its direction
is changed by reversing the value of the directionX or directionY
variable. The direction changes depend on whether the ball has touched
a horizontal or vertical wall. When the ball touches the right wall, having
missed the paddle, it passes through the right wall and re-emerges from
the left wall going in the same direction.

   Note how the frame method, ballHitsPaddle() is used to deter-
mine whether the ball has hit the paddle. This is necessary because only
the frame knows the locations of both the ball and the paddle.

14.7.3 The KeyListener Interface

The implementation of the PongFrame class is shown in figure 14.33. The
frame's main task is to manage the drawing of the ball and paddle and
to handle the user's key presses. Handling keyboard events is a simple
matter of implementing the KeyListener interface. This works in much
the same way as the ActionListener interface, which is used to handle
button clicks and other ActionEvents. Whenever a key is pressed, it
generates KeyEvents, which are passed to the appropriate methods of
the KeyListener interface.

   There's a bit of redundancy in the KeyListener interface in the sense
that a single key press and release generates three KeyEvents: A key-
typed event, when the key is pressed, a key-released event, when the key
is released, and a key-pressed event, when the key is pressed and released.
While it is important for some programs to be able to distinguish be-
tween a key-typed and key-released event, for this program, we will take
action whenever one of the arrow keys is pressed (typed and released).
Therefore, we implement the keyPressed() method as follows:

                                                                             

public void keyPressed ( KeyEvent e ) { // Check a r r o w k e y s

     int keyCode = e . getKeyCode ( ) ;

     i f ( keyCode == e . VK UP )          // Up a r r o w

     pad . moveUp ( ) ;

     e l s e i f ( keyCode == e .VK DOWN)  // Down a r r o w

     pad . moveDown ( ) ;

} // k e y R e l e a s e d ( )

                                                                             

Each key on the keyboard has a unique code that identifies the key.
The key's code is gotten from the KeyEvent object by means of the
                SECTION 14.7  CASE STUDY: The Game of Pong                                            685

                                                                                                       

import javax . swing .  ;
import java . awt .  ;
import java . awt . event .  ;

public c l a s s PongFrame extends JFrame implements KeyListener {
         private Ball ball ;
         pr ivat e Paddle pad ;

  public PongFrame ( ) {                      Create the paddle
         setBackground ( Color . white ) ;    // C r e a t e t h e b a l l
         addKeyListener ( this ) ;
         pad = new Paddle ( t h i s ) ; //
         b a l l = new B a l l ( t h i s ) ;
         ball . start ();

  } // PongFrame ( )

  public void paint ( Graphics g ) {
          g . setColor ( getBackground ( ) ) ; // E r a s e t h e drawing a r e a
          g . f i l l R e c t (0 ,0 , getWidth ( ) , getHeight ( ) ) ;

  g . setColor ( Color . blue ) ;             // P a i n t t h e b a l l

  g . f i l l O v a l ( b a l l . getX ( ) , b a l l . getY ( ) , b a l l . SIZE , b a l l . SIZE ) ;

  pad . r e s e t L o c a t i o n ( ) ;       // P a i n t t h e p a d d l e

  g . setColor ( Color . red ) ;

  g . f i l l R e c t ( pad . getX ( ) , pad . getY ( ) , Paddle .WIDTH, Paddle . HEIGHT ) ;

  } // p a i n t ( )

   public boolean ballHitsPaddle ( ) {                         pad . getX ( )
           r e t u r n b a l l . getX ( ) + B a l l . SIZE >=  Paddle . HEIGHT ;
                && b a l l . getY ( ) >= pad . getY ( )
                && b a l l . getY ( ) <= pad . getY ( ) +

  } // b a l l H i t s P a d d l e ( )

  public void keyPressed ( KeyEvent e ) { // Check f o r a r r o w k e y s

  int keyCode = e . getKeyCode ( ) ;

  i f ( keyCode == e . VK UP )                                 // Up a r r o w

  pad . moveUp ( ) ;

  e l s e i f ( keyCode == e .VK DOWN)                         // Down a r r o w

  pad . moveDown ( ) ;

  } // k e y R e l e a s e d ( )

  public void keyTyped ( KeyEvent e ) {}                       // Unused

  public void keyReleased ( KeyEvent e ) {} // Unused

  public s t a t i c void main ( S t r i n g [ ] args ) {

  PongFrame f = new PongFrame ( ) ;

  f . setSize (400 ,400);

  f . setVisible ( true );

} // PongFrame

                                                                                                       

                                  Figure 14.33: Definition of the PongFrame class.
                  686  CHAPTER 14  Threads and Concurrent Programming

Double buffering  getKeyCode() method. Then it is compared with the codes for the up-
                  arrow and down-arrow keys, which are implemented as class constants,
                  VK UP and VK DOWN, in the KeyEvent class. If either of those keys were
                  typed, the appropriate paddle method, moveUP() or moveDown(), is
                  called.

                     Note that even though we are not using the keyPressed() and
                  keyReleased() methods in this program, it is still necessary to provide
                  implementations for these methods in the frame. In order to implement
                  an interface, such as the KeyListener interface, you must implement
                  all the abstract methods in the interface. That is why we provide triv-
                  ial implementations of both the keyPressed() and keyReleased()
                  methods.

                  14.7.4 Animating the Bouncing Ball

                  Computer animation is accomplished by repeatedly drawing, erasing,
                  and re-drawing an object at different locations on the drawing panel.
                  The frame's paint() method is used for drawing the ball and the pad-
                  dle at their current locations. The paint() method is never called di-
                  rectly. Rather, it is called automatically after the constructor method
                  PongFrame(), when the program is started. It is then invoked indirectly
                  by the program by calling the repaint() method, which is called in the
                  run() method of the Ball class. The reason that paint() is called in-
                  directly is because Java needs to pass it the frame's current Graphics
                  object. Recall that in Java all drawing is done using a Graphics object.

                     In order to animate the bouncing ball, we first erase the current image
                  of the ball, then we draw the ball in its new location. We also draw the
                  paddle in its current location. These steps are carried out in the frame's
                  paint() method. First, the drawing area is cleared by painting its rect-
                  angle in the background color. Then the ball and paddle are painted at
                  their current locations. Note that before painting the paddle, we first call
                  its resetLocation() method. This causes the paddle to be relocated in
                  case the user has resized the frame's drawing area. There is no need to
                  do this for the ball because the ball's drawing area is updated within the
                  Ball.move() method every time the ball is moved.

                     One problem with computer animations of this sort is that the repeated
                  drawing and erasing of the drawing area can cause the screen to flicker.
                  In some drawing environments a technique known as double buffering
                  is used to reduce the flicker. In double buffering, an invisible, off-screen,
                  buffer is used for the actual drawing operations and it is then used to
                  replace the visible image all at once when the drawing is done. Fortu-
                  nately, Java's Swing components, including JApplet and JFrame, per-
                  form an automatic form of double buffering, so we needn't worry about
                  it. Some graphics environments, including Java's AWT environment, do
                  not perform double buffering automatically, in which case the program
                  itself must carry it out.

                     Like the other examples in this chapter, the game of Pong provides a
                  simple illustration of how threads are used to coordinate concurrent ac-
                  tions in a computer program. As most computer game fans will realize,
                  most modern interactive computer games utilize a multithreaded design.
                  The use of threads allows our interactive programs to achieve a respon-
                  siveness and sophistication that is not possible in single-threaded pro-
CHAPTER 14  Chapter Summary              687

grams. One of the great advantages of Java is that it simplifies the use of
threads, thereby making thread programming accessible to programmers.
However, one of the lessons that should be drawn from this chapter is
that multithreaded programs must be carefully designed in order to work
effectively.

SELF-STUDY EXERCISE

EXERCISE 14.12 Modify the PongFrame program so that it contains a
second ball that starts at a different location from the first ball.

Technical Terms                                                                 CHAPTER SUMMARY

asynchronous         multitasking         round-robin
blocked              multithreaded           scheduling
busy waiting         mutual exclusion
concurrent           priority scheduling  scheduling algorithm
critical section     producer/consumer    task
dispatched                                thread
fetch-execute cycle     model             thread life cycle
lock                 quantum              time slicing
monitor              queue
                     ready queue

Summary of Important Points

 Multitasking is the technique of executing several tasks at the same time
   within a single program. In Java we give each task a separate thread of
   execution, thus resulting in a multithreaded program.

 A sequential computer with a single central processing unit (CPU) can
   execute only one machine instruction at a time. A parallel computer
   uses multiple CPUs operating simultaneously to execute more than one
   instruction at a time.

 Each CPU uses a fetch-execute cycle to retrieve the next machine in-
   struction from memory and execute it. The cycle is under the control
   of the CPU's internal clock, which typically runs at several hundred
   megahertz--where 1 megahertz (MHz) is 1 million cycles per second.

 Time slicing is the technique whereby several threads can share a single
   CPU over a given time period. Each thread is given a small slice of the
   CPU's time under the control of some kind of scheduling algorithm.

 In round-robin scheduling, each thread is given an equal slice of time,
   in a first-come-first-served order. In priority scheduling, higher-priority
   threads are allowed to run before lower-priority threads are run.

 There are generally two ways of creating threads in a program. One is
   to create a subclass of Thread and implement a run() method. The
   other is to create a Thread instance and pass it a Runnable object--
   that is, an object that implements run().

 The sleep() method removes a thread from the CPU for a determi-
   nate length of time, giving other threads a chance to run.

 The setPriority() method sets a thread's priority. Higher-priority
   threads have more and longer access to the CPU.
688  CHAPTER 14  Threads and Concurrent Programming

 Threads are asynchronous. Their timing and duration on the CPU are
  highly sporadic and unpredictable. In designing threaded programs,
  you must be careful not to base your algorithm on any assumptions
  about the threads' timing.

 To improve the responsiveness of interactive programs, you could
  give compute-intensive tasks, such as drawing lots of dots, to a lower-
  priority thread or to a thread that sleeps periodically.

 A thread's life cycle consists of ready, running, waiting, sleeping, and
  blocked states. Threads start in the ready state and are dispatched to
  the CPU by the scheduler, an operating system program. If a thread
  performs an I/O operation, it blocks until the I/O is completed. If it
  voluntarily sleeps, it gives up the CPU.

 According to the producer/consumer model, two threads share a re-
  source, one serving to produce the resource and the other to consume
  the resource. Their cooperation must be carefully synchronized.

 An object that contains synchronized methods is known as a mon-
  itor. Such objects ensure that only one thread at a time can execute a
  synchronized method. The object is locked until the thread completes
  the method or voluntarily sleeps. This is one way to ensure mutually
  exclusive access to a resource by a collection of cooperating threads.

 The synchronized qualifier can also be used to designate a method
  as a critical section, whose execution should not be preempted by one of
  the other cooperating threads.

 In designing multithreaded programs, it is useful to assume that if a
  thread can be interrupted at a certain point, it will be interrupted there.
  Thread coordination should never be left to chance.

 One way of coordinating two or more cooperating threads is to use
  the wait/notify combination. One thread waits for a resource to
  be available, and the other thread notifies when a resource becomes
  available.
CHAPTER 14  Solutions to Self-Study Exercises            689

  SOLUTION 14.1                                               SOLUTIONS TO
                                                           SELF-STUDY EXERCISES

  public class PrintOdds implements Runnable {
      p r i v a t e i n t bound ;
     public PrintOdds ( int b) {
       bound = b ;
     }

   public void print ( ) {               k+=2)
      i f ( i n t k = 1 ; k < bound ;
          System . out . println (k ) ;

   }

   public void run ( ) {

      print ();

   }

}

                                                          

SOLUTION 14.2 On my system, the experiment yielded the following output, if
each thread printed its number after every 100,000 iterations:

                                                          

1111112222222211111111333333322222221111113333333

222224444444433333344444445555555544444555555555555       


This suggests that round-robin scheduling is being used.

SOLUTION 14.3 If each thread is given 50 milliseconds of sleep on each itera-
tion, they tend to run in the order in which they were created:

                                                          

123451234512345...                                        


SOLUTION 14.4 The garbage collector runs whenever the available memory
drops below a certain threshold. It must have higher priority than the application,
since the application won't be able to run if it runs out of memory.

SOLUTION 14.5 To improve the responsiveness of an interactive program, the
system could give a high priority to the threads that interact with the user and a
low priority to those that perform noninteractive computations, such as number
crunching.

SOLUTION 14.6 If the JVM were single threaded, it wouldn't be possible to
break out of an infinite loop, because the program's loop would completely con-
sume the CPU's attention.

SOLUTION 14.7 If round-robin scheduling is used, each thread will be get a por-
tion of the CPU's time, so the GUI thread will eventually get its turn. But you don't
know how long it will be before the GUI gets its turn, so there might still be an
unacceptably long wait before the user's actions are handled. Thus, to guarantee
responsiveness, it is better to have the drawing thread sleep on every iteration.

SOLUTION 14.8 If Dotty's priority is set to 1, a low value, this does improve
the responsiveness of the interface, but it is significantly less responsive than using
a sleep() on each iteration.
                                  690              CHAPTER 14  Threads and Concurrent Programming

                                  SOLUTION 14.9 In a real bakery only one customer at a time can take a number.
                                  The take-a-number gadget "enforces" mutual exclusion by virtue of its design:
                                  There's room for only one hand to grab the ticket and there's only one ticket per
                                  number. If two customers got "bakery rage" and managed to grab the same ticket,
                                  it would rip in half and neither would benefit.

                                  SOLUTION 14.10 One experiment to run would be to make the clerk's perfor-
                                  mance very slow by using large sleep intervals. If the algorithm is correct, this
                                  should not affect the order in which customers are served. Another experiment
                                  would be to force the clerk to work fast but the customers to work slowly. This
                                  should still not affect the order in which the customers are served.

                                  SOLUTION 14.11 You should observe that the waiting line builds up as cus-
                                  tomers enter the bakery, but the clerk should still serve the customers in the correct
                                  order.

                                  SOLUTION 14.12 A two-ball version of Pong would require the following
                                  changes to the original version:

                                   1. A new Ball() constructor that has parameters to set the initial location and
                                         direction of the ball.

                                   2. The PongFrame should create a new Ball instance, start it, and draw it.

EXERCISES                         EXERCISE 14.1 Explain the difference between the following pairs of terms:

Note: For programming exercises,  a. Blocked and ready.                     e. Concurrent and time slicing.
first draw a UML class diagram
describing all classes and their  b. Priority and round-robin scheduling. f. Mutual exclusion and critical section.
inheritance relationships and/or
associations.                     c. Producer and consumer.                 g. Busy and nonbusy waiting.

                                  d. Monitor and lock.

                                  EXERCISE 14.2 Fill in the blanks.

                                  a.               happens when a CPU's time is divided among several different

                                      threads.

                                  b. A method that should not be interrupted during its execution is known as a

                                                .

                                  c. The scheduling algorithm in which each thread gets an equal portion of the

                                      CPU's time is known as             .

                                  d. The scheduling algorithm in which some threads can preempt other threads is

                                      known as           .

                                  e. A             is a mechanism that enforces mutually exclusive access to a syn-

                                      chronized method.

                                  f. A thread that performs an I/O operation may be forced into the          state

                                      until the operation is completed.

                                  EXERCISE 14.3 Describe the concept of time slicing as it applies to CPU
                                  scheduling.

                                  EXERCISE 14.4 What's the difference in the way concurrent threads would be
                                  implemented on a computer with several processors and on a computer with a
                                  single processor?

                                  EXERCISE 14.5 Why are threads put into the blocked state when they perform
                                  an I/O operation?

                                  EXERCISE 14.6 What's the difference between a thread in the sleep state and a
                                  thread in the ready state?
CHAPTER 14  Exercises  691

EXERCISE 14.7 Deadlock is a situation that occurs when one thread is holding
a resource that another thread is waiting for, while the other thread is holding
a resource that the first thread is waiting for. Describe how deadlock can occur
at a four-way intersection with cars entering from each branch. How can it be
avoided?

EXERCISE 14.8 Starvation can occur if one thread is repeatedly preempted by
other threads. Describe how starvation can occur at a four-way intersection and
how it can be avoided.

EXERCISE 14.9 Use the Runnable interface to define a thread that repeatedly
generates random numbers in the interval 2 through 12.

EXERCISE 14.10 Create a version of the Bakery program that uses two clerks
to serve customers.

EXERCISE 14.11 Modify the Numbers program so that the user can in-
teractively create NumberThreads and assign them a priority. Modify the
NumberThreads so that they print their numbers indefinitely (rather than for a
fixed number of iterations). Then experiment with the system by observing the
effect of introducing threads with the same, lower, or higher priority. How do
the threads behave when they all have the same priority? What happens when
you introduce a higher-priority thread into the mix? What happens when you
introduce a lower-priority thread into the mix?

EXERCISE 14.12 Create a bouncing ball simulation in which a single ball
(thread) bounces up and down in a vertical line. The ball should bounce off the
bottom and top of the enclosing frame.

EXERCISE 14.13 Modify the simulation in the previous exercise so that more
than one ball can be introduced. Allow the user to introduce new balls into the
simulation by pressing the space bar or clicking the mouse.

EXERCISE 14.14 Modify your solution to the previous problem by having the
balls bounce off the wall at a random angle.

EXERCISE 14.15 Challenge: One type of producer/consumer problem is the
reader/writer problem. Create a subclass of JTextField that can be shared by
threads, one of which writes a random number to the text field, and the other of
which reads the value in the text field. Coordinate the two threads so that the
overall effect of the program will be to print the values from 0 to 100 in the proper
order. In other words, the reader thread shouldn't read a value from the text field
until there's a value to be read. The writer thread shouldn't write a value to the
text field until the reader has read the previous value.

EXERCISE 14.16 Challenge: Create a streaming banner thread that moves a
simple message across a panel. The message should repeatedly enter at the left
edge of the panel and exit from the right edge. Design the banner as a subclass of
JPanel and have it implement the Runnable interface. That way it can be added
to any user interface. One of its constructors should take a String argument that
lets the user set the banner's message.

EXERCISE 14.17 Challenge: Create a slide show program, which repeatedly
cycles through an array of images. The action of displaying the images should
be a separate thread. The frame thread should handle the user interface. Give
the user some controls that let it pause, stop, start, speed up, and slow down the
images.
692  CHAPTER 14  Threads and Concurrent Programming

EXERCISE 14.18 Challenge: Create a horse race simulation, using separate
threads for each of the horses. The horses should race horizontally across the
screen, with each horse having a different vertical coordinate. If you don't have
good horse images to use, just make each horse a colored polygon or some other
shape. Have the horses implement the Drawable interface, which we introduced
in Chapter chapter-inheritance.

EXERCISE 14.19 Challenge: Create a multithreaded digital clock application.
One thread should keep time in an endless while loop. The other thread should
be responsible for updating the screen each second.
Chapter 15

Sockets and Networking

OBJECTIVES

After studying this chapter, you will
 Understand some basics about networks.
 Know how to use Java's URL class to download network resources from a GUI or console application.
 Be able to design networking applications, using the client/server model.
 Understand how to use Java's Socket and ServerSocket classes.

OUTLINE

15.1 Introduction
15.2 An Overview of Networks
15.3 Using Network Resources from an Applet
15.4 From the Java Library: java.net.URL
15.5 The Slide Show Program
15.6 Using Network Resources from an Application
15.7 Client/Server Communication via Sockets
15.8 Case Study: Generic Client/Server Classes
15.9 Playing One Row Nim Over the Network
15.10 Java Network Security Restrictions

         Special Topic: Privacy and the Internet
15.11 Java Servlets and Server Pages

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              693
                                  694                 CHAPTER 15  Sockets and Networking

                                  15.1 Introduction

                                  One of the key strengths of Java is the support it provides for the Internet
                                  and client/server programming. In the previous chapter, we saw how to
                                  make Java programs transfer information to and from external files. Al-
                                  though files are external to the programs that process them, they are still
                                  located on the same computer. In this chapter, we learn how to transfer
                                  information to and from files that reside on a network. This enables pro-
                                  grams to communicate with programs running on other computers. With
                                  networking, we can communicate with computers anywhere in the world.

                                  15.2 An Overview of Networks

Network topology                  Networking is a broad and complex topic. In a typical computer science
                                  curriculum, it is covered in one or more upper-level courses. Neverthe-
Figure 15.1: Star, bus, and ring  less, in this chapter you can learn enough about networking to be able to
topologies.                       use network resources and to design simple Java networking applications.

                                  15.2.1 Network Size and Topology

                                  Computer networks come in a variety of sizes and shapes. A local area
                                  network (LAN) is usually a privately owned network located within a sin-
                                  gle office or a single organization. Your campus network would be an
                                  example of a LAN. A wide area network (WAN) spans a wide geographical
                                  distance like a country or a continent. It may use a combination of public,
                                  private, and leased communication devices. Some of the large commercial
                                  networks, such as MCI and Sprint, are examples of WANs.

                                     The computers that make up a network can be arranged in a variety of
                                  topologies, or shapes, some of the most common of which are shown in Fig-
                                  ures 15.1 and 15.2. As you would expect, different topologies use different
                                  techniques for transmitting information from computer to computer.

                                       Hub

                                       Star topology  Bus topology

                                                                                     Ring topology

                                     In a star network (Fig. 15.1), a central computer functions as a hub,
                                  with every other computer in the network connected to the hub. Each
SECTION 15.2  An Overview of Networks                   695
                                                                 Figure 15.2: Tree and fully con-
                                                                 nected mesh topologies.

                  Hub

Hub                              Hub

                  Tree topology         Fully connected
                                        mesh topology

computer can communicate with the others but only through the hub. The
bus topology doesn't have a hub computer. Instead, each node looks at
each message sent on the bus to find those that are addressed to it. In
sending a message, a node waits until the bus is free and then transmits
the message.

   A ring network (Fig. 15.1) also has no host, and the computers are con-
nected in a loop, through which they exchange information. The tree
topology (Fig. 15.2) is organized into a hierarchy, with each level (trunk
of the tree, major branch of the tree) controlled by a hub. The fully con-
nected mesh network directly connects all points to all points, eliminat-
ing the "middleman." Here there is no need to go through one or more
other computers in order to communicate with a particular computer in
the network.

   Network topologies differ quite a bit in the expense of the wiring they
require, their efficiency, their susceptibility to failure, and the types of
protocols they use. These differences are beyond the scope of this chapter.

15.2.2 Internets

An internet (lowercase i) is a collection of two or more distinct networks,     An internet vs. the Internet
joined by devices called routers (Fig. 15.3). An internet is like a meeting of
the United Nations. Each country sends a delegation, all of whose mem-
bers speak that country's language. A national delegation is like a single
computer network. Language interpreters take on the task of translating
one language to another so that any two delegations, say, the United States
and China, can communicate. The routers play a similar translation role
within an internet. The UN conference, composed of communicating del-
egations from all the different countries of the world, is like a worldwide
internet.

   The United Nations is an apt analogy for the Internet (uppercase I),
which is an example of a particular worldwide internet. Internets, in the
generic sense, shouldn't be confused with the Internet. It's quite likely
that your campus LAN is itself composed of several, smaller networks,
each of which uses its own "language."
                                                 696          CHAPTER 15  Sockets and Networking
Figure 15.3: An internet is a col-
lection of distinct networks joined                                 Router
together by routers.

                                                      LAN             LAN

                                                      Router  WAN     Router

                                                      LAN     Router  LAN

Network protocols  SELF-STUDY EXERCISES

                   EXERCISE 15.1 In a network of ten computers, which topology would
                   require the most cables?

                   EXERCISE 15.2 Which topology would be most resistant to having one
                   of its computers crash?

                   EXERCISE 15.3 Which topology would be least resistant to having one
                   of its computers crash?

                   15.2.3 Network Protocols

                   A protocol is a set of rules that governs the communication of infor-
                   mation. For example, the World Wide Web is based on the HyperText
                   Transfer Protocol (HTTP). HTTP describes how information is to be ex-
                   changed between a Web browser, such as Internet Explorer or Netscape
                   Navigator, and a Web server, which stores an individual's or company's
                   Web pages. Web pages are encoded in the HyperText Markup Language
                   (HTML). Among other things, the HTTP protocol can interpret HTML
                   pages.

                      Similarly, the Simple Mail Transfer Protocol (SMTP) is a set of rules
                   that governs the transfer of e-mail. And the File Transfer Protocol (FTP) is
                   the protocol that governs the transfer of files across the Internet.

                   Application Protocols

                   These three examples--HTTP, SMTP, and FTP--are examples of applica-
                   tion protocols. They are relatively high-level protocols that support and
                   govern a particular network application, such as e-mail or WWW ac-
                   cess. Among the things they determine how we address different com-
                   puters on the network. For example, the HTTP protocol specifies Web
                   addresses by using a Uniform Resource Locator (URL). A URL speci-
                   fies three necessary bits of information: The method used to transfer in-
                   formation (e.g., HTTP or FTP), the address of the host computer (e.g.,
SECTION 15.2  An Overview of Networks  697

www.prenhall.com), and the path describing where the file is located          
on the host ( /morelli/index.html):                                           

                                                                              
                                                                              
   METHOD: //HOST/PATH
   HTTP : //www. p r e n h a l l . com/ m o r e l l i /index . html            Internet domain names
 

Similarly, an e-mail address is specified by the SMTP protocol to consist
of a local mailbox address (George.W.Bush) followed by the address of
the computer (mail.whitehouse.gov):

 

   LOCAL MAILBOX@COMPUTER
    George .W. Bush@mail . whitehouse . gov
 

Another good example of an application protocol is the Internet's Domain
Name System (DNS), which is the system that governs how names, such
as whitehouse.gov and java.trincoll.edu, can be translated into
numeric addresses. In the DNS, each host computer on the Internet is
identified with a unique host name--for example, mail, java--which is
usually made up by the network administrator whose job it is to man-
age an organization's network. The DNS divides the entire Internet into
a hierarchy of domains and subdomains. The generic domains are names
like com, edu, and mil, which refer to the type of organization-- com-
mercial, educational, and military, respectively. In addition to these there
are country domains, such as fr, au, and nz, for France, Australia, and
New Zealand. Finally, individuals and organizations can buy their own
domain names, such as whitehouse, microsoft, and trincoll.

   What makes the whole system work is that certain computers within
the network are designated as DNS servers. It is their role to translate
names such as java.trincoll.edu to numeric addresses whenever
they are requested to do so by clients such as the SMTP or the HTTP
server. Also, the DNS servers must communicate among themselves to
make sure that their databases of names and addresses are up-to-date.

SELF-STUDY EXERCISE                                                           Server  Request service  Client
                                                                                      Provide service
EXERCISE 15.4 What's the URL of the Web server at Prentice Hall?
Identify its component parts--host name, domain name, Internet domain.        Figure 15.4: Client/server appli-
                                                                              cation.
15.2.4 Client/Server Applications

The HTTP, FTP, SMTP, and DNS protocols are examples of client/server
protocols, and the applications they support are examples of client/server
applications. In general, a client/server application is one in which the
task at hand has been divided into two subtasks, one performed by the
client and one performed by the server (Fig. 15.4).

   For example, in the HTTP case, the Web browser plays the role of a
client by requesting a Web page from a Web (HTTP) server. A Web server
is just a computer that runs HTTP software--a program that implements
the HTTP protocol. For e-mail, the program you use to read your e-mail--
Eudora, Pine, or Outlook--is an e-mail client. It requests certain services,
such as send mail or get mail, from an e-mail (SMTP) server, which is
simply a computer that runs SMTP software. In the FTP case, to transfer
                                          698  CHAPTER 15  Sockets and Networking

                                          a program from one computer to another, you would use an FTP client,
                                          such as Fetch. Finally, in the DNS case, the DNS servers handle requests
                                          for name to address translations that come from HTTP, FTP, and SMTP
                                          servers, acting in this case like clients.

                                             So we can say that a client/server application is one that observes the
                                          following protocol:

                                                                                                                           

  Server :                                     S e t up a s e r v i c e on a p a r t i c u l a r h o s t computer .
  Client :                                     Contact the server and request the s e r v i c e .
  Server :                                     Accept a request from a c l i e n t and provide the s e r v i c e .

                                                                                                                                         

                                          As these examples illustrate, many Internet applications are designed as
                                          client/server applications.

                                          JAVA EFFECTIVE DESIGN Divide and Conquer. The client/server
                                          protocol is an example of the effective use of the divide-and-conquer
                                          strategy.

       Application level: Provide         SELF-STUDY EXERCISE
       services. (HTTP, SMTP, DNS)
       Transport layer: Deliver packets;  EXERCISE 15.5 Lots of our everyday interactions fit into the client/ser-
       error recovery. (TCP, UDP)         ver model. Suppose you are the client in the following services:
       Network layer: Move packets;
       provide internetworking. (IP)         Buying a piece of software at a bookstore.
       Physical and data link layers:
       Transmit bits over a medium           Buying a piece of software over the phone.
       from one address to another.
       (ETHERNET)                            Buying a piece of software over the Internet.

Figure 15.5: Levels of network            Identify the server and then describe the basic protocol.
protocols.
Packet transfer                           15.2.5 Lower Level Network Protocols

Disparate protocols                       Modern computer networks, such as the Internet, are organized into a
                                          number of levels of software and hardware. Each level has its own collec-
                                          tion of protocols (Fig. 15.5).

                                             The application level, which contains the HTTP, FTP, SMTP, and DNS
                                          protocols, is the highest level. Underlying the application-level protocols
                                          are various transmission protocols, such as the Transfer Control Protocol (TCP)
                                          and the User Datagram Protocol (UDP). These protocols govern the trans-
                                          fer of large blocks of information, or packets, between networked com-
                                          puters. All of the applications we mentioned--WWW, e-mail, and file
                                          transfer-- involve data transmission and, therefore, rely on one or more
                                          of the transmission protocols.

                                             At the very lowest end of this hierarchy of protocols are those that
                                          govern the transmission of bits or electronic pulses over wires and those
                                          that govern the delivery of data from node to node. Most of these proto-
                                          cols are built right into the hardware--the wires, connectors, transmission
                                          devices--that networks use. On top of these are protocols, such as the
                                          ethernet protocol and token ring protocol, that govern the delivery of pack-
                                          ets of information on a local area network. These too may be built right
                                          into the network hardware.

                                             As you might expect, these lower level protocols are vastly different
                                          from each other. An ethernet network cannot talk directly to a token ring
SECTION 15.2  An Overview of Networks                       699               Figure 15.6: Routers between indi-
                                                                               vidual networks use the IP proto-
 Ethernet-based LAN                     Token-ring based LAN                   col to translate one network pro-
                                                                               tocol to another.
                                                 "bonjour"
      "hello"        hello=bonjour              "au revoir"
   "goodbye"      au revoir=goodbye
                                        French protocol
English protocol  Router (IP protocol)

network. How can we connect such disparate networks together? Think            The Internet protocol
again of our United Nations analogy. How do we get French-speaking net-
works to communicate with English-speaking networks? The answer sup-
plied by the Internet is to use the Internetworking Protocol (IP), which
governs the task of translating one network protocol to a common format
(Fig. 15.6).

   To push the UN analogy a bit further, the Internet's IP is like a univer-
sal language built into the routers that transmit data between disparate
networks. On one end of a transmission, a router takes a French packet
of information received from one of the delegates in its network. The
router translates the French packet into an IP packet, which it then sends
on through the network to its destination. When the IP packet gets close
to its destination, another router takes it and translates it into an English
packet before sending it on to its destination on its network.

15.2.6 The java.net Package

As we have seen, networks are glued together by a vast array of protocols.     java.net.*
Most of these protocols are implemented in software that runs on general-
purpose computers. You can install software on your personal computer
to turn it into a Web server, an FTP server, or an e-mail server. Some of the
lower level protocols are implemented in software that runs on special-
purpose computers, the routers. Still other protocols, such as the ethernet
protocol, are implemented directly in hardware.

   Fortunately, we don't have to worry about the details of even the high-
est level protocols in order to write client/server applications in Java. The
java.net (Fig. 15.7) package supplies a powerful and easy-to-use set of
classes that supports network programming.

   The java.net.URL class provides a representation of the Internet's
Uniform Resource Locator that we described earlier. We'll show how to
use its methods to download WWW pages. We'll also look at an example
that uses a URL and an input stream so that files stored on the Web can be
used as input files to a Java applet or application program.

   The Socket and ServerSocket classes provide methods that let us
develop our own networking applications. They enable us to make a
direct connection to an Internet host, and read and write data through
InputStreams and OutputStreams. As we will see, this is no
more difficult than reading and writing data to and from files. The
DatagramPacket and DatagramSocket classes provide support for
even lower-level networking applications, based on Internet packets.
                                                 700                             CHAPTER 15  Sockets and Networking
Figure 15.7: The java.net pack-
age.                                                                             java.net                 HttpURLConnection

                                                                 java.lang         DatagramPacket
                                                                        Object      DatagramSocket
                                                                                    InetAddress
                                                                   java.io          ServerSocket
                                                                    IOException
                                                                                        Socket
                                                                                         URL
                                                                                   URLConnection
                                                                                   URLEncoded

                                                                                 MalformedURLException    BindException
                                                                                 ProtocolException        ConnectException
                                                                                 SocketException          NoRouteToHostException
                                                                                 UnknownHostException
                                                                                 UnknownServiceException

                          15.3 Using Multimedia Network Resources for a
                                  Graphical Program

Problem statement         Suppose you want to write an graphical program that will display a cat-
Specifying Web resources  alog consisting of images or documents that you've prepared and stored
                          on your Web site. Perhaps you can use such a program to give people
                          who visit your site a downloadable tour of your campus as a slide show
                          (Fig. 15.8). Or perhaps a company might use such a program to advertise
                          its products. In addition to making the catalog available through its main
                          Web site, you can imagine it running continuously as a slide show on a
                          computer kiosk in the company's lobby.

                             In order to solve this problem we have to be able to download and
                          display Web resources. As you know, Web resources are multimedia. That
                          is, they could be documents, images, sounds, video clips, and so on. All
                          Web resources are specified in terms of their Uniform Resource Locators
                          (URLs). Thus, to download an image (or an HTML file or audio clip), we
                          usually type its URL into a Web browser. We want our program to know
                          beforehand the URLs of the images it will display, so there won't be any
                          need for inputting the URL. We want to implement something like the
                          following algorithm:

                                                                                                                                  

                          repeat forever

                            Generate t h e URL f o r t h e next s l i d e .

                            Use t h e URL t o download t h e image or document .

                            Display the image or document .                                                                       
SECTION 15.4  From the Java Library: java.net.URL  701

A URL specification is just a String, such as,

                                                                                                      

h t t p : //www. c s . t r i n c o l l . edu : 8 0 / ~ ram/ j j j /slideshow/ s l i d e 1 . g i f     


which describes how to retrieve the resource. First, it specifies the
protocol or method that should be used to download the resource
(http). Then, it provides the domain name of the server that
runs the protocol and the port number where the service is running
(www.cs.trincoll.edu:80). Next, the URL specifies the resource's file
name (~ram/jjj/slideshow/slide1.gif).

15.4 From the Java Library: java.net.URL

GIVEN SUCH a URL specification, how can we download its associated                                                         URL
resource? Are there Java classes that can help us solve this problem? For-
tunately, there are. First, the java.net.URL class contains methods to                              +URL(in urlSpec : String)
help retrieve the resource associated with a particular URL (Fig. 15.9). The                        +openConnection() : URLConnection
URL class represents a Uniform Resource Locator. The URL() constructor                              +openStream() : InputStream
shown here (there are others) takes a URL specification as a String and,
assuming it specifies a valid URL, it creates a URL object. If the URL speci-                      Figure 15.9: The java.net.URL
fication is invalid, a MalformedURLException is thrown. A URL might                                class.
be invalid if the protocol were left off or if it is not a known protocol. The
following simple code creates a URL for the home page of our companion
Web site:

                                                                                                        java.sun.com/j2se/1.5.0/docs/api/

URL u r l ;

try {

   url =

   new URL( " h t t p ://www. p r e n h a l l . com: 8 0 / m o r e l l i /index . html " ) ;

} catch ( MalformedURLException e ) {

   System . out . p r i n t l n ( "Malformed URL : " + u r l . t o S t r i n g ( ) ) ;

}

                                                                                                   

Note how we catch the MalformedURLException when we create a                                       URLs and streams
new URL.

   Once we have a valid URL instance, it can be used to download the
data or object associated with it. There are different ways to do this. The
openConnection() method creates a URLConnection, which can then
be used to download the resource. You would only use this method if
your application required extensive control over the download process.
A much simpler approach would use the openStream() method. This
method will open an InputStream, which you can then use to read the
associated URL data the same way you would read a file. This method is
especially useful for writing Java applications (in addition to applets). As
you might guess, downloading Web resources is particularly easy from a
Java applet. Now let's search around for other methods that we can use.
         702                                     CHAPTER 15  Sockets and Networking

         15.4.1      Code Reuse: The java.applet.Applet Class

         The java.applet.Applet class itself contains several useful methods
         for downloading and displaying Web resources. These methods are in-
         herited by javax.swing.JApplet:

                                                                                                            

             public class Applet extends Panel {

                     public AppletContext getAppletContext ( ) ;

                     public AudioClip getAudioClip (URL u r l ) ;

                     public Image getImage (URL u r l ) ;

                     public void play (URL u r l ) ;

                     public void showStatus ( S t r i n g msg ) ;

             }

                                                                                                            

         As you see, both the getImage() and getAudioClip() methods use a
         URL to download a resource. An AudioClip is a sound file encoded in
         AU format, a special type of encoding for sound files. The getImage()
         method can return files in either GIF or JPEG format, two popular image
         file formats. The play() method downloads and plays an audio file in
         one easy step. For example, to download and play an audio clip within an
         applet requires just two lines of code:

                                                                                                            

URL u r l ;

  try {

     u r l = new

     URL( " h t t p ://www. c s . t r i n c o l l . edu /~ram/ j j j /slideshow/sound . au" ) ;

     play ( url ) ;

  } catch ( MalformedURLException e ) {

     System . out . p r i n t l n ( "Malformed URL : " + u r l . t o S t r i n g ( ) ) ;

  }

                                                                                                            

         Similarly, to download (and store a reference to) an image is just as simple:

                                                                                                            

 URL u r l ;                                                                                                ;
  try {                                                                                                       

      u r l = new
       URL( " h t t p ://www. c s . t r i n c o l l . edu /~ram/ j j j /slideshow/ s l i d e 0 . g i f " )
     imgRef = getImage ( url ) ;
  } catch ( MalformedURLException e ) {

         System . out . p r i n t l n ( "Malformed URL : " + u r l . t o S t r i n g ( ) ) ;
  }


         So, if applets were still in fashion, then these would be the methods we
         need to implement our slide show. For an application, to load an image
      SECTION 15.4  From the Java Library: java.net.URL                                703

      you need to declare the ImageRef and the call to read the image url is
      different:

                                                                                                            

 URL u r l ;                                                                                                ;
  Image imageRef ;                                                                                            
  try {

      u r l = new
       URL( " h t t p ://www. c s . t r i n c o l l . edu /~ram/ j j j /slideshow/ s l i d e 0 . g i f " )
     imgRef = javax . imageio . ImageIO . read ( url ) ;
  } catch ( MalformedURLException e ) {

         System . out . p r i n t l n ( "Malformed URL : " + u r l . t o S t r i n g ( ) ) ;
  }


      For sound we need the javax.sound.sampled package. After con-
      structing the URL, we need to set up an AudioInputStream, put the
      format of the stream into a DataLine.info object, and then get the line
      as a Clip, which we can then use to play the sound. The AudioSystem
      class is used heavily for this.

                                                                                                            

C l i p c l i p ; URL u r l = n u l l ;                                                                              line
try {

       u r l = new
      URL( " h t t p :// c o o p l o g i c . com/cheyney/sound/ l i f t M u s i c . wav" ) ;
       AudioInputStream audio =

              AudioSystem . getAudioInputStream ( url ) ; // g e t s t r e a m f r o m u r l
       DataLine . Info info =

              new DataLine . I n f o ( C l i p . c l a s s , audio . getFormat ( ) ) ; // i n f o n e e d e d f o r
       i f ( ! AudioSystem . isLineSupported ( info ) ) {

              System . e r r . p r i n t l n ( "Audio f i l e not supported : " + i n f o ) ;
              return ;
       }

       try {
              c l i p = ( Clip ) AudioSystem . getLine ( info ) ; // t h e c l i p d o e s t h e work
              c l i p . open ( audio ) ; // o p e n t h e s t r e a m .
              clip . s t a r t ( ) ; // s t a r t t h e s t r e a m on a s e p a r a t e t h r e a d .

      // l o o p u n t i l c l i p has f i n i s h e d

      while ( clip . getFramePosition ( ) < clip . getFrameLength ( ) ) {

         try {

            Thread . sleep ( 1 0 ) ;

         } catch ( Exception e) {

            e . printStackTrace ();

         }

      }

   } catch ( LineUnavailableException ex ) {

      ex . printStackTrace ( ) ;

   }

} catch ( MalformedURLException e ) {

   System . out . p r i n t l n ( "Malformed URL : " + u r l . t o S t r i n g ( ) ) ;

} catch ( UnsupportedAudioFileException ae ) {

   System . out . println ( "not supported : " + ae ) ;

} catch ( IOException ioex ) {

   ioex . printStackTrace ( ) ;

}

                                                                                                            
                                      704                    CHAPTER 15  Sockets and Networking

What methods can we use?                 We'll use the URL() constructor to create a URL from a String,
                                      and we'll use the javax.imageio.ImageIO.read(url) method to
                                      retrieve the images from the Web.

                                      15.5 The Slide Show Program

                                      Problem Specification

                                      Let's suppose our slide show will repeatedly display a set of images
                                      named "slide0.gif," "slide1.gif," and "slide2.gif." Suppose these images
                                      are stored on a Web site on www.cs.trincoll.edu and are stored in a
                                      directory named /~ram/jjj/slideshow. This means our program will
                                      have to load the following three URLs:

                                                                                                                                      

                                      h t t p : //www. c s . t r i n c o l l . edu /~ram/ j j j /slideshow/ s l i d e 0 . g i f

                                      h t t p : //www. c s . t r i n c o l l . edu /~ram/ j j j /slideshow/ s l i d e 1 . g i f

                                      h t t p : //www. c s . t r i n c o l l . edu /~ r a m j j j /slideshow/ s l i d e 2 . g i f
                                                                                                                                      

                                      We want our show to cycle endlessly through these images, leaving about
                                      5 seconds between each slide.

                                      User Interface Design

           JFrame                     The user interface for this program is graphical, but it doesn't contain any
                                      GUI components. It just needs to display an image every 5 seconds. It
     SlideShowFrame                   can use a simple paint() method to display an image each time it is
+ WIDTH : int                         repainted:
+ HEIGHT : int
- NIMGS : int                                                                                                                      
- slide[] : Image
- currentImage : Image                public void paint ( Graphics g) {
- nextImage : int
+ paint()                                  if ( currentImage != null )
+ nextSlide()
+ init()                                   g . drawImage ( currentImage , 10 , 10 , t h i s ) ;

                                      }

                                                                                                                                   

                                      The assumption here is that the currentImage instance variable will be
                                      set initially to null. Each time an image is downloaded, it will be set to
                                      refer to that image. Because paint() is called before the program starts
                                      downloading the images, it is necessary to guard against attempting to
                                      draw a null image, which would lead to an exception.

                                      Problem Decomposition

Figure 15.10: The SlideShow-          One problem we face with this program is getting it to pause between fig-
Frame downloads and displays          p830f2 each slide. One way to do this is to set up a loop that does nothing
the images.                           for about 5 seconds:

                     쳃nterface                                                                                                   
                      Runnable
                  + run()             f o r ( i n t k = 0 ; k < 1 0 0 0 0 0 0 ; k++ ) ; // B u s y w a i t i n g                   
                                      
                        Timer
     - frame : SlideShowFrame         However, this isn't a very good solution. As we saw in Chapter 14, this
     + Timer(in a : SlideShowFrame)   is a form of busy waiting that monopolizes the CPU, making it very diffi-
     + run()                          cult to break out of the loop. Another problem with this loop is that we
                                      don't really know how many iterations to do to approximate 5 seconds of
                                      idleness.

FIGURE 15.11 The Timer class
delays the frame thread between each
slide.
SECTION 15.5  The Slide Show Program                  705

   A much better design would be to use a separate timer thread, which
can sleep() for 5 seconds between each slide. So our program will have
two classes: one to download and display the slides and one to serve as a
timer (Figs. 15.10 and 15.11). ( Java Swing has a Timer class that works a
little bit differently, see the javadoc for a description.)

 SlideShowFrame--This JFrame subclass will take care of download-
  ing and displaying the images and starting the timer thread.

 Timer--This class will implement the Runnable interface so that it
  can run as a separate thread. It will repeatedly sleep for 5 seconds and
  then tell the frame to display the next side.

JAVA EFFECTIVE DESIGN Busy Waiting. Instead of busy waiting,
a thread that sleeps for a brief period on each iteration is a better way
to introduce a delay into an algorithm.

15.5.1 The SlideShowFrame class

What should we do with the images we download? Should we repeatedly
download and display them, or should we just download them once and
store them in memory? The second of these alternatives seems more effi-
cient. If an image has already been downloaded, it would be wasteful to
download it again.

 JAVA EFFECTIVE DESIGN Network Traffic. In general, a design
 that minimizes network traffic is preferable.

   So we'll need an array to store the images. Our slide show will then       What data do we need?
consist of retrieving the next image from the array and displaying it. To
help us with this task, let's use a nextImg variable as an array index to    
keep track of the next image. Even though it isn't absolutely necessary, we  
could use a third variable here, currentImage, to keep track of the cur-
rent image being displayed. Thus, our frame needs the following instance      Method design
variables:



  private  s t a t i c f i n a l i n t NIMGS = 3 ;
  private  Image [ ] s l i d e = new Image [NIMGS ] ;
  private  Image currentImage = null ;
  private  int nextImg = 0;


   Given these variables, let's now write a method to take care of choos-
ing the next slide. Recall that the paint() method is responsible for dis-
playing currentImage, so all this method needs to do is to update both
currentImage and nextImg. This method should be designed so that it
can be called by the Timer thread whenever it is time to display the next
slide, so it should be a public method. It can be a void method with no
706                        CHAPTER 15  Sockets and Networking

parameters, because the frame already contains all the necessary informa-
tion to display the next slide. Thus, there's no need for information to be
passed back and forth between Timer and this method:

                                                                              

public void nextSlide ( ) {

     currentImage = slide [ nextImg ] ;

     nextImg = ( nextImg + 1 ) % NIMGS ;

     repaint ();

}// n e x t S l i d e ( )

                                                                              

The method's algorithm is very simple. It sets currentImage to what-
ever slide is designated by nextImg and it then updates nextImg's
value. Note here the use of modular arithmetic to compute the value
of nextImg. Given that NIMGS is 3, this algorithm will cause nextImg
to take on the repeating sequence of values 0, 1, 2, 0, 1, 2, and so forth.
Finally, the method calls repaint() to display the image.

JAVA PROGRAMMING TIP Modular Arithmetic. Modular
arithmetic
(x % N) is useful for cycling repeatedly through the values
0, 1, . . . , N - 1.

The frame's constructor, SlideShowFrame() method will have two
tasks:

 Download and store the images in slide[].
 Start the Timer thread.

As we discussed, downloading Web resources for an application requires
the use of the javax.imageio.ImageIO.read() method. Here we just
place these method calls in a loop:

                                                                              

f o r ( i n t k = 0 ; k < NIMGS ; k++)

     s l i d e [ k ] = javax . imageio . ImageIO . read ( getCodeBase ( ) ,

                           " g i f s /demo" + k + " . g i f " ) ;             

Note here how we convert the loop variable k into a String and con-
catenate it right into the URL specification. This allows us to have URLs
containing "slide0.gif," "slide1.gif," and "slide2.gif." This makes our pro-
gram easily extensible should we later decide to add more slides to the
SECTION 15.5  The Slide Show Program                                   707

show. Note also the use of the class constant NIMGS as the loop bound.
This too adds to the program's extensibility.

JAVA PROGRAMMING TIP Concatenation. Concatenating an
integer value (k) with a string lets you create file names of the form
file1.gif, file2.gif, and so on.

   The task of starting the Timer thread involves creating an instance of
the Timer class and calling its start() method:

                                                                             

Thread t i m e r = new Thread (new Timer ( t h i s ) ) ;

timer . start ( ) ;
                                                                             

Note that Timer is passed a reference to this frame. This enables Timer
to call the frame's nextSlide() method every 5 seconds. This program-
ming technique is known as callback and the nextSlide() method is an
example of a callback method (Fig. 15.12).

JAVA PROGRAMMING TIP Callback. Communication between                            1: start()
two objects can often be handled using a callback technique. One                  nextSlide()
object is passed a reference to the other object. The first object uses the
reference to call one of the public methods of the other object.

This completes our design and development of SlideShowFrame, which              : SlideShowFrame  : Timer
is shown in Figure 15.13.

15.5.2 The Timer Class

The Timer class is a subclass of Thread, which means it must implement        Figure 15.12: Timer uses the
the run() method. Recall that we never directly call a thread's run()         nextSlide() method to call back
method. Instead, we call its start() method, which automatically calls        the frame to remind it to switch to
run(). This particular thread has a very simple and singular function. It     the next slide.
should call the SlideShowFrame.nextSlide() method and then sleep              The timer thread
for 5 seconds. So its main algorithm will be:                                

                                                                             

    while ( true ) {
           frame . nextSlide ( ) ;
           sleep ( 5000 ) ;

    }
 

However, recall that Thread.sleep() throws the Interrupted-
Exception. This means that we'll have to embed this while loop in a
try/catch block.

   To call the frame's nextSlide() method, we also need a reference
to the SlideShowFrame, so we need to give it a reference, such as an
instance variable, as well as a constructor that allows the frame to pass
Timer a reference to itself.

   Given these design decisions, the complete implementation of Timer
is shown in Figure 15.14. To see how it works, download it from the Java,
Java, Java Web site and run it.
 708                                   CHAPTER 15   Sockets and Networking
                                                                                    
          java . awt .  ;
          javax . swing .  ;
  import  javax . imageio . ImageIO ;
  import  java . net .;
  import
  import

public class SlideShowFrame extends JFrame {
       public s t a t i c f i n a l i n t WIDTH=300 , HEIGHT= 2 0 0 ;
       p r i v a t e s t a t i c f i n a l i n t NIMGS = 3 ;
       p r i v a t e Image [ ] s l i d e = new Image [NIMGS ] ;
       private Image currentImage = null ;
       private int nextImg = 0;

  public void paint ( Graphics g) {
         g . setColor ( getBackground ( ) ) ;
         g . f i l l R e c t ( 0 , 0 , WIDTH, HEIGHT ) ;
         if ( currentImage != null )
                g . drawImage ( currentImage , 10 , 10 , t h i s ) ;

  }// p a i n t ( )

  public void nextSlide ( ) {
         currentImage = slide [ nextImg ] ;
         nextImg = ( nextImg + 1 ) % NIMGS ;
         repaint ();

  }// n e x t S l i d e ( )

  public SlideShowFrame ( ) {

          f o r ( i n t k = 0 ; k < NIMGS ; k++)

          s l i d e [ k ] = ImageIO . read ( getCodeBase ( ) ,

                                 " g i f s /demo" + k + " . g i f " ) ;

          Thread t i m e r = new Thread (new Timer ( t h i s ) ) ;

          timer . start ( ) ;

          s e t S i z e ( WIDTH, HEIGHT ) ;

  }// c o n s t r u c t o r

}// S l i d e S h o w F r a m e

                                                                         

          Figure 15.13: The SlideShowFrame class.

SELF-STUDY EXERCISE

EXERCISE 15.6 Describe the design changes you would make to
SlideShowFrame if you wanted to play a soundtrack along with your
slides. Assume that the sounds are stored in a sequence of files,
"sound0.au," sound1.au," and so forth, on your Web site.

15.6 Adding Text Network Resources for an
        Application

The SlideShowFrame illustrates the use of multimedia resources from
the web. However, much of the files we may want to retrieve are text
based, and we want to be able to use these resources side-by-side with the
available multimedia. The next application describes how to do just this.
SECTION 15.6  Adding Text Network Resources for anApplication 709

                                                            

public class Timer implements Runnable {
       private SlideShowFrame frame ;

  public Timer ( SlideShowFrame app ) {
         frame = app ;

  }

  public void run ( ) {

  try {

           while ( true ) {

               frame . nextSlide ( ) ;

               Thread . sleep ( 5000 ) ;

           }

  } catch ( InterruptedException e) {

           System . out . println ( e . getMessage ( ) ) ;

  }

  }// run ( )

}// Timer

                                                            

               Figure 15.14: The Timer class.

Problem Specification                                                           Problem statement

Suppose a realtor asks you to write a Java application that will allow         
customers to view pictures and descriptions of homes from an online            
database. The application should allow the customer to select a home
and should then display both an image of the home and a text description
of its features, such as square footage, asking price, and so on.

   Suppose that the database of image and text files is kept at a fixed loca-
tion on the Web, but the names of the files themselves may change. This
will enable the company to change the database as it sells the homes. The
company will provide a text file that contains the names of the files for the
current selection of homes to input into the program. To simplify matters,
both image and text files have the same name but different extensions--
for example, ranch.txt and ranch.gif. The data file will store just the
names of the files, one per line, giving it the following format:

 

    beautifulCape
    handsomeRanch
    lovelyColonial
 

15.6.1 Downloading a Text File from the Web                                    Understanding the problem

This application requires us to solve two new problems:

1. How do we download a text file of names that we want to use as menu
    items?

2. How do we download a text file and display it in a JTextArea?
3. How do we download and display an image file?

The SlideShowFrame solves the problem of downloading and display-
ing an image file. So, the most challenging part of this program is the task
of downloading a Web text file and using its data in the program.
                         710                      CHAPTER 15  Sockets and Networking

File download algorithm     For this program we must make use of two types of text data down-
Text or binary data?     loaded from the Web. The first will be the names of the image and docu-
                         ment files. We'll want to read these names and use them as menu items
                         that the user can select. Second, once the user has selected a house to
                         view, we must download and display an image and a text description of
                         the house. Downloading the text is basically the same as downloading the
                         file of names. The only difference is that we need to display this text in a
                         JTextArea. Downloading the image file can be handled in more or less
                         the same way that it was handled in the SlideShowFrame-- by using a
                         special Java method to download and display the image file.

                            Clearly, the problems of downloading a file from the Web and reading a
                         file from the disk are quite similar. Recall that we used streams to handle
                         the I/O operation when reading disk files. The various InputStream
                         and OutputStream classes contained the read() and write() meth-
                         ods needed for I/O. The situation is the same for downloading Web files.

                            Recall that the URL class contains the openStream() method, which
                         opens an InputStream to the resource associated with the URL. Once
                         the stream has been opened, you can read data from the stream just as if
                         it were coming from a file. The program doesn't care whether the data are
                         coming from a file on the Internet or a file on the disk. It just reads data
                         from the stream. So, to download a data file from the Internet, regardless
                         of whether it's a text file, image file, audio file, or whatever, you would
                         use the following general algorithm:

                                                                                                             

                         URL u r l ;

                         InputStream data ;

                         try {

                              u r l = new URL( fileURL ) ;            // C r e a t e a URL

                              data = url . openStream ( ) ; // Open a s t r e a m t o URL

                              / / READ THE F I L E I N T O MEMORY} / / R e a d d a t

                              data . close ( ) ;                      // C l o s e t h e s t r e a m

                         } catch ( MalformedURLException e ) { // Thrown by URL ( )

                              System . out . println ( e . getMessage ( ) ) ;

                         } catch ( IOException e ) {

                              System . out . println ( e . getMessage ( ) ) ;

                         }

                                                                                                             

                         The algorithm consists of four basic steps:

                          Create a URL instance.
                          Open an InputStream to it.
                          Read the data.
                          Close the stream.

                         Step 3 of this algorithm--read the data--involves many lines of code and
                         has, therefore, been left as a subtask suitable for encapsulation within a
                         method.

                         Reading the Data

                         As we saw in the previous chapter, the algorithm for step 3 will depend
                         on the file's data. If it's a text file, we would like to read one line at a time,
                         storing the input in a String. If it's an image or an audio file, we would
                         read one byte at a time.
SECTION 15.6  Adding Text Network Resources for anApplication 711

   Because our data are contained in a text file, we want to read one line at      What library methods can we use?
a time. The BufferedReader class contains a readLine() method that
returns either a String storing the line or the value null when it reaches
the end of file. The following method shows how you would read a text
file into the program's JTextArea, which is named display:

                                                                                   

p r i v a t e void r e a d T e x t I n t o D i s p l a y (URL u r l )

                                               throws IOException {

  BufferedReader data

     = new BufferedReader (

                      new InputStreamReader ( u r l . openStream ( ) ) ) ;

  display . setText ("" ) ;                    // R e s e t t h e t e x t a r e a

  String line = data . readLine ( ) ;

  while ( line != null ) {                     // Read e a c h l i n e

     display . append ( l i n e + "\n" ) ; // Add t o d i s p l a y

     line = data . readLine ( ) ;

  }

  data . close ( ) ;

}// r e a d T e x t I n t o D i s p l a y ( )

                                                                                   

The method is passed the file's URL and it uses the URL.openStream()               I/O exceptions
method to open the input stream. Note that the method throws
IOException, which means that any I/O exceptions that get raised will
be handled by the calling method.

   In this example, the input algorithm reads each line of the file and adds
it to the display. For our real estate application, the same basic algo-
rithm can be used to read the names of the data files and store them in
a menu from which a user makes selections. For example, if we use a
JComboBox menu named homeChoice, we would simply add each line
to it:

                                                                                   

  String line = data . readLine ( ) ;                                               쳃nterface ItemListener
  while ( line != null ) {

         homeChoice . addItem ( l i n e ) ;
         line = data . readLine ( ) ;
  }


Interface Design                                                                      +itemStateChanged()

The interface for this application is very important. It should provide                       JFrame
some means to display a text file and an image. The text file can be
displayed in a JTextArea, and the image can be drawn on a JPanel.                             RealEstateViewer
                                                                                      +WIDTH : int=400
   Next, let's consider the types of controls a user might need. The cus-             -HEIGHT : int=400
tomer should be allowed to select a home to view from a menu of options.              -dataFileURL : String
Because the program will have the list of available homes, it can provide             -baseURL : String
the options in a JComboBox pull-down menu.                                            -display : JTextArea
                                                                                      -homeChoice : JComboBox
   To create an appropriate layout, we want to make sure that the controls,           -imagePanel : ImagePanel
the image, and JTextArea all have their own region of the application's               -currentImage : Image
window. This suggests a BorderLayout, which is the default layout                     +RealEstateViewer()
for a JFrame. We can put the JComboBox menu at the "North" border,                    +itemStateChanged()
and the image and text on the "West" and "East" borders, respectively.                +main()
Figure 15.15 illustrates these various design decisions.

                                                                                   Figure 15.16: The RealEstate-
                                                                                   Viewer class defines the user in-
                                                                                   terface.
712                                CHAPTER 15  Sockets and Networking

 JFrame  JPanel       JComboBox    JTextArea                                                  Figure 15
                                                                                              sign for th
                                                                     Component Hierarchy
                      Choice menu  BorderNorth
                                                                     JFrame
                      JTextArea for displaying                             JComboBox Menu
                      information about                                    Display JTextArea
                      the home.                                            Canvas JPanel

            Image     BorderLayout east
         drawn here

         Border west

Problem Decomposition: RealEstateViewer

The task of downloading and displaying information from the Internet is
best handled by two separate classes: One to perform the downloading
and user interface tasks and the other to take care of displaying the image.

   The task of downloading the image and text files from the Web can be
handled by the program's main class, the RealEstateViewer, which
will also handle the user interface (Fig. 15.16). As the application's top-
level window, RealEstateViewer will is subclass of JFrame. Be-
cause its controls will include a JComboBox, it must implement the
itemStateChanged() method of the ItemListener interface.

   What components and other instance variables will we need for this
class? According to our interface design, it will need a JComboBox,
a JTextArea, and the ImagePanel. Because it will be downloading
images, it will need an Image variable.

   The constants used by this application include the URL string for the
data file. Also, because all the images and data files will start with the
same prefix,

                                                                                              

h t t p : // j a v a . t r i n c o l l . edu /~ j j j a v a /homes/                           


we should make this a constant in the program. These preliminary de-
cisions lead to the initial version of RealEstateViewer shown in Fig-
ure 15.17. Note that the main() method merely creates an instance of
the application and shows it. Note also that the currentImage variable
is declared public. This will let the ImagePanel have direct access to
currentImage whenever it needs to display a new image.
SECTION 15.6  Adding Text Network Resources for anApplication 713

                                                                                              

import     java . awt .  ;
import     java . awt . event .  ;
import     java . net .;
import     java . io .;
import     javax . swing .  ;

public class RealEstateViewer extends JFrame
                                                          implements ItemListener {

   public s t a t i c f i n a l i n t WIDTH=400 ,HEIGHT= 2 0 0 ;
   private final String dataFileURL =

       " h t t p :// j a v a . t r i n c o l l . edu /~ j j j a v a /homes/homes . t x t " ;
   pri vate f i n a l S t r i n g baseURL =

       " h t t p :// j a v a . t r i n c o l l . edu /~ j j j a v a /homes/" ;
   p r i v a t e JTextArea d i s p l a y = new JTextArea ( 2 0 , 2 0 ) ;
   p r i v a t e JComboBox homeChoice = new JComboBox ( ) ;
   p r i v a t e ImagePanel imagePanel = new ImagePanel ( t h i s ) ;
   public Image currentImage = null ;

  public   RealEstateViewer () { }   // S t u b C o n s t r u c t o r
  public
                                     // I t e m L i s t e n e r i n t e r f a c e

           void itemStateChanged ( ItemEvent evt ) { } // S t u b

  public s t a t i c void main ( S t r i n g args [ ] ) {

  R e a l E s t a t e V i e w e r viewer = new R e a l E s t a t e V i e w e r ( ) ;

  viewer . s e t S i z e ( viewer .WIDTH, viewer . HEIGHT ) ;

  viewer . setVisible ( true ) ;

  viewer . addWindowListener (new WindowAdapter ( ) {

        public void windowClosing ( WindowEvent e ) {

           System . e x i t ( 0 ) ; // Q u i t t h e a p p l i c a t i o n

        }

  });

  }// main ( )

}// R e a l E s t a t e V i e w e r

                                                                                              

           Figure 15.17: The RealEstateViewer, Version 1.

The ImagePanel Class                                                                                                    JPanel

We'll use a second class, the ImagePanel, to handle displaying the im-                                        +paintComponent()
age (Figs. 15.18 and 15.19). The reason we use a separate class for this
task is that we want the image to appear in its own panel (which appears                                             ImagePanel
on the West border of the main window). In addition to its constructor,                           -frame : RealEstateViewer
the only method needed in this class is the paintComponent() method.                              +ImagePanel(in f : RealEstateViewer)
This method will be called automatically whenever the main window is                              +paintComponent()
repainted. Its task is simply to get the current image from its parent frame
and display it. Note that a reference to the parent frame is passed to the                       Figure 15.18: An overview of the
object in its constructor.                                                                       ImagePanel class.

Method Decomposition

The stub methods listed in the initial version of RealEstateViewer
(Fig. 15.17) outline the main tasks required by the application. Some of
these methods are very simple and even trivial to implement. Others
should be broken up into subtasks.
               714                             CHAPTER 15  Sockets and Networking
                                                                                                     

                import  javax . swing .  ;
                import  java . awt .  ;

              public class ImagePanel extends JPanel {

                   private RealEstateViewer frame ;

                   public ImagePanel ( RealEstateViewer parent ) {
                          frame = parent ;

                   }

                   public void paintComponent ( Graphics g) {

                        if ( frame . currentImage != null )

                        g . drawImage ( frame . currentImage , 0 , 0 , t h i s ) ;

                   }

              }// I m a g e P a n e l

                                                                                                         

                                       Figure 15.19: The ImagePanel class.

                 The constructor method should be responsible for creating the user in-
              terface, most of which will involve the routine tasks of registering a lis-
              tener for the homeChoice menu and setting up an appropriate layout
              that implements the design we developed for the user interface:

                                                                                                         

                public RealEstateViewer () {

                        super ( "Home Viewer A p p l i c a t i o n " ) ; // S e t w i n d o w t i t l e

                        homeChoice . addItemListener ( this ) ;

                        t h i s . getContentPane ( ) . add ( "North" , homeChoice ) ;

                        t h i s . getContentPane ( ) . add ( " East " , display ) ;

                        t h i s . getContentPane ( ) . add ( " Center " , imagePanel ) ;

                        display . setLineWrap ( true ) ;

                        initHomeChoices ( ) ;       // S e t up c h o i c e box

                        showCurrentSelection ( ) ; // D i s p l a y c u r r e n t home

                }

                                                                                                         

ItemListener  Note the last two statements of the method. The first sets up the
              JComboBox by reading its contents from a file stored in the company's
              database. Because that task will require several statements, we define
              it as a separate method, initHomeChoices(), and defer its develop-
              ment for now. Similarly, the task of displaying the current menu choice
              has been organized into the showCurrentSelection() method, whose
              development we also defer for now.

                 The itemStateChanged() method is called automatically when the
              user selects a home from the JComboBox menu. Its task is to download
              and display information about the current menu selection. To do this, it
              can simply call the showCurrentSelection() method:

                                                                                                         

                public void itemStateChanged ( ItemEvent evt ) {

                        showCurrentSelection ( ) ;

                }

                                                                                                         
SECTION 15.6  Adding Text Network Resources for anApplication 715

Downloading the Menu Items

Recall that according to our specification, the real estate firm stores
its current listing of homes in a text file, one home per line. The
initHomeChoices() method downloads the text and uses its contents
to set up the items in the homeChoice JComboBox menu:

                                                                                

private void initHomeChoices ( ) {
   try {
      URL u r l = new URL( dataFileURL ) ;
       BufferedReader data = new BufferedReader (
              new InputStreamReader ( u r l . openStream ( ) ) ) ;
       String line = data . readLine ( ) ;
       while ( line != null ) {
          homeChoice . addItem ( l i n e ) ;
          line = data . readLine ( ) ;
       }

     data . close ( ) ;
  } catch ( MalformedURLException e ) {

     System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;
  } catch ( IOException e ) {

     System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;
  }

}// i n i t H o m e C h o i c e s ( )

                                                                                

It uses the algorithm we developed earlier for downloading a text file.
Each line of the text file represents a menu item, so, as each line is read by
readLine(data), it is added to the JComboBox menu.

Downloading and Displaying Home Information

The showCurrentSelection() method is responsible for download-
ing and displaying images and text files whenever the user selects a home
to view. Recall that our specification called for using the name of the menu
item as a basis for constructing the name of its corresponding text file and
image file. Therefore, the basic algorithm we need is

 Get the user's home choice.
 Create a URL for the associated text file.
 Download and display the associated text file.
 Create a URL for the associated GIF file.
 Download and display the image.

Because downloading a text document requires stream processing, we              Method decomposition
should handle that in a separate method. The task of downloading an
image file is also a good candidate for a separate method. Both of these
methods will use a URL, so we can leave that task up to showCurrent-
Selection() itself. The showCurrentSelection() method will cre-
                               716                                  CHAPTER 15  Sockets and Networking

                               ate the URLs and then invoke the appropriate methods to download and
                               display the resources:

                                                                                                                 

                               private void showCurrentSelection ( ) {
                                  URL u r l = n u l l ;

                                                                                 // Get u s e r ' s c h o i c e

                                    String choice = homeChoice . getSelectedItem ( ) . toString ( ) ;

                                    try {                           // C r e a t e u r l and download f i l e

                                    u r l = new URL( baseURL + c h o i c e + " . t x t " ) ;

                                    readTextIntoDisplay ( url );

                                                                    // C r e a t e u r l and download image

                                    u r l = new URL( baseURL + c h o i c e + " . g i f " ) ;

                                    currentImage = ImageIO . read ( url ) ;

                                    Toolkit . getDefaultToolkit ( ) . beep ( ) ; // Beep u s e r

                                    repaint ();

                                    } catch ( MalformedURLException e ) {

                                    System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

                                    } catch ( IOException e ) {

                                    System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

                                    } // Try / c a t c h b l o c k

                               } // s h o w C u r r e n t S e l e c t i o n ( )

                                                                                                                 

                               Note that we have also elected to handle both the MalformedURLException
                               and IOException in this method. The advantage of this design is that it
                               separates exception handling from the normal algorithm and organizes it
                               into one method. Finally, note how string concatenation is used to build
                               the URL specifications, each of which consists of three parts: the baseURL,
                               the user's choice, and the file extension.

                                  The task of reading the text file and displaying its contents has been en-
                               capsulated into the readTextIntoDisplay() method. This private
                               utility method performs a standard file-reading algorithm using the
                               readLine() method that we developed earlier. Figure 15.20 provides
                               a view of the program's appearance as it is displaying information to a
                               user. Figure 15.21 provides the complete implementation of this program.

Figure 15.20: The RealEstate-
Viewer program downloads im-
ages and documents over the
Web.

                               15.6.2 Reusing Code

                               As in other examples we have developed, our discovery and use of the
                               javax.imageio.ImageIO.read() method and other classes from the
SECTION 15.6  Adding Text Network Resources for anApplication 717

                                                                                              

import  java . awt .  ;
import  java . awt . event .  ;
import  java . net .;
import  java . io .;
import  javax . swing .  ;

public class RealEstateViewer extends JFrame
                                                          implements ItemListener {

   public s t a t i c f i n a l i n t WIDTH=400 ,HEIGHT= 2 0 0 ;
   private final String dataFileURL =

       " h t t p :// j a v a . t r i n c o l l . edu /~ j j j a v a /homes/homes . t x t " ;
   pri vate f i n a l S t r i n g baseURL =

       " h t t p :// j a v a . t r i n c o l l . edu /~ j j j a v a /homes/" ;
   p r i v a t e JTextArea d i s p l a y = new JTextArea ( 2 0 , 2 0 ) ;
   p r i v a t e JComboBox homeChoice = new JComboBox ( ) ;
   p r i v a t e ImagePanel imagePanel = new ImagePanel ( t h i s ) ;
   public Image currentImage = null ;

  public RealEstateViewer () {

  super ( "Home Viewer A p p l i c a t i o n " ) ; // S e t w i n d o w t i t l e

  homeChoice . addItemListener ( this ) ;

  t h i s . getContentPane ( ) . add ( "North" , homeChoice ) ;

  t h i s . getContentPane ( ) . add ( " East " , display ) ;

  t h i s . getContentPane ( ) . add ( " Center " , imagePanel ) ;

  display . setLineWrap ( true ) ;

  initHomeChoices ( ) ;                     // S e t up t h e c h o i c e box

  showCurrentSelection ( ) ; // D i s p l a y t h e c u r r e n t home

  } // R e a l E s t a t e V i e w e r ( )

  private void initHomeChoices ( ) {

  try {

        URL u r l = new URL( dataFileURL ) ;

        BufferedReader data = new BufferedReader (

         new InputStreamReader ( u r l . openStream ( ) ) ) ;

        String line = data . readLine ( ) ;

        while ( line != null ) {

        homeChoice . addItem ( l i n e ) ;

        line = data . readLine ( ) ;

        } data . close ( ) ;

  } catch ( MalformedURLException e ) {

        System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

  } catch ( IOException e ) {

        System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

  }

  }// i n i t H o m e C h o i c e s ( )

                                                                                              

        Figure 15.21: The RealEstateViewer class, Part I.
718                                  CHAPTER 15  Sockets and Networking

                                                                                                             

  p r i v a t e void r e a d T e x t I n t o D i s p l a y (URL u r l ) throws IOException {

     BufferedReader data

        = new BufferedReader (

                                     new InputStreamReader ( u r l . openStream ( ) ) ) ;

     display . setText ("" ) ;                     // R e s e t t h e t e x t a r e a

     String line = data . readLine ( ) ;

     while ( line != null ) {                      // Read e a c h l i n e

        display . append ( l i n e + "\n" ) ; // And add i t t o t h e d i s p l a y

        line = data . readLine ( ) ;

     } data . close ( ) ;

  }// r e a d T e x t I n t o D i s p l a y ( )

  private void showCurrentSelection ( ) {

     URL u r l = n u l l ;                                 // Get u s e r ' s c h o i c e

     String choice = homeChoice . getSelectedItem ( ) . toString ( ) ;

     try {

        u r l = new URL( baseURL + c h o i c e + " . t x t " ) ;                         // C r e a t e URL

        readTextIntoDisplay ( url ) ; // Download and d i s p l a y t e x t f i l e

        u r l = new URL( baseURL + c h o i c e + " . g i f " ) ;                         // C r e a t e URL

                                                                  // Download image

        currentImage = ImageIO . read ( url ) ;

        Toolkit . getDefaultToolkit ( ) . beep ( ) ;              // A l e r t t h e u s e r

        repaint ();

     } catch ( MalformedURLException e ) {

           System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

     } catch ( IOException e ) {

           System . out . p r i n t l n ( "ERROR : " + e . getMessage ( ) ) ;

     }

  }// s h o w C u r r e n t S e l e c t i o n ( )

  public void itemStateChanged ( ItemEvent evt ) {
     showCurrentSelection ( ) ;

  } // i t e m S t a t e C h a n g e d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

     R e a l E s t a t e V i e w e r viewer = new R e a l E s t a t e V i e w e r ( ) ;

     viewer . s e t S i z e ( viewer .WIDTH, viewer . HEIGHT ) ;

     viewer . setVisible ( true ) ;

     viewer . addWindowListener (new WindowAdapter ( ) {

        public void windowClosing ( WindowEvent e ) {

           System . exit ( 0 ) ;                 // Q u i t t h e a p p l i c a t i o n

        }

     });

  }// main ( )

}// R e a l E s t a t e V i e w e r

                                                                                                             

           Figure 15.21: (continued) RealEstateViewer, Part II.
SECTION 15.6  Client/Server Communication via Sockets               719

Java class library illustrate an important principle of object-oriented pro-
gramming.

JAVA EFFECTIVE DESIGN Code Reuse. Before writing code to
perform a particular task, search the available libraries to see if there is
already code that performs that task.

An important step in designing object-oriented programs is making ap-
propriate use of existing classes and methods. In some cases, you want
to directly instantiate a class and use its methods to perform the desired
tasks. In other cases, it is necessary to create a subclass (inheritance) or im-
plement an interface (inheritance) in order to gain access to the methods
you need.

   Of course, knowing what classes exist in the libraries is something that
comes with experience. There's no way that a novice Java programmer
would know about, say, the ImageIO.read() method. However, one
skill or habit that you should try to develop is always to ask yourself the
question: "Is there a method that will do what I'm trying to do here?" That
question should be the first question on your search through the libraries
and reference books.

                                                                                  

h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/a p i/               


15.7 Client/Server Communication via Sockets

As we said earlier, many networking applications are based on the client/         Sockets and ports
server model. According to this model, a task is viewed as a service that
can be requested by clients and handled by servers. In this section, we
develop a simple client/server framework based on a socket connection
between the client and the server.

   A socket is a simple communication channel through which two pro-
grams communicate over a network. A socket supports two-way commu-
nication between a client and a server, using a well-established protocol.
The protocol simply prescribes rules and behavior that both the server and
client must follow in order to establish two-way communication.

   According to this protocol, a server program creates a socket at a certain
port and waits until a client requests a connection. A port is a particular
address or entry point on the host computer, which typically has hun-
dreds of potential ports. It is usually represented as a simple integer value.
For example, the standard port for an HTTP (Web) server is 80. Once the
connection is established, the server creates input and output streams to
the socket and begins sending messages to and receiving messages from
                                  720          CHAPTER 15  Sockets and Networking

                                  the client. Either the client or the server can close the connection, but it's
                                  usually done by the client.

                                  JAVA DEBUGGING TIP Reserved Port Numbers. Port numbers
                                  below 1024 are reserved for system use and should not be used by an
                                  application program.

Client/server protocol               To help clarify this protocol, think of some service performed by a hu-
Sockets and channels              man using a telephone connection. The "server" waits for the phone to
                                  ring. When it rings, the server picks it up and begins communicating
                                  with the client. A socket, combined with input and output streams, is
                                  something like a two-way phone connection.

                                     From the client's side, the protocol goes as follows: The client creates a
                                  socket and attempts to make a connection to the server. The client has to
                                  know the server's URL and the port at which the service exists. Once
                                  a connection has been established, the client creates input and output
                                  streams to the socket and begins exchanging messages with the server.
                                  The client can close the connection when the service is completed.

                                     Think again of the telephone analogy. A human client picks up the
                                  phone and dials the number of a particular service. This is analogous to
                                  the client program creating a socket and making a connection to a server.
                                  Once the service agent answers the phone, two-way communication be-
                                  tween the client and the server can begin.

                                     Figure 15.22 provides a view of the client/server connection. Note that
                                  a socket has two channels. Once a connection has been established be-
                                  tween a client and a server, a single two-way channel exists between them.
                                  The client's output stream is connected to the server's input stream. The
                                  server's output stream is connected to the client's input stream.

                                   JAVA PROGRAMMING TIP Socket Streams. Each socket has two
                                   streams, one for input and one for output.

Figure 15.22: A socket is a two-               Socket connection
channel communication link.                       Input stream

                                       Server    Output stream    Client

                                  15.7.1 The Server Protocol

                                  Let's now see how a client/server application would be coded in Java. The
                                  template in Figure 15.23 shows the code that is necessary on the server
                                  side. The first step the server takes is to create a ServerSocket. The
                                  first argument to the ServerSocket() method is the port at which the
                                  service will reside. The second argument specifies the number of clients
                                  that can be backlogged, waiting on the server, before a client will be re-
                                  fused service. If more than one client at a time should request service, Java
SECTION 15.7  Client/Server Communication via Sockets                                 721

would establish and manage a waiting list, turning away clients when the                    Waiting for client requests
list is full.

   The next step is to wait for a client request. The accept() method will
block until a connection is established. The Java system is responsible for
waking the server when a client request is received.

                                                                                       

Socket socket ;  // R e f e r e n c e t o t h e s o c k e t

ServerSocket port ; // The p o r t where t h e s e r v e r w i l l l i s t e n

try {

   p o r t = new S e r v e r S o c k e t ( 1 0 0 0 1 , 5 ) ; // C r e a t e a p o r t

   socket = port . accept ( ) ; // Wait f o r c l i e n t to c a l l

   // Communicate wi t h t h e c l i e n t

   socket . close ( ) ;

} catch ( IOException e ) {

   e . printStackTrace ();

}

                                                                                       

       Figure 15.23: Template for the server protocol.

   Once a connection is established, the server can begin communicating                     Initiating a request
with the client. As we have suggested, a socket connection is like a two-
way telephone conversation. Both the client and server can "talk" back
and forth to each other. The details of this step are not shown here. As
we will see, the two-way conversation is managed by connecting both an
input and an output stream to the socket.

   Once the conversation between client and server is finished--once the
server has delivered the requested service--the server can close the con-
nection by calling close(). Thus, there are four steps involved on the
server side:

 Create a ServerSocket and establish a port number.
 Listen for and accept a connection from a client.
 Converse with the client.
 Close the socket.

What distinguishes the server from the client is that the server establishes
the port and accepts the connection.

15.7.2 The Client Protocol

The client protocol (Fig. 15.24) is just as easy to implement. Indeed, on
the client side there are only three steps involved. The first step is to re-
quest a connection to the server. This is done in the Socket() construc-
tor by supplying the server's URL and port number. Once the connection
is established, the client can carry out two-way communication with the
server. This step is not shown here. Finally, when the client is finished,
it can simply close() the connection. Thus, from the client side, the
protocol involves just three steps:

 Open a socket connection to the server, given its address.
 Converse with the server.
 Close the connection.
                   722                                   CHAPTER 15  Sockets and Networking

                   What distinguishes the client from the server is that the client initiates the
                   two-way connection by requesting the service.

                                                                                                                   

                   Socket connection ;                   // R e f e r e n c e t o t h e s o c k e t

                   try {                                 // R e q u e s t a c o n n e c t i o n

                      c o n n e c t i o n = new S o c k e t ( " j a v a . c s . t r i n c o l l . edu" ,  10001);

                        // C a r r y on a two -way c o m m u n i c a t i o n

                        connection . close ( ) ; // C l o s e t h e s o c k e t

                   } catch ( IOException e ) {

                        e . printStackTrace ();

                   }

                                                                                                                   

                          Figure 15.24: Template for the client protocol.

                   15.7.3 A Two-Way Stream Connection

Output routine     Now that we have seen how to establish a socket connection between
Protected methods  a client and server, let's look at the actual two-way communication
                   that takes place. Because this part of the process will be exactly the
                   same for both client and server, we develop a single set of methods,
                   writeToSocket() and readFromSocket(), that may be called by ei-
                   ther.

                      The writeToSocket() method takes two parameters, the Socket
                   and a String, which will be sent to the process on the other end of the
                   socket:

                                                                                                                   

                      protected void writeToSocket ( Socket sock , String str )

                                                         throws IOException {

                          oStream = sock . getOutputStream ( ) ;

                          for ( int k = 0; k < str . length ( ) ; k++)

                          oStream . write ( str . charAt (k ) ) ;

                      }// w r i t e T o S o c k e t ( )

                                                                                                                   

                   If writeToSocket() is called by the server, then the string will be sent
                   to the client. If it is called by the client, the string will be sent to the server.

                      The method is declared protected because we will define it in a
                   superclass so that it can be inherited and used by both the client and
                   server classes. Note also that the method declares that it throws an
                   IOException. Because there's no way to fix an IOException, we'll just
                   let this exception be handled elsewhere, rather than handling it within the
                   method.

                      In order to write to a socket we need only get the socket's
                   OutputStream and then write to it. For this example, oStream
                   is an instance variable of the client/server superclass. We use the
                   Socket.getOutputStream() method to get a reference to the socket's
                   output stream. Note that we are not creating a new output stream here.
                   We are just getting a reference to an existing stream, which was created
                   when the socket connection was accepted. Note also that we do not close
                   the output stream before exiting the method. This is important. If you
SECTION 15.7  Client/Server Communication via Sockets                  723

close the stream, you will lose the ability to communicate through the
socket.

JAVA LANGUAGE RULE Socket Streams. When a socket is
created, it automatically creates its own streams. To use one you just
need to get a reference to it.

JAVA DEBUGGING TIP Socket Streams. After writing to or reading
from a socket I/O stream, do not close the stream. That would make
the socket unusable for subsequent I/O.

   Given the reference to the socket's output stream, we simply write each
character of the string using the OutputStream.write() method. This
method writes a single byte. Therefore, the input stream on the other
side of the socket must read bytes and convert them back into characters.

JAVA EFFECTIVE DESIGN Designing a Protocol. In designing
two-way communication between a client and a server, you are
designing a protocol that each side must use. Failure to design and
implement a clear protocol will cause the communication to break
down.

The readFromSocket() method takes a Socket parameter and returns                     Input routine
a String:                                                                           

                                                                                    

    protected String readFromSocket ( Socket sock )
                                                              throws IOException {

           iStream = sock . getInputStream ( ) ;
           String s t r ="" ;
           char c ;
           while ( ( c = ( char ) iStream . read ( ) ) != '\n ' )

                   str = str + c + "" ;
           return str ;
    }
 

It uses the Socket.getInputStream() method to obtain a reference to
the socket's input stream, which has already been created. So here again
it is important that you don't close the stream in this method. A socket's
input and output streams will be closed automatically when the socket
connection itself is closed.

   The InputStream.read() method reads a single byte at a time from
the input stream until an end-of-line character is received. For this par-
ticular application, the client and server will both read and write one line
of characters at a time. Note the use of the cast operator (char) in the
read() statement. Because bytes are being read, they must be converted
                   724                              CHAPTER 15  Sockets and Networking

                   to char before they can be compared to the end-of-line character or con-
                   catenated to the String. When the read loop encounters an end-of-line
                   character, it terminates and returns the String that was input.

                   JAVA DEBUGGING TIP Bytes and Chars. It is a syntax error to
                   compare a byte and a char. One must be converted to the other
                   using an explicit cast operator.

                   15.8 CASE STUDY: Generic Client/Server Classes

Problem statement  Suppose your boss asks you to set up generic client/server classes that
The echo service   can be used to implement a number of related client/server applications.
                   One application that the company has in mind is a query service, in which
                   the client would send a query string to the server, and the server would
                   interpret the string and return a string that provides the answer. For ex-
                   ample, the client might send the query, "Hours of service," and the client
                   would respond with the company's business hours.

                      Another application the company wants will enable the client to fill out
                   an order form and transmit it as a string to the server. The server will
                   interpret the order, fill it, and return a receipt, including instructions as to
                   when the customer will receive the order.

                      All of the applications to be supported by this generic clien-
                   t/server will communicate via strings, so something very much like the
                   readFromSocket() and writeToSocket() methods can be used for
                   their communication. Of course, you want to design classes so they can
                   be easily extended to support byte-oriented, two-way communications,
                   should that type of service become needed.

                      In order to test the generic models, we will subclass them to create a
                   simple echo service. This service will echo back to the client any message
                   that the server receives. For example, we'll have the client accept key-
                   board input from the user and then send the user's input to the server and
                   simply report what the server returns. The following shows the output
                   generated by a typical client session:

                                                                                                     

                   CLIENT : connected t o ' j a v a . c s . t r i n c o l l . edu '

                   SERVER : Hello , how may I help you ?

                   CLIENT : type a l i n e or ' goodbye ' t o q u i t

                   INPUT : h e l l o

                   SERVER : You s a i d ' h e l l o '

                   INPUT : t h i s i s fun

                   SERVER : You s a i d ' t h i s i s fun '

                   INPUT : j a v a j a v a j a v a

                   SERVER : You s a i d ' j a v a j a v a j a v a '

                   INPUT : goodbye

                   SERVER : Goodbye

                   CLIENT : c o n n e c t i o n c l o s e d                                          
                   

                   On the server side, the client's message will be read from the input stream
                   and then simply echoed back (with some additional characters attached)
  SECTION 15.8  CASE STUDY: Generic Client/Server Classes 725

  through the output stream. The server doesn't display a trace of its activity
  other than to report when connections are established and closed. We
  will code the server in an infinite loop so that it will accept connections
  from a (potentially) endless stream of clients. In fact, most servers are
  coded in this way. They are designed to run forever and must be restarted
  whenever the host that they are running needs to be rebooted. The output
  from a typical server session is as follows:

                                                                                                      

Echo server at java . cs . t r i n c o l l . edu / 1 5 7 . 2 5 2 . 1 6 . 2 1 waiting for connections
Accepted a connection from java . cs . t r i n c o l l . edu / 1 5 7 . 2 5 2 . 1 6 . 2 1
Closed the connection

Accepted a connection from java . cs . t r i n c o l l . edu / 1 5 7 . 2 5 2 . 1 6 . 2 1

Closed the connection                                                                                 


  JAVA EFFECTIVE DESIGN Infinite Loop. A server is an application
  that's designed to run in an infinite loop. The loop should be exited
  only when some kind of exception occurs.

  15.8.1 Object-Oriented Design                                                                                               Thread

  A suitable solution for this project will make extensive use of object-                                               +run()
  oriented design principles. We want Server and Client classes that can
  easily be subclassed to support a wide variety of services. The solution                                                ClientServer
  should make appropriate use of inheritance and polymorphism in its design.                             # iStream : InputStream
  Perhaps the best way to develop our generic class is first to design the                               # oStream : OutputStream
  echo service, as a typical example, and then generalize it.                                            # readFromSocket(in s : Socket) : String
                                                                                                         # writeToSocket(in s : String, in str)
  The Threaded Root Subclass: ClientServer
                                                                                                               Client       Server
  One lesson we can draw at the outset is that both clients and servers                                  +run()        +run()
  use basically the same socket I/O methods. Thus, as we've seen, the
  readFromSocket() and writeToSocket() methods could be used by
  both clients and servers. Because we want all clients and servers to inherit
  these methods, they must be placed in a common superclass. Let's name
  this the ClientServer class.

     Where should we place this class in the Java hierarchy? Should it be a
  direct subclass of Object, or should it extend some other class that would
  give it appropriate functionality? One feature that would make our clients
  and servers more useful is if they were independent threads. That way
  they could be instantiated as part of another object and given the subtask
  of communicating on behalf of that object.

     Therefore, let's define the ClientServer class as a subclass of
  Thread (Fig. 15.25). Recall from Chapter 14 that the typical way to derive
  functionality from a Thread subclass is to override the run() method.
  The run() method will be a good place to implement the client and
  server protocols. Because they are different, we'll define run() in both
  the Client and Server subclasses.

     For now, the only methods contained in ClientServer (Fig. 15.26)
  are the two I/O methods we designed. The only modification we have

                                                                                                      Figure 15.25: Overall design of a
                                                                                                      client/server application.
726                                   CHAPTER 15  Sockets and Networking

made to the methods occurs in the writeToSocket() method, where
we have added code to make sure that any strings written to the socket
are terminated with an end-of-line character.

   This is an important enhancement, because the read loop in the
readFromSocket() method expects to receive an end-of-line character.
Rather than rely on specific clients to guarantee that their strings end with
\n, our design takes care of this problem for them. This ensures that ev-

                                                                                       

import java . io .  ;
import java . net .  ;

public class ClientServer extends Thread {

  protected InputStream iStream ; // I n s t a n c e v a r i a b l e s
  protected OutputStream oStream ;

  protected String readFromSocket ( Socket sock )
                                                                 throws IOException {

     iStream = sock . getInputStream ( ) ;
     String s t r ="" ;
     char c ;
     while ( ( c = ( char ) iStream . read ( ) ) != '\n ' )

         str = str + c + "" ;
     return str ;
  }

  protected void writeToSocket ( Socket sock , String str )

                                              throws IOException {

     oStream = sock . getOutputStream ( ) ;

     i f ( s t r . charAt ( s t r . length ( ) - 1 ) != '\n ' )

     s t r = s t r + '\n ' ;

     for ( int k = 0; k < str . length ( ) ; k++)

     oStream . write ( str . charAt (k ) ) ;

  } // w r i t e T o S o c k e t ( )

}// C l i e n t S e r v e r

                                                                                       

Figure 15.26: The ClientServer class serves as the superclass for clien-
t/server applications.

ery communication that takes place between one of our clients and servers
will be line oriented.

  JAVA EFFECTIVE DESIGN Defensive Design. Code that performs
  I/O, whether across a network or otherwise, should be designed to
  anticipate and remedy common errors. This will lead to more robust
  programs.

15.8.2 The EchoServer Class

Let's now develop a design for the echo server. This class will be a sub-
class of ClientServer (Fig. 15.27). As we saw in discussing the server
protocol, one task that echo server will do is create a ServerSocket
                 SECTION 15.8  CASE STUDY: Generic Client/Server Classes 727

  Design of the                           ClientServer
ass.

                                                              EchoServer

                                          -port : ServerSocket
                                          -socket : Socket
                                          +EchoServer(in por : int, in backlogs : int)
                                          # provideService(in s : Socket)
                                          +run()

                 and establish a port number for its service. Then it will wait for a         What data do we need?
                 Socket connection, and once a connection is accepted, the echo server       
                 will then communicate with the client. This suggests that our server needs
                 at least two instance variables. It also suggests that the task of creat-
                 ing a ServerSocket would be an appropriate action for its constructor
                 method. This leads to the following initial definition:

                  

                     import java . net .  ;
                     import java . io .  ;

                 public class EchoServer extends ClientServer {

                   private ServerSocket port ;
                   private Socket socket ;

                   public EchoServer ( i n t portNum , i n t nBacklog ) {
                      try {
                          p o r t = new S e r v e r S o c k e t ( portNum , nBacklog ) ;
                      } catch ( IOException e ) {
                          e . printStackTrace ();
                      }

                   }

                   public void run ( ) { } // S t u b method

                 }// E c h o S e r v e r

                                                                                             

                 Note that the constructor method catches the IOException. Note also
                 that we have included a stub version of run(), which we want to define
                 in this class.

                    Once EchoServer has set up a port, it should issue the port.accept()
                 method and wait for a client to connect. This part of the server protocol
                 belongs in the run() method. As we have said, most servers are designed The server algorithm
                 to run in an infinite loop. That is, they don't just handle one request and
                 then quit. Instead, once started (usually by the system), they repeatedly
                             728          CHAPTER 15  Sockets and Networking

                             handle requests until deliberately stopped by the system. This leads to the
                             following run algorithm:

                                                                                                                

                             public void run ( ) {
                                try {
                                    System . out . println ( "Echo server at "
                                                               + InetAddress . getLocalHost ()
                                                               + " waiting for connections " ) ;
                                    while ( true ) {
                                       socket = port . accept ( ) ;
                                       System . out . println ( "Accepted a connection from "
                                                                             + socket . getInetAddress ( ) ) ;
                                       provideService ( socket );
                                       socket . close ( ) ;
                                       System . out . println ( "Closed the connection\n" ) ;
                                    }

                                  } catch ( IOException e ) {
                                       e . printStackTrace ();

                                  }

                             }// run ( )

                                                                                                                

                             For simplicity, we are printing the server's status messages on
                             System.out. Ordinarily these should go to a log file. Note also
                             that the details of the actual service algorithm are hidden in the
                             provideService() method.

                                As described earlier, the provideService() method consists of writ-
                             ing a greeting to the client and then repeatedly reading a string from the
                             input stream and echoing it back to the client via the output stream. This
                             is easily done using the writeToSocket() and readFromSocket()
                             methods we developed. The implementation of this method is shown,
                             along with the complete implementation of EchoServer, in Figure 15.28.

                                The protocol used by EchoServer.provideService() starts by
                             saying "hello" and loops until the client says "goodbye." When the client
                             says "goodbye," the server responds with "goodbye." In all other cases
                             it responds with "You said X," where X is the string that was received
                             from the client. Note the use of the toLowerCase() method to con-
                             vert client messages to lowercase. This simplifies the task of checking for
                             "goodbye" by removing the necessity of checking for different spellings
                             of "Goodbye."

                             JAVA EFFECTIVE DESIGN Defensive Design. Converting I/O to
                             lowercase helps to minimize miscommunication between a client and
                             server and leads to a more robust protocol.

Designing for extensibility     This completes the design of the EchoServer. We have deliberately
                             designed it in a way that will make it easy to convert into a generic
                             server. Hence, we have the motivation for using provideService()
                             as the name of the method that provides the echo service. In order to
                             turn EchoServer into a generic Server class, we can simply make
                             provideService() an abstract method, leaving its implementation to
                             the Server subclasses. We'll discuss the details of this change later.
         SECTION 15.8  CASE STUDY: Generic Client/Server Classes 729

                                                                                            

import java . net .  ;
import java . io .  ;
public class EchoServer extends ClientServer {

   private ServerSocket port ;
   private Socket socket ;
   public EchoServer ( i n t portNum , i n t nBacklog ) {

       try {
           p o r t = new S e r v e r S o c k e t ( portNum , nBacklog ) ;

       } catch ( IOException e ) {
          e . printStackTrace ();

       }

  } // E c h o S e r v e r ( )

  public void run ( ) {

  try {

  System . out . println ( "Echo server at " +

  InetAddress . getLocalHost () + " waiting for connections " ) ;

  while ( true ) {

  socket = port . accept ( ) ;

  System . out . println ( "Accepted a connection from " +

                                     socket . getInetAddress ( ) ) ;

  provideService ( socket );

  socket . close ( ) ;

  System . out . println ( "Closed the connection\n" ) ;

  } // w h i l e

  } catch ( IOException e ) {

  e . printStackTrace ();

  } // t r y / c a t c h

  }// run ( )

  protected void provideService ( Socket socket ) {

  String s t r ="" ;

  try {

  w r i t e T o S o c k e t ( s o c k e t , " Hello , how may I help you ?\n" ) ;

  do {

  str = readFromSocket ( socket ) ;

  i f ( s t r . toLowerCase ( ) . equals ( "goodbye" ) )

         writeToSocket ( socket , "Goodbye\n" ) ;

  else

         w r i t e T o S o c k e t ( s o c k e t , "You s a i d ' " + s t r + " ' \ n" ) ;

  } while ( ! s t r . toLowerCase ( ) . equals ( "goodbye" ) ) ;

  } catch ( IOException e ) {

  e . printStackTrace ();

  } // t r y / c a t c h

  }// p r o v i d e S e r v e r ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  EchoServer s e r v e r = new EchoServer ( 1 0 0 0 1 , 3 ) ;

  server . start ();

  }// main ( )

}// E c h o S e r v e r

                                                                                            

                Figure 15.28: EchoServer simply echoes the client's message.
                                             730                                 CHAPTER 15  Sockets and Networking

                                             15.8.3  The EchoClient Class

                   ClientServer              The EchoClient class is just as easy to design (Fig. 15.29). It, too, will be a
                                             subclass of ClientServer. It needs an instance variable for the Socket
                    EchoClient               that it will use, and its constructor should be responsible for opening a
 # socket : Socket                           socket connection to a particular server and port. The main part of its
+EchoClient(in url : String, in port : int)  protocol should be placed in the run() method. The initial definition is
 # requestService(in s : Socket)             as follows:
 # readFromKeyboard() : String
+run()                                                                                                                        

Figure 15.29: Design of the                  import java . net .  ;
EchoClient class.                            import java . io .  ;

                                             public class EchoClient extends ClientServer {

                                                     protected Socket socket ;

                                                     public EchoClient ( String url , int port ) {
                                                        try {
                                                            s o c k e t = new S o c k e t ( u r l , p o r t ) ;
                                                            System . out . p r i n t l n ( "CLIENT : connected t o "
                                                                                                + url + " : " + port );
                                                        } catch ( Exception e) {
                                                            e . printStackTrace ();
                                                            System . exit ( 1 ) ;
                                                        }

                                                     }// E c h o C l i e n t ( )

                                                     public void run ( ) { }// S t u b method

                                             }// E c h o C l i e n t

                                                                                                                              

The client algorithm                         The constructor method takes two parameters that specify the URL and
                                             port number of the echo server. By making these parameters, rather than
                                             hard coding them within the method, we give the client the flexibility to
                                             connect to servers on a variety of hosts.

                                                As with other clients, EchoClient's run() method will consist of re-
                                             questing some kind of service from the server. Our initial design called for
                                             EchoClient to repeatedly input a line from the user, send the line to the
                                             server, and then display the server's response. Thus, for this particular
                                             client, the service requested consists of the following algorithm:

                                                                                                                              

                                             Wait for the server to say " hello " .

                                             Repeat

                                                     Prompt and get and l i n e of input from the user .

                                                     Send the user ' s l i n e to the server .

                                                     Read the server ' s response .

                                                     Display the response to the user .

                                             u n t i l the user types "goodbye"                                               
                                             

                                             With an eye toward eventually turning EchoClient into a generic
                                             client, let's encapsulate this procedure into a requestService()
                                             method that we can simply call from the run() method. Like for the
            SECTION 15.8  CASE STUDY: Generic Client/Server Classes 731

           provideService() method, this design is another example of the en-
           capsulation principle:

            JAVA EFFECTIVE DESIGN Encapsulation. Encapsulating a portion
            of the algorithm into a separate method makes it easy to change the
            algorithm by overriding the method.

           The requestService() method will take a Socket parameter and per-
           form all the I/O for this particular client:

                                                                                                                    

protected void requestService ( Socket socket ) throws IOException {
   String servStr = readFromSocket ( socket ) ;

/ Check for " Hello "                      " + servStr );      // R e p o r t t h e s e r v e r ' s  response
                                           type a line or
 System . out . p r i n t l n ( "SERVER :                  ' goodbye ' to quit " ) ;
 System . out . p r i n t l n ( "CLIENT :

/ Prompt

  if ( servStr . substring (0 ,5). equals ("Hello" )) {

     String userStr = "" ;

     do {

     userStr = readFromKeyboard ( ) ;                                              // Get i n p u t

     writeToSocket ( socket , userStr + "\n" ) ;                                 // Send i t t o s e r v e r

     servStr = readFromSocket ( socket ) ;                 // Read t h e s e r v e r ' s r e s p o n s e

     System . out . p r i n t l n ( "SERVER : " + s e r v S t r ) ; // R e p o r t s e r v e r ' s r e s p o n s e

     } while ( ! userStr . toLowerCase ( ) . equals ( "goodbye" ) ) ;            // U n t i l ' goodbye '

  }

  // r e q u e s t S e r v i c e ( )

                                                                                                                    

           Although this method involves several lines, they should all be familiar
           to you. Each time the client reads a message from the socket, it prints
           it on System.out. The first message it reads should start with the sub-
           string "Hello". This is part of its protocol with the client. Note how the
           substring() method is used to test for this. After the initial greeting
           from the server, the client begins reading user input from the keyboard,
           writing it to the socket, then reading the server's response, and displaying
           it on System.out.

              Note that the task of reading user input from the keyboard has been
           made into a separate method, which is one we've used before:

                                                                                                                    

           protected String readFromKeyboard ( ) throws IOException {

                                      BufferedReader input = new BufferedReader (

                                                     new InputStreamReader ( System . i n ) ) ;

                                      System . out . p r i n t ( "INPUT : " ) ;

                                      String line = input . readLine ( ) ;

                                      return line ;

           }// r e a d F r o m K e y b o a r d ( )

                                                                                                                    

              The only method remaining to be defined is the run(), which is
           shown with the complete definition of EchoClient in Figure 15.30.
           The run() method can simply call the requestService() method.
           When control returns from the requestService() method, run()
           closes the socket connection. Because requestService() might throw
732                            CHAPTER 15  Sockets and Networking

an IOException, the entire method must be embedded within a
try/catch block that catches that exception.

Testing the Echo Service

Both EchoServer and EchoClient contain main() methods (Figs. 15.28

and 15.30). In order to test the programs, you would run the server on one

computer and the client on another computer. (Actually they can both be

run on the same computer, although they wouldn't know this and would

still access each other through a socket connection.)

The EchoServer must be started first, so that its service will be avail-

able when the client starts running. It also must pick a port number. In

this case it picks 10001. The only constraint on its choice is that it cannot

use one of the privileged port numbers--those below 1024--and it cannot

use a port that's already in use.

                                                                                            

public s t a t i c void main ( S t r i n g args [ ] ) {

     EchoServer s e r v e r = new EchoServer ( 1 0 0 0 1 , 3 ) ;

     server . start ();

}// main ( )

                                                                                            

When an EchoClient is created, it must be given the server's URL

(java.trincoll.edu) and the port that the service is using:

                                                                                            

public s t a t i c void main ( S t r i n g args [ ] ) {

     EchoClient client =

              new E c h o C l i e n t ( " j a v a . t r i n c o l l . edu" , 1 0 0 0 1 ) ;

     client . start ();

}// main ( )

                                                                                            

As they are presently coded, you will have to modify both EchoServer

and EchoClient to provide the correct URL and port for your environ-

ment. In testing this program, you might wish to experiment by trying to

introduce various errors into the code and observing the results. When

you run the service, you should observe something like the following

output on the client side:

                                                                                            

CLIENT : connected t o j a v a . t r i n c o l l . edu : 1 0 0 0 1

SERVER : Hello , how may I help you ?

CLIENT : type a l i n e or ' goodbye ' t o q u i t

INPUT : t h i s i s a t e s t

SERVER : You s a i d ' t h i s i s a t e s t '

INPUT : goodbye

SERVER : Goodbye

CLIENT : c o n n e c t i o n c l o s e d                                                    


15.9 Playing One Row Nim Over the Network

In the previous section we developed and tested a generic echo service.
It is based on a common root class, ClientServer, which is a subclass
of Thread. Both EchoServer and EchoClient extend the root class,
SECTION 15.9  Playing One Row Nim Over the Network                                   733

                                                                                                                                

import java . net .  ;
import java . io .  ;

public class EchoClient extends ClientServer {

  protected Socket socket ;

  public EchoClient ( String url , int port ) {
       try {
            s o c k e t = new S o c k e t ( u r l , p o r t ) ;
            System . out . p r i n t l n ( "CLIENT : connected t o " + u r l + " : " + p o r t ) ;
         } catch ( Exception e) {
            e . printStackTrace ();
            System . exit ( 1 ) ;
         }

   }// E c h o C l i e n t ( )

  public void run ( ) {                                                   closed" );
     try {
             requestService ( socket );
             socket . close ( ) ;
            System . out . p r i n t l n ( "CLIENT : c o n n e c t i o n
     } catch ( IOException e ) {
            System . out . println ( e . getMessage ( ) ) ;
            e . printStackTrace ();
     }

  }// run ( )

  protected void requestService ( Socket socket ) throws IOException {

  String servStr = readFromSocket ( socket ) ;                                             // Check f o r " H e l l o "

  System . out . p r i n t l n ( "SERVER : " + s e r v S t r ) ;          // R e p o r t t h e s e r v e r ' s r e s p o n s e

  System . out . p r i n t l n ( "CLIENT : type a l i n e or ' goodbye ' t o q u i t " ) ; // P r o m p t u s e r

  if ( servStr . substring (0 ,5). equals ("Hello" )) {

     String userStr = "" ;

     do {

     userStr = readFromKeyboard ( ) ;                                     // Get i n p u t from u s e r

     writeToSocket ( socket , userStr + "\n" ) ; // Send i t t o s e r v e r

     servStr = readFromSocket ( socket ) ;                                // Read s e r v e r ' s r e s p o n s e

     System . out . p r i n t l n ( "SERVER : " + s e r v S t r ) ; // R e p o r t s e r v e r ' s r e s p o n s e

     } while ( ! userStr . toLowerCase ( ) . equals ( "goodbye" ) ) ; // U n t i l ' g o o d b y e '

  }

  }// r e q u e s t S e r v i c e ( )

  protected String readFromKeyboard ( ) throws IOException {
     BufferedReader input = new BufferedReader (new InputStreamReader ( System . i n ) ) ;
     System . out . p r i n t ( "INPUT : " ) ;
     String line = input . readLine ( ) ;
     return line ;

  }// r e a d F r o m K e y b o a r d ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  E c h o C l i e n t c l i e n t = new E c h o C l i e n t ( " j a v a . t r i n c o l l . edu" , 1 0 0 0 1 ) ;

  client . start ();

  }// main ( )

}// E c h o C l i e n t

                                                                                                                                

Figure 15.30: The EchoClient class prompts the user for a string and
sends it to the EchoServer, which simply echoes it back.
                                                 734  CHAPTER 15  Sockets and Networking
Figure 15.31: Class hierarchy for a
generic client/server application.                            Thread
                                                         +main()

                                                                            ClientServer

                                                      # iStream : InputStream
                                                      # oStream : OutputStream

                                                      # readFromSocket(in sock : Socket) : String
                                                      # writetoSocket(in sock : Socket, in str : String)

                                                                           Server                               Client

                                                      # port : ServerSocket                     # socket : Socket
                                                      # socket : Socket
                                                      +Server(in port : int, in backlog : int)  +Client()
                                                      +run()                                    +run()
                                                      # provideService(in s : Socket)           # readFromKeyboard()
                                                                                                # requestService(in s : Socket)

                                                                               NimServer

                                                      -port : ServerSocket
                                                      -socket : ServerSocket
                                                      +NimServer(in portNum : int, in nBacklog : int)
                                                      # provideService(in s : Socket)
                                                      +run()

                                                                                                           NimClient

                                                                              # socket : Socket
                                                                             +NimClient(in url : String, in requestServer : Socket)
                                                                              # requestService(in s : Socket)
                                                                             +main()

Designing for extensibility  and each implements its own version of run(). In this section, we will
Abstract service methods     generalize this design so that it can support a wide range of services. To
                             illustrate the effectiveness of the design, we will use it as the basis for a
                             program that plays One Row Nim over the Internet.

                                In order to generalize our design, we begin by identifying those ele-
                             ments that are common to all servers and clients and what is particular to
                             the echo service and client. Clearly, the general server and client protocols
                             that are defined here in their respective run() methods, are something
                             that all servers and clients have in common. What differs from one appli-
                             cation to another is the particular service provided and requested, as de-
                             tailed in their respective provideService() and requestService()
                             methods. In this example, the service that is provided will be One Row
                             Nim. The clients that use this service will be (human) players of the game.

                                Therefore, the way to generalize this application is to define the
                             run() method in the generic Server and Client classes. The
                             overall design of the One Row Nim service will now consist of five
                             classes organized into the hierarchy shown in Figure 15.31. At the
                             root of the hierarchy is the ClientServer class, which contains noth-
                             ing but I/O methods used by both clients and servers. The ab-
                             stract Server and Client classes contain implementations of the
SECTION 15.9  Playing One Row Nim Over the Network  735

Thread.run() method, which defines the basic protocols for servers
and clients, respectively. The details of the particular service are
encoded in the provideService() and requestService() meth-
ods. Because the run() methods defined in Client and Server
call provideService() and requestService(), respectively, these
methods must be declared as abstract methods in the Server and
Client classes. Any class that contains an abstract method must itself
be declared abstract.

   Note that we have left the readFromSocket() and writeToSocket()
methods in the ClientServer class. These methods are written in
a general way and can be used, without change, by a wide range
of clients and servers. If necessary, they can also be overridden by
a client or server. In fact, as we will see, the NimServer class
does override the writeToSocket() method. Similarly, note that the
readFromKeyboard() method is defined in the Client superclass.
This is a general method that can be used by a large variety of clients,
so it is best if they don't have to redefine it themselves.

   These design decisions lead to the definitions of Server and
Client shown in Figures 15.32 and 15.33, respectively. Note
that provideService() and requestService() are left unimple-
mented. Subclasses of Server, such as NimServer, and subclasses of
Client, such as NimClient, can implement provideService() and
requestService() in a way that is appropriate for the particular ser-
vice they are providing.

JAVA EFFECTIVE DESIGN Polymorphism. Defining a method as
abstract within a superclass, and implementing it in various ways
in subclasses, is an example of polymorphism. Polymorphism is a
powerful object-oriented design technique.

15.9.1 The NimServer Class                                                Extensibility

Given the abstract definition of the Server class, defining a new ser-
vice is simply a matter of extending Server and implementing the
provideService() method in the new subclass. We will name the
subclass NimServer.
736                     CHAPTER 15  Sockets and Networking

                                                                                           

import java . net .  ;
import java . io .  ;

public abstract class Server extends ClientServer {
   protected ServerSocket port ;
   protected Socket socket ;

  public S e r v e r ( i n t portNum , i n t nBacklog ) {
     try {
         p o r t = new S e r v e r S o c k e t ( portNum , nBacklog ) ;
     } catch ( IOException e ) {
         e . printStackTrace ();
     } // t r y / c a t c h

  }// S e r v e r ( )

  public void run ( ) {
     try {
         System . out . println ( " Server at " +
                                        InetAddress . getLocalHost () +
                                        " waiting for connections " ) ;
         while ( true ) {
             socket = port . accept ( ) ;
            System . out . println ( "Accepted a connection from "
                                                        + socket . getInetAddress ( ) ) ;
             provideService ( socket );
             socket . close ( ) ;
            System . out . println ( "Closed the connection\n" ) ;
         }// w h i l e
     } catch ( IOException e ) {
         e . printStackTrace ();
     } // t r y / c a t c h

  }// run ( )

  // I m p l e m e n t e d i n s u b c l a s s

  protected abstract void provideService ( Socket socket ) ;

}// S e r v e r

                                                                                           

                 Figure 15.32: The abstract Server class.
  SECTION 15.9  Playing One Row Nim Over the Network                                      737

                                                                                           

import java . net .  ;
import java . io .  ;

public abstract class Client extends ClientServer {
   protected Socket socket ;

  public Client ( String url , int port ) {                            to " + url +
     try {                                                                " : " + port );
         s o c k e t = new S o c k e t ( u r l , p o r t ) ;
         System . out . p r i n t l n ( "CLIENT : connected

     } catch ( Exception e) {
         e . printStackTrace ();
         System . ex it ( 1 ) ;

     } // t r y / c a t c h b l o c k
  }// C l i e n t ( )

  public void run ( ) {                                                closed" );
     try {
         requestService ( socket );
         socket . close ( ) ;
         System . out . p r i n t l n ( "CLIENT : c o n n e c t i o n
     } catch ( IOException e ) {
         System . out . println ( e . getMessage ( ) ) ;
         e . printStackTrace ();
     } // t r y / c a t c h b l o c k

  }// run ( )

  // I m p l e m e n t e d i n s u b c l a s s

  protected abstract void requestService ( Socket socket )
                                                                   throws IOException ;

  protected String readFromKeyboard ( ) throws IOException {

  BufferedReader input = new BufferedReader

                        (new InputStreamReader ( System . i n ) ) ;

  System . out . p r i n t ( "INPUT : " ) ;

  String line = input . readLine ( ) ;

  return line ;

  }// r e a d F r o m K e y b o a r d ( )

}// C l i e n t

                                                                                           

                 Figure 15.33: The abstract Client class.
738                                              CHAPTER 15  Sockets and Networking
                                                                                                                  

          java . net .;
  import  java . io .;
  import

public class NimServer extends Server {
   public NimServer ( int port , int backlog ) {
       super ( port , backlog ) ;
   }

   protected void provideService ( Socket socket ) {
      OneRowNim nim = new OneRowNim ( ) ;
       try {
          w r i t e T o S o c k e t ( s o c k e t , "Hi Nim p l a y e r . You ' r e P l a y e r 1 and I 'm P l a y e r 2 . " +
                   nim . reportGameState ( ) + " " + nim . getGamePrompt ( ) + "\n" ) ;
          play ( nim , s o c k e t ) ;
       } catch ( IOException e ) {
          e . printStackTrace ();
       } // t r y / c a t c h

   } // p r o v i d e S e r v i c e ( )

  p r i v a t e void play (OneRowNim nim , S o c k e t s o c k e t ) throws IOException {
     NimPlayer computerPlayer = new NimPlayer ( nim ) ;
     nim . addComputerPlayer ( computerPlayer ) ;
      String s t r ="" , response="" ;
      int userTakes = 0 , computerTakes = 0;
     do {
         str = readFromSocket ( socket ) ;
         boolean legalMove = false ;
         do {
             userTakes = Integer . parseInt ( str ) ;
             i f ( nim . t a k e S t i c k s ( userTakes ) ) {
                legalMove = true ;
                nim . changePlayer ( ) ;
                response = nim . reportGameState ( ) + " " ;
                 i f ( ! nim . gameOver ( ) ) {
                    computerTakes = I n t e g e r . p a r s e I n t ( computerPlayer . makeAMove( "" ) ) ;
                    response = response + " My turn . I t a k e " + computerTakes + " s t i c k s . " ;
                    nim . t a k e S t i c k s ( computerTakes ) ;
                    nim . changePlayer ( ) ;
                    response = response + nim . reportGameState ( ) + " " ;
                    i f ( ! nim . gameOver ( ) )
                         response = response + nim . getGamePrompt ( ) ;
                } // i f not game over
                writeToSocket ( socket , response ) ;
            } else {
                  w r i t e T o S o c k e t ( s o c k e t , " That ' s an i l l e g a l move . Try again . \ n" ) ;
                  str = readFromSocket ( socket ) ;
            } // i f u s er t a k e s
         } while ( ! legalMove ) ;
     } while ( ! nim . gameOver ( ) ) ;

  } // play

  // Overriding w r i t e T o S o c k e t t o remove \n from s t r

  protected void writeToSocket ( Socket soc , String s t r ) throws IOException {

     S t r i n g B u f f e r sb = new S t r i n g B u f f e r ( ) ;

     for ( int k = 0; k < s t r . length ( ) ; k++)

          i f ( s t r . charAt ( k ) != '\n ' )

          sb . append ( s t r . charAt ( k ) ) ;

     super . writeToSocket ( soc , sb . t o S t r i n g ( ) + "\n" ) ;

  }

  public s t a t i c void main ( S t r i n g args [ ] ) {

     NimServer s e r v e r = new NimServer ( 1 0 0 0 1 , 5 ) ;

     server . start ();

  } // main ( )

} // NimServer
                                                                                                                                

                         Figure 15.34: The NimServer class.

   Figure 15.34 provides a definition of the NimServer subclass. Note
how its implementation of provideService() uses an instance of
the OneRowNim class from Chapter 8. Also, the play() method,
which encapsulates the game-playing algorithm, uses an instance of
SECTION 15.9  Playing One Row Nim Over the Network  739

NimPlayer, also from Chapter 8. You might recall that OneRowNim is          Overriding a method
a TwoPlayerGame and NimPlayer defines methods that allow a com-
puter to play an optimal game of One Row Nim. In this example, the
server acts as one of the players and use a NimPlayer to manage its play-
ing strategy. Thus, clients that connect to NimServer will be faced by a
computer that plays an optimal game.

   If you compare the details of the NimServer's play() method with
the play() method from the implementation of OneRowNim, you will
see that they are very similar. In this implementation, we use public
methods of the OneRowNim object to manage the playing of the game.
Thus, addComputerPlayer() adds an instance of NimPlayer to the
game. The takeSticks(), changePlayer(), and gameOver() meth-
ods are used to manage the moves made by both itself and the client. And
the getGamePrompt() and reportGameState() methods are used to
manage the interaction and communication with the client. Note also
that whenever it is the server's turn to move, it uses the NimPlayer's
makeAMove() method to determine the optimal move to make.

   Although the programming logic employed in the play() method
looks somewhat complex, it is very similar to the logic employed in the
Chapter 8 version of the game. The main difference here is that the
server uses the writeToSocket() and readFromSocket() methods
to manage the communication with the client. In this regard, this instance
of provideService() is no different than the provideService()
method we used in the EchoServer class.

   Finally, note that NimServer provides an implementation of the
writeToSocket() method. This method is implemented in the
ClientServer() class and is inherited by NimServer. However,
the default implementation assumes that the client will use the a car-
riage return (\n) to determine the end of a particular message in
the socket. Because OneRowNim's methods, getGamePrompt() and
reportGameState(), contain embedded carriage returns, it is necessary
to filter these. The new version of writeToSocket() performs this fil-
tering and calls the default method (super.writeToSocket(), after it
has finished its filtering task.

15.9.2 The NimClient Class

The NimClient class is even easier to implement. As its task is sim-        Creating new clients
ply to manage the communication between the human user and the
NimServer, it is very similar to the requestService() method we
used in EchoClient. The relationship between the abstract Client class
(Fig. 15.33) and its extension in NimClient (Fig. 15.35) is very similar
to the relationship between Server and NimServer. The request-
Service() method is called by Client.run(). It is implemented in
NimClient. In this way, the Client class can serve as a superclass
for any number of clients. New clients for new services can be derived
from Client by simply implementing their own requestService()
method.
 740                                 CHAPTER 15  Sockets and Networking

          java . net .;
  import  java . io .;
  import

public class NimClient extends Client {
   p r i v a t e KeyboardReader kb = new KeyboardReader ( ) ;
   public NimClient ( String url , int port ) {
       super ( url , port ) ;
   }

protected void requestService ( Socket socket ) throws IOException {

String servStr = readFromSocket ( socket ) ;                // Get s e r v e r ' s r e s p o n

kb . prompt ( "NIM SERVER : " + s e r v S t r +" \n" ) ; // R e p o r t s e r v e r ' s r e s

i f ( s e r v S t r . s u b s t r i n g ( 0 , 6 ) . e q u a l s ( "Hi Nim" ) ) {

          String userStr = "" ;

          do {

          u s e r S t r = kb . getKeyboardInput ( ) ;       // Get u s e r ' s move

          writeToSocket ( socket , userStr + "\n" ) ; // Send i t t o s e r v e r

          servStr = readFromSocket ( socket ) ;             // Read s e r v e r ' s r e s p o

          kb . prompt ( "NIM SERVER : " + s e r v S t r + "\n" ) ; // R e p o r t r e s p o n s

          } while ( s e r v S t r . indexOf ( "Game over ! " ) == -1); // U n t i l g a m e o v e r

}

}// r e q u e s t S e r v i c e ( )

     public s t a t i c void  main ( S t r i n g args [ ] ) {            10001);
         NimClient client     = new NimClient ( " l o c a l h o s t " ,
         client . start ();

     } // main ( )

  } // N i m C l i e n t


                Figure 15.35: The derived NimClient class.

 JAVA EFFECTIVE DESIGN Inheritance. By placing as much
 functionality as possible into a generic client/server superclass, you
 can simplify the creation of new services. This is an effective use of
 Java's inheritance mechanism.

15.9.3 Testing the Nim Service

Testing the One Row Nim service will be no different than testing the
Echo service. To test the service, you want to run both NimServer and
NimClient at the same time and preferably on different computers. As
they are presently coded, you will have to modify the main() methods
of both NimServer and NimClient to provide the correct URL and port
for your environment.

SELF-STUDY EXERCISE

EXERCISE 15.7 The design of the client/server hierarchy makes it easy
to create a new service by extending both the Server and Client classes.
Describe how you would implement a scramble service with this model.
A scramble service can be used by people trying to solve the daily scram-
ble puzzles found in many newspapers. Given a string of letters, the
SECTION 15.10  Java Network Security Restrictions  741

scramble service will return a string containing all possible letter com-
binations. For example, given "cat," the scramble service will return "act
atc cat cta tac tca."

EXERCISE 15.8 Describe what happens when each of the following
errors is introduced into the EchoClient or EchoServer programs:

   Specify the wrong host name when running EchoClient.

   Specify the wrong port number when running EchoClient.

   Remove the reference to \n in the writeToSocket() call in
      requestService().

15.10 Java Network Security Restrictions

One of the most attractive features of Java is that extensive effort has been  Code verification
made to make it a secure language. This is especially important for a lan-     Limited privileges
guage that makes it so easy to implement networking applications. After        Limited network access
all, nobody wants to download a Java applet that proceeds to erase the
hard disk. Such an applet might be written by a cyber terrorist, deliber-      Trusted code
ately aiming to cause severe damage, or it might be written by a cyber
doofus, who inadvertently writes code that does severe damage.

   What are some of Java's techniques for guarding against either deliber-
ate or inadvertent insecure code? One level of security is Java's bytecode
verification process, which the Java Virtual Machine performs on any "un-
trusted" code that it receives. Java checks every class that it loads into
memory to make sure it doesn't contain illegal or insecure code. Another
line of defense is the so-called sandbox security model, which refers to
the practice of restricting the kinds of things that certain programs can do.
For example, the "sandbox" environment for Java applets restricts them
from having any access whatsoever to the local file system.

   Another restriction imposed on applets is to limit their networking ca-
pabilities. For example, a Java applet cannot create a network connection
to any computer except the one from which its code was downloaded.
Also, a Java applet cannot listen for, or accept, connections on privileged
ports--those numbered 1024 or lower. Together, these two restrictions
severely limit the kinds of client/server programs that can be built as
applets.

   Java sets aside certain locations as repositories for trusted code. For
example, the Java class libraries would be placed in such a location, as
would the directories where your Java programs are stored. Any class
loaded from some other directory is considered untrusted. By this def-
inition, applets downloaded over the Internet would be considered un-
trusted code.

   In addition to the restrictions for applets, which apply to all untrusted
code, Java defines a number of other limitations:

 Untrusted code cannot make use of certain system facilities, such as
  System.exit() and classes in the java.security package.

 Untrusted code cannot make use of certain AWT methods, such as
  methods that access the system clipboard. Another AWT restriction
742  CHAPTER 15  Sockets and Networking

  is that any window created by untrusted code must display a mes-
  sage informing the user that it is untrusted. You might have seen such
  messages on windows opened from applets.
 Untrusted code is limited in the kinds of threads it can create.

   Security enhancements introduced in JDK 1.2 are based on the concepts
of "permission" and "policy." Code is assigned "permissions" based on
the security policy currently in effect. Each permission specifies the type
of access allowed for a particular resource (such as "read" and "write"
access to a specified file or directory, or "connect" access to a given host
and port). The policy that controls permissions can be initialized from an
external configurable policy file. Unless a permission is explicitly granted
to code, it cannot access the resource that is guarded by that permis-
sion. These new enhancements offer a more fine-grained and extensible
approach to security for both applets and applications.

   As this brief overview illustrates, the Java Virtual Machine is designed
with security as one of its primary issues. This doesn't guarantee 100 per-
cent security, but it is a big improvement over some of the languages and
systems that preceded Java. Moreover, security is an ongoing concern
of the Java development process. Flaws in the existing security system
are fixed very quickly. Advanced methods are constantly being devel-
oped and incorporated into the system. One such enhancement is the
use of encryption to guarantee the integrity of classes transferred over the
network.

15.11 Java Servlets and Java Server Pages

In this chapter we have been discussing the client/server model of com-
puting. Thus far we have learned how to implement client/server ap-
plications using socket connections between programs running on differ-
ent computers. Because it requires the programmer to directly create and
manage the socket protocol, this socket-level approach is a low-level ap-
proach. It is important to know about sockets and how they are used, but
most client/server applications are programmed at a much higher level
by using Java library classes.

   Our focus in this section will be to give you a brief sense of how Java
programs can be integrated into the Web pages. We will discuss two
approaches: Java Server Pages (JSP) and Java servlets. As Web-based ap-
proaches, both of these require the use of HTML (HyperText Markup Lan-
guage) code, the language that is used for coding Web pages. This means
that in order to write your own servlets and JSPs you would really have to
learn a little about HTML code. Fortunately, learning HTML code is not
difficult and although it doesn't fit within the scope of this book, you can
easily find books or Web sites that cover basic HTML coding. Moreover,
in order for servlets and JSPs to work, they must be associated with a Web
server that is specially configured to understand Java code. At the end of
this section we will provide links to a Web site where you can learn more
about HTML and about how to set up your own JSPs and servlets.
SECTION 15.11  Java Servlets and Java Server Pages                                 743

15.11.1 Java Server Pages

A Java Server Page (JSP) is a Web page that contains small snippets of
Java code. The simple example discussed here was downloaded from on
online tutorial at

                                                                                         

    h t t p : //developer . apple . com/ i n t e r n e t / j a v a /tomcat1 . html       

The Java code on a JSP embedded within <% ... %> brackets and inter-
spersed among a page's HTML tags. The Java code can extend over one
or more lines. Figure 15.36 shows the complete sourcecode for a simple
JSP.

                                                                                    

<html><head><t i t l e >Very Simple JSP Example</ t i t l e ></head>
<body b g c o l o r =" white ">

<h1>Very B a s i c JSP</h1>

Current time : <%= new j a v a . u t i l . Date ( ) %>
<br><br>

Reload this page to watch the greeting change .
<br><br><b>

<!-- i n c l u d i n g l i n e s o f Jav a code i n an HTML page -->

<%

    i n t um = ( i n t ) ( Math . random ( )  5 ) ;

    switch ( um )

    {

       case 0 : out . p r i n t l n ( "Welcome" ) ; break ;

       case 1: out . println ( "Bienvenidos" ) ; break ;

       case 2: out . println ( "Bienvenue" ) ; break ;

       case 3: out . println ( "Bienvenuti" ) ; break ;

       case 4 : out . p r i n t l n ( "Willkommen" ) ; break ;

       d e f a u l t : out . p r i n t l n ( "Huh? " + um ) ;

    }

    out . p r i n t l n ( "<br>" ) ;

%>

</b>

</body>

</html>
                                                                                    

         Figure 15.36: A simple JavaServer Page (JSP).

   In this example we see two uses of Java code. In the first case, a JSP
expression tag is used to display the current date on the Web page:

                                                                                         

       Current time : <%= new j a v a . u t i l . Date ( ) %>                            

A JSP expression element begins with <%= and ends with %>. The expres-
sion contained within the tag is evaluated, converted into a Java String
744                    CHAPTER 15  Sockets and Networking

                                                                              Figure 15

                                                                              JSP.

and inserted into the Web page. In this case the Date object is evaluated
and its string value is displayed on the Web page (Fig. 15.37).

   In the second case, a scriptlet of Java code uses the Math.random()
method to display a random greeting on the Web page. A scriptlet extends
over several lines and is contained within the <%...%> tag (Fig. 15.36).
Note the use of the output statement, out.println(). The out object is
a built-in output stream. Anything written to out will be transmitted as
part of the HTML code that is sent to the Web page. In this case, one of
the greetings is displayed each time the page is reloaded.

   Obviously, this simple example only scratches the surface of what you
can do with JSP. If you want to learn more about JSP, there are many help-
ful online tutorials available, such as http://www.jsptut.com/. How-
ever, remember that in order to experiment with JSP, it will be necessary
to have access to a JSP-aware Web server either on your own computer or
on one provided by your service provider.

15.11.2 Java Servlets

A Java servlet is another high-level approach to developing client/server
applications. A servlet is a Java program that runs on a Web server and
processes Web pages using the HyperText Transfer Protocol (HTTP). In a
Web application, the browser serves as the client.

   Many URLs that we access on the web are pure HTML files that are
simply transmitted back to the browser by the Web server. For example,
the URL for a simple HTML document on the author's Web site is:

                                                                              

h t t p : //www. c s . t r i n c o l l . edu /~ram/ j j j / h e l l o . html  

SECTION 15.11  Java Servlets and Java Server Pages  745

If you type that URL into a Web browser, the Web server at
www.cs.trincoll.edu would transmit the following text file to your
browser, which would then render and display the document.

                                                                                

<HTML>            Simple  HTML Document</TITLE>
<HEAD>

     <TITLE>Very
</HEAD>

   <BODY>                                                                       
          <CENTER><H1>H e l l o </H1></CENTER>                                   Servlets vs. Applets

   </BODY>
   </HTML>
 

If we want the server to do some processing and submit the results of
that processing to the browser, we could use a Java servlet. A servlet can
perform some processing task and return the results of that task to the
browser in the form of an HTML document.

   The difference between a Java servlet and a Java applet is that an applet
performs all of its processing on the client side of the client/server connec-
tion. A servlet performs its processing on the server side. When you load
a Java applet into a browser, the Web server downloads the applet's byte-
code into the browser. The browser then runs the byte code, assuming, of
course, it is equipped with a plugin for the Java Virtual Machine (JVM).
When you access a Java servlet from a browser, the Web server performs
some computation and transmits just the results to the browser.

   There are several advantages of servlets over applets. First, servlets cut
down significantly on the amount of data that has to be transmitted to
the browser. Second, because the servlet returns an HTML-encoded page,
there are many fewer platform-related problems. All browsers can inter-
pret HTML code, but not all browsers have the right plugins for interpret-
ing Java applets. Third, servlets are not subject to the same security and
privacy restrictions as Java applets, which, as we saw earlier in the chap-
ter, must be run as untrusted code. Finally, Java servlets can directly access
large databases and other resources that are stored on the server. Access
to such resources via an applet would be very difficult and inefficient.

   So, servlets have many advantages over applets. Because of these ad-
vantages they have quickly become an industry standard for developing
client/server applications on the Web.

15.11.3 A Simple Servlet Example

To illustrate the difference between a Java servlet and a simple HTML
page, Figure 15.38 shows a servlet that creates a Web page that says
"Hello." As you can see, a servlet is a Java program. In addi-
tion to libraries that you are already familiar with, such as java.io,
it also imports names from two new libraries: javax.servlet and
javax.servlet.http. The program defines a single class, the
HelloServlet class, which is a subclass of HttpServlet, the standard
superclass for all Java servlets.

   The servlet defines the doGet() method. This is a method that is de-
fined in the HttpServlet superclass. Our HelloServlet is overriding
 746                                   CHAPTER 15   Sockets and Networking
                                                                                    
          java . io .;
          java . text .;
  import  java . util .;
  import  javax . servlet .;
  import  javax . servlet . http .;
  import
  import

public class HelloServlet extends HttpServlet {

   public void doGet ( HttpServletRequest request ,
                                   HttpServletResponse response )

          throws IOException , ServletException
   {

          response . setContentType ( " text/html" ) ;
          PrintWriter out = response . getWriter ( ) ;

          out . p r i n t l n ( "<HTML>" ) ;

          out . p r i n t l n ( "<HEAD>" ) ;

          out . p r i n t l n ( "<TITLE>Simple S e r v l e t </TITLE>" ) ;

          out . p r i n t l n ( "</HEAD>" ) ;

          out . p r i n t l n ( "<BODY>" ) ;

          out . p r i n t l n ( "<H1> Hi , from a J ava S e r v l e t .</H1>" ) ;

          out . p r i n t l n ( "</BODY>" ) ;

          out . p r i n t l n ( "</HTML>" ) ;

   }

}

                                                                                   

          Figure 15.38: A simple Java servlet.

that method. In general, Web browsers make two types of requests when
they request a Web page, a get or a post. We won't go into the differences
between these requests. The result in either case is that the Web server
will respond to the request by transmitting some text data to the browser.
When a browser makes a get request, the server will automatically call
the servlet's doGet() method. That's why we have to override it. The
HttpServlet class also has a default doPost() method, which is called
automatically to handle post requests.

   Note the two parameters in the doGet() method: the HttpServlet-
Request and the HttpServletResponse. The doPost() method has
the same two parameters. These are the objects that are used to hold the
data that are communicated between the client and the server. When the
client (browser) makes a get request, the HttpServletRequest objects
hold the data contained in the request. These data might include data that
a user has typed into an HTML form. We will see an example of how to
extract these data in the next section.

   The HttpServletResponse object is where the servlet will write its
response. As you can see from examining the code, the HttpServlet-
Response object has an associated output stream, a PrintWriter, and
it is a simple matter to write text to that output stream. Note that the text
we write is HTML code that is practically identical to the code contained
in the previous HTML example.
SECTION 15.11  Java Servlets and Java Server Pages  747

15.11.4 The Nim Servlet

The simple servlet in the preceding section illustrates how the servlet com-
municates with the client--by writing HTML code to the HttpServlet-
Response object. Let's now look at an example that uses two-way com-
munication between the client and server. To keep the example simple,
we will revisit once again on our One Row Nim game. In this application
the servlet will manage the One Row Nim game and will play against a
human player, who will access the game through a Web browser.

                                                                              Figure 15.39: The interface for the
                                                                              Nim servlet.

   The browser interface for this version of the game is shown in Fig-
ure 15.39. As you can see, it is a simple Web page. The sticks in this
instance are replaced by pennies. In addition to reporting the total num-
ber of pennies left, the page displays images of pennies. This Web page
itself is organized as a simple HTML form, which contains one text field
for the user's input. Each time the user hits the RETURN key in the text
 748                                   CHAPTER 15   Sockets and Networking
                                                                                    
          java . io .;
          java . util .;
  import  javax . servlet .;
  import  javax . servlet . http .;
  import
  import

public class NimServlet extends HttpServlet {

  p r i v a t e OneRowNim nim = n u l l ;
  private NimPlayer nimPlayer = null ;

  public void doPost ( HttpServletRequest request ,
                                    HttpServletResponse response )

     throws IOException , ServletException
  {

         doGet ( request , response ) ;
  }

  // The doGet ( ) method g o e s h e r e .

} // N i m S e r v l e t

                                                                    

Figure 15.40: Java code for the NimServlet, minus the doGet() method.

field, the user's input is transmitted to the servlet where it is processed.
The servlet then transmits a new page to the user's browser, which shows
the updated state of the game.

   Let's now look at the servlet program itself, whose code is shown in
Figures 15.40 and 15.41. This servlet program is quite a bit longer than
the simple hello server, but it is not really any more complex or difficult.
The NimServlet extends the HttpServlet superclass and overrides
the doGet() method. Note that it also overrides the doPost() method,
by simply having that method call the doPost() method. So this servlet
will work for both get and post requests.

   NimServlet uses two other objects: a OneRowNim object and a
NimPlayer object. You should be familiar with these from Chapter 8,
so we won't go over their internal details here. The OneRowNim object
manages the playing of the game and the NimPlayer object acts as a
computer-based player of the game. Note that variable references for
these two objects are declared in the beginning of the class definition, but
the objects themselves are declared within the doGet() method.

   One of the tricky parts of NimServlet is how we declare the
OneRowNim object. As you might already know, the HTTP protocol is
said to be a stateless protocol, which means that each time a browser sub-
mits a request to a Web server, the Web server sees the request as a com-
pletely independent communication. The server does not, in and of itself,
maintain an internal state that keeps track of a series of transactions with
a particular browser session. For example, when you are shopping for
books on Amazon, each time you go to a new page, the Amazon web
server treats that request as a completely independent action. Web appli-
cations use various techniques to get around the stateless nature of the
SECTION 15.11  Java Servlets and Java Server Pages                                                                                   749

                                                                                                                           

d doGet ( HttpServletRequest request , HttpServletResponse response )
  IOException , ServletException

 . setContentType ( " text/html" ) ;
iter out = response . getWriter ( ) ;
sion session = request . getSession ( true ) ;

n t l n ( "<html>" ) ;
n t l n ( "<body>" ) ;
n t l n ( "<head>" ) ;
n t l n ( "<t i t l e >Simple Nim Game</t i t l e >" ) ;
n t l n ( "</head>" ) ;
n t l n ( "<body>" ) ;

n t l n ( "<c e n t e r><h1>One Row Nim</h1></c e n t e r>" ) ;
n t l n ( "<c e n t e r><h3>The Rules</h3>" ) ;
n t l n ( "A random number o f pennies i s thrown on t h e t a b l e .<BR>" ) ;
n t l n ( "Two p l a y e r s a l t e r n a t e making moves,<BR>" ) ;
n t l n ( " p i c k i n g up between 1 and 3 pennies on each move.<BR>" ) ;
n t l n ( "The p l a y e r who p i c k s up t h e l a s t penny l o s e s .<BR><BR>" ) ;

  == n u l l ) {
  new OneRowNim( 7 + ( i n t ) ( Math . random ( )  1 1 ) ) ;
 ayer = new NimPlayer ( nim ) ;
 r i n t l n ( "<h4>You go f i r s t !</h4></c e n t e r>" ) ;
{

 serTakes = Integer . parseInt ( request . getParameter ( "pickup" ) ) ;
nim . t a k e S t i c k s ( userTakes ) ) {

   . p r i n t l n ( "<h4><f o n t c o l o r = ' red'>Woops . That ' s an i l l e g a l move ! . Try again . </f o n t><h4>" ) ;
     i f ( ! nim . gameOver ( ) ) {

m. changePlayer ( ) ;
   . p r i n t l n ( "<h4>So , you took <f o n t c o l o r = ' blue '>" + userTakes + "</f o n t><BR>" ) ;
   . p r i n t l n ( " That l e a v e s me with <f o n t c o l o r = ' blue '>" + nim . g e t S t i c k s ( ) + "</f o n t><BR>" ) ;
    iTake = nimPlayer . move ( ) ;
   . p r i n t l n ( "OK. I t a k e <f o n t c o l o r = ' red'>" + iTake + " </f o n t>pennies .<BR></h4>" ) ;

m. takeSticks ( iTake ) ;
m. changePlayer ( ) ;

  f not gameover
  e nim != n u l l
m . gameOver ( ) ) {
 m . g e t P l a y e r ( ) == 1 )
   p r i n t l n ( "<c e n t e r><h3>Who ' s Turn : <f o n t c o l o r = ' magenta'> Your turn </f o n t><h3></c e n t e r>" ) ;

 p r i n t l n ( "<c e n t e r><h3>Who ' s Turn : <f o n t c o l o r = ' magenta'> My turn </f o n t><h3></c e n t e r>" ) ;
r i n t l n ( "<c e n t e r><h3>Pennies L e f t : <f o n t c o l o r = ' red'>" + nim . g e t S t i c k s ( ) + "</f o n t><h3></c e n t e r>" ) ;
r i n t l n ( "<c e n t e r>" ) ;
n t k = 0 ; k < nim . g e t S t i c k s ( ) ; k++)
 p r i n t l n ( "<img s r c = ' h t t p :// xroads . v i r g i n i a . edu /~CAP/LINCOLN/ c e n t . j p g ' width = ' 2 5 ' h e i g h t = '25 ' > " ) ;
r i n t l n ( "</c e n t e r><br>" ) ;

 r i n t l n ( "<c e n t e r>" ) ;                                                           Me.</ f o n t><h4></c e n t e r>" ) ;
 r i n t l n ( "<form a c t i o n = '/ j j j 3 e /NimServlet ' method = 'POST'>" ) ;
 r i n t l n ( "<t a b l e border ='0'>" ) ;
 r i n t l n ( "<t r><td>How many do you pickup ? : </td>" +
<td><input type = ' t e x t ' name= ' pickup ' value ='0'></td></t r>" ) ;
 r i n t l n ( "</t a b l e>" ) ;
 r i n t l n ( "</c e n t e r>" ) ;
 r i n t l n ( "</form>" ) ;
{

 r i n t l n ( "<h3><f o n t c o l o r = ' red'>Game over!</ f o n t><h3>" ) ;
 m . g e t P l a y e r ( ) == 1 )
  p r i n t l n ( "<c e n t e r><h4>And t h e winner i s : <f o n t c o l o r = ' magenta'>

  p r i n t l n ( "<c e n t e r><h4>And t h e winner i s : <f o n t c o l o r = ' magenta'> You.</ f o n t><h4></c e n t e r>" ) ;
r i n t l n ( "<c e n t e r><h4><f o n t c o l o r = ' magenta'> Nice game!</ f o n t><h4></c e n t e r>" ) ;
r i n t l n ( "<c e n t e r><h4>To play again , j u s t r e l o a d t h e page.<h4></c e n t e r>" ) ;
 null ;
 e game over
n t l n ( "</body>" ) ;
n t l n ( "</html>" ) ;

                                                                                                                            

Figure 15.41: Java code for the NimServlet's doGet() method.
750                              CHAPTER 15  Sockets and Networking

HTTP protocol. One technique is to use cookies to record the progress of a

session. A cookie is a small text file containing data that the server uses to

keep track of a user's session. Data that identifies the user and the state of

the transaction--for example, buying a book--are passed back and forth

between the browser and the server each time the user visits the Amazon

Web site.

Java's servlet library contains methods and objects that support the use

of cookies. But rather than use cookies, we will use the OneRowNim ob-

ject itself to keep track of the state of the Nim game. The first time the

user submits a request to Nim servlet--that is, when the user first visits

the servlet's URL--the servlet will create an instance of the OneRowNim

object. Creating a OneRowNim object will have the effect of initializing the

game, including the creation of a NimPlayer to play the server's moves.

The OneRowNim object will persist throughout the playing of the game

and will handle all subsequent user's move. When the game is over, the

NimServlet will, in effect, dispose of the OneRowNim object by setting

its reference to null. Thus, in outline form, the code for creating and

disposing of the OneRowNim object goes as follows:

                                                                                

// F i r s t r e q u e s t : S t a r t a new Nim game

i f ( nim == n u l l ) {

     nim = new OneRowNim( 7 + ( i n t ) ( Math . random ( )  1 1 ) ) ;

     nimPlayer = new NimPlayer ( nim ) ;

// Code d e l e t e d h e r e .

else {

     // Code f o r p l a y i n g t h e game g o e s h e r e .

}

i f ( ! nim . gameOver ( ) ) {

     // Code f o r p l a y i n g t h e game g o e s h e r e .

} else {

     // Code d e l e t e d h e r e .

     nim = null ;

}

                                                                                

Those places where code has been deleted in this segment would con-

tain Java code for responding to the user's input and deciding how many

pennies to take.

Unlike the HelloServlet, the NimServlet accepts input from the

client. The code for handling user input is as follows:

                                                                                

int userTakes =

           Integer . parseInt ( request . getParameter ( "pickup" ) ) ;         

This statements reads the user's input from the text field on the Web page
by using the request.getParameter() method. This is one of the
public methods of the HttpServletRequest object. The name of the
text field is 'pickup', which is provided as an argument in this method
call. As we noted above, the text field itself is on element of the HTML
  CHAPTER 15  Chapter Summary                                                 751

  form contained in the servlet's Web page. The HTML code for creating
  the form element is also generated by the servlet:

                                                                                             

out . p r i n t l n ( "<form a c t i o n = '/ j j j 3 e /NimServlet ' method = 'POST'>" ) ;

out . p r i n t l n ( "<t a b l e border = '0 ' > " ) ;

out . p r i n t l n ( "<t r ><td>How many do you p i c k up ? : </td>" +

  "<td><in put type = ' t e x t ' name= ' pickup ' value ='0'></td></t r >" ) ;              

  Unless you already know something about HTML, you won't completely
  understand this code. We will give a minimal explanation. In HTML, a
  text field is known as a input element of type 'text'. Note that this code
  segment names the element 'pickup', which allows our program to refer
  to it by that name.

     The remaining details in the servlet have to do with managing the game
  and repeat concepts that were covered in Chapter 8. We won't repeat them
  here, other than to note that any output sent to the client must be in the
  form of HTML statements, hence the appearance throughout the code of
  HTML tags, which are the elements in the angle brackets.

  15.11.5 Setting Up and Using Java Servlets

  Java servlets can only run on a Web server that is specially configured to
  interpret them. To experiment with the servlets discussed in this chapter,
  just go to the following URL:

                                                                                             

  h t t p : //www. c s . t r i n c o l l . edu /~ram/ j j j / s e r v l e t s                
  

  That web page contains links to both the HelloServlet and NimServlet.
  It also contains links to Web sites where you can learn more about creat-
  ing servlets. In order to create and run your own servlets, you will need
  access to a Web server that has been specially configured to run servlets.
  There are several very good free servers that support Java servlets. You
  can download one of these onto your own computer and follow the direc-
  tions on how to set it up. Links to Java servlet sites are also provided on
  our servlets page.

  Technical Terms                                                                            CHAPTER SUMMARY

  busy waiting            HyperText Transfer             post
  callback method            Protocol (HTTP)             protocol
  client                                                 router
  client/server           internet                       sandbox security
                          Internet
     protocols            Internetworking                   model
  domain name                                            scriptlet
  ethernet protocol          Protocol (IP)               server
  File Transfer Protocol  Java Server Page               servlet
                                                         Simple Mail Transfer
     (FTP)                   (JSP)
  get                     packet                            Protocol (SMTP)
                          port
                      752                                     CHAPTER 15  Sockets and Networking

                      socket        Uniform Resource          World Wide Web
                      trusted code     Locator (URL)             (WWW)

                      Summary of Important Points

                       An internet is a collection of two or more distinct networks joined by
                         routers, which have the task of translating one network's language to
                         the other's. The Internet is a network of networks that uses the Internet
                         Protocol (IP) as the translation medium.

                       A protocol is a set of rules that controls the transfer of information
                         between two computers in a network. The HyperText Transfer Pro-
                         tocol (HTTP) governs information exchange on the World Wide Web
                         (WWW). The Simple Mail Transfer Protocol controls mail service on the
                         Internet. The File Transfer Protocol (FTP) controls the transfer of files
                         between Internet computers. The Domain Name System (DNS) governs
                         the use of names on the Internet.

                       A client/server application is one that divides its task between a client,
                         which requests service, and a server, which provides service. Many In-
                         ternet applications and protocols are based on the client/server model.

                       Lower-level protocols, such as the ethernet protocol and token ring pro-
                         tocol, govern the transmission of data between computers on a single
                         network. The Internet Protocol (IP) translates between such protocols.

                       A Uniform Resource Locator (URL) is a standard way of specifying
                         addresses on the Internet. It consists of several parts separated
                         by slashes and colons: method://host:port/path/file. The
                         java.net.URL class is used to represent URLs.

                       Files of text or data (images, audio files) on the Internet or Web can be
                         downloaded using the same InputStreams and OutputStreams as
                         files located on a disk. To read or write a resource located on a network,
                         you need to connect its URL to an input or output stream.

                       The java.awt.Toolkit class contains useful methods for down-
                         loading Images into an application.

                       A socket is a two-way communication channel between two running
                         programs on a network. The java.net.Socket class can be used
                         to set up communication channels for client/server applications. The
                         server process listens at a socket for requests from a client. The client
                         process requests service from a server listening at a particular socket.
                         Once a connection exists between client and server, input and output
                         streams are used to read and write data over the socket.

SOLUTIONS TO          SOLUTION 15.1 The fully connected mesh topology requires the most cables.
SELF-STUDY EXERCISES
                      SOLUTION 15.2 The fully connected mesh topology would have the most po-
                      tential to use alternate routes if one of the host computers crashed.

                      SOLUTION 15.3 The star topology would be rendered completely useless if its
                      central hub crashed.

                      SOLUTION 15.4 Prentice Hall's Web server is located at

                                                                                                 

                      h t t p : //www. p r e n h a l l . com                                     
                      
CHAPTER 15  Solutions to Self-Study Exercises                                          753

The protocol is http. The host computer is named www. Prentice Hall's domain
name is prenhall, and it is part of the com (commercial) Internet domain.

SOLUTION 15.5
 For buying a piece of software at a bookstore, the server would be the sales

    clerk. The protocol would be to select the software from off the shelf, bring it to
    the checkout counter, give the sales clerk money, and get a receipt.
 For buying a piece of software over the phone, the server would be the tele-
    phone sales clerk. The protocol would be to select from a catalog, provide the
    sales clerk with your credit card information, and say goodbye.
 For buying a piece of software over the Internet, the server would be the
    computer that handles the transaction. The protocol would be to select the
    item from a Web-based form, provide the form with personal and payment
    information, and click on the Buy button.

SOLUTION 15.6 To play sounds along with slides in the SlideShowFrame,
you would make the following modifications to the code:

                                                                                        

p r i v a t e C l i p soundClip [ ] = new C l i p [NIMGS ] ;

private Clip currentClip = null ;                                                       


Declare an array of URLs to store the URLs of the audio files you want to play.
    Assign Clips to the array at the same time you input the images:

                                                                                        

f o r ( i n t k = 0 ; k < NIMGS ; k++) {

   url =

   new URL( " h t t p ://www. c s . t r i n c o l l . edu /~ram/ j j j / s l i d e " +

                                                              k + ". gif" );

   s l i d e [ k ] = imageIO . read ( url ) ;

   URL soundURL =

   new URL( " h t t p ://www. c s . t r i n c o l l . edu /~ram/ j j j /sound" +

                                                              k + " . au" ) ;

   AudioInputStream audio =

                   AudioSystem . getAudioInputStream ( url ) ;

   DataLine . I n f o i n f o = new DataLine . I n f o ( C l i p . c l a s s ,

                                                                          audio . getFormat ( ) ) ;

   soundClip [ k ] = ( Clip ) AudioSystem . getLine ( info ) ;

}

                                                                                        

Change the nextSlide() code to the following

                                                                                        

  public void nextSlide ( ) {                         playback            soundClip
         currentClip . stop ( ) ; // s t o p sound    // g e t n e x t      at beginning
         currentClip = soundClip [ nextImg ] ;      // s t a r t c l i p
         currentClip . setFramePosition (0);                                           
         currentImage = slide [ nextImg ] ;
         nextImg = ( nextImg + 1 ) % NIMGS ;
         repaint ();

  }

                                  754                        CHAPTER 15  Sockets and Networking

                                  Each time an image is displayed in paint(), play the corresponding sound by
                                  using the URL from the array:

                                                                                                      

                                  public     void paint ( Graphics g) {
                                         if  ( currentImage != null ) {
                                              g . drawImage ( currentImage , 1 0 , 1 0 , t h i s ) ;
                                         }
                                              currentClip . start ();

                                  }

                                                                                                      

                                  SOLUTION 15.7 The scramble service would be implemented by defining two
                                  new classes: The ScrambleServer class is a subclass of Server, and the
                                  ScrambleClient class is a subclass of Client. The ScrambleClient would
                                  implement the requestService() method and the ScrambleServer would
                                  implement the provideService() method.

                                  SOLUTION 15.8
                                   If you specify the wrong host name or port, you will get the following excep-

                                      tion: java.net.ConnectException: Connection refused.
                                   If you leave off the \n in the writeToSocket() call, nothing will go wrong

                                      because the writeToSocket() method will catch this error and add the end-
                                      of-line character to the string before sending it to the server. The server reads
                                      lines from the client, so every communication must end with \n or the protocol
                                      will break down.

EXERCISES                         EXERCISE 15.1 Explain the difference between each of the following pairs of

Note: For programming exercises,  terms:
first draw a UML class diagram
describing all classes and their  a. Stream and socket.      d. Client and server.
inheritance relationships and/or
associations.                     b. Internet and internet.  e. Ethernet and Internet.

                                  c. Domain name and port.   f. URL and domain name.

                                  EXERCISE 15.2 What is a protocol? Give one or two examples of protocols that
                                  are used on the Internet.

                                  EXERCISE 15.3 What service is managed by the HTTP protocol?

                                  EXERCISE 15.4 Give examples of client applications that use the HTTP
                                  protocol.

                                  EXERCISE 15.5 Why is it important that applets be limited in terms of their
                                  network and file system access? Describe the various networking restrictions that
                                  apply to Java applets.

                                  EXERCISE 15.6 What does the Internet Protocol do? Describe how it
                                  would be used to join an ethernet and a token ring network.

                                  EXERCISE 15.7 Describe one or two circumstances under which a Connect-
                                  Exception would be thrown.

                                  EXERCISE 15.8 Modify the SlideShowFrame so that it plays an audio file
                                  along with each slide.

                                  EXERCISE 15.9 Design and implement a Java applet that downloads a random
                                  substitution cryptogram and provides an interface that helps the user try to solve
                                  the cryptogram. The interface should enable the user to substitute an arbitrary
                                  letter for the letters in the cryptogram. The cryptogram files should be stored in
                                  the same directory as the applet itself.
CHAPTER 15  Exercises  755

EXERCISE 15.10 Design and implement a Java application that displays a ran-
dom message (or a random joke) each time the user clicks a GetMessage button.
The messages should be stored in a set of files in the same directory as the applet
itself. Each time the button is clicked, the applet should download one of the
message files.

EXERCISE 15.11 Write a client/server application of the message or joke ser-
vice described in the previous exercise. Your implementation should extend the
Server and Client classes.

EXERCISE 15.12 Write an implementation of the scramble service. Given a
word, the scramble service will return a string containing all possible permuta-
tions of the letter combinations in the word. For example, given "man," the scram-
ble service will return "amn, anm, man, mna, nam, nma." Use the Server and
Client classes in your design. (See the Self-Study Exercises for a description of
the design.)

EXERCISE 15.13 Challenge: Modify the Nim server game in this chapter so
that the client and server can negotiate the rules of the game, including how many
sticks, how many pick ups per turn, and who goes first.
756  CHAPTER 15  Sockets and Networking
Chapter 16

Data Structures: Lists,
Stacks, and Queues

OBJECTIVES

After studying this chapter, you will
 Understand the concepts of a dynamic data structure and an Abstract Data Type (ADT).
 Be able to create and use dynamic data structures such as linked lists and binary search trees.
 Understand the stack, queue, set, and map ADTs.
 Be able to use inheritance to define extensible data structures.
 Know how to use the TreeSet, TreeMap, HashSet, and HashMap library classes.
 Be able to use the Java generic type construct.

OUTLINE

16.1 Introduction
16.2 The Linked List Data Structure
16.3 Object-Oriented Design: The List Abstract Data Type (ADT)
16.4 The Stack ADT
16.5 The Queue ADT

         Special Topic: The LISP Language
16.6 From the Java Library: The Java Collections Framework and Generic Types
16.7 Using the Set and Map interfaces
16.8 The Binary Search Tree Data Structure

          Chapter Summary
          Solutions to Self-Study Exercises
          Exercises

                                              757
                      758         CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                      16.1  Introduction

                      A data structure is used to organize information that a computer can ac-
                      cess and process easily and efficiently. You are already familiar with one
                      type of data structure--arrays, which we discussed in Chapter 9. If you
                      remember, an array is an example of a data structure in which all of the
                      data are of the same type or class and in which individual elements are ac-
                      cessed by their position (index or subscript). An array is an example of a
                      static structure, because its size is fixed for the duration of the program's
                      execution. (This is a different meaning of static than the Java keyword
                      static.)

                         The Vector class from Chapter 9 is another example of a data struc-
                      ture. Like an array, individual vector elements are accessed by their posi-
                      tion. However, unlike arrays, a vector is an example of a dynamic struc-
                      ture--that is, one that can grow and shrink during a program's execution.

                         These are only two of the many data structures developed by computer
                      scientists. For more advanced problems, it is often necessary to develop
                      specialized structures to store and manipulate information. Some of these
                      structures--linked lists, stacks, queues, binary trees, hash tables--have
                      become classic objects of study in computer science.

                         This chapter describes how to implement a linked list and how to use
                      inheritance to extend the list to implement the stack and queue struc-
                      tures. Then the Java Collections Framework implementation of numerous
                      data structures in the java.util package will be described. The data
                      structure classes in this library make use of a new Java construct, called
                      generic types. Finally, the binary tree data structure that is used in the Java
                      Collections Framework will be studied briefly.

                      16.2 The Linked List Data Structure

Static vs. dynamic    As we said, a static data structure is one whose size is fixed during a
Referring to objects  program's execution--a static structure's memory is allocated at compile
                      time. By contrast, a dynamic structure is one that can grow and shrink as
                      needed. In this section, we will develop a dynamic list, which is a data
                      structure whose elements are arranged in a linear sequence. There is a
                      first element in the list, a second element, and so on. Lists are quite gen-
                      eral and, as we will discuss later, lists have a broad range of applications.
                      Depending on how elements are inserted and removed from a list, they
                      can be used for a range of specialized purposes.

                      16.2.1 Using References to Link Objects

                      As you know from earlier chapters, when you create an object using the
                      new operator you get back a reference to the object that you then can assign
                      to a reference variable. In the following example, b is a reference to a
                      JButton:

                                                                                                       

                      J B u t t o n b = new J B u t t o n ( ) ;                                        
                      
SECTION 16.2  The Linked List Data Structure                 759
                                                                      Figure 16.1: A linked list of Nodes
                     Node Data Link Reference Null reference          terminated by a null link.

                    Abby                John  Kelly

We have defined many classes that contained references to other objects:

                                                                                  

  public class      Student {                                                     
                    S t r i n g name ;
           private                                                                 Self-referential objects

  }                                                                               

                                                                                                             Node
In this example, name is a reference to a String object.                                      -data : Object
   A linked list is a list in which a collection of nodes are linked together                 -next : Node

by references from one node to the next. To make a linked list, we will de-        +setData(in o : Object) +Node(in o : Object)
fine a class of self-referential objects. A self-referential object is an object
that contains a reference to an object of the same class. The convention is                   +getData() : Object
to name these objects Nodes:                                                                  +setNext(in link : Node)
                                                                                              +getNext() : Node

                                                                                    FIGURE 16.2 The Node class.
  public class      Node {
                    S t r i n g name ;
           private  Node next ;

           private

  }


   fig-nodeuml In addition to the reference to a String object, each Node
object contains a reference to another Node object. The next variable is
often called a link because it is used to link together two Node objects. For
example, Figure 16.1 provides an illustration of a linked list of Nodes.

   By assigning references to the next variables in each Node, we can
chain together arbitrarily long lists of objects. Therefore, we will want to
add methods to our Node class that enable us to manipulate a Node's next
variable (Fig. 16-2). By assigning it a reference to another Node, we can
link two Nodes together. By retrieving the link's value, we can find the
next Node in the list.

JAVA LANGUAGE RULE Self-Referential Object. A self-referential
object is one that contains an instance variable that refers to an object of
the same class.

In addition to the link variable, each Node stores some data. In this exam-       Linking objects together
ple, the data is a single String. But there's no real limit to the amount
and type of data that can be stored in a linked list. Therefore, in addition
to methods that manipulate a Node's link, we will also want methods to
                         760        CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                         manipulate its data. These points suggest the following basic design for a
                         Node:

                                                                                                        

                         public c l a s s Node {
                                  private Object data ;
                                  p r i v a t e Node next ;

                              public Node ( O b j e c t o b j ) ;   // C o n s t r u c t o r

                              public void setData ( Object obj ) ;  // Data a c c e s s
                              public Object getData ( ) ;

                              p u b li c void s e t N e x t ( Node l i n k ) ; // L i n k a c c e s s

                              public Node getNext ( ) ;

                         } // Node

                                                                                                        

Divide and conquer       Note that we have defined the Node's data in the most general possible
Accessing a list's data  way: As a reference to an Object. Because the Object class is the root of
                         Java's entire class hierarchy, an Object can encompass any kind of data.
                         By using Java's wrapper classes, such as Integer and Double, a Node's
                         data can even include primitive data.

                            The important point is that regardless of its type of data, a Node will
                         have data access methods and link access methods. The data access meth-
                         ods differ, depending on the type of data, but the link access methods will
                         generally be the same.

                         JAVA EFFECTIVE DESIGN Link Versus Data. Making a clear
                         distinction between an object's data and those elements used to
                         manipulate the object is an example of the divide-and-conquer
                         principle.

                         SELF-STUDY EXERCISES

                         EXERCISE 16.1 Write a statement to create a new Node whose data
                         consist of the String "Hello."

                         EXERCISE 16.2 Write a statement to create a new Node whose data
                         consist of the Student named "William." Assume that the Student class
                         has a constructor with a String parameter for the student's name.

                         16.2.2 Example: The Dynamic Phone List

                         Let's define a PhoneListNode class that can be used to implement a
                         phone list (Fig. 16.3). This definition will be a straightforward specializa-
                         tion of the generic Node list defined in the previous section. Each element
                         of the phone list will consist of a person's name and phone number. These
                         will be the node's data and can be stored in two String variables. To
                         access these data, we will provide a constructor and a basic set of access
                         methods. Thus, we have the definition shown in Figure 16.4.
SECTION 16.2  The Linked List Data Structure                               761
                                                                                    Figure 16.3: Design of the
                                                PhoneListNode                       PhoneListNode class.
                       -name : String
                       -phone : String                                        
                       -next : PhoneListNode
                       +PhoneListNode(in name : String, in phone : String)    
                       +setData(in name : String, in phone : String)
                       +getName() : String
                       +getData() : String
                       +toString() : String
                       +setNext(in next : PhoneListNode)
                       +getNext() : PhoneListNode

                    PhoneListNode       {
                    S t r i n g name ;  next ;
  public class      String phone ;
           private  PhoneListNode
           private
           private

public PhoneListNode ( String s1 , String s2 ) {
       name = s1 ;
       phone = s2 ;
       next = null ;

} // P h o n e L i s t N o d e ( )

public void setData ( String s1 , String s2 ) {
       name = s1 ;
       phone = s2 ;

} // s e t D a t a ( )

public S t r i n g getName ( ) {
       r e t u r n name ;

} // getName ( )

public String getData () {
       r e t u r n name + " " + phone ;

} // g e t D a t a ( )

public String toString () {
       r e t u r n name + " " + phone ;

} // t o S t r i n g ( )

public void setNext ( PhoneListNode nextPtr ) {
       next = nextPtr ;

} // s e t N e x t ( )

           public PhoneListNode getNext ( ) {
                  return next ;

           } // g e t N e x t ( )
  } // P h o n e L i s t N o d e


                       Figure 16.4: The PhoneListNode class.
                                           762  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                                              The constructor and data access methods should be familiar to you.
                                           Note that the constructor sets the initial value of next to null, which
                                           means that it refers to no object.

                                           JAVA DEBUGGING TIP Null Reference. A common programming
                                           error is the attempt to use a null reference to refer to an object. This
                                           usually means the reference has not been successfully initialized.

Manipulating a list's nodes                Let's discuss the details of the link access methods--the setNext() and
                                           getNext() methods--which are also simple to implement. Because this
  Roger M                                  is a PhoneListNode, these methods take PhoneListNode as a parame-
  090-997-2918                             ter and return type, respectively. Given a reference to a PhoneListNode,
                                           the setNext() method assigns it to next. The getNext() method
                 Jane M                    simply returns the value of its next link.
                 090-997-1987
                                              Let's now see how we would use these methods to construct a list. The
                             Stacy K       following statements create three nodes:
                             090-997-9188
                                                                                                                        
Figure 16.5: The phone list: a
linked list of nodes, each of which        PhoneListNode node1 =
contains a person's name and
phone number.                                   new PhoneListNode ( " Roger M" , "090-997-2918" ) ;

                                           PhoneListNode node2 =

                                                new PhoneListNode ( " J a n e M" , "090-997-1987" ) ;

                                           PhoneListNode node3 =

                                                new PhoneListNode ( " S t a c y K" , "090-997-9188" ) ;                 

                                           The next two statements chain the nodes together into the list shown in
                                           Figure 16.5:

                                                                                                                        

                                           node1 . setNext ( node2 ) ;

                                           node2 . setNext ( node3 ) ;
                                                                                                                        

                                           If we wanted to add a fourth node to the end of this list, we could use the
                                           following statements:

                                                                                                                        

                                           PhoneListNode node4 =

                                                new PhoneListNode ( " gary g" , "201-119-8765" ) ;

                                           node3 . setNext ( node4 ) ;                                                  
                                           

                                           Although this example illustrates the basic technique for inserting nodes
                                           at the end of the list, it depends too much on our knowledge of the list.
                                           In order to be truly useful we will have to develop a more general set of
                                           methods to create and manipulate a list of nodes. As we will see, a better
                                           design would be able to find the end of the list without knowing anything
                                           about the list's data.

                                           JAVA EFFECTIVE DESIGN Generality. In a well-designed list data
                                           structure, you should be able to manipulate its elements without
                                           knowing anything about its data.
SECTION 16.2  The Linked List Data Structure                          763

SELF-STUDY EXERCISE                                                                                 PhoneList
                                                                                 -head : PhoneListNode
EXERCISE 16.3 Suppose you know that nodeptr is a reference to the                +PhoneList()
last element of a linked list of PhoneListNodes. Create a new element            +isEmpty() : boolean
for "Bill C" with phone number "111-202-3331" and link it into the end of        +insert(in node : PhoneListNode)
the list.                                                                        +getPhone(in name : String) : String
                                                                                 +remove(in name : String)
16.2.3 Manipulating the Phone List
                                                                               FIGURE 16.6 The PhoneList class
In addition to the Nodes that make a list, we must define a class containing   has a reference to the first node of the
methods to manipulate the list. This class will include the insert, access,    list (head) and methods to insert,
and remove methods. It must also contain a reference to the list itself.       remove, and look up information.
This leads to the basic design shown in Figure 16.6. Because this is a list
of PhoneListNodes, we need a PhoneListNode reference to point to               An empty list
fig-phonelistclass the list, which is the purpose of the head variable.

   A preliminary coding of the PhoneList class is shown in Figure 16.7.
As you can see there, when a new PhoneList instance is constructed,
head is initialized to null, meaning the list is initially empty. Since
we will frequently want to test whether the list is empty, we define the
boolean isEmpty() method for that purpose. As you can see, its defi-
nition says that a list is empty when the reference to the head of this list
is null.

  JAVA PROGRAMMING TIP The null Reference. A null reference
  is useful for defining limit cases, such as an empty list or an
  uninstantiated object.

                                                                       

public class PhoneList {
       private PhoneListNode head ;

  public PhoneList () {

     head = null ;                  // S t a r t w it h empty l i s t

  }

  public boolean isEmpty ( ) { // D e f i n e s an empty l i s t

     r e t u r n head == n u l l ;

  }

  public void i n s e r t ( PhoneListNode node ) { }

  public S t r i n g getPhone ( S t r i n g name ) { }

  public S t r i n g remove ( S t r i n g name ) { }

  public void print ( ) { }

} // P h o n e L i s t

                                                                       

     Figure 16.7: A preliminary version of the PhoneList class.

Inserting Nodes into a List

The insert() method will have the task of inserting new PhoneList-
Nodes into the list. There are a number of ways to do this. The node could
be inserted at the beginning or at the end of the list, or in alphabetical
order, or possibly in other ways. As we'll see, it is easiest to insert a new
node at the head of the list. But for this example, let's develop a method
that inserts the node at the end of the list.
                                                 764          CHAPTER 16  Data Structures: Lists, Stacks, and Queues
Figure 16.8: Two cases. (a) The
list is empty before the insertion,                           Before insertion   After insertion
which takes place at head. (b) The
list is not empty, so the insertion                            Head              Head  Newnode
takes place at the end of the list.                                                    529-8109

                                                                          (a) Insertion into empty list

                                                         Head              Head    Abby
                                                                                 529-8109
                                                                 Abby
                                                               529-8109                    Gary
                                                                                         529-5112
                                                                         Gary
                                                                       529-5112                  Newnode
                                                                                                 529-0011

                                                                          (b) Insertion into existing list

                      There are two cases we need to worry about for this algorithm. First, if                                      Insertion a
                   the list is empty, we can insert the node by simply setting head to point
                   to the node [Figure 16.8(a)]. Second, if the list is not empty, we must move
                   through, or traverse, the links of the list until we find the last node and
                   insert the new node after it [Figure 16.8(b)]. In this case, we want to set
                   the next variable of the last node to point to the new node. This gives us
                   the following algorithm:

                                                                                                                                    

                   public void i n s e r t ( PhoneListNode newNode ) {

                                                      if ( isEmpty ( ) )

                                                      head = newNode ;           // I n s e r t a t head o f l i s t

                                                      else {

                                                      PhoneListNode current = head ; // S t a r t t r a v e r s a l a t h e a d

                                                      while ( current . getNext ( ) != null ) // W h i l e n o t l a s t node

                                                         current = current . getNext ( ) ; // go to n e x t node

                                                         c u r r e n t . s e t N e x t ( newNode ) ; // Do t h e i n s e r t i o n

                                                      }

                   } // i n s e r t ( )

                                                                                                                                    

Traversing a list  Recall that when nodes are linked, their next variables are non-null.
                   So when a node's next variable is null, that indicates the end of the
                   list--there's no next node. Thus, our algorithm begins by checking if
                   the list is empty. If so, we assign head the reference to newNode, the
                   PhoneListNode that's being inserted.

                      If the list is not empty, then we need to find the last node. In order to
                   traverse the list, we will need a temporary variable, current, which will
SECTION 16.2  The Linked List Data Structure                                    765

always point to the current node. It's important to understand the while
loop used here:

                                                                                      
                                                                                      
  PhoneListNode current = head ;              // I n i t i a l i z e r
  while ( current . getNext ( ) != null )     // E n t r y c o n d i t i o n           Loop-exit condition

           current = current . getNext ( ) ;    // U p d a t e r                       Figure 16.9: The temporary vari-
                                                                                       able current is used to traverse
                                                                                       the list to find its end.
The loop variable, current, is initialized by setting it to point to the head
of the list. The entry condition tests whether the next link, leading out
of current, is null (Fig. 16.9). That is, when the link coming out of a
node is null, then that node is the last node in the list [Figure 16.9(c)].
Inside the while loop, the update expression simply assigns the next node
to current. In that way, current will point to each successive node
until the last node is found. It's very important that the loop exits when
current.getNext() is null--that is, when the next pointer of the cur-
rent node is null. That way current is pointing to the last node and can
be used to set its next variable to the node being inserted [Figure 16.9(d)].
Thus, after the loop is exited, current still points to the last node. At that
point, the setNext() method is used to link newNode into the list as the
new last node.

      Current

                                              (a) Start at the head of the list

Head

               Current

                                              (b) Traverse by following the links

Head

                        Current

                                              (c) Find the end of the list

Head

                        Current

                                 New (d) Insert the new node

Head

JAVA DEBUGGING TIP List Traversal. A common error in
designing list-traversal algorithms is an erroneous loop-entry or
loop-exit condition. One way to avoid this error is to hand trace your
algorithm to make sure your code is correct.
                766  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                Printing the Nodes of a List

                The print() method also uses a traversal strategy to print the data from         List traver
                each node of the list. Here again it is necessary to test whether the list
                is empty. If so, we must print an error message. (This would be a good
                place to throw a programmer-defined exception, such as an EmptyList-
                Exception.) If the list is not empty, then we use a temporary variable to
                traverse the list, printing each node's data along the way:

                                                                                                 

                public void print ( ) {

                     if ( isEmpty ( ) )

                     System . out . p r i n t l n ( "Phone l i s t i s empty" ) ;

                     PhoneListNode current = head ; // S t a r t t r a v e r s a l a t h e a d

                     while ( current != null ) {        // While n o t end o f l i s t

                     System . out . println ( current . toString ( ) ) ; // p r i n t d a t a

                     current = current . getNext ( ) ;  //

                go to next node

                   }

                } // p r i n t ( )

                                                                                                 

                Note the differences between this while loop and the one used in the
                insert() method. In this case, we exit the loop when current becomes
                null; there's no action to be taken after the loop is exited. The print-
                ing takes place within the loop. Thus, in this case, the entry condition,
                (current != null), signifies that the task has been completed.

                JAVA PROGRAMMING TIP Terminating a Traversal. In designing
                list-traversal algorithms where the reference, p, points to the nodes in
                the list, if you need to refer to the last node in the list after the traversal
                loop exits, then your exit condition should be p.getNext() ==
                null. If you have finished processing the nodes when the loop exits,
                your exit condition should be p == null.

List traversal  Looking up a Node in a List

                Because the record associated with a person can be located anywhere in
                the list, the traversal strategy must also be used to look up someone's
                phone number in the PhoneList. Here again we start at the head of the
                list and traverse through the next links until we find the node containing
                the desired phone number. This method takes the name of the person as a
                parameter. There are three cases to worry about: (1) The list is empty; (2)
                the normal case where the person named is found in the list; and (3) the
SECTION 16.2  The Linked List Data Structure                                           767

person named is not in the list. Because the method returns a String, we
can return error messages in the first and third cases:

                                                                                             

  public S t r i n g getPhone ( S t r i n g name ) {                                         
                                                                                              Compound exit condition
  if ( isEmpty ( ) )                   // Case 1 : Empty l i s t

  return "Phone l i s t i s empty" ;

  else {

  PhoneListNode current = head ;

  while ( ( c u r r e n t . getNext ( ) ! = n u l l ) &&

                            ( ! c u r r e n t . getName ( ) . e q u a l s ( name ) ) )

  current = current . getNext ( ) ;

  i f ( c u r r e n t . getName ( ) . e q u a l s ( name ) )

          return current . getData ( ) ; // Case 2 : Found name

  else

  // C a s e 3 : No s u c h p e r s o n

                r e t u r n ( " Sorry . No e n t r y f o r " + name ) ;
       }

  } // g e t P h o n e ( )


Note the while loop in this case. As in the insert() method, when the
loop exits, we need a reference to the current node so that we can print
its phone number [current.getData()]. But here there are three ways
to exit the loop: (1) We reach the end of the list without finding the named
person; (2) we find the named person in the interior of the list; or (3) we
find the named person in the last node of the list. In any case, it is nec-
essary to test whether the name was found or not after the loop is exited.
Then appropriate action can be taken.

SELF-STUDY EXERCISE

EXERCISE 16.4 What if the exit condition for the while loop in
getPhone() were stated as

                                                                                        

(( current . getNext () != null ) | |

  ( ! c u r r e n t . getName ( ) . e q u a l s ( name ) ) )                            

Removing a Node from a List                                                                  Node-removal algorithm

By far the most difficult task is that of removing a node from a list. In
the PhoneList we use the person's name to identify the node, and we
return a String that can be used to report either success or failure. There
are four cases to worry about in designing this algorithm: (1) The list is
empty, (2) the first node is being removed, (3) some other node is being
removed, and (4) the named person is not in the list. The same traversal
strategy we used in getPhone() is used here, with the same basic while
loop for cases 3 and 4.

   As Figure 16.10 shows, the first two cases are easily handled. If the list is
empty, we just return an error message. We use current as the traversal
variable. If the named node is the first node, we simply need to set head
to current.getNext(), which has the effect of making head point to
the second node in the list [Figure 16.11(a)]. Once the node is cut out from
                                   768       CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                                                                                                                               

                  p u b l i c S t r i n g remove ( S t r i n g name ) { // R e m o v e a n e n t r y b y     name
                                                                                                             list
                    if ( isEmpty ( ) )                                      // Case 1 : empty
                                                                                                             first
                       return "Phone l i s t i s empty" ;

                    PhoneListNode current = head ;

                    PhoneListNode previous = null ;

                    i f ( c u r r e n t . getName ( ) . e q u a l s ( name ) ) { // C a s e 2 : r e m o v e         node

                       head = current . getNext ( ) ;

                       r e t u r n "Removed " + c u r r e n t . t o S t r i n g ( ) ;

                    }

                    while ( ( c u r r e n t . getNext ( ) ! = n u l l ) &&

                                                       ( ! c u r r e n t . getName ( ) . e q u a l s ( name ) ) ) {

                       previous = current ;

                       current = current . getNext ( ) ;

                    }

                    i f ( c u r r e n t . getName ( ) . e q u a l s ( name ) ) { // C a s e 3 : r e m o v e n a m e d n o d e

                       previous . setNext ( current . getNext ( ) ) ;

                       r e t u r n "Removed " + c u r r e n t . t o S t r i n g ( ) ;

                    } else

                       r e t u r n ( " S o r r y . No e n t r y f o r " + name ) ; // C a s e 4 : n o d e n o t f o u n d

                  } // remove ( )

                                                                                                                               

                                             Figure 16.10: The remove() method.

                                   the chain of links, there will be no further reference to it. In this case, Java
                                   will recapture the memory it uses when it does garbage collection.

                                   JAVA LANGUAGE RULE Garbage Collection. Java's garbage
                                   collector handles the disposal of unused objects automatically. This
                                   helps to simplify linked-list applications. In languages such as C++,
                                   the programmer would have to dispose of the memory occupied by the
                                   deleted node.

Tandem traversal                   In order to remove some other node besides the first, two traversal vari-
                                   ables are needed: previous and current. They proceed together down
                                   the list, with previous always pointing to the node just before the
                                   current node. The reason, of course, is that to remove the current
                                   node, you need to adjust the link pointing to it contained in the previous
                                   node [Figure 16.11(b)]. That is, the new value of previous.next will
                                   be the current value of current.next. We use the getNext() and
                                   setNext() methods to effect this change:

                                                                                                                               

                                        previous . setNext ( current . getNext ( ) ) ;                                         
                                   
SECTION 16.2  The Linked List Data Structure                        769
                                                                             Figure 16.11: Removing different
                  Head                                                       nodes from a linked list.

Head                                   Removed nodes
              (a) Removing first node  will be garbage

                                           collected

Previous Current

Head
       Previous Current

Head
             (b) Removing other node

Testing the List                                                               Designing test data

In developing list-processing programs, it is important to design good test
data. As we have seen, both the insertion and removal operations involve
several distinct cases. Proper testing of these methods ideally would test
every possible case. The main() program in Figure 16.12 illustrates the
kinds of tests that should be performed. This method could be incorpo-
rated directly into the PhoneList class, or it could be made part of a
separate class.
Of course, there are often so many combinations of list operations that ex-
haustive testing might not be feasible. At the very least you should design
test data that test each of the different conditions identified in your algo-
rithms. For example, in testing removals from a list, you should test all
four cases that we discussed. In testing insertions or lookups, you should
test all three cases that we identified.

JAVA EFFECTIVE DESIGN Test Data. Test data for validating
list-processing algorithms should (at least) test each of the cases
identified in each of the removal and insertion methods.

SELF-STUDY EXERCISES

EXERCISE 16.5 Trace through the main() method line by line and
predict its output.

EXERCISE 16.6 Design a test of PhoneList that shows that new ele-
ments can be inserted into a list after some or all of its previous nodes
have been removed.
770            CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                                                                                             

public s t a t i c void main ( S t r i n g argv [ ] ) {

                                       // C r e a t e l i s t and i n s e r t nodes

  PhoneList l i s t = new PhoneList ( ) ;
  l i s t . i n s e r t ( new PhoneListNode ( " Roger M" , " 997 -0020 " ) ) ;
  l i s t . i n s e r t ( new PhoneListNode ( " Roger W" , " 997 -0086 " ) ) ;
  l i s t . i n s e r t ( new PhoneListNode ( " Rich P" , " 997 -0010 " ) ) ;
  l i s t . i n s e r t ( new PhoneListNode ( " J a n e M" , " 997 -2101 " ) ) ;
  l i s t . i n s e r t ( new PhoneListNode ( " S t a c y K" , " 997 -2517 " ) ) ;

                                       // T e s t w h e t h e r i n s e r t i o n s  worked

  System . out . p r i n t l n ( "Phone Directory " ) ;
  list . print ();

                                       // T e s t w h e t h e r l o o k u p s work

  System . out . p r i n t l n ( " Looking up numbers by name" ) ;
  System . out . p r i n t l n ( l i s t . getPhone ( " Roger M" ) ) ;
  System . out . println ( l i s t . getPhone ( "Rich P" ) ) ;
  System . out . p r i n t l n ( l i s t . getPhone ( " S t a c y K" ) ) ;
  System . out . p r i n t l n ( l i s t . getPhone ( "Mary P" ) ) ;
  System . out . p r i n t l n ( l i s t . remove ( "Rich P" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

     // T e s t removals , p r i n t i n g l i s t a f t e r e a c h r e m o v a l

  System . out . p r i n t l n ( l i s t . remove ( " Roger M" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

  System . out . p r i n t l n ( l i s t . remove ( " S t a c y K" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

  System . out . p r i n t l n ( l i s t . remove ( " J a n e M" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

  System . out . p r i n t l n ( l i s t . remove ( " J a n e M" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

  System . out . p r i n t l n ( l i s t . remove ( " Roger W" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

  System . out . p r i n t l n ( l i s t . remove ( " Roger W" ) ) ;

  System . out . p r i n t l n ( "Phone Directory " ) ;

  list . print ();

} // main ( )

                                                                                             

Figure 16.12: A main() method containing a set of tests for the
PhoneList class.

16.3 OBJECT-ORIENTED DESIGN:
        The List Abstract Data Type (ADT)

The PhoneList example from the previous section illustrates the basic
concepts of the linked list. Keep in mind that there are other implemen-
tations that could have been described. For example, some linked lists
use a reference to both the first and last elements of the list. Some lists
SECTION 3  OOD: The List ADT  771

use nodes that have two pointers, one to the next node and one to the            A generic list structure
previous node. This enables traversals in two directions--front to back          Information hiding
and back to front--as well as making it easier to remove nodes from the          Design specifications
list. The example we showed was intended mainly to illustrate the basic
techniques involved in list processing.

   Also, the PhoneList example is limited to a particular type of data--
namely, a PhoneListNode. Let's develop a more general linked list class
and a more general node class that can be used to store and process lists
of any kind of data.

   An Abstract Data Type (ADT) involves two components: the data that
are being stored and manipulated and the methods and operations that
can be performed on those data. For example, an int is an ADT. The
data are the integers ranging from some MININT to some MAXINT. The
operations are the various integer operations: addition, subtraction, mul-
tiplication, and division. These operations prescribe the ways that ints
can be used. There are no other ways to manipulate integers.

   Moreover, in designing an ADT, it's important to hide the implemen-
tation of the operations from the users of the operations. Thus, our pro-
grams have used all of these integer operations on ints, but we have no
real idea how they are implemented--that is, what exact algorithm they
use.

   Objects can be designed as ADTs, because we can easily distinguish
an object's use from its implementation. Thus, the private parts of an
object--its instance variables and private methods--are hidden from the
user while the object's interface--its public methods--are available. As
with the integer operators, the object's public methods prescribe just how
the object can be used.

   So let's design a list ADT. We want it to be able to store any kind of data,
and we want to prescribe the operations that can be performed on those
data--the insert, delete, and so on. Also, we want to design the ADT so
that it can be extended to create more specialized kinds of lists.

The Node Class

 JAVA EFFECTIVE DESIGN Generalizing a Type. An effective                                                 Node
 strategy for designing a list abstract data type is to start with a specific              -data : Object
 list and generalize it. The result should be a more abstract version of                   -next : Node
 the original list.                                                                        +Node(in o : Object)
                                                                                           +setData(in o : Object)
Our approach will be to generalize the classes we created in the Phone-                    +getData() : Object
List example. Thus, the PhoneListNode will become a generic Node                           +setNext(in link : Node)
that can store any kind of data (Fig. 16-13). Some of the changes are                      +getNext() : Node
merely name changes. Thus, wherever we had PhoneListNode, we now                           +toString() : String
have just Node. The link access methods have not changed significantly.
What has changed is that instead of instance variables for the name, phone       Figure 16.13: The Node class
number, and so on, we now have just a single data reference to an Object.        is a generalization of the
This is as general as you can get, because, as we pointed out earlier, data      PhoneListNode class.
can refer to any object, even to primitive data.

   The implementation of the Node class is shown in Figure 16.14. Note
that the data access methods, getData() and setData(), use references
                                       772        CHAPTER 16          Data Structures: Lists, Stacks, and Queues
                                                                                                                             
                                       
                                                                                   // S t o r e s any kin d o f d a t a
                                       public c l a s s Node {
                                            private Object data ;
                                            p r i v a t e Node next ;

                                            p u b l i c Node ( O b j e c t o b j ) { // C o n s t r u c t o r

                                               data = obj ;

                                               next = null ;

                                            }                                // Data a c c e s s methods

                                            public void setData ( Object obj ) {

                                               data = obj ;

                                            }

                                            public Object getData () {

                                               return data ;

                                            }

                                            public String toString () {

                                               return data . toString ( ) ;

                                            }                                // Lin k a c c e s s methods

                                            public void s e t N e x t ( Node n e x t P t r ) {

                                               next = nextPtr ;

                                            }

                                            public Node getNext ( ) {

                                               return next ;

                                            }

                                       } // Node

                                                                                                               

                                       Figure 16.14: The Node class is a more abstract version of the Phone-
                                       ListNode class.

                         List          to Object for their parameter and return type. Note also how we've de-
                                       fined the toString() method. It just invokes data.toString(). Be-
       -head : Node                    cause toString() is defined in Object, every type of data will have this
       +List()                         method. And because toString() is frequently overridden in defining
       +isEmpty() : boolean            new objects, it is useful here.
       +print()
       +insertAtFront(in o : Object)   The List Class
       +insertAtRear(in o : Object)
       +removeFirst() : Object         Let's now generalize the PhoneList class (Fig. 16-15). The List class
       +removeLast() : Object          will still contain a reference to the head of the list, which will now be a
                                       list of Nodes. It will still define its constructor, its fig-listuml isEmpty()
FIGURE 16.15 The List class            method, and its print() method in the same way as in the PhoneList.
contains a pointer to the head of the
list and public methods to insert and     However, in designing a generic List class, we want to design some
remove objects from both the front     new methods, particularly because we want to use this class as the basis
and rear of the list.                  for more specialized lists. The PhoneList.insert() method was used
                                       to insert nodes at the end of a list. In addition to this method, let's design a
                                       method that inserts at the head of the list. Also, PhoneList had a method
                                       to remove nodes by name. However, now that we have generalized our
                                       data, we don't know if the list's Objects have a name field, so we'll scrap
                                       this method in favor of two new methods that remove a node from the
                                       beginning or end of the list, respectively.

                                          We already know the basic strategies for implementing these new
                                       methods, which are shown in the definition in Figure 16.16. We have re-
                                       named the insertAtRear() method, which otherwise is very similar
SECTION 3  OOD: The List ADT                                                       773

                                                                                                                  

public class List {

  p r i v a t e Node head ;

  public L i s t ( ) { head = null ; }

  public boolean isEmpty ( ) { r e t u r n head == n u l l ; }

  public void print ( ) {

     if ( isEmpty ( ) )

        System . out . p r i n t l n ( " L i s t i s empty" ) ;

     Node c u r r e n t = head ;

     while ( current != null ) {

        System . out . println ( current . toString ( ) ) ;

        current = current . getNext ( ) ;

     }

  } // p r i n t ( )

  public void insertAtFront ( Object obj ) {

     Node newnode = new Node ( o b j ) ;

     newnode . setNext ( head ) ;

     head = newnode ;

  }

  public void insertAtRear ( Object obj ) {

     if ( isEmpty ( ) )

        head = new Node ( o b j ) ;

     else {

        Node c u r r e n t = head ;             // S t a r t a t head o f l i s t

        while ( current . getNext ( ) != null ) // F i n d t h e end o f t h e l i s t

           current = current . getNext ( ) ;

           c u r r e n t . s e t N e x t ( new Node ( o b j ) ) ; // C r e a t e a n d i n s e r t n e w N o d e

        }

  } // i n s e r t A t R e a r ( )

  public Object removeFirst () {

     if ( isEmpty ( ) )                    // Empty L i s t

           return null ;

     Node f i r s t = head ;

     head = head . getNext ( ) ;

     return f i r s t . getData ( ) ;

  } // r e m o v e F i r s t ( )

  public Object removeLast ( ) {

     i f ( isEmpty ( ) ) // empty l i s t

           return null ;

     Node c u r r e n t = head ;

     i f ( c u r r e n t . getNext ( ) == n u l l ) { // S i n g l e t o n l i s t

           head = null ;

           return current . getData ( ) ;

     }

     Node previous = n u l l ;                // A l l o t h e r c a s e s

     while ( current . getNext ( ) != null ) {

        previous = current ;

        current = current . getNext ( ) ;

     }

     previous . setNext ( null ) ;

     return current . getData ( ) ;

  } // r e m o v e L a s t ( )

} // L i s t

                                                                                                                  

                      Figure 16.16: The List ADT.
                     774  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                     to the PhoneList.insert() method. The key change is that now its
                     parameter must be an Object, because we want to be able to insert any
                     kind of object into our list. At the same time, our list consists of Nodes, so
                     we have to use the Object to create a Node in our insert methods:

                                                                                                        

                     head = new Node ( o b j ) ;                                                        
                     

                     Recall that the Node constructor takes an Object argument and simply
                     assigns it to the data reference. So when we insert an Object into the list,
                     we make a new Node and set its data variable to point to that Object.
                     Note that we check whether the list is empty before traversing to the last
                     node.

                        The new insertAtFront() method (Fig. 16.16) is simple to imple-
                     ment, since no traversal of the list is necessary. You just need to create
                     a new Node with the Object as its data element and then link the new
                     node into the head of the list:

                                                                                                        

                     Node newnode = new Node ( o b j ) ;

                     newnode . setNext ( head ) ;

                     head = newnode ;                                                                   
                     

                     See Figure 16.8a for a graphical representation of this type of insertion.
                        The new removeFirst() method is also quite simple to implement.

                     In this case, you want to return a reference to the Object that's stored in
                     the first node, but you need to adjust head so that it points to whatever the
                     previous head.next was pointing to before the removal. This requires
                     the use of a temporary variable, as shown in the method.

                        The new removeLast() method is a bit more complicated. It handles
                     three cases: (1) The empty list case, (2) the single node list, and (3) all other
                     lists. If the list is empty, it returns null. Obviously, it shouldn't even be
                     called in this case. In designing subclasses of List we will first invoke
                     isEmpty() before attempting to remove a node.

                        If the list contains a single node, we treat it as a special case and set
                     head to null, thus resulting in an empty list. In the typical case, case
                     3, we traverse the list to find the last node, again using the strategy of
                     maintaining both a previous and a current pointer. When we find
                     the last node, we must adjust previous.next so that it no longer points
                     to it.

                     Testing the List ADT

Heterogeneous lists  Testing the list ADT follows the same strategy used in the PhoneList
                     example. However, one of the things we want to test is that we can indeed
                     create lists of heterogeneous types--lists that include Integers mixed
                     with Floats, mixed with other types of objects. The main() method in
                     Figure 16.17 illustrates this feature.
SECTION 3  OOD: The List ADT                                               775

                                                                                             

public s t a t i c void main ( S t r i n g argv [ ] ) {

                  // C r e a t e l i s t and i n s e r t h e t e r o g e n e o u s nodes

  L i s t l i s t = new L i s t ( ) ;
  l i s t . i n s e r t A t F r o n t (new PhoneRecord ( " Roger M" , " 997 -0020 " ) ) ;
  l i s t . i n s e r t A t F r o n t (new I n t e g e r ( 8 6 4 7 ) ) ;
  l i s t . i n s e r t A t F r o n t (new S t r i n g ( " Hello , World ! " ) ) ;
  l i s t . i n s e r t A t R e a r (new PhoneRecord ( " J a n e M" , " 997 -2101 " ) ) ;
  l i s t . i n s e r t A t R e a r (new PhoneRecord ( " S t a c y K" , " 997 -2517 " ) ) ;

  // P r i n t t h e l i s t

  System . out . println ( "Generic List " ) ;

  list . print ();

  // Remove o b j e c t s and p r i n t r e s u l t i n g l i s t

  Object o;

  o = l i s t . removeLast ( ) ;

  System . out . p r i n t l n ( " Removed " + o . t o S t r i n g ( ) ) ;

  System . out . println ( "Generic List : " ) ;

  list . print ();

  o = l i s t . removeLast ( ) ;

  System . out . p r i n t l n ( " Removed " + o . t o S t r i n g ( ) ) ;

  System . out . println ( "Generic List : " ) ;

  list . print ();

  o = l i s t . removeFirst ( ) ;

  System . out . p r i n t l n ( " Removed " +o . t o S t r i n g ( ) ) ;

  System . out . println ( "Generic List : " ) ;

  list . print ();

} // main ( )

                                                                                             

  Figure 16.17: A series of tests for the List ADT.

  JAVA EFFECTIVE DESIGN The List ADT. One advantage of
  defining a List ADT is that it lets you avoid having to write the
  relatively difficult list-processing algorithms each time you need a list
  structure.

   The list we create here involves various types of data. The Phone-                        Figure 16.18: The PhoneRecord
Record class is a scaled-down version of the PhoneListNode we used in                        class stores data for a phone direc-
the previous example (Fig. 16.18). Its definition is shown in Figure 16.19.                  tory.
Note how we use an Object reference to remove objects from the list in
main(). We use the Object.toString() method to display the object
that was removed.

                                                    PhoneRecord

                          -name : String
                          -phone : String
                          +PhoneRecord(in name : String, in phone : String)
                          +toString() : String
                          +getName() : String
                          +getPhone() : String
                    776     CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                                                                         

                    public class PhoneRecord {
                             p r i v a t e S t r i n g name ;
                             private String phone ;

                         public PhoneRecord ( String s1 , String s2 ) {

                            name = s1 ;

                            phone = s2 ;

                         }

                         public String toString () {

                            r e t u r n name + " " + phone ;

                         }

                         public S t r i n g getName ( ) {

                            r e t u r n name ;

                         }

                         public String getPhone ( ) {

                            return phone ;

                         }

                    } // P ho ne Re co rd

                                                                         

                            Figure 16.19: A PhoneRecord class.

                    SELF-STUDY EXERCISES

                    EXERCISE 16.7 Trace through the main() method line by line and
                    predict its output.

                    EXERCISE 16.8 Design a test of the List program that shows that it is
                    possible to insert new elements into a list after some or all of its previous
                    nodes have been removed.

Stack applications  16.4 The Stack ADT

                    A stack is a special type of list that allows insertions and removals to be
                    performed only to the front of the list. Therefore, it enforces last-in-first-
                    out (LIFO) behavior on the list. Think of a stack of dishes at the salad
                    bar. When you put a dish on the stack, it goes onto the top of the stack.
                    When you remove a dish from the stack, it comes from the top of the stack
                    (Fig. 16.20).

                       The stack operations are conventionally called push, for insert, and
                    pop, for remove, respectively. Thus, the stack ADT stores a list of data
                    and supports the following operations:

                     Push--inserts an object onto the top of the stack.
                     Pop--removes the top object from the stack.
                     Empty--returns true if the stack is empty.
                     Peek--retrieves the top object without removing it.

                       Stacks are useful for a number of important computing tasks. For ex-
                    ample, during program execution, method call and return happens in a
                    LIFO fashion. The last method called is the first method exited. There-
                    fore, a stack structure known as the run-time stack is used to manage
                    method calls during program execution. When a method is called, an
SECTION 16.4  The Stack ADT                                       777
                                                                           Figure 16.20: A stack is a list that
                Top          Top   New                                     permits insertions and removals
                                                                           only at its top.

     In a stack, insertions
     and deletions occur

            at the top

activation block is created, which includes the method's parameters, lo-                              List
cal variables, and return address. The activation block is pushed onto               # head : Node
the stack. When that method call returns, the return address is retrieved           +List()
from the activation block and the whole block is popped off the stack.               # isEmpty() : boolean
The Exception.printStackTrace() method uses the run-time stack                       # print()
to print a trace of the method calls that led to an exception.                       # insertAtFront(in o : Object)
                                                                                     # insertAtRear(in o : Object)
16.4.1 The Stack Class                                                               # removeFirst() : Object
                                                                                     # removeLast() : Object
Given our general definition of List and Node, it is practically trivial to
define the stack ADT as a subclass of List (Fig. 16-21). As a subclass of                            Stack
List, a Stack will inherit all of the public and protected methods de-
fined in List. Therefore, we can simply use the insertAtFront() and                       +Stack()
removeFirst() methods for the push and pop operations, respectively                       +push(in o : Object)
(Fig. 16.22). Because the isEmpty() method is defined in List, there's                    +pop() : Object
no need to override it in Stack. In effect, the push() and pop() methods                  +peek() : Object

                                                                            Figure 16.21: As a subclass of
                                                                             List, a Stack inherits all of
public class Stack extends List {                                            its public (+) and protected (#)
                                                                             elements. Therefore, push()
  public Stack () {                                                          can be defined in terms of
                                                                             insertAtFront() and pop()
     super ( ) ;             // I n i t i a l i z e t h e l i s t            can be defined in terms of
                                                                             removeFirst().
  }

  public void push ( Object obj ) {

     insertAtFront ( obj );

  }

  public Object pop ( ) {

     return removeFirst ( ) ;

  }

} // S t a c k

                                                                   

                     Figure 16.22: The Stack ADT.

merely rename the insertAtFront() and removeFirst() methods.
Note that the Stack() constructor calls the superclass constructor. This
is necessary so that the list can be initialized.

   Do we have to make any changes to the List class in order to use it
this way? Yes. We want to change the declaration of head from private
to protected, so it can be accessed in the Stack class. And we want
                    778  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                    to declare List's public access methods, such as insertAtFront()
                    and removeFirst(), as protected. That will allow them to be used
                    in Stack, and in any classes that extend List, but not by other classes.
                    This is essential. Unless we do this we haven't really restricted the stack
                    operations to push and pop and, therefore, we haven't really defined a
                    stack ADT. Remember, an ADT defines the data and the operations on the
                    data. A stack ADT must restrict access to the data to just the push and pop
                    operations.

                    JAVA LANGUAGE RULE Protected Elements. An object's
                    protected elements are hidden from all other objects except
                    instances of the same class or its subclasses.

                    JAVA EFFECTIVE DESIGN Information Hiding. Use the private
                    and protected qualifiers to hide an ADT's implementation details
                    from other objects. Use public to define the ADT's interface.

Reversing a string  SELF-STUDY EXERCISE

                    EXERCISE 16.9 Define the peek() method for the Stack class. It
                    should take no parameters and return an Object. It should return the
                    Object on the top of the stack.

                    16.4.2 Testing the Stack Class

                    Now let's test our stack class by using a stack to reverse the letters in a
                    String. The algorithm is this: Starting at the front of the String, push
                    each letter onto the stack until you reach the end of the String. Then
                    pop letters off the stack and concatenate them, left to right, into another
                    String, until the stack is empty (Fig. 16.23).

                       Note that because our Nodes store Objects, we must convert each
                    char into a Character, using the wrapper class. Note also that we can
                    use the toString() method to convert from Object to String as we
                    are popping the stack.

                    16.5 The Queue ADT

                    A queue is a special type of list that limits insertions to the end of the list
                    and removals to the front of the list. Therefore, it enforces first-in-first-out
                    (FIFO) behavior on the list. Think of the waiting line at the salad bar. You
                    enter the line at the rear and you leave the line at the front (Fig. 16.24).

                       The queue operations are conventionally called enqueue, for insert, and
                       dequeue, for remove, respectively. Thus, the queue ADT stores a list of
                       data and supports the following operations:

                         Enqueue--insert an object onto the rear of the list.
                         Dequeue--remove the object at the front of the list.
                         Empty--return true if the queue is empty.
                       Queues are useful for a number of computing tasks. For example, the
                    ready, waiting, and blocked queues used by the CPU scheduler all use a
                         SECTION 16.5  The Queue ADT                                                      779
                                                                                                             

                        public s t a t i c void main ( S t r i n g argv [ ] ) {  string " ;
                                 S t a c k s t a c k = new S t a c k ( ) ;
                                 String string = "Hello this is a test

                        System . out . println ( " String : " + string ) ;
                        for ( int k = 0; k < string . length ( ) ; k++)

                               s t a c k . push (new C h a r a c t e r ( s t r i n g . charAt ( k ) ) ) ;

                        Object o = null ;

                        String reversed = "" ;

                        while ( ! stack . isEmpty ( ) ) {

                           o = s t a c k . pop ( ) ;

                           reversed = reversed + o. toString ( ) ;

                        }

                        System . out . println ( "Reversed String : " + reversed ) ;

                      } // main ( )

                                                                                                           

                      Figure 16.23: A method to test the Stack ADT, which is used here to
                      reverse a String of letters.

                      FIFO protocol. Queues are also useful in implementing certain kinds of
                      simulations. For example, the waiting line at a bank or a bakery can be
                      modeled using a queue.

queue is a list that       Head            Head
ns at the rear and
front only.

                                                                                 New

                                        In a queue, insertions
                                     take place at the rear, and
                                     removals occur at the front
                                     780            CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                 List                16.5.1 The Queue Class
# head : Node
+List()                              The Queue class is also trivial to derive from List (Fig. 16.25). Here we
# isEmpty() : boolean                just restrict operations to the insertAtRear() and removeFirst()
# print()                            methods (Fig. 16.26). To test the methods of this class, we replace the
# insertAtFront(in o : Object)       push() and pop() operations of the last example to enqueue() and
# insertAtRear(in o : Object)        dequeue(), respectively (Fig. 16.27). In this case, the letters of the test
# removeFirst() : Object             string will come out of the queue in the same order they went in--FIFO.
# removeLast() : Object
                                                                                                                                 
                Queue
                                     public c l a s s Queue extends L i s t {
  +Queue()
  +enqueue(in o : Object)                 public Queue ( ) {
  +dequeue() : Object
                                                super ( ) ;   // I n i t i a l i z e t h e l i s t

                                          }

                                          public void enqueue ( Object obj ) {

                                                insertAtRear ( obj );

                                          }

                                          public Object dequeue ( ) {

Figure 16.25: The Queue's                       return removeFirst ( ) ;

                                          }

enqueue() and dequeue()              }// Queue

methods can use the List's                                                                                                       

insertAtRear()                  and                          Figure 16.26: The Queue ADT.

removeFirst()   methods,

respectively.

                                                                                                                                 

                                     public s t a t i c void main ( S t r i n g argv [ ] ) {
                                             Queue queue = new Queue ( ) ;
                                              String string = "Hello this is a test string " ;
                                             System . out . println ( " String : " + string ) ;
                                              for ( int k = 0; k < string . length ( ) ; k++)
                                                     queue . enqueue ( new C h a r a c t e r ( s t r i n g . charAt ( k ) ) ) ;
                                             System . out . p r i n t l n ( "The current queue : " ) ;
                                             queue . print ( ) ;

                                          Object o = null ;

                                          System . out . println ( "Dequeuing : " ) ;

                                          while ( ! queue . isEmpty ( ) ) {

                                                o = queue . dequeue ( ) ;

                                                System . out . print ( o . toString ( ) ) ;

                                          }

                                     } // main ( )

                                                                                                                                 

                                     Figure 16.27: A method to test the Queue ADT. Letters inserted in a queue
                                     come out in the same order they went in.

                                       JAVA EFFECTIVE DESIGN ADTs. ADTs encapsulate and manage
                                       the difficult tasks involved in manipulating the data structure. But
                                       because of their extensibility, they can be used in a wide range of
                                       applications.
SECTION 16.5  The Queue ADT                                                                   781

SELF-STUDY EXERCISE

EXERCISE 16.10 Define a peekLast() method for the Queue class.
It should take no parameters and return an Object. It should return
a reference to the Object stored in the last Node of the list without
removing it.

Special Topic: The LISP Language

One of the very earliest computer languages, and the one that's most of-
ten associated with artificial intelligence (AI), is LISP, which stands for
LISt Processor. LISP has been, and still is, used to build programs for hu-
man learning, natural language processing, chess playing, human vision
processing, and a wide range of other applications.

   The earliest (pure) versions of LISP had no control structures and the
only data structure they contained was the list structure. Repetition in the
language was done by recursion. Lists are used for everything in LISP,
including LISP programs themselves. LISP's unique syntax is simple. A
LISP program consists of symbols, such as 5 and x, and lists of symbols,
such as (5), (1 2 3 4 5), and ((this 5) (that 10)), where a list is anything en-
closed within parentheses. The null list is represented by ().

   Programs in LISP are like mathematical functions. For example, here's
a definition of a function that computes the square of two numbers:

                                                                                                    

( define ( square x) ( x x) )                                                                       


The expression (square x) is a list giving the name of the function and its
parameter. The expression (* x x) gives the body of the function.

   LISP uses prefix notation, in which the operator is the first symbol in
the expression, as in (* x x). This is equivalent to (x * x) in Java's infix
notation, where the operator occurs between the two operands. To run
this program, you would simply input an expression like (square 25) to the
LISP interpreter, and it would evaluate it to 625.

   LISP provides three basic list operators. The expression (car x) returns
the first element of the (nonempty) list x. The expression (cdr x) returns
the tail of the list x. Finally, (cons z x) constructs a list by making z the head
of the list and x its tail. For example, if x is the list (1 3 5), then (car x) is 1,
(cdr x) is (3 5), and (cons 7 x) is (7 1 3 5).

   Given these basic list operators, it is practically trivial to define a stack
in LISP:

                                                                                                    

( define ( push x stack ) ( cons x stack ) )

( d e f i n e ( pop s t a c k ) ( s e t f s t a c k ( cdr s t a c k ) ) ( c a r s t a c k ) )       


The push operation creates a new stack by forming the cons of the element
x and the previous version of the stack. The pop operation returns the
car of the stack but first changes the stack (using setf) to the tail of the
original stack.
                                        782  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                                           These simple examples show that you can do an awful lot of computa-
                                        tion using just a simple list structure. The success of LISP, particularly its
                                        success as an AI language, shows the great power and generality inherent
                                        in recursion and lists.

                                        16.6 From the Java Library: The Java Collections
                                                Framework and Generic Types

java.sun.com/j2se/1.5.0/docs/api/       THE JAVA CLASS LIBRARY contains implementations of some abstract
                                        data types. The Java utility package, java.util.*, contains a good
                                        number of classes and interfaces designed to facilitate storing and ma-
                                        nipulating groups of objects. This family of related interfaces and classes
                                        is called the Java collections framework. It contains structures that corre-
                                        spond to the ADTs that we have just discussed, plus other data structures.
                                        Java 5.0 has reimplemented the Java collections framework using generic
                                        types that allow a programmer to specify a type for the objects that are
                                        stored in the structure.

                                        16.6.1 Generic types in Java

generic types                           Declaring classes that use the generic type construct introduced in Java 5.0
                                        involves using new syntax to refer to the class name. Such classes and in-
                        Vector<E>       terfaces, including those in the collections framework, use angle brackets
                                        containing one or more variables (separated by commas) to refer to un-
+Vector()                               specified type names. For example, you would use <E> or <K,V> to refer
+Vector(in size : int)                  to unspecified type names. Thus, names of classes or interfaces imple-
+addElement(in o : E)                   mented with generic types are written with the syntax ClassName<E>.
+elementAt(in index : int) : E
+insertElementAt(in o : E, in x : int)     Let's reconsider the Vector class, which was introduced in Chapter 9.
+indexOf(in o : Object) : int           The Vector class, which is part of the Java collections framework, has
+lastIndexOf(in o : Object) : int       a generic type implementation in Java 5.0. Figure 16.28 describes the
+removeElementAt(in index : int)        Vector<E> class. Notice that the E refers to an unspecified type name,
+size() : int                           that is, the name of a class or interface. This type is specified when a
                                        corresponding variable is declared. The type must also be included after a
Figure 16.28: The java.util.-           constructor's type name when an object is instantiated and assigned to the
Vector class is implemented             variable. The following code demonstrates how to create a Vector<E>
with a generic type in Java 5.0.        object for storing String objects.

                                                                                                                        

                                             Vector<S t r i n g > s t r V e c = new Vector<S t r i n g > ( ) ;

                                             strVec . addElement ( "alpha" ) ;

                                             strVec . addElement ( " beta " ) ;

                                             String str = strVec . elementAt ( 0 ) ;                                    

                                        In effect, the <E> serves as parameter for the type of objects that will be
                                        stored in the Vector. Java 5.0 still allows the use of the unparameterized
                                        Vector class which is equivalent to instantiating a Vector<Object>
SECTION 6  Java Collections and Generic Types             783

object. If you use a Vector object, the above code would be written as
follows.

                                                                               

  Vector s t r V e c = new Vector ( ) ;

  strVec . addElement ( "alpha" ) ;

  strVec . addElement ( " beta " ) ;

  String str = ( String ) strVec . elementAt ( 0 ) ;                           

   One benefit a generic type provides is type checking of method argu-
ments at compile time. If strVec is a Vector<String> object, then the
statement

                                                                               

  s t r V e c . addElement (new I n t e g e r ( 5 7 ) ) ;                      

will generate a compile-time error. By contrast, if strVec was just a                            Vector<E>
plain Vector object, no error would be found at compile time. Thus, if
a programmer wishes to create an array of String objects, using generic                           Stack<E>
types will help guarantee that the objects being stored are actually of type
String. In this way, using generic types helps to reduce the number of            +empty() : boolean
programming errors and thereby makes programs safer and more robust.              +peek() : E
                                                                                  +pop() : E
   A second benefit of using generic types is that the return type of objects     +push(in o : E) : E
retrieved from the data structure will be of the specified type rather than       +search(in o : Object) : int
of type Object. If you compare the last statement in each of the two
code segments above, you can see that using a generic type eliminates the
need to cast an Object to a String. This is a big convenience for the
programmer, because forgetting to cast objects from one type to another is
a common programming error.

The java.util.Stack<E> class

The Java collections framework includes the Stack<E> class, imple-              Figure 16.29: The java.util.-
mented as a subclass of the Vector<E> class. It contains the methods            Stack<E> class is a subclass of
shown in Figure 16.29. For the most part, its methods provide the same          Vector<E>.
functionality as the methods we developed earlier in this chapter.
Note that the methods provide the functionality of a stack ADT but the de-     
tails of its implementation are hidden from the user. An object of this class
can be declared, instantiated, and used in a manner like the Vector<E>         
code.

 

         Stack<S t r i n g > s t k = new Stack<S t r i n g > ( ) ;
         stk . push ( "alpha" ) ;
         stk . push ( " beta " ) ;
         S t r i n g s t r = s t k . pop ( ) ;
 

SELF-STUDY EXERCISE

EXERCISE 16.11 Write a class with only a main() method that modi-
fies Figure 16.23 so that it uses the parameterized java.util.Stack<E>
class instead of the Stack class used there.
                                           784                   CHAPTER 16  Data Structures: Lists, Stacks, and Queues

  AbstractSequentialList<E>                16.6.2 The List<E> interface
                                                     and the LinkedList<E> class
                       쳃nterface
                            List<E>        The java.util.LinkedList<E> is an implementation of a linked list
                                           (Fig. 16.30). Like our implementation earlier in this chapter, it contains
      +add(in index : int, in o : E)       methods that can be used to define the standard stack and queue methods.
      +remove(in index : int) : E
      +get(in index : int) : E                Many of the standard list-processing methods are defined as part of
                                           the java.util.List<E> interface. The advantage of defining list op-
                LinkedList<E>              erations as an interface is that they can be implemented by a number of
                                           data structures. Code for using the list methods can be written to work
+add(in index : int, in o : E)             independently of the data structure being used.
+addFirst(in o : E)
+addLast(in o : E)                            For example, the collections framework contains LinkedList<E> and
+get(in index : int) : E                   ArrayList<E>, both of which implement the List<E> interface. In
+getFirst() : E                            this section, we will demonstrate how to make appropriate use of the
+getLast() : E                             List<E> interface and data structures that implement it.
+removeFirst() : E
+removeLast() : E                             Suppose that a programmer is developing an application to track ac-
                                           tivity of employees working at a small company's phone-in help desk.
Figure  16.30:                        The  The programmer has decided to use the LinkedList<E> data structure
                                           to store objects of the PhoneRecord class that was defined earlier in this
LinkedList<E> class imple-                 chapter and will use methods of the List<E> interface to manipulate the
                                           data. A list seems to be an appropriate structure for this problem since
ments the List<E> interface.
                                                An unknown (but relatively small) amount of data will be involved.
Only a partial list of methods are
                                                The company wants the data stored in the order it is generated.
shown.
                                                The main use of the data will be to print out the list's phone records.

                                           The programmer might write a short method like that in Figure 16.31 to
                                           demonstrate how the List<E> and LinkedList<E> structures will be
                                           used.

                                                                                                                                  

                                           public s t a t i c void t e s t L i s t ( ) {
                                              L i s t <PhoneRecord> t h e L i s t = new L i n k e d L i s t <PhoneRecord > ( ) ;

                                           // new A r r a y L i s t <PhoneRecord > ( ) ; c o u l d a l s o be used .

                                           t h e L i s t . add (new PhoneRecord ( " Roger M" , "090-997-2918" ) ) ;

                                           t h e L i s t . add (new PhoneRecord ( " J a n e M" , "090-997-1987" ) ) ;

                                           t h e L i s t . add (new PhoneRecord ( " S t a c y K" , "090-997-9188" ) ) ;

                                           t h e L i s t . add (new PhoneRecord ( "Gary G" , "201-119-8765" ) ) ;

                                           t h e L i s t . add (new PhoneRecord ( " J a n e M" , "090-997-1987" ) ) ;

                                           System . out . println ( " Testing a LinkedList List " ) ;

                                           for ( PhoneRecord pr : theList )

                                                System . out . println ( pr ) ;

                                           } // t e s t L i s t

                                                                                                                                  

                                           Figure 16.31: A method that demonstrates the interface List<E> and the
                                           class LinkedList<E>.

                                           Note that the statement

                                                                                                                                  

                                           L i s t <PhoneRecord> t h e L i s t = new L i n k e d L i s t <PhoneRecord > ( ) ;     
                                           
SECTION 16.7  Using the Set and Map Interfaces                          785

declares a variable theList of interface type List<E> but assigns an ob-
ject of class type LinkedList<E>. This is appropriate because the class
implements the interface and the code uses only methods from the inter-
face. The class ArrayList<E> in the collections framework also imple-
ments the List<E> interface. It uses an array rather than a linked list to
store elements and has a constructor with an int parameter that sets the
size of the array. If the programmer knew that theList would contain
close to, but always less than, 100 elements, then it might be better to
declare:

                                                                              

L i s t <PhoneRecord> t h e L i s t = new A r r a y L i s t <PhoneRecord > ( 1 0 0 ) ;
                                                                              

Also note the unusual looking for loop at the end of the method. This is a              The for-each loop
new feature of Java 5.0 which can be used to simplify the coding of loops
that iterate through every object in a collection of objects. The statement

                                                                              

  for ( PhoneRecord pr : theList ) {  }                                       

should be thought of as executing the enclosed statements for each
PhoneRecord object, pr, in the theList data structure. In previous ver-
sions of Java, an interface named Iterator had to be used to enumerate
all the elements in a collection. The Iterator approach is more flexible--
for example, it allows you to iterate through just some of the members of
the collection-- and will therefore still have to be used for more complex
loops.

   The output of the method will be:

                                                                              

  Roger M 090-997-2918

  Jane M 090-997-1987

  Stacy K 090-997-9188

  Gary G 201-119-8765

  Jane M 090-997-1987                                                         

   In the next section we will examine two other structures in the collec-
tions framework, the Set interface and the Map interface.

JAVA EFFECTIVE DESIGN Code Reuse. Given the relative
difficulty of writing correct and efficient list-processing algorithms,
applications that depend on lists should make use of library classes
whenever possible.

16.7 Using the Set and Map Interfaces

The Set and Map interfaces are similar to the List interface in that there
are multiple classes in the collections framework that implement them.

16.7.1 Using the Set Interface.

The Set interface is modeled after the set theory principles taught in math-
ematics. In mathematics, sets are groups of elements with a clearly defined
                                  786  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

Figure 16.32: A partial list of   algorithm for deciding if any given element is in any given set. Elements
methods of the Set<E> interface.  can be added to sets and can be removed from sets. Sets cannot have
                                  duplicate elements; if an element is added to a set that already contains
Overriding methods                an element equal to it, the new set still has a single such element. The ele-
                                  ments of a set have no natural order; two sets that have the same elements
                                  listed in different orders are considered to be the same set.

                                     In computer science and in Java, data structures that model sets are
                                  designed for large collections of data. Such data structures have a method
                                  that determines if an object is in a given set with an efficient algorithm. For
                                  large data sets, using such a method is much faster than iterating through
                                  a list. Sometimes, you may or may not be able to list the elements of
                                  a set data structure in some natural order, depending on how the data
                                  structure is implemented. An incomplete listing of the methods of the
                                  Set<E> interface is given in the UML diagram in Figure 16.32.

                                     TreeSet<E> and HashSet<E> are two classes in the collections
                                  framework that implement the Set<E> interface. They both provide fast
                                  operations to check whether an element is in a set. They also provide quick
                                  insertion of an element into the set or removal of an element from a set. For
                                  large sets--those having at least several thousand elements--where there
                                  are large numbers of insertions, deletions, and tests for whether elements
                                  are in a set, linked lists would be much slower.

                                     When using the Set<E> interface for a user-defined class E, you will
                                  likely want to override the definition of the equals() method from the
                                  Object class in E because that method is used when computing the
                                  value of aSet.contains(anElement). When using the TreeSet<E>
                                  class for a user defined class E, you should implement the compareTo()
                                  method of the Comparable interface because it is used to order the el-
                                  ements of E. In the next section, we will discuss the specific manner in
                                  which elements are ordered. Finally, when using the HashSet<E> class
                                  for a user defined class E, you should override the hashCode() method
                                  of the Object class because it is used HashSet<E>. Hash codes are in-
                                  dexes that are computed from the particular object that is being stored
                                  in the HashSet. Given an object's hash code, the object can be retrieved
                                  directly, as we do with object's stored in an array. However, we will not
                                  discuss hash codes in any detail in this text.

                                  Problem Statement

                                  Let's think about a simple example for using a set data structure. Sup-
                                  pose that a programmer is developing an application for a large com-
                                  pany for maintaining a no-call list. The programmer has decided to use
                                  the TreeSet<E> data structure to store objects of the PhoneRecord
                                  class that was defined earlier in this chapter and will use methods of the
                                  Set<E> interface to manipulate the data.

                                     A TreeSet seems to be an appropriate structure for this problem, since

                                           A large amount of data will be involved.

                                           The company wants the PhoneRecord data stored in alphabeti-
                                             cal order.

                                           The main use of the data will be to test whether names are in the
                                             set.
SECTION 16.7  Using the Set and Map Interfaces                                     787

The programmer might write a short method like that in Figure 16.33 to
demonstrate how the Set<E> and TreeSet<E> structures will be used.

                                                                                    

public s t a t i c void testSet ( ) {
   Set<PhoneRecord> t h e S e t = new Tr ee Se t <PhoneRecord > ( ) ;

  // new HashSet <PhoneRecord > ( ) ; c o u l d a l s o be used .

  t h e S e t . add (new PhoneRecord ( " Roger M" , "090-997-2918" ) ) ;
  t h e S e t . add (new PhoneRecord ( " J a n e M" , "090-997-1987" ) ) ;
  t h e S e t . add (new PhoneRecord ( " S t a c y K" , "090-997-9188" ) ) ;
  t h e S e t . add (new PhoneRecord ( "Gary G" , "201-119-8765" ) ) ;
  t h e S e t . add (new PhoneRecord ( " J a n e M" , "090-987-6543" ) ) ;

  System . out . p r i n t l n ( " Testing TreeSet and Set " ) ;

  PhoneRecord ph1 =

  new PhoneRecord ( " Roger M" , "090-997-2918" ) ;

  PhoneRecord ph2 =

  new PhoneRecord ( "Mary Q" , "090-242-3344" ) ;

  System . out . print ( "Roger M contained in theSet i s " ) ;

  System . out . p r i n t l n ( theSet . contains ( ph1 ) ) ;

  System . out . p r i n t ( "Mary Q c o n t a i n e d i n t h e S e t i s " ) ;

  System . out . p r i n t l n ( theSet . contains ( ph2 ) ) ;

  for ( PhoneRecord pr : theSet )

  System . out . println ( pr ) ;

} // t e s t S e t

                                                                                    

Figure 16.33: A method that demonstrates use of the interface Set<E>
and the class TreeSet<E>.

   In order for the testSet() method to work as we would like, we need
to have the PhoneRecord class implement the Comparable interface
and to override the equals() method. For this example, it is reason-
able to assume that the name field of PhoneRecord objects should be
unique so that it can be used to decide if two PhoneRecord objects are
equal. The name field of PhoneRecord can also be used to define the
other two methods discussed above. Thus, add the following code to the
PhoneRecord class.

                                                                                         

  public boolean equals ( Object ob ){
         r e t u r n name . e q u a l s ( ( ( PhoneRecord ) ob ) . getName ( ) ) ;

  } // e q u a l s ( )

  public int compareTo ( Object ob ){
       r e t u r n name . compareTo ( ( ( PhoneRecord ) ob ) . getName ( ) ) ;

  } // compareTo ( )

  public int hashCode ( ) {

  r e t u r n name . hashCode ( ) ;

  } // hashCode ( )

                                                                                         
                                 788  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

                                 The output of the TestSet() method is listed below:

                                                                                                               

                                      Testing TreeSet and Set

                                      Roger M i s contained in theSet i s true

                                      Mary Q i s c o n t a i n e d i n t h e S e t i s f a l s e

                                      Gary G 201-119-8765

                                      Jane M 090-997-1987

                                      Roger M 090-997-2918

                                      Stacy K 090-997-9188                                                     

                                 Notice that Jane M PhoneRecord appears only once in the listing of
                                 elements in the set.

                                 16.7.2 Using the Map<K,V> Interface.

Figure 16.34: A partial list of  The Map<K,V> interface is modeled after looking up definitions for words
methods of Map<K,V>.             in a dictionary. In computer science, maps are considered to be a collection
                                 of pairs of elements. A pair consists of a key that corresponds to a word
                                 being looked up and a value corresponding to the definition of the word.
                                 Pairs can be added to maps and can be removed from maps. Maps cannot
                                 have distinct pairs with the same keys; if you attempt to add a pair to a
                                 map that already contains a pair with the same key, the second pair will
                                 replace the first. An incomplete listing of the methods of the Map<K,V>
                                 interface is given in the UML diagram in Figure 16.34. TreeMap<K,V>
                                 and HashMap<K,V> are two classes in the collections framework that
                                 implement the Map<K,V> interface.

                                    Let's now consider a simple example of using a map data structure.
                                 Suppose that our programmer has been hired by a large company to de-
                                 velop an application that maintains an electronic phone list for company
                                 employees. The programmer has decided to use the TreeMap<E> data
                                 structure to store pairs of names and telephone numbers and will use
                                 methods of the Map<V,K> interface to manipulate the data.

                                    A TreeMap seems like an appropriate data structure for this problem,
                                    since

                                       A large amount of data will be involved.

                                       The company wants the PhoneRecord data stored in alphabeti-
                                         cal order.

                                          The main use of the data will be to use names to access telephone
                                            numbers.

                                 The programmer might write a short method like that in Figure 16.35 to
                                 demonstrate how the Map<K,V> and TreeMap<K,V> structures will be
                                 used.

                                    The output for this test program is:

                                                                                                               

                                      Stacy K has phone 090-997-9188

                                      Jane M has phone 090-233-0000                                            

                                 Notice the the second phone number for Jane M is the one that is stored
                                 in the data structure.
   SECTION 16.8  The Binary Search Tree Data Structure                      789
                                                                               

                                                                               
  public s t a t i c void testMap ( ) {
     Map<S t r i n g , S t r i n g > theMap =
           new TreeMap<S t r i n g , S t r i n g > ( ) ;

       / / n e w H a s h M a p <K , V > ( ) ; c o u l d a l s o b e u s e d

     theMap . put ( " Roger M" , "090-997-2918" ) ;
     theMap . put ( " J a n e M" , "090-997-1987" ) ;
     theMap . put ( " S t a c y K" , "090-997-9188" ) ;
     theMap . put ( "Gary G" , "201-119-8765" ) ;
     theMap . put ( " J a n e M" , "090-233-0000" ) ;
     System . out . p r i n t l n ( " T e s t i n g TreeMap and Map" ) ;
     System . out . print ( " Stacy K has phone " ) ;
     System . out . p r i n t ( theMap . g e t ( " S t a c y K" ) ;
     System . out . print ( " Jane M has phone " ) ;
     System . out . p r i n t ( theMap . g e t ( " J a n e M" ) ;
  } // t e s t L i s t


Figure 16.35: A method that demonstrates use of the interface Map<K,V>
and the class TreeMap<K,V>.

16.8 The Binary Search Tree Data Structure

To gain some appreciation of what binary search trees are and why they
are useful in implementing the Set and Map interfaces, let's make a few
comments about implementing very simple versions of these structures.

   Like a linked list, a binary tree is a data structure consisting of a col-
lection of nodes that are linked together by references from one node to
another. However, unlike a linked list, each node in a binary tree contains
references to two other other nodes, (left and right), corresponding to
the left- and right-subtrees growing out of a particular node. A subtree is
a tree that is part of larger tree. This creates a tree-like structure, as shown
in Figure 16.36. Note that some of the references to other nodes might
be null. The trunk of the tree corresponds to the node labeled root. In
computer science, trees are almost always drawn upside down. Thus the
trunk of the tree, root, is at the top of the figure.

   If we assume that the objects contained in a tree are from a class that
implements the Comparable interface, then a binary search tree is a bi-
nary tree in which the objects are ordered so that the object at a particular
node is greater than the objects stored in its left subtree and less than the
objects stored in its right subtree.

   Figure 16.36 shows a binary search tree with the phone list data that we
have used throughout the chapter. Objects are compared by comparing
the names alphabetically. From the figure it is easy to see that searching
for a object should start at the root of the tree. At each node, examining the
name at the node will tell you whether you have found the object there.
Otherwise, by checking the name at the node, you can decide which sub-
tree the data could be in, and you can traverse either left or right through
each level of the tree. One can deduce that if the tree is balanced--that is,
if at most nodes the size of the left subtree is about the same size as the
right subtree--searching the tree much faster than searching a linked list.
                                                 790  CHAPTER 16  Data Structures: Lists, Stacks, and Queues
Figure 16.36: A binary search tree
of PhoneTreeNodes.

This is one of the main advantages of using a binary search tree over a
linked list.

   The TreeSet and TreeMap classes implement sophisticated algo-
rithms for inserting and removing data from a tree, which guarantees
that the tree remains relatively balanced. The details of these algorithms
are beyond the scope of this book, but would be a subject of study in a
standard Data Structures and Algorithms course.

   We will conclude this subsection by giving a brief outline of an imple-
mentation of a simple binary search tree that stores our phone list data.
Like our LinkedList example, you need to define a node class and a
tree class. The node class with unimplemented methods, would look like:

                                                                                                                                

public class PhoneTreeNode {
     p r i v a t e S t r i n g name ;
     private String phone ;
     private PhoneTreeNode l e f t ;
     private PhoneTreeNode ri g ht ;

                                                      public PhoneTreeNode ( S t r i n g nam , S t r i n g pho ) { }

                                                      public void s e t D a t a ( S t r i n g nam , S t r i n g pho ) { }

                                                      public S t r i n g getName ( ) { }

                                                      public boolean c o n t a i n s ( S t r i n g nam , S t r i n g pho ) { }

                                                      public void i n s e r t ( S t r i n g nam , S t r i n g pho ) { }

                                                      // o t h e r methods

} // PhoneTreeNode

                                                                                                                                
SECTION 16.8  The Binary Search Tree Data Structure                        791

The tree structure itself contains a reference to a node:

                                                                                 

public class PhoneTree {
   private PhoneTreeNode root ;

  public PhoneTree (){ }
  public boolean c o n t a i n s ( S t r i n g nam , S t r i n g pho ) { }
  public void i n s e r t ( S t r i n g nam , S t r i n g pho ) { }

  // o t h e r methods

} // PhoneTreeNode

                                                                                 

We will implement only the two contains() methods. The PhoneTree
version is very simple:

                                                                                 

public boolean c o n t a i n s ( S t r i n g nam , S t r i n g pho ) {

  i f ( r o o t == n u l l ) r e t u r n f a l s e ;

  e l s e r e t u r n r o o t . c o n t a i n s ( nam , pho ) ;

} // c o n t a i n s ( ) i n P h o n e T r e e

                                                                                 

The implementation of the contains() method of PhoneTreeNode is
only slightly more involved.

                                                                                 

public boolean c o n t a i n s ( S t r i n g nam , S t r i n g pho ) {

  i f ( name . e q u a l s (nam ) )

     return true ;

  e l s e i f ( name . compareTo (nam) < 0 ) { // n a m e < nam

     i f ( r i g h t == n u l l ) r e t u r n f a l s e ;

     e l s e r e t u r n r i g h t . c o n t a i n s (nam , pho ) ;

  } else { {\ color {cyan} // name > nam}

     i f ( l e f t == n u l l ) r e t u r n f a l s e ;

     e l s e r e t u r n l e f t . c o n t a i n s ( nam , pho ) ;

  }

} // c o n t a i n s ( ) i n PhoneTreeNode

                                                                                 
                 792  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

CHAPTER SUMMARY     In this chapter, we have given you a brief introduction to the concept of
                 a dynamic data structure and tried to illustrate how they work and why
                 they are useful for organizing and managing large amounts of data. We
                 also introduced you to an important new language feature introduced in
                 Java 5.0, the concept of generic types. Obviously, we have only scratched
                 the surface of the important topic of data structures and the algorithms
                 used to manage them. For a broader and deeper treatment of this subject,
                 you will have to take a Data Structures and Algorithms course, which is a
                 fundamental course in most computer science curricula.

                 Technical Terms

                 Abstract Data Type  Java collections   queue
                    (ADT)               framework       reference
                                                        self-referential object
                 binary search tree  key                stack
                 data structure      last-in-first-out  static structure
                 dequeue                                traverse
                 dynamic structure      (LIFO)          value
                 enqueue             link               vector
                 first-in-first-out  list
                                     linked list
                    (FIFO)           pop
                 generic type        push

                 Summary of Important Points

                  A data structure is used to organize data and make them more efficient
                    to process. An array is an example of a static structure, since its size
                    does not change during a program's execution. A vector is an example
                    of a dynamic structure, one whose size can grow and shrink during a
                    program's execution.

                  A linked list is a linear structure in which the individual nodes of the list
                    are joined together by references. A reference is a variable that refers to
                    an object. Each node in the list has a link variable that refers to another
                    node. An object that can refer to the same kind of object is said to be
                    self-referential.

                  The Node class is an example of a self-referential class. It contains a
                    link variable that refers to a Node. By assigning references to the link
                    variable, Nodes can be chained together into a linked list. In addition
                    to their link variables, Nodes contain data variables, which should be
                    accessible through public methods.

                  Depending on the use of a linked list, nodes can be inserted at various
                    locations in the list: at the head, the end, or in the middle of the list.

                  Traversal algorithms must be used to access the elements of a singly
                    linked list. To traverse a list you start at the first node and follow the
                    links of the chain until you reach the desired node.

                  Depending on the application, nodes can be removed from the front,
                    rear, or middle of a linked list. Except for the front node, traversal
                    algorithms are used to locate the desired node.

                  In developing list algorithms, it is important to test them thoroughly.
                    Ideally, you should test every possible combination of insertions and
CHAPTER 16  Solutions to Self-Study Exercises                           793

  removals that the list can support. Practically, you should test every
  independent case of insertions and removals that the list supports.
 An Abstract Data Type (ADT) is a concept that combines two elements:
  A collection of data, and the operations that can be performed on the
  data. For the list ADT, the data are the values (Objects or ints)
  contained in the nodes that make up the list, and the operations are
  insertion, removal, and tests of whether the list is empty.
 In designing an ADT, it's important to provide a public interface that
  can be used to access the ADT's data. The ADT's implementation de-
  tails should not matter to the user and should, therefore, be hidden. A
  Java class definition, with its public and private aspects, is perfectly
  suited to implement an ADT.
 A stack is a list that allows insertions and removals only at the front
  of the list. A stack insertion is called a push and a removal is called a
  pop. The first element in a stack is usually called the top of the stack.
  The Stack ADT can easily be defined as a subclass of List. Stacks are
  used for managing the method call and return in most programming
  languages.
 A queue is a list that only allows insertions at the rear and removals
  from the front of a list. A queue insertion is called enqueue, and a re-
  moval is called dequeue. The Queue ADT can easily be defined as a
  subclass of List. Queues are used for managing the various lists used
  by the CPU scheduler--such as the ready, waiting, and blocked queues.
 A binary search tree is a binary tree in which the ordered data stored at
  any node is greater than all data stored in the left subtree and is less
  than all data stored in the right subtree.

  SOLUTION 16.1   Node (new  String ("Hello" ) ) ;                           SOLUTIONS TO
                                                                          SELF-STUDY EXERCISES

 Node node = new                                                         

                                                                         
  SOLUTION 16.2   Node (new  Student ( "William" ) ) ;                   

                                                                         
 Node node = new
                                                                         

  SOLUTION 16.3


  PhoneListNode newNode =
                  new PhoneListNode ( " B i l l C" , "111-202-3331" ) ;

  nodeptr . s e t N e x t ( newNode ) ;

794  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

SOLUTION 16.4 The following condition is too general. It will cause the loop to
exit as soon as a nonnull node is encountered, whether or not the node matches
the one being sought.

                                                                                  

(( current . getNext () != null ) | |

                      ( ! c u r r e n t . getName ( ) . e q u a l s ( name ) ) )  

SOLUTION 16.5 The PhoneList program will generate the following output,
which has been edited slightly to improve its readability:

                                                                                  

Phone Directory
---------------

Roger M 997-0020            Roger W   997-0086  Rich P 997-0010
                                      997-2517
Jane M 997-2101             Stacy K
                                      P
Looking up numbers by name

     Roger M 997-0020

     Rich P 997-0010

     Stacy K 997-2517

     Sorry . No e n t r y f o r Mary

Removed Rich P 997 -0010

Phone Directory

---------------

Roger M 997-0020            Roger W 997-0086    Jane M 997-2101

Stacy K 997-2517

Removed Roger M 997 -0020

Phone Directory

---------------

Roger W 997-0086            Jane M    997-2101  Stacy K 997-2517

Removed S t a c y K 997 -2517

Phone Directory

---------------

Roger W 997-0086            Jane M    997-2101

Removed J a n e M 997 -2101

Phone Directory

---------------

Roger W 997-0086            Jane M
Sorry . No e n t r y f o r
Phone Directory
---------------

Roger W 997-0086
Removed Roger W 997 -0086
Phone Directory
---------------

Phone l i s t i s empty                                                           

CHAPTER 16  Solutions to Self-Study Exercises                                   795

SOLUTION 16.6 Executing the following method calls will test whether it is

possible to insert items into a list after items have been removed:

                                                                                 

      // C r e a t e and i n s e r t some nodes

PhoneList l i s t = new PhoneList ( ) ;

l i s t . i n s e r t (new PhoneListNode ( " Roger M" , " 997 -0020 " ) ) ;

l i s t . i n s e r t (new PhoneListNode ( " Roger W" , " 997 -0086 " ) ) ;

System . out . p r i n t l n ( l i s t . remove ( " Roger M" ) ) ;

l i s t . i n s e r t (new PhoneListNode ( " Rich P" , " 997 -0010 " ) ) ;

System . out . p r i n t l n ( l i s t . remove ( " Roger W" ) ) ;

l i s t . i n s e r t (new PhoneListNode ( " J a n e M" , " 997 -2101 " ) ) ;

l i s t . i n s e r t (new PhoneListNode ( " S t a c y K" , " 997 -2517 " ) ) ;

System . out . p r i n t l n ( l i s t . remove ( " J a n e M" ) ) ;

System . out . p r i n t l n ( l i s t . remove ( " S t a c y K" ) ) ;

list . print ();

      // L i s t s h o u l d be empty

                                                                                 

SOLUTION 16.7 The List ADT program will produce the following output:

                                                                                 

Generic List
---------------

Hello , World !

8647

Roger M 997-0020

Jane M 997-2101

Stacy K 997-2517

  Removed S t a c y K 997 -2517

Generic List :

Hello , World !

8647

Roger M 997-0020

Jane M 997-2101

  Removed J a n e M 997 -2101

Generic List :

Hello , World !

8647

Roger M 997-0020

  Removed Hello , World !

Generic List :

8647

Roger M 997-0020
                                                                                 
796        CHAPTER 16  Data Structures: Lists, Stacks, and Queues

SOLUTION 16.8 Executing the following method calls will test whether it is

possible to insert items into a List after items have been removed:

                                                                                         

        // C r e a t e and i n s e r t some nodes

L i s t l i s t = new L i s t ( ) ;

l i s t . i n s e r t A t F r o n t (new PhoneRecord ( " Roger M" , " 997 -0020 " ) ) ;

l i s t . i n s e r t A t F r o n t (new PhoneRecord ( " Roger W" , " 997 -0086 " ) ) ;

System . out . println ( "Current List Elements" ) ;

list . print ();

Object o = l i s t . removeLast ( ) ; // Remove l a s t e l e m e n t

l i s t . insertAtFront (o ) ; // I n s e r t a t t h e f r o n t of t h e l i s t

System . out . println ( "Current List Elements" ) ;

list . print ();

o = l i s t . removeFirst ( ) ;

System . out . p r i n t l n ( "Removed " + o . t o S t r i n g ( ) ) ;

o = l i s t . removeFirst ( ) ;

System . out . p r i n t l n ( "Removed " + o . t o S t r i n g ( ) ) ;

list . insertAtRear (o );

System . out . println ( "Current List Elements" ) ;

list . print ();             // L i s t s h o u l d have one e l e m e n t

                                                                                         

SOLUTION 16.9 The peek() method should just return the first node without
deleting it:

                                                                                         

public Object peek ( ) {

        return head ;

}

                                                                                         

SOLUTION 16.10 The peekLast() method can be modeled after the List.re-
moveLast() method:

                                                                                         

public Object peekLast () {

   if ( isEmpty ( ) )

     return null ;

   else {

     Node c u r r e n t = head ;     // S t a r t a t head o f l i s t

     while ( current . getNext ( ) != null ) // F i n d end o f l i s t

        current = current . getNext ( ) ;

        return current ;

// R e t u r n l a s t node

     }

} // p e e k L a s t ( )

                                                                                         
CHAPTER 16  Exercises                                                           797

SOLUTION 16.11 The following class tests the java.util.Stack<E> class:

                                                                                    

import java . u t i l .  ;
public class StackTest{
public s t a t i c void main ( S t r i n g argv [ ] ) {

     Stack<Character> s t a c k = new Stack<Character > ( ) ;
     String string = "Hello this is a test string " ;

  System . out . println ( " String : " + string ) ;
  for ( int k = 0; k < string . length ( ) ; k++)

     s t a c k . push (new C h a r a c t e r ( s t r i n g . charAt ( k ) ) ) ;

  Character ch = null ;

  String reversed = "" ;

  while ( ! stack . empty ( ) ) {

        ch = s t a c k . pop ( ) ;

        reversed = reversed + ch . charValue ( ) ;

  }

  System . out . println ( "Reversed String : " + reversed ) ;

} // main ( )

} // S t a c k T e s t c l a s s

                                                                                    

EXERCISE 16.1 Explain the difference between each of the following pairs of            EXERCISES

terms:                                                                                 Note: For programming exercises,
                                                                                       first draw a UML class diagram
a. Stack and queue.                 d. Push and pop.                                   describing all classes and their
                                                                                       inheritance relationships and/or
b. Static structure and dynamic structure. e. Enqueue and dequeue.                     associations.

c. Data structure and Abstract Data Type. f. Linked list and node.

EXERCISE 16.2 Fill in the blanks.

a. An Abstract Data Type consists of two main parts:         and                 .

b. An object that contains a variable that refers to an object of the same class is a

        .

c. One application for a            is to manage the method call and returns in a

  computer program.

d. One application for a            is to balance the parentheses in an arithmetic

  expression.

e. A           operation is one that starts at the beginning of a list and processes

  each element.

f. A vector is an example of a      data structure.

g. An array is an example of a      data structure.

h. By default, the initial value of a reference variable is         .

EXERCISE 16.3 Add a removeAt() method to the List class to return the
object at a certain index location in the list. This method should take an int
parameter, specifying the object's position in the list, and it should return an
Object.

EXERCISE 16.4 Add an insertAt() method to the List class that will insert
an object at a certain position in the list. This method should take two parameters,
the Object to be inserted, and an int to designate where to insert it. It should
return a boolean to indicate whether the insertion was successful.
798  CHAPTER 16  Data Structures: Lists, Stacks, and Queues

EXERCISE 16.5 Add a removeAll() method to the List class. This void
method should remove all the members of the list.

EXERCISE 16.6 Write an int method named size() that returns the number
of elements in a List.

EXERCISE 16.7 Write an boolean method named contains(Object o)
that returns true if its Object parameter is contained in the list.

EXERCISE 16.8 The head of a list is the first element in the list. The tail of a list
consists of all the elements except the head. Write a method named tail() that
returns a reference to the tail of the list. Its return value should be Node.

EXERCISE 16.9 Write a program that uses the List ADT to store a list of 100
random floating-point numbers. Write methods to calculate the average of the
numbers.

EXERCISE 16.10 Write a program that uses the List ADT to store a list of
Student records, using a variation of the Student class defined in Chapter 11.
Write a method to calculate the mean grade point average for all students in the
list.

EXERCISE 16.11 Write a program that creates a copy of a List. It is necessary
to copy each node of the list. This will require that you create new nodes that
are copies of the nodes in the original list. To simplify this task, define a copy
constructor for your node class and then use that to make copies of each node of
the list.

EXERCISE 16.12 Write a program that uses a Stack ADT to determine if a
string is a palindrome--spelled the same way backward and forward.

EXERCISE 16.13 Design and write a program that uses a Stack to determine
whether a parenthesized expression is well-formed. Such an expression is well
formed only if there is a closing parenthesis for each opening parenthesis.

EXERCISE 16.14 Design and write a program that uses Stacks to determine
whether an expression involving both parentheses and square brackets is well
formed.

EXERCISE 16.15 Write a program that links two lists together, appending the
second list to the end of the first list.

EXERCISE 16.16 Design a Stack class that uses a Vector instead of a linked
list to store its elements. This is the way Java's Stack class is defined.

EXERCISE 16.17 Design a Queue class that uses a Vector instead of a linked
list to store its elements.

EXERCISE 16.18 Write a program that uses the List<E> and LinkedList<E>
classes to store a list of Student records, using a variation of the Student class
defined in Chapter 11. Write a method to calculate the mean grade point average
for all students in the list.

EXERCISE 16.19 Write an implementation of the insert() method of the
PhoneTree class described at the end of this chapter.

EXERCISE 16.20 Write an implementation of the insert() method of the
PhoneTreeNode class described at the end of this chapter.
CHAPTER 16  Exercises  799

EXERCISE 16.21 Challenge: Design a List class, similar in functionality to the
one we designed in this chapter, that uses an array to store the list's elements. Set
it up so that the middle of the array is where the first element is placed. That
way you can still insert at both the front and rear of the list. One limitation of this
approach is that, unlike a linked list, an array has a fixed size. Allow the user to
set the initial size of the array in a constructor, but if the array becomes full, don't
allow any further insertions.

EXERCISE 16.22 Challenge: Add a method to the program in the previous
exercise that lets the user increase the size of the array used to store the list.

EXERCISE 16.23 Challenge: Recursion is a useful technique for list processing.
Write recursive versions of the print() method and the lookup-by-name method
for the PhoneList. (Hint: The base case in processing a list is the empty list. The
recursive case should handle the head of the list and then recurse on the tail of the
list. The tail of the list is everything but the first element.)

EXERCISE 16.24 Challenge: Design an OrderedList class. An ordered list is
one that keeps its elements in order. For example, if it's an ordered list of integers,
then the first integer is less than or equal to the second, the second is less than or
equal to the third, and so on. If it's an ordered list of employees, then perhaps
the employees are stored in order according to their social security numbers. The
OrderedList class should contain an insert(Object o) method that inserts
its object in the proper order. One major challenge in this project is designing
your class so that it will work for any kind of object. (Hint: Define an Orderable
interface that defines an abstract precedes() method. Then define a subclass of
Node that implements Orderable. This will let you compare any two Nodes to
see which one comes before the other.)
800  CHAPTER 16  Data Structures: Lists, Stacks, and Queues
Appendix A

Coding Conventions

This appendix covers various aspects of programming style and coding conven-
tions. It follows the conventions suggested in the Java Language Specification
(http://java.sun.com/docs/books/jls/), which is summarized on Sun's
Java Web site (http://java.sun.com/docs/). The conventions have been
modified somewhat to fit the needs of an academic programming course. For
further details see

                                                                                      

h t t p : // j a v a . sun . com/docs/codeconv/index . html
                                                                                      

    Coding conventions improve the readability and maintainability of the code.
Because maintenance is often done by programmers who did not have a hand in
designing or writing the original code, it is important that the code follow certain
conventions. For a typical piece of commercial software, much more time and
expense are invested in maintaining the code than in creating the code.

Comments

Java recognizes two types of comments: C-style comments use the same syntax
found in C and C++. They are delimited by /* ... */ and //. The first set of
delimiters is used to delimit a multiline comment. The Java compiler will ignore
all text that occurs between /* and */. The second set of delimiters is used for a
single-line comment. Java will ignore all the code on the rest of the line following
a double slash (//). C-style comments are called implementation comments and are
mainly used to describe the implementation of your code.

    Documentation comments are particular to Java. They are delimited by
/** ... */. These are used mainly to describe the specification or design of
the code rather than its implementation. When a file containing documentation
comments is processed by the javadoc tool that comes with the Java Development
Kit (JDK), the documentation comments will be incorporated into an HTML doc-
ument. This is how online documentation has been created for the Java library
classes.

Implementation Commenting Guidelines

Implementation (C-style) comments should be used to provide an overview of the
code and to provide information that is not easily discernible from the code itself.
They should not be used as a substitute for poorly written or poorly designed
code.

                                              801
802                                    APPENDIX A  Coding Conventions

    In general, comments should be used to improve the readability of the code. Of
course, readability depends on the intended audience. Code that's easily readable
by an expert programmer may be completely indecipherable to a novice. Our
commenting guidelines are aimed at someone who is just learning to program in
Java.

Block Comments

A block comment or comment block is a multiline comment that is used to describe

files, methods, data structures, and algorithms:

                                                                                      

     /

      M u l t i l i n e comment block

     /

                                                                                      

Single-Line Comments

A single-line comment can be delimited either by // or by /* ... */. The // is

also used to comment out a line of code that you want to skip during a particular

run. The following example illustrates these uses:

                                                                                      

     / S i n g l e l i n e comment /

     System . out . println ( "Hello" ) ;         // End o f l i n e comment

     // System . o u t . p r i n t l n ( " Goodbye " ) ;

                                                                                      

Note that the third line is commented out and would be ignored by the Java
compiler.

    In this text, we generally use slashes for single-line and end-of-line comments.
And we frequently use end-of-line comments to serve as a running commentary
on the code itself. These types of comments serve a pedagogical purpose--to teach
you how the code works. In a "production environment" it would be unusual to
find this kind of running commentary.

Java Documentation Comments

Java's online documentation has been generated by the javadoc tool that comes

with the Java Development Kit (JDK). To conserve space, we use documentation

comments only sparingly in the programs listed in this textbook itself. However,

javadoc comments are used more extensively to document the online source

code that accompanies the textbook.

Documentation comments are placed before classes, interfaces, constructors,

methods, and fields. They generally take the following form:

                                                                                      

     / 

      The Example c l a s s blah blah

      @author J . Programmer

     /

public c l a s s Example { . . .                                                      


Note how the class definition is aligned with the beginning of the comment.

Javadoc comments use special tags, such as author and param, to identify certain

elements of the documentation. For details on javadoc, see

                                                                                      

h t t p : // j a v a . sun . com/ j 2 s e / 1 . 5 . 0 / docs/ t o o l d o c s /
                                                                                      
APPENDIX A  Coding Conventions                                          803

Indentation and White Space

The use of indentation and white space helps to improve the readability of the
program. White space refers to the use of blank lines and blank space in a program.
It should be used to separate one program element from another, with the goal
being to draw attention to the important elements of the program.

 Use a blank line to separate method definitions and to separate a class's in-
   stance variables from its methods.

 Use blank spaces within expressions and statements to enhance their readabil-
   ity.

 Be consistent in the way you use white space in your program.

    Code should be indented in a way that shows the logical structure of the pro-
gram. You should use a consistent number of spaces as the size of the indentation
tab. The Java Language Specification recommends four spaces.

    In general, indentation should represent the contained in relationships within
the program. For example, a class definition contains declarations for instance
variables and definitions of methods. The declarations and definitions should be
indented by the same amount throughout the class definition. The statements
contained in the body of a method definition should be indented:

                                                                                        

public void instanceMethod ( ) {

      System . out . println ( "Hello" ) ;

      return ;

}

                                                                                        

An if statement contains an if clause and an else clause, which should be indented:

                                                                                        

if ( condition )

      System . out . println ( " I f part " ) ; // I f c l a u s e

else

      System . out . println ( " Else part " ) ; // E l s e c l a u s e                 

The statements contained in the body of a loop should be indented:

                                                                                        

for ( int k = 0; k < 100; k++) {

      System . out . println ( "Hello " + 'k ' ) ; // Loop body

}

                                                                                        

    Finally, indentation should be used whenever a statement or expression is too
long to fit on a single line. Generally, lines should be no longer than 80 characters.

Naming Conventions

The choice of identifiers for various elements within a program can help improve
the readability of the program. Identifiers should be descriptive of the element's
purpose. The name of class should be descriptive of the class's role or function.
The name of a method should be descriptive of what the method does.

    The way names are spelled can also help improve a program's readability. Ta-
ble A.1 summarizes the various conventions recommended by the Java Language
Specification and followed by professional Java programmers.
804                              APPENDIX A  Coding Conventions

TABLE A.1 Naming rules for Java identifiers.

Identifier Type     Naming Rule                                    Example

Class               Nouns in mixed case with the first             OneRowNim
Interfaces          letter of each internal word capitalized.      TextField
Method
                    Same as class names. Many interface names      Drawable
Instance Variables  end with the suffix able.                      ActionListener
Constants
Loop Variables      Verbs in mixed case with the first letter in   actionPerformed()
                    lowercase and the first letter of internal     sleep()
                    words capitalized.                             insertAtFront()

                    Same as method names. The name should          maxWidth
                    be descriptive of how the variable is used.    isVisible

                    Constants should be written in uppercase with  MAX LENGTH
                    internal words separated by .                  XREF

                    Temporary variables, such as loop variables,   int k;
                    may have single character names: i, j, k.      int i;

Use of Braces

Curly braces { } are used to mark the beginning and end of a block of code.
They are used to demarcate a class body, a method body, or simply to combine a
sequence of statements into a single code block. There are two conventional ways
to align braces and we have used both in the text. The opening and closing brace
may be aligned in the same column with the enclosed statements indented:

                                                                                         

public void sayHello ( )

{

     System . out . println ( "Hello" ) ;

}

                                                                                         

This is the style that's used in the first part of the book, because it's easier for
someone just learning the syntax to check that the braces match up.

    Alternatively, the opening brace may be put at the end of the line where the
code block begins, with the closing brace aligned under the beginning of the line
where the code block begins:

                                                                                         

public void sayHello ( ) {

     System . out . println ( "Hello" ) ;

}

                                                                                         

This is the style that's used in the last two parts of the book, and it seems the style
preferred by professional Java programmers.
APPENDIX A  Coding Conventions                                    805

    Sometimes even with proper indentation, it it difficult to tell which closing
brace goes with which opening brace. In those cases, you should put an end-
of-line comment to indicate what the brace closes:

                                                                                       

public void sayHello ( ) {

     for ( int k=0; k < 10; k++) {

     System . out . println ( "Hello" ) ;

     } // f o r l o o p

} // s a y H e l l o ( )

                                                                                       

File Names and Layout

Java source files should have the .java suffix, and Java bytecode files should have
the .class suffix.

    A Java source file can only contain a single public class. Private classes and
interfaces associated with a public class can be included in the same file.

Source File Organization Layout

All source files should begin with a comment block that contains important iden-

tifying information about the program, such as the name of the file, author, date,

copyright information, and a brief description of the classes in the file. In the

professional software world, the details of this "boilerplate" comment will vary

from one software house to another. For the purposes of an academic computing

course, the following type of comment block would be appropriate:

                                                                                       

  /

   Filename : Example . java

   Author : J . Programmer

   Date : April , 20 1999

   Description : This program i l l u s t r a t e s basic

   coding conventions .

  /

                                                                                       

The beginning comment block should be followed by any package and import

statements used by the program:

                                                                                       

package java . mypackage ;

import java . awt .  ;                                                                 


The package statement should only be used if the code in the file belongs to the
package. None of the examples in this book use the package statement. The import
statement allows you to use abbreviated names to refer to the library classes used
in your program. For example, in a program that imports java.awt.* we can
refer to the java.awt.Button class as simply Button. If the import statement
were omitted, we would have to use the fully qualified name.

    The import statements should be followed by the class definitions contained
in the file. Figure A-1 illustrates how a simple Java source file should be formatted
and documented.
806                               APPENDIX A  Coding Conventions

                                                                                                

/

   Filename : Example . java

   Author : J . Programmer

   Date : April , 20 1999

   Description : This program     illustrates                       basic

          coding conventions .

  /

import java . awt .  ;

/ 

   The Example c l a s s i s an example of a simple

          class definition .

   @author J . Programmer

  /

public c l a s s Example {

    / Doc comment f o r i n s t a n c e v a r i a b l e , v a r 1 /

    public int var1 ;

    / 

        C o n s t r u c t o r method documentat comment               describes

          what the c o n s t r u c t o r does .

       /

    public Example ( ) {

       // . . . method i m p l e m e n t a t i o n g o e s h e r e

    }

    / 

        An i n s t a n c e M e t h o d ( ) d o c u m e n t a t i o n comment d e s c r i b e s

          what the method does .

        @param N i s a parameter than . . . .

        @return This method r e t u r n s blah blah

       /

    public int instanceMethod ( int N ) {

       // . . . method i m p l e m e n t a t i o n g o e s h e r e }

    }

} // Example

                                                                                                

              Figure A-1: A sample Java source file.
APPENDIX A  Coding Conventions                                          807

Statements

Declarations

There are two kinds of declaration statements: field declarations, which include a
class's instance variables, and local variable declarations.

 Put one statement per line, possibly followed by an end-of-line comment if the
   declaration needs explanation.

 Initialize local variables when they are declared. Instance variables are given
   default initializations by Java.

 Place variable declarations at the beginning of code blocks in which they are
   used rather than interspersing them throughout the code block.

The following class definition illustrates these points:

                                                                                    

public cl ass Example {          // Window l e n g t h and width
     private int size = 0;       // Window ' s c u r r e n t a r e a
     private int area = 0;

  public void myMethod ( ) {     // B e g i n n i n g o f method b l o c k
       i n t mouseX = 0 ;

  if ( condition ) {

       i n t mouseY = 0 ;        // B e g i n n i n g o f i f b l o c k

  ...

  } // i f

  } // myMethod ( )

} // Example

                                                                                    

Executable Statements

Simple statements, such as assignment statements, should be written one per
line and should be aligned with the other statements in the block. Compound
statements are those that contain other statements. Examples would include if
statements, for statements, while statements, and do-while statements. Com-
pound statements should use braces and appropriate indentation to highlight the
808                              APPENDIX A  Coding Conventions

statement's structure. Here are some examples of how to code several kinds of
compound statements:

                                                                                       

     if ( condition ) {          // A s i m p l e i f s t a t e m e n t

      statement1 ;

      statement2 ;

     } // i f

     if ( condition1 ) {         // An i f - e l s e s t a t e m e n t

      statement1 ;

     } else if ( condition2 ) {

      statement2 ;

      statement3 ;

     } else {

      statement4 ;

      statement5 ;

     } // i f / e l s e

for ( i n i t i a l i z e r ; entry-condition ; updater ) { // F o r l o o p

      statement1 ;

      statement2 ;

} // f o r

while ( condition ) {            // While s t a t e m e n t

      statement1 ;

      statement2 ;

} // w h i l e

do {                             // Do- w h i l e s t a t e m e n t

      statement1 ;

      statement2 ;

} while ( condition ) ;
                                                                                       

Preconditions and Postconditions

A good way to design and document loops and methods is to specify their pre-
conditions and postconditions. A precondition is a condition that must be true be-
fore the method (or loop) starts. A postcondition is a condition that must be true
after the method (or loop) completes. Although the conditions can be represented
formally--using boolean expressions--this is not necessary. It suffices to give a
clear and concise statement of the essential facts before and after the method (or
loop).

    Chapter 6 introduces the use of preconditions and postconditions and Chapters
6 through 8 provide numerous examples of how to use them. It may be helpful to
reread some of those examples and model your documentation after the examples
shown there.

Sample Programs

For specific examples of well-documented programs used in the text, see the
online source code that is available on the accompanying Web site at

                                                                                    

h t t p : //www. p r e n h a l l . com/ m o r e l l i                               

Appendix B

The Java Development Kit

The Java Development Kit (JDK) for JavaTM 2 Platform Standard Edition is a set
of command-line tools for developing Java programs. It is available for free in
versions for recent editions of Microsoft Windows, Linus, Macintosh OS X, and
Solaris (Sun Microsystems).

    Download information and documentation are available for the entire range of
products associated with the JavaTM 2 Platform, Standard Edition (Java SE) at;

                                                                                   

h t t p : // j a v a . sun . com/ j 2 s e /
                                                                                   

This appendix summarizes some of the primary tools available in the JDK. For
more detailed information you should consult Sun's Web site.

    Table B.1 provides a summary of some of the JDK tools.

TABLE B.1 Tools included in the Java Development Kit.

Tool Name Description

javac         Java compiler. Translates source code into bytecode.
java          Java interpreter. Translates and executes bytecode.
javadoc       Java documentation generator. Creates HTML pages from
              documentation comments embedded in Java programs.
appletviewer  Appletviewer. Used instead of a browser to run Java applets.
jar           Java archive manager. Manages Java archive (JAR) files.
jdb           Java debugger. Used to find bugs in a program.
javap         Java disassembler. Translates bytecode into Java source code.

Sun Microsystems provides detailed instructions on how to install JDK for Java
SE on computers running any of the above operating systems, including how to
set the system's PATH and CLASSPATH variables. Installation instructions can be
located using the above link to downloading information.

The Java Compiler: javac

The Java compiler (javac) translates Java source files into Java bytecode. A Java
source file must have the .java extension. The javac compiler will create a
bytecode file with the same name but with the .class extension. The javac
command takes the following form:

                                              809
               810  APPENDIX B  The Java Development Kit

               javac [ options ] sourcefiles [ files ]

               The brackets in this expression indicate optional parts of the command. Thus,
               options is an optional list of command-line options (including the -classpath
               option), and files is an optional list of files, each of which contains a list of Java
               source files. The files option would be used if you were compiling a very large
               collection of files, too large to list each file individually on the command line.

                   Most of the time you would simply list the sourcefiles you are compiling imme-
               diately after the word javac, as in the following example:

                                                                                                        

               javac MyAppletClass . java MyHelperClass . java                                          
               

               Given this command, javac will read class definitions contained in MyAppletClass.java
               and MyHelperClass.java in the current working directory and translate them
               into bytecode files named MyAppletClass.class and MyHelperClass.class.

                   If a Java source file contains inner classes, these would be compiled into sepa-
               rate class files. For example, if MyAppletClass.java contained an inner class
               named Inner, javac would compile the code for the inner class into a file named
               MyAppletClass$Inner.class.

                   If you are writing a program that involves several classes, it is not necessary to
               list each individual class on the command line. You must list the main class--that
               is, the class where execution will begin. The compiler will perform a search for
               all the other classes used in the main class. For example, if MyAppletClass uses
               an instance of MyHelperClass, you can compile both classes with the following
               command:

                                                                                                        

               javac MyAppletClass . java
                                                                                                        

               In this case, javac will perform a search for the definition of MyHelperClass.

               How Java Searches for Class Definitions

The Classpath  When compiling a file, javac needs a definition for every class or interface
               that's used in the source file. For example, if you are creating a subclass of
               java.applet.Applet, javac will need definitions for all of Applet's super-
               classes, including Panel, Container, and Component. The definitions for these
               classes are contained in the java.awt package. Here's how javac will search for
               these classes.

                   Javac will first search among its library files for definitions of classes, such as
               Applet and Panel. Next, javac will search among the files and directories listed
               on the user's class path. The class path is a system variable that lists all the user
               directories and files that should be searched when compiling a user's program.
               JDK no longer requires a class path variable. The class path can be set either by
               using the environment variable CLASSPATH or by using the -classpath option
               when invoking javac. By default, JDK will check in the current working directory
               for user classes. It doesn't require that the CLASSPATH variable be set. If this
               variable is set, it must include the current directory. The preferred way to set the
               classpath is by using -classpath option. For example,

                                                                                                        

               j a v a c -c l a s s p a t h . . / source : . MyApplet . java                            
               

               will tell javac to search in both the current directory (.) and in the ../source
               directory for user source files. Because the details for setting the CLASSPATH
               variable are system dependent, it's best to consult the online installation docu-
               mentation to see exactly how this is done on your system.
APPENDIX B  The Java Development Kit                      811

    During a successful search, javac may find a source file, a class file, or both.
If it finds a class file but not source file, javac will use the class file. This would
be the case for Java library code. If javac finds a source file but not a class file, it
will compile the source and use the resulting class file. This would be the case for
the first compilation of one of your source programs. If javac finds both a source
and a class file, it determines whether the class file is up-to-date. If so, it uses it. If
not, it compiles the source and uses the resulting class file. This would be the case
for all subsequent compilations of one of your source programs.

    As noted earlier, if your application or applet uses several source files, you need
only provide javac with the name of the main application or applet file. It will
find and compile all the source files, as long as they are located in a directory that's
listed in the class path.

The Java Interpreter: java

The java interpreter launches a Java application. This command takes one of the
following forms:

java  [ options ]  classname           [ argument . . . ]
java  [ options ]  -jar
                                       file.jar            [ argument . . . ]

If the first form is used, java starts a Java runtime environment. It then loads the
specified classname and runs that class's main() method, which must be declared
as follows:

                                                                                                      

public s t a t i c void main ( S t r i n g args [ ] )                                                 


The String parameter args[] is an array of strings, which is used to pass any
arguments listed on the command line. Command-line arguments are optional.

    If the second form of the java command is used, java will load the classes and
resources from the specified Java archive (JAR). In this case, the special -jar option
flag must be specified. The options can also include many other command-line
options, including the -classpath option.

The appletviewer

The appletviewer tool lets you run Java applets without using a Web browser.
This command takes the following form:

appletviewer [ threads flag ] [ options ] url . . .

The optional threads flag tells Java which of the various threading options to use.
This is system dependent. For details on this feature and the command line options,
refer to Sun's Web site.

    The appletviewer will connect to one or more HTML documents specified by
their Uniform Resource Locators (URLs). It will display each applet referenced in
those documents in a separate window. Some example commands would be

                                                                                                      

  appletviewer  h t t p : / /www . d o m a i n . e d u / ~ a c c o u n t / m y a p p l e t . h t m l  
  appletviewer  myapplet . html                                                                        AppletViewer tags


In the first case, the document's full path name is given. In the second case, since
no host computer is mentioned, appletviewer will assume that the applet is
located on the local host and will search the class path for myapplet.html.
812                        APPENDIX B  The Java Development Kit

    Once appletviewer retrieves the HTML document, it will find the applet
by looking for either the object, embed, or applet tags within the document.
The appletviewer ignores all other HTML tags. It just runs the applet. If it
cannot find one of these tags, the appletviewer will do nothing. If it does locate
an applet, it starts a runtime environment, loads the applet, and then runs the
applet's init() method. The applet's init() must have the following method
signature:

                                                                                       

public void i n i t ( )                                                                


The applet Tag

The applet tag is the original HTML 3.2 tag used for embedding applets within
an HTML document. If this tag is used, the applet will be run by the browser,
using the browser's own implementation of the Java Runtime Environment (JRE).

    Note, however, that if your applet uses the latest Java language features and the
browser is not using the latest version of JRE, the applet may not run correctly. For
example, this might happen if your applet makes use of Swing features that are not
yet supported in the browser's implementation of the JRE. In that case, your applet
won't run under that browser.

    To ensure that the applet runs with the latest version of the JRE--the one pro-
vided by Sun Microsystems--you can also use the object or the embed tags.
These tags are used to load the appropriate version of the JRE into the browser
as a plugin module. A plugin is a helper program that extends the browser's
functionality.

    The applet tag takes the following form:

                                                                                       

<applet

     code="yourAppletClass . c l a s s "

     object=" serializedObjectOrJavaBean "

     codebase=" c l a s s F i l e D i r e c t o r y "

     width=" pixelWidth "

     height=" pixelHeight "

>

     <param name=" . . . " value=" . . . ">

     ...

     alternate -text

</app let >                                                                            


You would use only the code or object attribute, not both. For the programs in
this book, you should always use the code tag. The code tag specifies where the
program will begin execution--that is, in the applet class.

    The optional codebase attribute is used to specify a relative path to the applet.
It may be omitted if the applet's class file is in the same directory as the HTML
document.

    The width and height attributes specify the initial dimensions of the ap-
plet's window. The values specified in the applet tag can be overridden in the
applet itself by using the setSize() method, which the applet inherits from the
java.awt.Component class.

    The param tags are used to specify arguments that can be retrieved when the
applet starts running (usually in the applet's init() method). The methods for
retrieving parameters are defined in the java.applet.Applet class.
APPENDIX B  The Java Development Kit                                      813

    Finally, the alternative-text portion of the applet tag provides text that
would be displayed on the Web page if the appletviewer or browser is unable to
locate the applet.

    Here's a simple example of an applet tag:

                                                                                           

<applet
       code="HelloWorldApplet . c l a s s "
       codebase=" c l a s s f i l e s "
       width=" 200 "
        h e i g h t =" 200 "

>

  <param name=" author " value=" J av a J av a J av a ">
  <param name=" date " value="May 1999 ">

  Sorry , your browser does not seem to be able to

  locate the HelloWorldApplet .

</a p p let >
                                                                                           

In this case, the applet's code is stored in a file name HelloWorld-
Applet.class, which is stored in the classfiles subdirectory--that is, a sub-
directory of the directory containing the HTML file. The applet's window will be
200  200 pixels. And the applet is passed the name of the program's author and
date it was written. Finally, if the applet cannot be located, the "Sorry . . . " message
will be displayed instead.

The object Tag

The object tag is the HTML 4.0 tag for embedding applets and multimedia ob-
jects in an HTML document. It is also an Internet Explorer (IE) 4.x extension to
HTML. It allows IE to run a Java applet using the latest JRE plugin from Sun. The
object tag takes the following form:

                                                                                           

<object
        c l a s s i d ="name o f t h e plugin program"
       codebase=" url for the plugin program"
       width=" pixelWidth "
        height=" pixelHeight "

>

  <param name=" code " value=" yourClass . c l a s s ">

  <param name=" codebase " value=" c l a s s F i l e D i r e c t o r y ">

  ...

  alternate -text

</o b j e c t >                                                                            

814                        APPENDIX B  The Java Development Kit

Note that parameters are used to specify your applet's code and codebase. In ef-
fect, these are parameters to the plugin module. An example tag that corresponds
to the applet tag for the HelloWorldApplet might be as follows:

                                                                                    

<object
        c l a s s i d =" c l s i d : 8 AD9C840-044E-11D1-B3E9 -00805F499D93"
       codebase=" h t t p :// j a v a . sun . com/products/plugin/"
       width=" 200 "
        h e i g h t =" 200 "

>

     <param name=" code " value=" HelloWorldApplet . c l a s s ">
     <param name=" codebase " value=" c l a s s f i l e s ">
     <param name=" author " value=" J av a J av a J av a ">
     <param name=" date " value="May 1999 ">

     Sorry , your browser does not seem to be able to

     locate the HelloWorldApplet .

</o b j e c t >
                                                                                    

If the browser has an older version of the plug in than shown in the codebase
attribute, the user will be prompted to download the newer version. If the browser
has the same or newer version, that version will run. In theory Netscape 6 should
also work the same as IE. For further details on how to use the object tag, see
Sun's plugin site at:

                                                                                    

h t t p : // j a v a . sun . com/products/plugin/                                   


The embed Tag

The embed tag is Netscape's version of the applet and object tags. It is in-
cluded as an extension to HTML 3.2. It can be used to allow a Netscape 4.x browser
to run a Java applet using the latest Java plugin from Sun. It takes the following
form:

                                                                                    

<embed

     type="Type of program"

     code="yourAppletClass . c l a s s "

     codebase=" c l a s s F i l e D i r e c t o r y "

     pluginspage=" l o c a t i o n o f plugin f i l e on t h e web"

     width=" pixelWidth "

     height=" pixelHeight "

>

     <noembed>

     Alternative text

     </noembed>

</embed>                                                                            


The type and pluginspage attributes are not used by the appletviewer, but they
are necessary for browsers. They would just be ignored by the appletviewer.
APPENDIX B  The Java Development Kit                                            815

For example, an embed tag for HelloWorldApplet would be as follows:

                                                                                      

<EMBED

   type=" a p p l i c a t i o n /x-jav a -a p p l e t ; v e r s i o n = 1 . 4 "

   width=" 200 "

   h e i g h t =" 200 "

   code="HelloWorldApplet . c l a s s "

   codebase=" c l a s s f i l e s "

   pluginspage=" h t t p :// j a v a . sun . com/products/plugin/"

>

   <NOEMBED>

        Sorry . This page won ' t be a b l e t o run t h i s a p p l e t .

   </NOEMBED>

</EMBED>                                                                              


    It may be possible to combine the applet, embed, and object tags in the
same HTML file. Sun provides much more information, as well as demo programs
on its plugin website:

                                                                                      

h t t p : // j a v a . sun . com/products/plugin/                                     


The Java Archiver jar Tool

The jar tool can be used to combine multiple files into a single JAR archive file.
Although the jar tool is a general-purpose archiving and compression tool, it was
designed mainly to facilitate the packaging of Java applets and applications into a
single file.

    The main justification for combining files into a single archive and compressing
the archive is to improve download time. The jar command takes the following
format:

jar [ options ] destination-file input-file [ input-files ]

For an example of its usage, let's use it to archive the files involved in the
WordGuess example in Chapter 9. As you may recall, this example used classes,
such as TwoPlayerGame, and interfaces, such as IGame, that were developed in
earlier sections of the chapter. So, to help manage the development of WordGuess,
it would be useful to have a library containing those files that must be linked
together when we compile WordGuess.

    This is a perfect use of a jar file. Let's name our library nplayerlib.jar.
We choose this name because the library can be used to create game programs that
have N players, including two-player games.
816                        APPENDIX B  The Java Development Kit

    For the two-player game, WordGuess, we want to combine all the .class files
needed by WordGuess.java into a single jar file. Here's a list of the files we want
to archive:

                                                                                     

CLUIPlayableGame . class

ComputerGame . c l a s s

GUIPlayableGame . class

IGame . c l a s s

KeyboardReader . class

Player . class

TwoPlayerGame . c l a s s

UserInterface . class                                                                


Assuming all of these files are contained in a single directory (along with other
files, perhaps), then the command we use from within that directory is as follows:

                                                                                     

jar cf nplayerlib . jar . class
                                                                                     

In this case, the cf options specify that we are creating a jar file named
animated.jar that will consist of all the files having the .class suffix. This
will create a file named nplayerlib.jar. To list the contents of this file, you can
use the following command:

                                                                                     

jar tf nplayerlib . jar
                                                                                     

Once we have created the jar file, we can copy it into the directory that contains
our source code for the WordGuess program. We would then the following com-
mands to include the code contained in the library when we compile and run

WordGuess.java

                                                                                     

j a v a c -c l a s s p a t h n p l a y e r l i b . j a r : . WordGuess . j a v a

j a v a -c l a s s p a t h n p l a y e r l i b . j a r : . WordGuess                 


These commands, which use the -classpath option, tell javac and java to in-
clude code from the nplayerlib.jar. The notation :., links code in the current
directory () with the library code.

    Once we have created a library, we can also use it for Java applets. For exam-
ple, suppose we have developed an applet version of the WordGuess game and
linked all of the applet's code into a jar file named wordguessapplet.jar. The
  APPENDIX B  The Java Development Kit                                         817

  following HTML file would allow users to download the applet from their web
  browser:

                                                                                               

  <html>

              <head><t i t l e >WordGuess Applet</ t i t l e ></head>

              <body>

              <applet

                    archive="wordguessapplet . j a r "

                    code="WordGuessApplet . c l a s s "

                    width=350 height =350

              >

                    <parameter name=" author " value=" J av a J av a J av a ">

                    <parameter name=" date " value=" A p r i l 2005 ">

              </app let >

              </body>

  </html>
                                                                                               

  When specified in this way, the browser will take care of downloading the archive
  file and extracting the individual files needed by the applet. Note that the code
  attribute must still designate the file where the program will start execution.

  The Java Documentation Tool: javadoc

  The javadoc tool parses the declarations and documentation comments in a
  Java source file and generates a set of HTML pages that describes the follow-
  ing elements: public and protected classes, inner classes, interfaces, constructors,
  methods, and fields.

      The javadoc tool can be used on a single file or an entire package of files.
  Recall that a Java documentation comment is one that begins with /** and ends
  with */. These are the comments that are parsed by javadoc.

      The javadoc tool has many features, and it is possible to use Java doclets to
  customize your documentation. For full details on using the tool, it is best to
  consult Sun's Web site. To illustrate how it might be used, let's just look at a simple
  example.

      The FirstApplet program from Chapter 1 contains documentation com-
  ments. It was processed using the following command:

                                                                                               

  javadoc FirstApplet . java
                                                                                               

  javadoc generated the following HTML documents:

                                                                                               

FirstApplet . html     -The main documentation f i l e

a l l c l a s s e s -frame . html -Names and l i n k s t o a l l t h e c l a s s e s used i n

                           FirstApplet

overview-t r e e . html -A t r e e showing F i r s t A p p l e t ' s p l a c e

                           in the class hierarchy

packages . html        -D e t a i l s on the packages used in F i r s t A p p l e t

index . html           -Top-l e v e l HTML document f o r

                           FirstApplet documentation

index-a l l . html     -Summary o f a l l methods and v a r i a b l e s i n

                           FirstApplet                                                         
818  APPENDIX B  The Java Development Kit

To see how the documentation appears, review the FirstApplet.java source
file and the documentation it generated. Both are available at

                                                                          

h t t p : //www. p r e n h a l l . com/ m o r e l l i /                   

Appendix C

The ASCII and Unicode
Character Sets

Java uses version 2.0 of the Unicode character set for representing character data.
The Unicode set represents each character as a 16-bit unsigned integer. It can,
therefore, represent 216 = 65,536 different characters. This enables Unicode to
represent characters from not only English but also a wide range of international
languages. For details about Unicode, see

                                                                                     

h t t p : //www. unicode . org                                                       


Unicode supersedes the ASCII character set (American Standard Code for In-

formation Interchange). The ASCII code represents each character as a 7-bit or

8-bit unsigned integer. A 7-bit code can represent only 27 = 128 characters. In

order to make Unicode backward compatible with ASCII, the first 128 characters

of Unicode have the same integer representation as the ASCII characters.

Table C.1 shows the integer representations for the printable subset of ASCII

characters. The characters with codes 0 through 31 and code 127 are nonprintable

characters, many of which are associated with keys on a standard keyboard. For

example, the delete key is represented by 127, the backspace by 8, and the return

key by 13.

                                819
820          APPENDIX C  ASCII and Unicode Character Sets

TABLE C.1 ASCII codes for selected characters

                                                        

Code  32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
Char  SP ! " # $ % & ' ( )  + , - . /

Code  48 49 50 51 52 53 54 55 56 57
Char  0123456789

Code  58 59 60 61 62 63 64
Char  : ; <=> ? @

Code  65 66 67 68 69 70 71 72 73 74 75 76 77
Char  A B CD E F GH I J K LM

Code  78 79 80 81 82 83 84 85 86 87 88 89 90
Char  NO P Q R S T U VWX Y Z

Code  91 92 93 94 95 96
Char
      [\] ^           `

Code  97 98 99 100 101 102 103 104 105 106 107 108 109
Char  abcd e f g h i j k l m

Code  110 111 112 113 114 115 116 117 118 119 120 121 122
Char  n o p q r s t u vwx y z

Code 123 124 125 126

Char { | } ~                                            
Appendix D

Java Keywords

The words shown in Table D.1 are reserved for use as Java keywords and cannot
be used as identifiers. The keywords const and goto, which are C++ keywords,
are not actually used in Java. They were included mainly to enable better error
messages to be generated when they are mistakenly used in a Java program.

    The words true, false, and null may look like keywords but are technically
considered literals. They also cannot be used as identifiers.

TABLE D.1 The Java keywords cannot be used as names for identifiers.

abstract  continue  for         new        switch
assert    default   goto        package    synchronized
boolean   do        if          private    this
break     double    implements  protected  throw
byte      else      import      public     throws
case      enum      instanceof  return     transient
catch     extends   int         short      try
char      final     interface   static     void
class     finally   long        strictfp   volatile
const     float     native      super      while

                                821
822  APPENDIX D  Java Keywords
Appendix E

Operator Precedence
Hierarchy

Table E.1 summarizes the precedence and associativity relationships for Java op-
erators. Within a single expression, an operator of order m would be evaluated be-
fore an operator of order n if m < n. Operators having the same order are evaluated
according to their association order. For example, the expression

                                                                                        

25 + 5  2 + 3                                                                           


would be evaluated in the order shown by the following parenthesized expression:

                                                                                        

  (25 + (5  2)) + 3  ==> ( 2 5 + 1 0 ) + 3 ==> 35 + 3 ==> 38
                                                                                  

In other words, because * has higher precedence than +, the multiplication op-
eration is done before either of the addition operations. And because addition
associates from left to right, addition operations are performed from left to right.

    Most operators associate from left to right, but note that assignment operators
associate from right to left. For example, consider the following code segment:

                                                                                        

  int i , j , k;     // E q u i v a l e n t t o i = ( j = ( k = 1 0 0 ) ) ;
  i = j = k = 100;
                                                                                  

In this case, each variable will be assigned 100 as its value. But it's important that
this expression be evaluated from right to left. First, k is assigned 100. Then its
value is assigned to j. And finally j's value is assigned to i.

    For expressions containing mixed operators, it's always a good idea to use
parentheses to clarify the order of evaluation. This will also help avoid subtle
syntax and semantic errors.

                     823
824             APPENDIX E  Operator Precedence Hierarchy

TABLE E.1 Java operator precedence and associativity table.

Order Operator  Operation                                    Association

0 ()            Parentheses                                  L to R
                                                             R to L
1 ++ --        Postincrement, Postdecrement, Dot Operator
                                                             R to L
2 ++ -- + - ! Preincrement, Predecrement,                    L to R
                                                             L to R
                Unary plus, Unary minus, Boolean NOT         L to R
                                                             L to R
3 (type) new    Type Cast, Object Instantiation              L to R
                                                             L to R
4 */%           Multiplication, Division, Modulus            L to R
                                                             R to L
5 +- +          Addition, Subtraction, String Concatenation

6 < > <= >=     Relational Operators

7 == !=         Equality Operators

8               Boolean XOR

9 &&            Boolean AND

10 ----         Boolean OR

11 = += -= *= /= %= Assignment Operators
Appendix F

Java Inner Classes

This appendix describes basic features of some advanced elements of the Java lan-
guage. As for many language features, there are details and subtleties involved in
using these features that are not covered here. For further details, you should
consult Sun's online references or other references for a more comprehensive
description.

What Are Inner Classes?

Inner classes were introduced in Java 1.1. This features lets you define a class as
part of another class, just as fields and methods are defined within classes. Inner
classes can be used to support the work of the class in which they are contained.

    Java defines four types of inner classes. A nested top-level class or interface
is a static member of an enclosing top-level class or interface. Such classes are
considered top-level classes by Java.

    A member class is a nonstatic inner class. It is not a top-level class. As a full-
fledged member of its containing class, a member class can refer to the fields and
methods of the containing class, even the private fields and methods. Just as
you would expect for the other instance fields and methods of a class, all instances
of a member class are associated with an instance of the enclosing class.

    A local class is an inner class that's defined within a block of Java code, such as
within a method or within the body of a loop. Local classes have local scope--they
can only be used within the block in which they are defined. Local classes can refer
to the methods and variables of their enclosing classes. They are used mostly to
implement adapters, which are used to handle events.

    When Java compiles a file containing a named inner class, it creates sepa-
rate class files for them with names that include the nesting class as a quali-
fier. For example, if you define an inner class named Metric inside a top-
level class named Converter, the compiler will create a class file named
Converter$Metric.class for the inner class. If you wanted to access the in-
ner class from some other class (besides Converter), you would use a qualified
name: Converter.Metric.

    An anonymous class is a local class whose definition and use are combined into
a single expression. Rather than defining the class in one statement and using it
in another, both operations are combined into a single expression. Anonymous
classes are intended for one-time use. Therefore, they don't contain constructors.
Their bytecode files are given names like ConverterFrame$1.class.

                                              825
                        826                                APPENDIX F  Java Inner Classes

                        Nested Top-Level Versus Member Classes

                        The Converter class (Figure F-1) shows the differences between a nested top-
                        level class and a member class. The program is a somewhat contrived example
                        that performs various kinds of metric conversions. The outer Converter class

                                                                                                                     

public class Converter {
   p r i v a t e s t a t i c f i n a l double INCH PER METER = 3 9 . 3 7 ;
   p r i v a t e f i n a l double LBS PER KG = 2 . 2 ;

  public static class Distance { // Nested Top- l e v e l                   class
     public double metersToInches ( double meters ) {
         r e t u r n meters  INCH PER METER ;
     }

  } // D i s t a n c e

  public class Weight {          // Member                 class

     public double kgsToPounds ( double kg ) {

        return kg  LBS PER KG ;

     }

  } // Weight

} // C o n v e r t e r

public class ConverterUser {

  public s t a t i c void main ( S t r i n g args [ ] ) {

     Converter . D i s t a n c e d i s t a n c e = new Converter . D i s t a n c e ( ) ;

     Converter c o n v e r t e r = new Converter ( ) ;

     Converter . Weight weight = c o n v e r t e r . new Weight ( ) ;

     System . out . println ( "5 m = " + distance . metersToInches (5 ) + " in " ) ;

     System . out . p r i n t l n ( "5 kg = " + weight . kgsToPounds ( 5 ) + " l b s " ) ;

  }

} // C o n v e r t e r U s e r

                                                                                                                     

                                Figure F-1: A Java application containing a top-level nested class.

                        serves as a container for the inner classes, Distance and Weight, which perform
                        specific conversions.

                            The Distance class is declared static, so it is a top-level class. It is contained
                        in the Converter class itself. Note the syntax used in ConverterUser.main()
                        to create an instance of the Distance class:

                                                                                                                     

                                Converter . D i s t a n c e d i s t a n c e = new Converter . D i s t a n c e ( ) ;  
                        

                        A fully qualified name is used to refer to the static inner class via its containing
                        class.

                            The Weight class is not declared static. It is, therefore, associated with in-
                        stances of the Converter class. Note the syntax used to create an instance of the
                        Weight class:

                                                                                                                     

                                Converter c o n v e r t e r = new Converter ( ) ;

                                Converter . Weight weight = c o n v e r t e r . new Weight ( ) ;
                                                                                                                     
APPENDIX F  Java Inner Classes                                        827

Before you can create an instance of Weight, you have to declare an instance of
Converter. In this example, we have used two statements to create the weight
object, which requires using the temporary variable, converter, as a reference to
the Converter object. We could also have done this with a single statement by
using the following syntax:

                                                                                        

Converter . Weight weight = new Converter ( ) . new Weight ( ) ;
                                                                                        

Note that in either case the qualified name Converter.Weight must be used to
access the inner class from the ConverterUser class.

    There are a couple of other noteworthy features in this example. First, an inner
top-level class is really just a programming convenience. It behaves just like any
other top-level class in Java. One restriction on top-level inner classes is that they
can only be contained within other top-level classes, although they can be nested
one within the other. For example, we could nest additional converter classes
within the Distance class. Java provides special syntax for referring to such
nested classes.

    Unlike a top-level class, a member class is nested within an instance of its con-
taining class. Because of this, it can refer to instance variables (LBS_PER_KG) and
instance methods of its containing class, even to those declared private. By con-
trast, a top-level inner class can only refer to class variables (INCH_PER_METER)--
that is, to variables that are declared static. So you would use a member class if
it were necessary to refer to instances of the containing class.

    There are many other subtle points associated with member classes, including
special language syntax that can be used to refer to nested member classes and
rules that govern inheritance and scope of member classes. For these details you
should consult the Java Language Specification, which can be accessed online at

                                                                                        

h t t p : // j a v a . sun . com/docs/books/ j l s /html/index . html                   


Local and Anonymous Inner Classes

In this next example, ConverterFrame, a local class is used to create an
ActionEvent handler for the application's two buttons (Fig. F-2).
As we have seen, Java's event-handling model uses predefined interfaces, such
as the ActionListener interface, to handle events. When a separate class is
defined to implement an interface, it is sometimes called an adapter class. Rather
than defining adapter classes as top-level classes, it is often more convenient to
define them as local or anonymous classes.

    The key feature of the ConverterFrame program is the createJButton()
method. This method is used instead of the JButton() constructor to create but-
tons and to create action listeners for the buttons. It takes a single String param-
eter for the button's label. It begins by instantiating a new JButton, a reference
to which is passed back as the method's return value. After creating an instance
button, a local inner class named ButtonListener is defined.

    The local class merely implements the ActionListener interface by defining
the actionPerformed method. Note how actionPerformed() uses the con-
taining class's converter variable to acquire access to the metersToInches()
and kgsToPounds() methods, which are inner class methods of the Converter
class (Fig. F-1). A local class can use instance variables, such as converter, that
are defined in its containing class.
                                    828                                                 APPENDIX F  Java Inner Classes
                                                                                                                                   
  import  javax . swing .  ;
  import  java . awt .  ;
  import  java . awt . event .  ;

public class ConverterFrame extends JFrame {                                            // R e f e r e n c e t o app
   p r i v a t e Converter c o n v e r t e r = new Converter ( ) ;
   p r i v a t e J T e x t F i e l d i n F i e l d = new J T e x t F i e l d ( 8 ) ;
   p r i v a t e J T e x t F i e l d o u t F i e l d = new J T e x t F i e l d ( 8 ) ;
   private JButton metersToInch ;
   private JButton kgsToLbs ;

  public ConverterFrame ( ) {
     metersToInch = c r e a t e J B u t t o n ( " Meters To Inches " ) ;
     kgsToLbs = c r e a t e J B u t t o n ( " K i l o s To Pounds" ) ;
     getContentPane ( ) . s e t L a y o u t ( new FlowLayout ( ) ) ;
     getContentPane ( ) . add ( i n F i e l d ) ;
     getContentPane ( ) . add ( o u t F i e l d ) ;
     getContentPane ( ) . add ( metersToInch ) ;
     getContentPane ( ) . add ( kgsToLbs ) ;

  } // C o n v e r t e r F r a m ( )

  private JButton createJButton ( String s ) { // A method                              to create a  JButton
     J B u t t o n j b u t t o n = new J B u t t o n ( s ) ;                            Local class
     class ButtonListener implements ActionListener { //

     public void actionPerformed ( ActionEvent e ) {
         double inValue = Double . valueOf ( inField . getText ( ) ) . doubleValue ( ) ;
         JButton button = ( JButton ) e . getSource ( ) ;
         i f ( button . getText ( ) . equals ( " Meters To Inches " ) )
             o u t F i e l d . s e t T e x t ( ""+ c o n v e r t e r . new D i s t a n c e ( ) . metersToInches ( inValue ) ) ;
         else
             o u t F i e l d . s e t T e x t ( ""+ c o n v e r t e r . new Weight ( ) . kgsToPounds ( inValue ) ) ;

     } // a c t i o n P e r f o r m e d ( )
  } // B u t t o n L i s t e n e r

  A c t i o n L i s t e n e r l i s t e n e r = new B u t t o n L i s t e n e r ( ) ; // C r e a t e a l i s t e n e r

  jbutton . addActionListener ( listener );                // R e g i s t e r b u t t o n s w i t h l i s t e n e r

  return jbutton ;

  } // c r e a t e J B u t t o n ( )

  public s t a t i c void main ( S t r i n g args [ ] ) {

  ConverterFrame frame = new ConverterFrame ( ) ;

  frame . setSize (200 ,200);

  frame . setVisible ( true ) ;

  } // main ( )

} // C o n v e r t e r F r a m e

                                                                                                                                 

                                      Figure F-2: The use of a local class as an ActionListener adapter.

                                          After defining the local inner class, the createJButton() method creates an
                                      instance of the class (listener) and registers it as the button's action listener.
                                      When a separate object is created to serve as listener in this way, it is called an
                                      adapter. It implements a listener interface and thereby serves as adapter between
APPENDIX F  Java Inner Classes  829

the event and the object that generated the event. Any action events that occur
on any buttons created with this method will be handled by this adapter. In other
words, for any buttons created by the createJButton() method, a listener ob-
ject is created and assigned as the button's event listener. By using local classes,
the code for doing this is much more compact and efficient.

    Local classes have some important restrictions. Although an instance of a local
class can use fields and methods defined within the class itself or inherited from its
superclasses, it cannot use local variables and parameters defined within its scope
unless these are declared final. The reason for this restriction is that final vari-
ables receive special handling by the Java compiler. Because the compiler knows
that the variable's value won't change, it can replace uses of the variable with their
values at compile time.
                                    830                                                      APPENDIX F  Java Inner Classes

                                    Anonymous Inner Classes

                                    An anonymous inner class is just a local class without a name. Instead of using two

                                    separate statements to define and instantiate the local class, Java provides syntax

                                    that let's you do it in one expression. The following code illustrates how this is

                                    done:

                                                                                                                              

private JButton createJButton ( String s ) { // A method to c r e a t e a J B u t t o n
   J B u t t o n j b u t t o n = new J B u t t o n ( s ) ;

  j b u t t o n . a d d A c t i o n L i s t e n e r ( new A c t i o n L i s t e n e r ( ) {  // Anonymous c l a s s

  public void actionPerformed ( ActionEvent e ) {

  double inValue = Double . valueOf ( inField . getText ( ) ) . doubleValue ( ) ;

  JButton button = ( JButton ) e . getSource ( ) ;

  i f ( button . getLabel ( ) . equals ( " Meters To Inches " ) )

  o u t F i e l d . s e t T e x t ( "" + c o n v e r t e r . new D i s t a n c e ( ) . metersToInches ( inValue ) ) ;

  else

  o u t F i e l d . s e t T e x t ( "" + c o n v e r t e r . new Weight ( ) . kgsToPounds ( inValue ) ) ;

  } // a c t i o n P e r f o r m e d ( )

  } ) ; // A c t i o n L i s t e n e r

  return jbutton ;

} // c r e a t e J B u t t o n ( )

                                                                                                                              

                                    Note that the body of the class definition is put right after the new operator. The
                                    result is that we still create an instance of the adapter object, but we define it on
                                    the fly. If the name following new is a class name, Java will define the anonymous
                                    class as a subclass of the named class. If the name following new is an interface, the
                                    anonymous class will implement the interface. In this example, the anonymous
                                    class is an implementation of the ActionListener interface.

                                        Local and anonymous classes provide an elegant and convenient way to im-
                                    plement adapter classes that are intended to be used once and have relatively
                                    short and simple implementations. The choice of local versus anonymous should
                                    largely depend on whether you need more than one instance of the class. If so, or if
                                    it's important that the class have a name for some other reason (readability), then
                                    you should use a local class. Otherwise, use an anonymous class. As in all design
                                    decisions of this nature, you should use whichever approach or style makes your
                                    code more readable and more understandable.
Appendix G

Java Autoboxing and
Enumeration

This appendix describes some basic properties of autoboxing and enumeration, two
of the features added to the Java language with the release of Java 5.0. As for
many language features, there are details and subtleties involved in using these
features that are not covered here. For further details, you should consult Sun's
online references or other references for a more comprehensive description.

Autoboxing and Unboxing

Autoboxing refers to the automatic storing of a value of primitive type into an
object of the corresponding wrapper class. Before autoboxing, it was necessary to
explicitly box values into wrapper class objects with code like:

                                                                                      

I n t e g e r i O b j = new I n t e g e r ( 3 4 5 ) ;

double num = - 2 . 3 4 5 ;

Double dObj = new Double (num ) ;                                                     


Java 5.0 automatically creates a wrapper class object from a value of primitive type
in many situations where a wrapper class object is expected. The assignments
above can be accomplished with the simpler code:

                                                                                      

Integer iObj = 345;

double num = - 2 . 3 4 5 ;

Double dObj = num ;
                                                                                      

    There is a corresponding feature in Java 5.0 which automatically performs the
unboxing of primitive values from wrapper class objects. Instead of the explicit
unboxing in:

                                                                                      

int m = iObj . intValue ( ) ;

double x = dObj . doubleValue ( ) ;
                                                                                      

                               831
832             APPENDIX G  Java Autoboxing and Enumeration

Java 5.0 allows the simpler:

                                                                                     

int m = iObj ;

double x = dObj ;                                                                    


    Java 5.0 provides autoboxing of primitive values and automatic unboxing of
wrapper class objects in expressions or in arguments of methods, where such a
conversion is needed to complete a computation. Beginning programmers are
unlikely to encounter many problems that require such conversions. One situa-
tion which often requires boxing and unboxing are applications that involve data
structures. The generic type data structures of Chapter 16 must store objects but
the data to be stored might be represented as values of a primitive type. The
code segment below should give you some idea of the type of situation where
autoboxing and unboxing can be a genuine help simplifying one's code:

                                                                                     

Stack<I n t e g e r > s t a c k = new Stack<I n t e g e r > ( ) ;

f o r ( i n t k = -1; k > -5; k--)

     stack . push ( k ) ;

while ( ! stack . empty ( ) )

     System . out . p r i n t l n ( Math . abs ( s t a c k . pop ( ) ) ) ;           

Notice that the stack.push(k) method is expecting an Integer object so the
int value stored in k will be autoboxed into such an object before the method
is executed. Also note that the Math.abs() method in the last line of the code
fragment is expecting a value of primitive type so the Integer value returned by
stack.pop() must be automatically unboxed before the Math.abs() method
can be applied.

    Sun's online Java 5.0 documentation can be consulted for a more precise de-
scription of where autoboxing and unboxing takes place and a list of some special
situations where code allowing autoboxing can lead to confusion and problems.

Enumeration

A new enumeration construct was included in Java 5.0 to make it simpler to repre-
sent a finite list of named values as a type. The enum keyword was added as part
of this construct. Standard examples of lists of values appropriate for enumera-
tions are the days of the week, months of the year, the four seasons, the planets,
the four suits in a deck of cards, and the ranks of cards in a deck of cards. The
following declaration of Season enumerated type is an example used by the Sun
online documentation.

                                                                                     

public enum Season { spring , summer , f a l l , winter }
                                                                                     

Compiling a file that contains only this statement will create a Season.class
file that defines a Java type just in the same way that compiling class definitions
does. The variables and values of type Season can be referred to in other classes
APPENDIX G  Java Autoboxing and Enumeration            833

just like other types and values. For example, the following statements are valid
statements in a method definition in another class:

                                                                                       

Season s1 = winter ;

i f ( s1 == s p r i n g )

  System . out . println ( s1 ) ;                                                      

Note that the values of enumerated types can be used in assignment statements,
equality relations, and it will be printed out exactly as declared in the enum
statement.

    The enum declaration could also occur inside the definition of a class and be
declared as either public or private. In this case the visibility of the type would
be determined in a manner similar to inner classes.

    A standard way to represent such a finite list of values in Java before the enum
construct was to create a list of constants of type int. For example, if one wanted
to represent the four seasons you would have to do it inside a definition of a class,
say of a class named Calendar. Such a representation might look like:

                                                                                       

public class Calendar {
       public s t a t i c f i n a l i n t SPRING = 0 ;
       public s t a t i c f i n a l i n t SUMMER = 1 ;
       public s t a t i c f i n a l i n t FALL = 2 ;
       public s t a t i c f i n a l i n t WINTER = 3 ;

  // O t h e r C a l e n d a r d e f i n i t i o n s

} // C a l e n d a r

                                                                                       

In addition to being a lengthier declaration, note that other classes that wish to
refer to this representation would have to use notation something like:

                                                                                       

i n t s1 = Calendar . WINTER ;

i f ( s1 == Calendar . SPRING )

  System . out . println ( s1 ) ;                                                      

In addition to being more awkward, note that the println() call will print out
an integer in this case. Some additional code would have to be written to be able
to print the names of the seasons from the int values used to represent them. It is
the case that for methods in the Calendar class, the names of the constants look
very much like the values of the enum type.
834                   APPENDIX G  Java Autoboxing and Enumeration

    To illustrate a couple of additional advantages of the enum structure, lets con-
sider using the int representation above in a method definition that describes the
start date of a given season. Code for such a method would look something like:

                                                                                        

     public static String startDate ( int s ){

     switch ( s ){

     c a s e SPRING : r e t u r n " Vernal Equinox " ;

     c a s e SUMMER : r e t u r n "Summer S o l s t i c e " ;

     c a s e FALL : r e t u r n "Autumnal Equinox " ;

     c a s e WINTER : r e t u r n " Winter S o l s t i c e " ;

     } // s w i t c h

     return "error" ;

     } // s t a r t D a t e ( )

                                                                                        

This method has a problem referred to as not being typesafe. We would want the
startDate() method to be called only with an argument equal to an int value
of 0, 1, 2, or 3. There is no way to tell the compiler to make sure that other int
values are not used as an argument to this method.

    Let's contrast this with a similar startDate() method that can refer to the
Season enumerated type that was defined above. The Calendar class (Figure G-
1) shows the definition of a startDate() method as well as a method to print
a list of seasons with corresponding starting dates. Note that the parameter of

                                                                        

public class Calendar {
       public static String startDate ( Season s ){
              switch ( s ){
              case spring : return "Vernal Equinox" ;
              c a s e summer : r e t u r n "Summer S o l s t i c e " ;
              case f a l l : return "Autumnal Equinox" ;
              case winter : return "Winter Solstice " ;
              } // s w i t c h
              return "error" ;
       } // s t a r t D a t e ( )

     public s t a t i c void printDates (){

     for ( Season s : Season . values ( ) )

     System . out . println ( s + " - " + startDate ( s ) ) ;

     } // p r i n t D a t e s ( )

} // C a l e n d a r

                                                                        

     Figure G-1: A Calendar class using the Season.

startDate() is of type Season and so the Java compiler can check that call
to this method have an argument of this type. This time the startDate() is
typesafe.

    The printDates() method illustrates another feature of the enumeration
structure. The for loop in this method is the for-in loop which was added
to Java 5.0. The expression Season.values() denotes a list of the elements of
the type in the order that they were declared. The for-in loop iterates through
all the values of the type in the correct order and, in this case, prints out the type
APPENDIX G  Java Autoboxing and Enumeration  835

name followed by a dash followed by the String computed by the startDate()
method. The output when the printDates() method is called is given below:

                                                                                    

spring - Vernal Equinox

summer - Summer S o l s t i c e

f a l l - Autumnal Equinox

winter - Winter Solstice                                                            


    The for-in loop provides a very nice way to iterate through the values of any
enumerated type. You may wish to write a corresponding method for the earlier
int representation of the seasons for a comparison.

    Sun's online Java 5.0 documentation provides a more precise definition of enu-
merated types and describes quite a number of other features that we have not
alluded to.
836  APPENDIX G  Java Autoboxing and Enumeration
Appendix H

Java and UML Resources

Reference Books

 David Flanagan, Java in a Nutshell Edition 5, 5th ed., O'Reilly and Associates
   2005. Part of the O'Reilly Java series, this book provides a concise desktop
   reference to Java and the API.

 James Gosling, Bill Joy, and Guy Steele, The Java Language Specification, 3d ed.,
   Addison-Wesley, 2005. This book, which is part of Addison-Wesley's Java Se-
   ries, provides a detailed description of the Java language. An online version is
   available at

                                                                                     

h t t p : // j a v a . sun . com/docs/books/ j l s
                                                                                     

 Martin Fowler, UML Distilled, 3d ed., Addison-Wesley, 2003. This book, which
   is part of Addison-Wesley's Object Technology Series, provides a concise intro-
   duction to UML.

Online References

 http://www.omg.org/ contains good information on UML.
 http://java.sun.com/j2se is one of Sun Microsystems' Java Web sites.

    From this page you can find links to downloads of JDK, API specifications, and
    documentation on all of Java, including Swing, AWT, and new features of Java
    5.0.
 http://java.sun.com/docs/codeconv/ provides a description of coding
    conventions suggested by the Java Language Specification and followed by the
    Java programming community. (These are summarized in Appendix A.)
 http://java.sun.com/tutorial provides an online Java tutorial.
 http://www.JARS.com provides reviews and ratings of the best Java applets.
 http://www.java-news-center.org/ is a clearinghouse for Java news,
    programming examples, debugging tips, and many other useful resources.

                 837
Index

absolute path name, 519                 class scope, 105
Abstract Data Type (ADT), 771           client, 697
accessor method, 102                    client-server, 4
arithmetic 210                          client/server protocols, 697
arithmetic operators, 208, 211          compiler, 8
array, 442                              computational overhead, 547
array allocation, 399                   Compute Average Example, 266
array assignment, 400                   computer memory, 3
array component, 396                    computer storage, 3
array component type, 396               concurrently, 644
array declaration, 397                  constructor, 110, 140
array element, 396                      constructor default, 112
array element type, 396                 containment hierarchy, 604
array initializer, 400, 443             content pane, 606
array length, 396, 397, 427             control structures, 277
array storage, 402                      controller, 596
ascent, 326                             counting loop, 270
ASCII, 232, 820                         CPU, 3
ASCII character set, 232                critical section, 673
assignment operator =, 213
assignment operators, 214               data hierarchy, 501
asynchronous, 653                       data structure, 298, 758
AWTEvent, 601                           Data Validation Example, 270
                                        database, 501
baseline, 326                           decrement operator -, 212
binary search, 416                      dequeue, 778
blocked, 655                            dialog box, 489
Boehm, 277                              digitToInteger() method, 237
Boole, George, 199                      Dikjstra, 277
bound, 272                              directory, 518
break, 274                              dispatched, 655
buffering, 504                          divide and conquer, 548
busy waiting, 675, 704                  divide-and-conquer, 416
                                        do-while structure, 272
Caesar cipher, 357                      domain names, 697
callback design, 612                    dynamic scope, 473
callback method, 707                    dynamic structure, 758
catch block, 470
central processing unit, 3              Encapsulation Principle, 88
char, 231                               encryption, 357
character conversion, 235               end-of-file character, 506
character conversion example, 238       enqueue, 778
charAt() method, 310                    error dialog, 489
checked exception, 464                  ethernet protocol, 698
cipher, 357                             event model, 598
ciphertext alphabet, 357                exception, 460

                                   838
INDEX                                                                            839

exception handling, 460                 method call stack, 474
                                        method call, recursive, 552
factorial, 549                          method invocation, 109
fetch-execute cycle, 3, 645             method stack trace, 475
Fibonacci sequence, 295, 588            modal dialog, 489
fields, 501                             model, 596
Filtering, 504                          monitor, 667
first-in-first-out (FIFO), 778          multidimensional array, 427
floating-point division, 208            multitasking, 645
for statement, 285                      multithreaded, 645
formal parameter, 103                   multiway selection, 125
                                        multiway-selection structure, 274
goto statement, 277                     mutator method, 102
                                        mutual exclusion, 667
head-and-tail algorithm, 552
high-level language, 7                  nested if-else, 125
HTML, 5                                 networks, 4
HTTP, 5
                                        object code, 8
if statement, 123                       object serialization, 530
if-else statement, 125                  object-oriented design, 355
increment operator ++, 212              object-oriented metaphor, 62
IndexOutOfBoundsException, 420          off-by-one error, 314
infinite loop, 272                      one-dimensional array, 396
Information Hiding Principle, 140
initializer, array, 427                 packets, 698
integer division, 208                   parameter, 107, 140
Internet, 5, 695                        parameter scope, 104
internet, 695                           path, 518
Internetworking Protocol (IP), 699      plaintext alphabet, 357
interpreter, 8                          platform independence, 7
ItemListener interface, 578             pop, 776
iterative method, 546                   port, 719
                                        postdecrement, 213
Jacopini, 277                           postincrement, 212
java.io package, 52                     precedence, 201, 210, 215
                                        precedence table, 239
keyword, cipher, 357                    predecrement, 213
                                        preincrement, 212
last-in-first-out (LIFO), 776           primitive type, 118
last-in-first-out (LIFO) protocol, 555  priority scheduling, 646
lastIndexOf() method, 304               producer/consumer model, 664
layout manager, 606                     promotion rule, 210
lexicographic order, 317, 318           protocol, 5, 696
life cycle, 654                         push, 776
link, 759
linked list, 759                        qualified name, 105
list, 758                               quantum, 646
listener, 598                           queue, 655, 778
local scope, 104
lock, 667                               ready queue, 655
loop design, 265                        record, 501
loop design principles, 270             recursion, 551
                                        recursion parameter, 553, 564
machine language, 7                     recursion, base case, 550
Maintainability Principle, 224, 402     recursion, recursive case, 549
840                                                             INDEX

recursive case, 550                  vector, 758
recursive definition, 549            view, 596
recursive method, 546, 581           void, 86
reference type, 118
relational operators, 214, 235       while statement, 129
repetition structure, 285            while structure, 129, 272
return statement, 123                widget hierarchy, 604
round-robin, 646                     Wirth, 277
routers, 695                         World Wide Web, 5
                                     WWW, 5
sandbox security model, 741
scope, 104                           zero indexed, 302
self-referential object, 759
self-similarity, 548
sequential search, 414
server, 697
signature, 140
socket, 719
software, 3
source code, 8
square, 450
stack, 776
static scope, 473
static structure, 758
String, 329
String equality, 321
String identity, 321
String methods, 330
String.equals(), 319
StringTokenizer class, 323
structured programming, 277, 285
subscript, 442
substitution cipher, 357
substring() method, 310
switch statement, 273

tail recursive, 573
TestEncrypt class, 363
thread, 644
throw an exception, 466
time slicing, 645
toString() method, 135
toUpperCase() method, 236
translator, 8
Transpose class, 362
transposition cipher, 357
traverse, 764
trusted code, 741
try block, 470
type conversion rule, 234

unchecked exception, 465
Uniform Resource Locator, 5
Uniform Resource Locator (URL), 696
URL, 5
UTF, 523
